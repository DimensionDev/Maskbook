diff --git a/dist/immer.cjs.development.js b/dist/immer.cjs.development.js
index a9d73e1439081dd86d2c5ba46ad87c0cb5887d14..08d65d0464cd0bbf72d7474a6a591ecd6e48f7a0 100644
--- a/dist/immer.cjs.development.js
+++ b/dist/immer.cjs.development.js
@@ -268,7 +268,17 @@ function freeze(obj, deep) {
   if (getArchtype(obj) > 1
   /* Map or Set */
   ) {
-      obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
+      var desc = {
+        configurable: true,
+        writable: true,
+        value: dontMutateFrozenCollections
+      };
+      Object.defineProperties(obj, {
+        set: desc,
+        add: desc,
+        clear: desc,
+        delete: desc
+      });
     }
 
   Object.freeze(obj);
@@ -1270,6 +1280,434 @@ function enableES5() {
   });
 }
 
+// types only!
+function enableMapSet() {
+  /* istanbul ignore next */
+  var _extendStatics = function extendStatics(d, b) {
+    _extendStatics = Object.setPrototypeOf || {
+      __proto__: []
+    } instanceof Array && function (d, b) {
+      d.__proto__ = b;
+    } || function (d, b) {
+      for (var p in b) {
+        if (b.hasOwnProperty(p)) d[p] = b[p];
+      }
+    };
+
+    return _extendStatics(d, b);
+  }; // Ugly hack to resolve #502 and inherit built in Map / Set
+
+
+  function __extends(d, b) {
+    _extendStatics(d, b);
+
+    function __() {
+      Object.defineProperty(this, "constructor", {
+        value: d
+      });
+    }
+
+    d.prototype = ( // @ts-ignore
+    __.prototype = b.prototype, new __());
+  }
+
+  var DraftMap = function (_super) {
+    var _Object$definePropert;
+
+    __extends(DraftMap, _super); // Create class manually, cause #502
+
+
+    function DraftMap(target, parent) {
+      this[DRAFT_STATE] = {
+        type_: 2
+        /* Map */
+        ,
+        parent_: parent,
+        scope_: parent ? parent.scope_ : getCurrentScope(),
+        modified_: false,
+        finalized_: false,
+        copy_: undefined,
+        assigned_: undefined,
+        base_: target,
+        draft_: this,
+        isManual_: false,
+        revoked_: false
+      };
+      return this;
+    }
+
+    var p = DraftMap.prototype;
+    Object.defineProperties(p, (_Object$definePropert = {
+      size: {
+        get: function get() {
+          return latest(this[DRAFT_STATE]).size;
+        },
+        configurable: true
+      },
+      has: {
+        configurable: true,
+        writable: true,
+        value: function value(key) {
+          return latest(this[DRAFT_STATE]).has(key);
+        }
+      },
+      set: {
+        configurable: true,
+        writable: true,
+        value: function value(key, _value2) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (!latest(state).has(key) || latest(state).get(key) !== _value2) {
+            prepareMapCopy(state);
+            markChanged(state);
+            state.assigned_.set(key, true);
+            state.copy_.set(key, _value2);
+            state.assigned_.set(key, true);
+          }
+
+          return this;
+        }
+      },
+      delete: {
+        configurable: true,
+        writable: true,
+        value: function value(key) {
+          if (!this.has(key)) {
+            return false;
+          }
+
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareMapCopy(state);
+          markChanged(state);
+
+          if (state.base_.has(key)) {
+            state.assigned_.set(key, false);
+          } else {
+            state.assigned_.delete(key);
+          }
+
+          state.copy_.delete(key);
+          return true;
+        }
+      },
+      clear: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (latest(state).size) {
+            prepareMapCopy(state);
+            markChanged(state);
+            state.assigned_ = new Map();
+            each(state.base_, function (key) {
+              state.assigned_.set(key, false);
+            });
+            state.copy_.clear();
+          }
+        }
+      },
+      forEach: {
+        configurable: true,
+        writable: true,
+        value: function value(cb, thisArg) {
+          var _this = this;
+
+          var state = this[DRAFT_STATE];
+          latest(state).forEach(function (_value, key, _map) {
+            cb.call(thisArg, _this.get(key), key, _this);
+          });
+        }
+      },
+      get: {
+        configurable: true,
+        writable: true,
+        value: function value(key) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          var value = latest(state).get(key);
+
+          if (state.finalized_ || !isDraftable(value)) {
+            return value;
+          }
+
+          if (value !== state.base_.get(key)) {
+            return value; // either already drafted or reassigned
+          } // despite what it looks, this creates a draft only once, see above condition
+
+
+          var draft = createProxy(state.scope_.immer_, value, state);
+          prepareMapCopy(state);
+          state.copy_.set(key, draft);
+          return draft;
+        }
+      },
+      keys: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          return latest(this[DRAFT_STATE]).keys();
+        }
+      },
+      values: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var _this2 = this,
+              _ref;
+
+          var iterator = this.keys();
+          return _ref = {}, _ref[iteratorSymbol] = function () {
+            return _this2.values();
+          }, _ref.next = function next() {
+            var r = iterator.next();
+            /* istanbul ignore next */
+
+            if (r.done) return r;
+
+            var value = _this2.get(r.value);
+
+            return {
+              done: false,
+              value: value
+            };
+          }, _ref;
+        }
+      },
+      entries: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var _this3 = this,
+              _ref2;
+
+          var iterator = this.keys();
+          return _ref2 = {}, _ref2[iteratorSymbol] = function () {
+            return _this3.entries();
+          }, _ref2.next = function next() {
+            var r = iterator.next();
+            /* istanbul ignore next */
+
+            if (r.done) return r;
+
+            var value = _this3.get(r.value);
+
+            return {
+              done: false,
+              value: [r.value, value]
+            };
+          }, _ref2;
+        }
+      }
+    }, _Object$definePropert[iteratorSymbol] = {
+      configurable: true,
+      writable: true,
+      value: function value() {
+        return this.entries();
+      }
+    }, _Object$definePropert));
+    return DraftMap;
+  }(Map);
+
+  function proxyMap_(target, parent) {
+    // @ts-ignore
+    return new DraftMap(target, parent);
+  }
+
+  function prepareMapCopy(state) {
+    if (!state.copy_) {
+      state.assigned_ = new Map();
+      state.copy_ = new Map(state.base_);
+    }
+  }
+
+  var DraftSet = function (_super) {
+    var _Object$definePropert2;
+
+    __extends(DraftSet, _super); // Create class manually, cause #502
+
+
+    function DraftSet(target, parent) {
+      this[DRAFT_STATE] = {
+        type_: 3
+        /* Set */
+        ,
+        parent_: parent,
+        scope_: parent ? parent.scope_ : getCurrentScope(),
+        modified_: false,
+        finalized_: false,
+        copy_: undefined,
+        base_: target,
+        draft_: this,
+        drafts_: new Map(),
+        revoked_: false,
+        isManual_: false
+      };
+      return this;
+    }
+
+    var p = DraftSet.prototype;
+    Object.defineProperties(p, (_Object$definePropert2 = {
+      size: {
+        get: function get() {
+          return latest(this[DRAFT_STATE]).size;
+        },
+        configurable: true
+      },
+      has: {
+        configurable: true,
+        writable: true,
+        value: function value(_value3) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value
+
+          if (!state.copy_) {
+            return state.base_.has(_value3);
+          }
+
+          if (state.copy_.has(_value3)) return true;
+          if (state.drafts_.has(_value3) && state.copy_.has(state.drafts_.get(_value3))) return true;
+          return false;
+        }
+      },
+      add: {
+        configurable: true,
+        writable: true,
+        value: function value(_value4) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (!this.has(_value4)) {
+            prepareSetCopy(state);
+            markChanged(state);
+            state.copy_.add(_value4);
+          }
+
+          return this;
+        }
+      },
+      delete: {
+        configurable: true,
+        writable: true,
+        value: function value(_value5) {
+          if (!this.has(_value5)) {
+            return false;
+          }
+
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareSetCopy(state);
+          markChanged(state);
+          return state.copy_.delete(_value5) || (state.drafts_.has(_value5) ? state.copy_.delete(state.drafts_.get(_value5)) :
+          /* istanbul ignore next */
+          false);
+        }
+      },
+      clear: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (latest(state).size) {
+            prepareSetCopy(state);
+            markChanged(state);
+            state.copy_.clear();
+          }
+        }
+      },
+      values: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareSetCopy(state);
+          return state.copy_.values();
+        }
+      },
+      entries: {
+        configurable: true,
+        writable: true,
+        value: function entries() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareSetCopy(state);
+          return state.copy_.entries();
+        }
+      },
+      keys: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          return this.values();
+        }
+      }
+    }, _Object$definePropert2[iteratorSymbol] = {
+      configurable: true,
+      writable: true,
+      value: function value() {
+        return this.values();
+      }
+    }, _Object$definePropert2.forEach = {
+      configurable: true,
+      writable: true,
+      value: function forEach(cb, thisArg) {
+        var iterator = this.values();
+        var result = iterator.next();
+
+        while (!result.done) {
+          cb.call(thisArg, result.value, result.value, this);
+          result = iterator.next();
+        }
+      }
+    }, _Object$definePropert2));
+    return DraftSet;
+  }(Set);
+
+  function proxySet_(target, parent) {
+    // @ts-ignore
+    return new DraftSet(target, parent);
+  }
+
+  function prepareSetCopy(state) {
+    if (!state.copy_) {
+      // create drafts for all entries to preserve insertion order
+      state.copy_ = new Set();
+      state.base_.forEach(function (value) {
+        if (isDraftable(value)) {
+          var draft = createProxy(state.scope_.immer_, value, state);
+          state.drafts_.set(value, draft);
+          state.copy_.add(draft);
+        } else {
+          state.copy_.add(value);
+        }
+      });
+    }
+  }
+
+  function assertUnrevoked(state
+  /*ES5State | MapState | SetState*/
+  ) {
+    if (state.revoked_) die(3, JSON.stringify(latest(state)));
+  }
+
+  loadPlugin("MapSet", {
+    proxyMap_: proxyMap_,
+    proxySet_: proxySet_
+  });
+}
+
+function enableAllPlugins() {
+  enableES5();
+  enableMapSet();
+  enablePatches();
+}
+
 function enablePatches() {
   var REPLACE = "replace";
   var ADD = "add";
@@ -1574,373 +2012,6 @@ function enablePatches() {
   });
 }
 
-// types only!
-function enableMapSet() {
-  /* istanbul ignore next */
-  var _extendStatics = function extendStatics(d, b) {
-    _extendStatics = Object.setPrototypeOf || {
-      __proto__: []
-    } instanceof Array && function (d, b) {
-      d.__proto__ = b;
-    } || function (d, b) {
-      for (var p in b) {
-        if (b.hasOwnProperty(p)) d[p] = b[p];
-      }
-    };
-
-    return _extendStatics(d, b);
-  }; // Ugly hack to resolve #502 and inherit built in Map / Set
-
-
-  function __extends(d, b) {
-    _extendStatics(d, b);
-
-    function __() {
-      this.constructor = d;
-    }
-
-    d.prototype = ( // @ts-ignore
-    __.prototype = b.prototype, new __());
-  }
-
-  var DraftMap = function (_super) {
-    __extends(DraftMap, _super); // Create class manually, cause #502
-
-
-    function DraftMap(target, parent) {
-      this[DRAFT_STATE] = {
-        type_: 2
-        /* Map */
-        ,
-        parent_: parent,
-        scope_: parent ? parent.scope_ : getCurrentScope(),
-        modified_: false,
-        finalized_: false,
-        copy_: undefined,
-        assigned_: undefined,
-        base_: target,
-        draft_: this,
-        isManual_: false,
-        revoked_: false
-      };
-      return this;
-    }
-
-    var p = DraftMap.prototype;
-    Object.defineProperty(p, "size", {
-      get: function get() {
-        return latest(this[DRAFT_STATE]).size;
-      } // enumerable: false,
-      // configurable: true
-
-    });
-
-    p.has = function (key) {
-      return latest(this[DRAFT_STATE]).has(key);
-    };
-
-    p.set = function (key, value) {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-
-      if (!latest(state).has(key) || latest(state).get(key) !== value) {
-        prepareMapCopy(state);
-        markChanged(state);
-        state.assigned_.set(key, true);
-        state.copy_.set(key, value);
-        state.assigned_.set(key, true);
-      }
-
-      return this;
-    };
-
-    p.delete = function (key) {
-      if (!this.has(key)) {
-        return false;
-      }
-
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-      prepareMapCopy(state);
-      markChanged(state);
-
-      if (state.base_.has(key)) {
-        state.assigned_.set(key, false);
-      } else {
-        state.assigned_.delete(key);
-      }
-
-      state.copy_.delete(key);
-      return true;
-    };
-
-    p.clear = function () {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-
-      if (latest(state).size) {
-        prepareMapCopy(state);
-        markChanged(state);
-        state.assigned_ = new Map();
-        each(state.base_, function (key) {
-          state.assigned_.set(key, false);
-        });
-        state.copy_.clear();
-      }
-    };
-
-    p.forEach = function (cb, thisArg) {
-      var _this = this;
-
-      var state = this[DRAFT_STATE];
-      latest(state).forEach(function (_value, key, _map) {
-        cb.call(thisArg, _this.get(key), key, _this);
-      });
-    };
-
-    p.get = function (key) {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-      var value = latest(state).get(key);
-
-      if (state.finalized_ || !isDraftable(value)) {
-        return value;
-      }
-
-      if (value !== state.base_.get(key)) {
-        return value; // either already drafted or reassigned
-      } // despite what it looks, this creates a draft only once, see above condition
-
-
-      var draft = createProxy(state.scope_.immer_, value, state);
-      prepareMapCopy(state);
-      state.copy_.set(key, draft);
-      return draft;
-    };
-
-    p.keys = function () {
-      return latest(this[DRAFT_STATE]).keys();
-    };
-
-    p.values = function () {
-      var _this2 = this,
-          _ref;
-
-      var iterator = this.keys();
-      return _ref = {}, _ref[iteratorSymbol] = function () {
-        return _this2.values();
-      }, _ref.next = function next() {
-        var r = iterator.next();
-        /* istanbul ignore next */
-
-        if (r.done) return r;
-
-        var value = _this2.get(r.value);
-
-        return {
-          done: false,
-          value: value
-        };
-      }, _ref;
-    };
-
-    p.entries = function () {
-      var _this3 = this,
-          _ref2;
-
-      var iterator = this.keys();
-      return _ref2 = {}, _ref2[iteratorSymbol] = function () {
-        return _this3.entries();
-      }, _ref2.next = function next() {
-        var r = iterator.next();
-        /* istanbul ignore next */
-
-        if (r.done) return r;
-
-        var value = _this3.get(r.value);
-
-        return {
-          done: false,
-          value: [r.value, value]
-        };
-      }, _ref2;
-    };
-
-    p[iteratorSymbol] = function () {
-      return this.entries();
-    };
-
-    return DraftMap;
-  }(Map);
-
-  function proxyMap_(target, parent) {
-    // @ts-ignore
-    return new DraftMap(target, parent);
-  }
-
-  function prepareMapCopy(state) {
-    if (!state.copy_) {
-      state.assigned_ = new Map();
-      state.copy_ = new Map(state.base_);
-    }
-  }
-
-  var DraftSet = function (_super) {
-    __extends(DraftSet, _super); // Create class manually, cause #502
-
-
-    function DraftSet(target, parent) {
-      this[DRAFT_STATE] = {
-        type_: 3
-        /* Set */
-        ,
-        parent_: parent,
-        scope_: parent ? parent.scope_ : getCurrentScope(),
-        modified_: false,
-        finalized_: false,
-        copy_: undefined,
-        base_: target,
-        draft_: this,
-        drafts_: new Map(),
-        revoked_: false,
-        isManual_: false
-      };
-      return this;
-    }
-
-    var p = DraftSet.prototype;
-    Object.defineProperty(p, "size", {
-      get: function get() {
-        return latest(this[DRAFT_STATE]).size;
-      } // enumerable: true,
-
-    });
-
-    p.has = function (value) {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value
-
-      if (!state.copy_) {
-        return state.base_.has(value);
-      }
-
-      if (state.copy_.has(value)) return true;
-      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
-      return false;
-    };
-
-    p.add = function (value) {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-
-      if (!this.has(value)) {
-        prepareSetCopy(state);
-        markChanged(state);
-        state.copy_.add(value);
-      }
-
-      return this;
-    };
-
-    p.delete = function (value) {
-      if (!this.has(value)) {
-        return false;
-      }
-
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-      prepareSetCopy(state);
-      markChanged(state);
-      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) :
-      /* istanbul ignore next */
-      false);
-    };
-
-    p.clear = function () {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-
-      if (latest(state).size) {
-        prepareSetCopy(state);
-        markChanged(state);
-        state.copy_.clear();
-      }
-    };
-
-    p.values = function () {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-      prepareSetCopy(state);
-      return state.copy_.values();
-    };
-
-    p.entries = function entries() {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-      prepareSetCopy(state);
-      return state.copy_.entries();
-    };
-
-    p.keys = function () {
-      return this.values();
-    };
-
-    p[iteratorSymbol] = function () {
-      return this.values();
-    };
-
-    p.forEach = function forEach(cb, thisArg) {
-      var iterator = this.values();
-      var result = iterator.next();
-
-      while (!result.done) {
-        cb.call(thisArg, result.value, result.value, this);
-        result = iterator.next();
-      }
-    };
-
-    return DraftSet;
-  }(Set);
-
-  function proxySet_(target, parent) {
-    // @ts-ignore
-    return new DraftSet(target, parent);
-  }
-
-  function prepareSetCopy(state) {
-    if (!state.copy_) {
-      // create drafts for all entries to preserve insertion order
-      state.copy_ = new Set();
-      state.base_.forEach(function (value) {
-        if (isDraftable(value)) {
-          var draft = createProxy(state.scope_.immer_, value, state);
-          state.drafts_.set(value, draft);
-          state.copy_.add(draft);
-        } else {
-          state.copy_.add(value);
-        }
-      });
-    }
-  }
-
-  function assertUnrevoked(state
-  /*ES5State | MapState | SetState*/
-  ) {
-    if (state.revoked_) die(3, JSON.stringify(latest(state)));
-  }
-
-  loadPlugin("MapSet", {
-    proxyMap_: proxyMap_,
-    proxySet_: proxySet_
-  });
-}
-
-function enableAllPlugins() {
-  enableES5();
-  enableMapSet();
-  enablePatches();
-}
-
 var immer =
 /*#__PURE__*/
 new Immer();
diff --git a/dist/immer.cjs.development.js.map b/dist/immer.cjs.development.js.map
index eb5765f7b602a9501a5f9e78e10a84f99b94dffd..5c5476d7e676ad7899a35042f603bf9661a1e53d 100644
--- a/dist/immer.cjs.development.js.map
+++ b/dist/immer.cjs.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"immer.cjs.development.js","sources":["../src/utils/env.ts","../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/patches.ts","../src/plugins/mapset.ts","../src/plugins/all.ts","../src/immer.ts"],"sourcesContent":["// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tthis.constructor = d\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: false,\n\t\t\t// configurable: true\n\t\t})\n\n\t\tp.has = function(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tp.set = function(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.forEach = function(\n\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\tthisArg?: any\n\t\t) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tp.get = function(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp.entries = function(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.entries()\n\t\t}\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: true,\n\t\t})\n\n\t\tp.has = function(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tp.add = function(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tp.entries = function entries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp.forEach = function forEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n"],"names":["hasSymbol","Symbol","hasMap","Map","hasSet","Set","hasProxies","Proxy","revocable","Reflect","NOTHING","for","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","errors","data","path","op","plugin","thing","die","error","args","e","msg","apply","Error","isDraft","value","isDraftable","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","Object","prototype","toString","proto","getPrototypeOf","Ctor","hasOwnProperty","call","Function","original","base_","ownKeys","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","getOwnPropertyDescriptors","target","res","forEach","key","getOwnPropertyDescriptor","each","iter","enumerableOnly","getArchtype","keys","entry","index","state","type_","has","prop","get","set","propOrOldValue","t","delete","add","is","x","y","latest","copy_","shallowCopy","base","slice","descriptors","i","length","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","plugins","getPlugin","pluginKey","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","autoFreeze_","createProxyProxy","parent","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","source","readPropFromProto","peek","prepareCopy","createProxy","getDescriptorFromProto","current","currentState","markChanged","deleteProperty","owner","defineProperty","setPrototypeOf","fn","arguments","isNaN","parseInt","Immer","config","recipe","defaultBase","self","curriedProduce","produce","hasError","Promise","then","p","ip","arg1","arg2","arg3","produceWithPatches","patches","inversePatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","createES5Proxy_","push","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","markChangesRecursively","markChangesSweep","createES5Draft","proxyProperty","assertUnrevoked","drafts","hasArrayChanges","hasObjectChanges","object","min","Math","baseValue","baseIsDraft","descriptor","JSON","stringify","enablePatches","REPLACE","ADD","REMOVE","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","clonePatchValueIfNeeded","assignedValue","origValue","unshift","replacement","parentType","join","type","deepClonePatchValue","splice","map","entries","k","v","cloned","immerable","enableMapSet","extendStatics","d","b","__proto__","__extends","__","DraftMap","_super","size","prepareMapCopy","cb","thisArg","_value","_map","values","next","r","done","DraftSet","prepareSetCopy","enableAllPlugins","bind","castDraft","castImmutable"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"immer.cjs.development.js","sources":["../src/utils/env.ts","../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/mapset.ts","../src/plugins/all.ts","../src/plugins/patches.ts","../src/immer.ts"],"sourcesContent":["// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tconst desc: PropertyDescriptor = {\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: dontMutateFrozenCollections\n\t\t}\n\t\tObject.defineProperties(obj, {\n\t\t\tset: desc,\n\t\t\tadd: desc,\n\t\t\tclear: desc,\n\t\t\tdelete: desc\n\t\t})\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tObject.defineProperty(this, \"constructor\", {\n\t\t\t\tvalue: d\n\t\t\t})\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperties(p, {\n\t\t\tsize: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\thas: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): boolean {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t\t\t}\n\t\t\t},\n\t\t\tset: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any, value: any) {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\t\t}\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelete: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): boolean {\n\t\t\t\t\tif (!this.has(key)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\tif (state.base_.has(key)) {\n\t\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t\t\t}\n\t\t\t\t\tstate.copy_!.delete(key)\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t},\n\t\t\tclear: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (latest(state).size) {\n\t\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\t\t\teach(state.base_, key => {\n\t\t\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tstate.copy_!.clear()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tforEach: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(\n\t\t\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\t\t\tthisArg?: any\n\t\t\t\t) {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t},\n\t\t\tget: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): any {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tconst value = latest(state).get(key)\n\t\t\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\t\t\treturn value\n\t\t\t\t\t}\n\t\t\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t\t\t}\n\t\t\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\tstate.copy_!.set(key, draft)\n\t\t\t\t\treturn draft\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalues: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\tconst iterator = this.keys()\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\t\t\tnext: () => {\n\t\t\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\t\tif (r.done) return r\n\t\t\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\t\t\t\t}\n\t\t\t},\n\t\t\tentries: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<[any, any]> {\n\t\t\t\t\tconst iterator = this.keys()\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\t\t\tnext: () => {\n\t\t\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\t\tif (r.done) return r\n\t\t\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\t\t\t\t}\n\t\t\t},\n\t\t\t[iteratorSymbol]: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\treturn this.entries()\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperties(p, {\n\t\t\tsize: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\thas: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): boolean {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\t\t\tif (!state.copy_) {\n\t\t\t\t\t\treturn state.base_.has(value)\n\t\t\t\t\t}\n\t\t\t\t\tif (state.copy_.has(value)) return true\n\t\t\t\t\tif (\n\t\t\t\t\t\tstate.drafts_.has(value) &&\n\t\t\t\t\t\tstate.copy_.has(state.drafts_.get(value))\n\t\t\t\t\t)\n\t\t\t\t\t\treturn true\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t},\n\t\t\tadd: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): any {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (!this.has(value)) {\n\t\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t\t}\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelete: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): any {\n\t\t\t\t\tif (!this.has(value)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\treturn (\n\t\t\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t},\n\t\t\tclear: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (latest(state).size) {\n\t\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.copy_!.clear()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalues: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\treturn state.copy_!.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\tentries: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function entries(): IterableIterator<[any, any]> {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\treturn state.copy_!.entries()\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\treturn this.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\t[iteratorSymbol]: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\treturn this.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\tforEach: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function forEach(cb: any, thisArg?: any) {\n\t\t\t\t\tconst iterator = this.values()\n\t\t\t\t\tlet result = iterator.next()\n\t\t\t\t\twhile (!result.done) {\n\t\t\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\t\t\tresult = iterator.next()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n"],"names":["hasSymbol","Symbol","hasMap","Map","hasSet","Set","hasProxies","Proxy","revocable","Reflect","NOTHING","for","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","errors","data","path","op","plugin","thing","die","error","args","e","msg","apply","Error","isDraft","value","isDraftable","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","Object","prototype","toString","proto","getPrototypeOf","Ctor","hasOwnProperty","call","Function","original","base_","ownKeys","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","getOwnPropertyDescriptors","target","res","forEach","key","getOwnPropertyDescriptor","each","iter","enumerableOnly","getArchtype","keys","entry","index","state","type_","has","prop","get","set","propOrOldValue","t","delete","add","is","x","y","latest","copy_","shallowCopy","base","slice","descriptors","i","length","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","dontMutateFrozenCollections","defineProperties","clear","plugins","getPlugin","pluginKey","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","autoFreeze_","createProxyProxy","parent","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","source","readPropFromProto","peek","prepareCopy","createProxy","getDescriptorFromProto","current","currentState","markChanged","deleteProperty","owner","defineProperty","setPrototypeOf","fn","arguments","isNaN","parseInt","Immer","config","recipe","defaultBase","self","curriedProduce","produce","hasError","Promise","then","p","ip","arg1","arg2","arg3","produceWithPatches","patches","inversePatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","createES5Proxy_","push","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","markChangesRecursively","markChangesSweep","createES5Draft","proxyProperty","assertUnrevoked","drafts","hasArrayChanges","hasObjectChanges","object","min","Math","baseValue","baseIsDraft","descriptor","JSON","stringify","enableMapSet","extendStatics","d","b","__proto__","__extends","__","DraftMap","_super","size","prepareMapCopy","cb","thisArg","_value","_map","values","next","r","done","entries","DraftSet","prepareSetCopy","enableAllPlugins","enablePatches","REPLACE","ADD","REMOVE","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","clonePatchValueIfNeeded","assignedValue","origValue","unshift","replacement","parentType","join","type","deepClonePatchValue","splice","map","k","v","cloned","immerable","bind","castDraft","castImmutable"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/immer.cjs.production.min.js b/dist/immer.cjs.production.min.js
index e0c17a832b1946ce56e1c5acb9ac102161239fbf..45cd4ddab57c6ce2e490249ad609c15853f51a3f 100644
--- a/dist/immer.cjs.production.min.js
+++ b/dist/immer.cjs.production.min.js
@@ -1,2 +1,2 @@
-function n(n){for(var t=arguments.length,r=Array(t>1?t-1:0),e=1;e<t;e++)r[e-1]=arguments[e];throw Error("[Immer] minified error nr: "+n+(r.length?" "+r.map((function(n){return"'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function t(n){return!!n&&!!n[H]}function r(n){return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var t=Object.getPrototypeOf(n);if(null===t)return!0;var r=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return r===Object||"function"==typeof r&&Function.toString.call(r)===Q}(n)||Array.isArray(n)||!!n[G]||!!n.constructor[G]||c(n)||v(n))}function e(n,t,r){void 0===r&&(r=!1),0===i(n)?(r?Object.keys:T)(n).forEach((function(e){r&&"symbol"==typeof e||t(e,n[e],n)})):n.forEach((function(r,e){return t(e,r,n)}))}function i(n){var t=n[H];return t?t.t>3?t.t-4:t.t:Array.isArray(n)?1:c(n)?2:v(n)?3:0}function u(n,t){return 2===i(n)?n.has(t):Object.prototype.hasOwnProperty.call(n,t)}function o(n,t){return 2===i(n)?n.get(t):n[t]}function f(n,t,r){var e=i(n);2===e?n.set(t,r):3===e?(n.delete(t),n.add(r)):n[t]=r}function a(n,t){return n===t?0!==n||1/n==1/t:n!=n&&t!=t}function c(n){return W&&n instanceof Map}function v(n){return X&&n instanceof Set}function s(n){return n.i||n.u}function p(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var t=U(n);delete t[H];for(var r=T(t),e=0;e<r.length;e++){var i=r[e],u=t[i];!1===u.writable&&(u.writable=!0,u.configurable=!0),(u.get||u.set)&&(t[i]={configurable:!0,writable:!0,enumerable:u.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),t)}function l(n,u){return void 0===u&&(u=!1),h(n)||t(n)||!r(n)?n:(i(n)>1&&(n.set=n.add=n.clear=n.delete=d),Object.freeze(n),u&&e(n,(function(n,t){return l(t,!0)}),!0),n)}function d(){n(2)}function h(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function y(t){var r=V[t];return r||n(18,t),r}function _(n,t){V[n]||(V[n]=t)}function b(){return J}function m(n,t){t&&(y("Patches"),n.o=[],n.v=[],n.s=t)}function j(n){O(n),n.p.forEach(w),n.p=null}function O(n){n===J&&(J=n.l)}function x(n){return J={p:[],l:J,h:n,_:!0,m:0}}function w(n){var t=n[H];0===t.t||1===t.t?t.j():t.O=!0}function S(t,e){e.m=e.p.length;var i=e.p[0],u=void 0!==t&&t!==i;return e.h.S||y("ES5").P(e,t,u),u?(i[H].M&&(j(e),n(4)),r(t)&&(t=P(e,t),e.l||g(e,t)),e.o&&y("Patches").g(i[H].u,t,e.o,e.v)):t=P(e,i,[]),j(e),e.o&&e.s(e.o,e.v),t!==B?t:void 0}function P(n,t,r){if(h(t))return t;var i=t[H];if(!i)return e(t,(function(e,u){return M(n,i,t,e,u,r)}),!0),t;if(i.A!==n)return t;if(!i.M)return g(n,i.u,!0),i.u;if(!i.R){i.R=!0,i.A.m--;var u=4===i.t||5===i.t?i.i=p(i.k):i.i;e(3===i.t?new Set(u):u,(function(t,e){return M(n,i,u,t,e,r)})),g(n,u,!1),r&&n.o&&y("Patches").F(i,r,n.o,n.v)}return i.i}function M(n,e,i,o,a,c){if(t(a)){var v=P(n,a,c&&e&&3!==e.t&&!u(e.D,o)?c.concat(o):void 0);if(f(i,o,v),!t(v))return;n._=!1}if(r(a)&&!h(a)){if(!n.h.K&&n.m<1)return;P(n,a),e&&e.A.l||g(n,a)}}function g(n,t,r){void 0===r&&(r=!1),n.h.K&&n._&&l(t,r)}function A(n,t){var r=n[H];return(r?s(r):n)[t]}function z(n,t){if(t in n)for(var r=Object.getPrototypeOf(n);r;){var e=Object.getOwnPropertyDescriptor(r,t);if(e)return e;r=Object.getPrototypeOf(r)}}function E(n){n.M||(n.M=!0,n.l&&E(n.l))}function R(n){n.i||(n.i=p(n.u))}function k(n,t,r){var e=c(t)?y("MapSet").$(t,r):v(t)?y("MapSet").C(t,r):n.S?function(n,t){var r=Array.isArray(n),e={t:r?1:0,A:t?t.A:b(),M:!1,R:!1,D:{},l:t,u:n,k:null,i:null,j:null,I:!1},i=e,u=Y;r&&(i=[e],u=Z);var o=Proxy.revocable(i,u),f=o.revoke,a=o.proxy;return e.k=a,e.j=f,a}(t,r):y("ES5").J(t,r);return(r?r.A:b()).p.push(e),e}function F(u){return t(u)||n(22,u),function n(t){if(!r(t))return t;var u,a=t[H],c=i(t);if(a){if(!a.M&&(a.t<4||!y("ES5").N(a)))return a.u;a.R=!0,u=D(t,c),a.R=!1}else u=D(t,c);return e(u,(function(t,r){a&&o(a.u,t)===r||f(u,t,n(r))})),3===c?new Set(u):u}(u)}function D(n,t){switch(t){case 2:return new Map(n);case 3:return Array.from(n)}return p(n)}function K(){function n(n,t){var r=f[n];return r?r.enumerable=t:f[n]=r={configurable:!0,enumerable:t,get:function(){return Y.get(this[H],n)},set:function(t){Y.set(this[H],n,t)}},r}function r(n){for(var t=n.length-1;t>=0;t--){var r=n[t][H];if(!r.M)switch(r.t){case 5:o(r)&&E(r);break;case 4:i(r)&&E(r)}}}function i(n){for(var t=n.u,r=n.k,e=T(r),i=e.length-1;i>=0;i--){var o=e[i];if(o!==H){var f=t[o];if(void 0===f&&!u(t,o))return!0;var c=r[o],v=c&&c[H];if(v?v.u!==f:!a(c,f))return!0}}var s=!!t[H];return e.length!==T(t).length+(s?0:1)}function o(n){var t=n.k;if(t.length!==n.u.length)return!0;var r=Object.getOwnPropertyDescriptor(t,t.length-1);if(r&&!r.get)return!0;for(var e=0;e<t.length;e++)if(!t.hasOwnProperty(e))return!0;return!1}var f={};_("ES5",{J:function(t,r){var e=Array.isArray(t),i=function(t,r){if(t){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,""+i,n(i,!0));return e}var u=U(r);delete u[H];for(var o=T(u),f=0;f<o.length;f++){var a=o[f];u[a]=n(a,t||!!u[a].enumerable)}return Object.create(Object.getPrototypeOf(r),u)}(e,t),u={t:e?5:4,A:r?r.A:b(),M:!1,R:!1,D:{},l:r,u:t,k:i,i:null,O:!1,I:!1};return Object.defineProperty(i,H,{value:u,writable:!0}),i},P:function(n,i,f){f?t(i)&&i[H].A===n&&r(n.p):(n.o&&function n(t){if(t&&"object"==typeof t){var r=t[H];if(r){var i=r.u,f=r.k,a=r.D,c=r.t;if(4===c)e(f,(function(t){t!==H&&(void 0!==i[t]||u(i,t)?a[t]||n(f[t]):(a[t]=!0,E(r)))})),e(i,(function(n){void 0!==f[n]||u(f,n)||(a[n]=!1,E(r))}));else if(5===c){if(o(r)&&(E(r),a.length=!0),f.length<i.length)for(var v=f.length;v<i.length;v++)a[v]=!1;else for(var s=i.length;s<f.length;s++)a[s]=!0;for(var p=Math.min(f.length,i.length),l=0;l<p;l++)f.hasOwnProperty(l)||(a[l]=!0),void 0===a[l]&&n(f[l])}}}}(n.p[0]),r(n.p))},N:function(n){return 4===n.t?i(n):o(n)}})}function $(){function f(n){if(!r(n))return n;if(Array.isArray(n))return n.map(f);if(c(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],f(n[1])]})));if(v(n))return new Set(Array.from(n).map(f));var t=Object.create(Object.getPrototypeOf(n));for(var e in n)t[e]=f(n[e]);return u(n,G)&&(t[G]=n[G]),t}function a(n){return t(n)?f(n):n}var s="add";_("Patches",{W:function(t,r){return r.forEach((function(r){for(var e=r.path,u=r.op,a=t,c=0;c<e.length-1;c++){var v=i(a),p=""+e[c];0!==v&&1!==v||"__proto__"!==p&&"constructor"!==p||n(24),"function"==typeof a&&"prototype"===p&&n(24),"object"!=typeof(a=o(a,p))&&n(15,e.join("/"))}var l=i(a),d=f(r.value),h=e[e.length-1];switch(u){case"replace":switch(l){case 2:return a.set(h,d);case 3:n(16);default:return a[h]=d}case s:switch(l){case 1:return"-"===h?a.push(d):a.splice(h,0,d);case 2:return a.set(h,d);case 3:return a.add(d);default:return a[h]=d}case"remove":switch(l){case 1:return a.splice(h,1);case 2:return a.delete(h);case 3:return a.delete(r.value);default:return delete a[h]}default:n(17,u)}})),t},F:function(n,t,r,i){switch(n.t){case 0:case 4:case 2:return function(n,t,r,i){var f=n.u,c=n.i;e(n.D,(function(n,e){var v=o(f,n),p=o(c,n),l=e?u(f,n)?"replace":s:"remove";if(v!==p||"replace"!==l){var d=t.concat(n);r.push("remove"===l?{op:l,path:d}:{op:l,path:d,value:p}),i.push(l===s?{op:"remove",path:d}:"remove"===l?{op:s,path:d,value:a(v)}:{op:"replace",path:d,value:a(v)})}}))}(n,t,r,i);case 5:case 1:return function(n,t,r,e){var i=n.u,u=n.D,o=n.i;if(o.length<i.length){var f=[o,i];i=f[0],o=f[1];var c=[e,r];r=c[0],e=c[1]}for(var v=0;v<i.length;v++)if(u[v]&&o[v]!==i[v]){var p=t.concat([v]);r.push({op:"replace",path:p,value:a(o[v])}),e.push({op:"replace",path:p,value:a(i[v])})}for(var l=i.length;l<o.length;l++){var d=t.concat([l]);r.push({op:s,path:d,value:a(o[l])})}i.length<o.length&&e.push({op:"replace",path:t.concat(["length"]),value:i.length})}(n,t,r,i);case 3:return function(n,t,r,e){var i=n.u,u=n.i,o=0;i.forEach((function(n){if(!u.has(n)){var i=t.concat([o]);r.push({op:"remove",path:i,value:n}),e.unshift({op:s,path:i,value:n})}o++})),o=0,u.forEach((function(n){if(!i.has(n)){var u=t.concat([o]);r.push({op:s,path:u,value:n}),e.unshift({op:"remove",path:u,value:n})}o++}))}(n,t,r,i)}},g:function(n,t,r,e){r.push({op:"replace",path:[],value:t===B?void 0:t}),e.push({op:"replace",path:[],value:n})}})}function C(){function t(n,t){function r(){this.constructor=n}f(n,t),n.prototype=(r.prototype=t.prototype,new r)}function i(n){n.i||(n.D=new Map,n.i=new Map(n.u))}function u(n){n.i||(n.i=new Set,n.u.forEach((function(t){if(r(t)){var e=k(n.A.h,t,n);n.p.set(t,e),n.i.add(e)}else n.i.add(t)})))}function o(t){t.O&&n(3,JSON.stringify(s(t)))}var f=function(n,t){return(f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,t){n.__proto__=t}||function(n,t){for(var r in t)t.hasOwnProperty(r)&&(n[r]=t[r])})(n,t)},a=function(){function n(n,t){return this[H]={t:2,l:t,A:t?t.A:b(),M:!1,R:!1,i:void 0,D:void 0,u:n,k:this,I:!1,O:!1},this}t(n,Map);var u=n.prototype;return Object.defineProperty(u,"size",{get:function(){return s(this[H]).size}}),u.has=function(n){return s(this[H]).has(n)},u.set=function(n,t){var r=this[H];return o(r),s(r).has(n)&&s(r).get(n)===t||(i(r),E(r),r.D.set(n,!0),r.i.set(n,t),r.D.set(n,!0)),this},u.delete=function(n){if(!this.has(n))return!1;var t=this[H];return o(t),i(t),E(t),t.u.has(n)?t.D.set(n,!1):t.D.delete(n),t.i.delete(n),!0},u.clear=function(){var n=this[H];o(n),s(n).size&&(i(n),E(n),n.D=new Map,e(n.u,(function(t){n.D.set(t,!1)})),n.i.clear())},u.forEach=function(n,t){var r=this;s(this[H]).forEach((function(e,i){n.call(t,r.get(i),i,r)}))},u.get=function(n){var t=this[H];o(t);var e=s(t).get(n);if(t.R||!r(e))return e;if(e!==t.u.get(n))return e;var u=k(t.A.h,e,t);return i(t),t.i.set(n,u),u},u.keys=function(){return s(this[H]).keys()},u.values=function(){var n,t=this,r=this.keys();return(n={})[L]=function(){return t.values()},n.next=function(){var n=r.next();return n.done?n:{done:!1,value:t.get(n.value)}},n},u.entries=function(){var n,t=this,r=this.keys();return(n={})[L]=function(){return t.entries()},n.next=function(){var n=r.next();if(n.done)return n;var e=t.get(n.value);return{done:!1,value:[n.value,e]}},n},u[L]=function(){return this.entries()},n}(),c=function(){function n(n,t){return this[H]={t:3,l:t,A:t?t.A:b(),M:!1,R:!1,i:void 0,u:n,k:this,p:new Map,O:!1,I:!1},this}t(n,Set);var r=n.prototype;return Object.defineProperty(r,"size",{get:function(){return s(this[H]).size}}),r.has=function(n){var t=this[H];return o(t),t.i?!!t.i.has(n)||!(!t.p.has(n)||!t.i.has(t.p.get(n))):t.u.has(n)},r.add=function(n){var t=this[H];return o(t),this.has(n)||(u(t),E(t),t.i.add(n)),this},r.delete=function(n){if(!this.has(n))return!1;var t=this[H];return o(t),u(t),E(t),t.i.delete(n)||!!t.p.has(n)&&t.i.delete(t.p.get(n))},r.clear=function(){var n=this[H];o(n),s(n).size&&(u(n),E(n),n.i.clear())},r.values=function(){var n=this[H];return o(n),u(n),n.i.values()},r.entries=function(){var n=this[H];return o(n),u(n),n.i.entries()},r.keys=function(){return this.values()},r[L]=function(){return this.values()},r.forEach=function(n,t){for(var r=this.values(),e=r.next();!e.done;)n.call(t,e.value,e.value,this),e=r.next()},n}();_("MapSet",{$:function(n,t){return new a(n,t)},C:function(n,t){return new c(n,t)}})}var I;Object.defineProperty(exports,"__esModule",{value:!0});var J,N="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),W="undefined"!=typeof Map,X="undefined"!=typeof Set,q="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,B=N?Symbol.for("immer-nothing"):((I={})["immer-nothing"]=!0,I),G=N?Symbol.for("immer-draftable"):"__$immer_draftable",H=N?Symbol.for("immer-state"):"__$immer_state",L="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",Q=""+Object.prototype.constructor,T="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,U=Object.getOwnPropertyDescriptors||function(n){var t={};return T(n).forEach((function(r){t[r]=Object.getOwnPropertyDescriptor(n,r)})),t},V={},Y={get:function(n,t){if(t===H)return n;var e=s(n);if(!u(e,t))return function(n,t,r){var e,i=z(t,r);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,t);var i=e[t];return n.R||!r(i)?i:i===A(n.u,t)?(R(n),n.i[t]=k(n.A.h,i,n)):i},has:function(n,t){return t in s(n)},ownKeys:function(n){return Reflect.ownKeys(s(n))},set:function(n,t,r){var e=z(s(n),t);if(null==e?void 0:e.set)return e.set.call(n.k,r),!0;if(!n.M){var i=A(s(n),t),o=null==i?void 0:i[H];if(o&&o.u===r)return n.i[t]=r,n.D[t]=!1,!0;if(a(r,i)&&(void 0!==r||u(n.u,t)))return!0;R(n),E(n)}return n.i[t]===r&&"number"!=typeof r&&(void 0!==r||t in n.i)||(n.i[t]=r,n.D[t]=!0,!0)},deleteProperty:function(n,t){return void 0!==A(n.u,t)||t in n.u?(n.D[t]=!1,R(n),E(n)):delete n.D[t],n.i&&delete n.i[t],!0},getOwnPropertyDescriptor:function(n,t){var r=s(n),e=Reflect.getOwnPropertyDescriptor(r,t);return e?{writable:!0,configurable:1!==n.t||"length"!==t,enumerable:e.enumerable,value:r[t]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.u)},setPrototypeOf:function(){n(12)}},Z={};e(Y,(function(n,t){Z[n]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),Z.deleteProperty=function(n,t){return Z.set.call(this,n,t,void 0)},Z.set=function(n,t,r){return Y.set.call(this,n[0],t,r,n[0])};var nn=function(){function e(t){var e=this;this.S=q,this.K=!0,this.produce=function(t,i,u){if("function"==typeof t&&"function"!=typeof i){var o=i;i=t;var f=e;return function(n){var t=this;void 0===n&&(n=o);for(var r=arguments.length,e=Array(r>1?r-1:0),u=1;u<r;u++)e[u-1]=arguments[u];return f.produce(n,(function(n){var r;return(r=i).call.apply(r,[t,n].concat(e))}))}}var a;if("function"!=typeof i&&n(6),void 0!==u&&"function"!=typeof u&&n(7),r(t)){var c=x(e),v=k(e,t,void 0),s=!0;try{a=i(v),s=!1}finally{s?j(c):O(c)}return"undefined"!=typeof Promise&&a instanceof Promise?a.then((function(n){return m(c,u),S(n,c)}),(function(n){throw j(c),n})):(m(c,u),S(a,c))}if(!t||"object"!=typeof t){if(void 0===(a=i(t))&&(a=t),a===B&&(a=void 0),e.K&&l(a,!0),u){var p=[],d=[];y("Patches").g(t,a,p,d),u(p,d)}return a}n(21,t)},this.produceWithPatches=function(n,t){if("function"==typeof n)return function(t){for(var r=arguments.length,i=Array(r>1?r-1:0),u=1;u<r;u++)i[u-1]=arguments[u];return e.produceWithPatches(t,(function(t){return n.apply(void 0,[t].concat(i))}))};var r,i,u=e.produce(n,t,(function(n,t){r=n,i=t}));return"undefined"!=typeof Promise&&u instanceof Promise?u.then((function(n){return[n,r,i]})):[u,r,i]},"boolean"==typeof(null==t?void 0:t.useProxies)&&this.setUseProxies(t.useProxies),"boolean"==typeof(null==t?void 0:t.autoFreeze)&&this.setAutoFreeze(t.autoFreeze)}var i=e.prototype;return i.createDraft=function(e){r(e)||n(8),t(e)&&(e=F(e));var i=x(this),u=k(this,e,void 0);return u[H].I=!0,O(i),u},i.finishDraft=function(n,t){var r=(n&&n[H]).A;return m(r,t),S(void 0,r)},i.setAutoFreeze=function(n){this.K=n},i.setUseProxies=function(t){t&&!q&&n(20),this.S=t},i.applyPatches=function(n,r){var e;for(e=r.length-1;e>=0;e--){var i=r[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}e>-1&&(r=r.slice(e+1));var u=y("Patches").W;return t(n)?u(n,r):this.produce(n,(function(n){return u(n,r)}))},e}(),tn=new nn,rn=tn.produce,en=tn.produceWithPatches.bind(tn),un=tn.setAutoFreeze.bind(tn),on=tn.setUseProxies.bind(tn),fn=tn.applyPatches.bind(tn),an=tn.createDraft.bind(tn),cn=tn.finishDraft.bind(tn);exports.Immer=nn,exports.applyPatches=fn,exports.castDraft=function(n){return n},exports.castImmutable=function(n){return n},exports.createDraft=an,exports.current=F,exports.default=rn,exports.enableAllPlugins=function(){K(),C(),$()},exports.enableES5=K,exports.enableMapSet=C,exports.enablePatches=$,exports.finishDraft=cn,exports.freeze=l,exports.immerable=G,exports.isDraft=t,exports.isDraftable=r,exports.nothing=B,exports.original=function(r){return t(r)||n(23,r),r[H].u},exports.produce=rn,exports.produceWithPatches=en,exports.setAutoFreeze=un,exports.setUseProxies=on;
+function r(r){for(var e=arguments.length,t=Array(e>1?e-1:0),n=1;n<e;n++)t[n-1]=arguments[n];throw Error("[Immer] minified error nr: "+r+(t.length?" "+t.map((function(r){return"'"+r+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function e(r){return!!r&&!!r[H]}function t(r){return!!r&&(function(r){if(!r||"object"!=typeof r)return!1;var e=Object.getPrototypeOf(r);if(null===e)return!0;var t=Object.hasOwnProperty.call(e,"constructor")&&e.constructor;return t===Object||"function"==typeof t&&Function.toString.call(t)===Q}(r)||Array.isArray(r)||!!r[G]||!!r.constructor[G]||c(r)||v(r))}function n(r,e,t){void 0===t&&(t=!1),0===i(r)?(t?Object.keys:T)(r).forEach((function(n){t&&"symbol"==typeof n||e(n,r[n],r)})):r.forEach((function(t,n){return e(n,t,r)}))}function i(r){var e=r[H];return e?e.t>3?e.t-4:e.t:Array.isArray(r)?1:c(r)?2:v(r)?3:0}function u(r,e){return 2===i(r)?r.has(e):Object.prototype.hasOwnProperty.call(r,e)}function o(r,e){return 2===i(r)?r.get(e):r[e]}function a(r,e,t){var n=i(r);2===n?r.set(e,t):3===n?(r.delete(e),r.add(t)):r[e]=t}function f(r,e){return r===e?0!==r||1/r==1/e:r!=r&&e!=e}function c(r){return W&&r instanceof Map}function v(r){return X&&r instanceof Set}function l(r){return r.i||r.u}function s(r){if(Array.isArray(r))return Array.prototype.slice.call(r);var e=U(r);delete e[H];for(var t=T(e),n=0;n<t.length;n++){var i=t[n],u=e[i];!1===u.writable&&(u.writable=!0,u.configurable=!0),(u.get||u.set)&&(e[i]={configurable:!0,writable:!0,enumerable:u.enumerable,value:r[i]})}return Object.create(Object.getPrototypeOf(r),e)}function p(r,u){if(void 0===u&&(u=!1),d(r)||e(r)||!t(r))return r;if(i(r)>1){var o={configurable:!0,writable:!0,value:b};Object.defineProperties(r,{set:o,add:o,clear:o,delete:o})}return Object.freeze(r),u&&n(r,(function(r,e){return p(e,!0)}),!0),r}function b(){r(2)}function d(r){return null==r||"object"!=typeof r||Object.isFrozen(r)}function h(e){var t=V[e];return t||r(18,e),t}function y(r,e){V[r]||(V[r]=e)}function _(){return J}function w(r,e){e&&(h("Patches"),r.o=[],r.v=[],r.l=e)}function m(r){g(r),r.s.forEach(O),r.s=null}function g(r){r===J&&(J=r.p)}function j(r){return J={s:[],p:J,h:r,_:!0,m:0}}function O(r){var e=r[H];0===e.t||1===e.t?e.g():e.j=!0}function x(e,n){n.m=n.s.length;var i=n.s[0],u=void 0!==e&&e!==i;return n.h.O||h("ES5").S(n,e,u),u?(i[H].P&&(m(n),r(4)),t(e)&&(e=S(n,e),n.p||M(n,e)),n.o&&h("Patches").M(i[H].u,e,n.o,n.v)):e=S(n,i,[]),m(n),n.o&&n.l(n.o,n.v),e!==B?e:void 0}function S(r,e,t){if(d(e))return e;var i=e[H];if(!i)return n(e,(function(n,u){return P(r,i,e,n,u,t)}),!0),e;if(i.A!==r)return e;if(!i.P)return M(r,i.u,!0),i.u;if(!i.k){i.k=!0,i.A.m--;var u=4===i.t||5===i.t?i.i=s(i.R):i.i;n(3===i.t?new Set(u):u,(function(e,n){return P(r,i,u,e,n,t)})),M(r,u,!1),t&&r.o&&h("Patches").F(i,t,r.o,r.v)}return i.i}function P(r,n,i,o,f,c){if(e(f)){var v=S(r,f,c&&n&&3!==n.t&&!u(n.D,o)?c.concat(o):void 0);if(a(i,o,v),!e(v))return;r._=!1}if(t(f)&&!d(f)){if(!r.h.K&&r.m<1)return;S(r,f),n&&n.A.p||M(r,f)}}function M(r,e,t){void 0===t&&(t=!1),r.h.K&&r._&&p(e,t)}function A(r,e){var t=r[H];return(t?l(t):r)[e]}function z(r,e){if(e in r)for(var t=Object.getPrototypeOf(r);t;){var n=Object.getOwnPropertyDescriptor(t,e);if(n)return n;t=Object.getPrototypeOf(t)}}function E(r){r.P||(r.P=!0,r.p&&E(r.p))}function k(r){r.i||(r.i=s(r.u))}function R(r,e,t){var n=c(e)?h("MapSet").$(e,t):v(e)?h("MapSet").C(e,t):r.O?function(r,e){var t=Array.isArray(r),n={t:t?1:0,A:e?e.A:_(),P:!1,k:!1,D:{},p:e,u:r,R:null,i:null,g:null,I:!1},i=n,u=Y;t&&(i=[n],u=Z);var o=Proxy.revocable(i,u),a=o.revoke,f=o.proxy;return n.R=f,n.g=a,f}(e,t):h("ES5").J(e,t);return(t?t.A:_()).s.push(n),n}function F(u){return e(u)||r(22,u),function r(e){if(!t(e))return e;var u,f=e[H],c=i(e);if(f){if(!f.P&&(f.t<4||!h("ES5").N(f)))return f.u;f.k=!0,u=D(e,c),f.k=!1}else u=D(e,c);return n(u,(function(e,t){f&&o(f.u,e)===t||a(u,e,r(t))})),3===c?new Set(u):u}(u)}function D(r,e){switch(e){case 2:return new Map(r);case 3:return Array.from(r)}return s(r)}function K(){function r(r,e){var t=a[r];return t?t.enumerable=e:a[r]=t={configurable:!0,enumerable:e,get:function(){return Y.get(this[H],r)},set:function(e){Y.set(this[H],r,e)}},t}function t(r){for(var e=r.length-1;e>=0;e--){var t=r[e][H];if(!t.P)switch(t.t){case 5:o(t)&&E(t);break;case 4:i(t)&&E(t)}}}function i(r){for(var e=r.u,t=r.R,n=T(t),i=n.length-1;i>=0;i--){var o=n[i];if(o!==H){var a=e[o];if(void 0===a&&!u(e,o))return!0;var c=t[o],v=c&&c[H];if(v?v.u!==a:!f(c,a))return!0}}var l=!!e[H];return n.length!==T(e).length+(l?0:1)}function o(r){var e=r.R;if(e.length!==r.u.length)return!0;var t=Object.getOwnPropertyDescriptor(e,e.length-1);if(t&&!t.get)return!0;for(var n=0;n<e.length;n++)if(!e.hasOwnProperty(n))return!0;return!1}var a={};y("ES5",{J:function(e,t){var n=Array.isArray(e),i=function(e,t){if(e){for(var n=Array(t.length),i=0;i<t.length;i++)Object.defineProperty(n,""+i,r(i,!0));return n}var u=U(t);delete u[H];for(var o=T(u),a=0;a<o.length;a++){var f=o[a];u[f]=r(f,e||!!u[f].enumerable)}return Object.create(Object.getPrototypeOf(t),u)}(n,e),u={t:n?5:4,A:t?t.A:_(),P:!1,k:!1,D:{},p:t,u:e,R:i,i:null,j:!1,I:!1};return Object.defineProperty(i,H,{value:u,writable:!0}),i},S:function(r,i,a){a?e(i)&&i[H].A===r&&t(r.s):(r.o&&function r(e){if(e&&"object"==typeof e){var t=e[H];if(t){var i=t.u,a=t.R,f=t.D,c=t.t;if(4===c)n(a,(function(e){e!==H&&(void 0!==i[e]||u(i,e)?f[e]||r(a[e]):(f[e]=!0,E(t)))})),n(i,(function(r){void 0!==a[r]||u(a,r)||(f[r]=!1,E(t))}));else if(5===c){if(o(t)&&(E(t),f.length=!0),a.length<i.length)for(var v=a.length;v<i.length;v++)f[v]=!1;else for(var l=i.length;l<a.length;l++)f[l]=!0;for(var s=Math.min(a.length,i.length),p=0;p<s;p++)a.hasOwnProperty(p)||(f[p]=!0),void 0===f[p]&&r(a[p])}}}}(r.s[0]),t(r.s))},N:function(r){return 4===r.t?i(r):o(r)}})}function $(){function e(r,e){function t(){Object.defineProperty(this,"constructor",{value:r})}a(r,e),r.prototype=(t.prototype=e.prototype,new t)}function i(r){r.i||(r.D=new Map,r.i=new Map(r.u))}function u(r){r.i||(r.i=new Set,r.u.forEach((function(e){if(t(e)){var n=R(r.A.h,e,r);r.s.set(e,n),r.i.add(n)}else r.i.add(e)})))}function o(e){e.j&&r(3,JSON.stringify(l(e)))}var a=function(r,e){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(r,e){r.__proto__=e}||function(r,e){for(var t in e)e.hasOwnProperty(t)&&(r[t]=e[t])})(r,e)},f=function(){function r(r,e){return this[H]={t:2,p:e,A:e?e.A:_(),P:!1,k:!1,i:void 0,D:void 0,u:r,R:this,I:!1,j:!1},this}var u;return e(r,Map),Object.defineProperties(r.prototype,((u={size:{get:function(){return l(this[H]).size},configurable:!0},has:{configurable:!0,writable:!0,value:function(r){return l(this[H]).has(r)}},set:{configurable:!0,writable:!0,value:function(r,e){var t=this[H];return o(t),l(t).has(r)&&l(t).get(r)===e||(i(t),E(t),t.D.set(r,!0),t.i.set(r,e),t.D.set(r,!0)),this}},delete:{configurable:!0,writable:!0,value:function(r){if(!this.has(r))return!1;var e=this[H];return o(e),i(e),E(e),e.u.has(r)?e.D.set(r,!1):e.D.delete(r),e.i.delete(r),!0}},clear:{configurable:!0,writable:!0,value:function(){var r=this[H];o(r),l(r).size&&(i(r),E(r),r.D=new Map,n(r.u,(function(e){r.D.set(e,!1)})),r.i.clear())}},forEach:{configurable:!0,writable:!0,value:function(r,e){var t=this;l(this[H]).forEach((function(n,i){r.call(e,t.get(i),i,t)}))}},get:{configurable:!0,writable:!0,value:function(r){var e=this[H];o(e);var n=l(e).get(r);if(e.k||!t(n))return n;if(n!==e.u.get(r))return n;var u=R(e.A.h,n,e);return i(e),e.i.set(r,u),u}},keys:{configurable:!0,writable:!0,value:function(){return l(this[H]).keys()}},values:{configurable:!0,writable:!0,value:function(){var r,e=this,t=this.keys();return(r={})[L]=function(){return e.values()},r.next=function(){var r=t.next();return r.done?r:{done:!1,value:e.get(r.value)}},r}},entries:{configurable:!0,writable:!0,value:function(){var r,e=this,t=this.keys();return(r={})[L]=function(){return e.entries()},r.next=function(){var r=t.next();if(r.done)return r;var n=e.get(r.value);return{done:!1,value:[r.value,n]}},r}}})[L]={configurable:!0,writable:!0,value:function(){return this.entries()}},u)),r}(),c=function(){function r(r,e){return this[H]={t:3,p:e,A:e?e.A:_(),P:!1,k:!1,i:void 0,u:r,R:this,s:new Map,j:!1,I:!1},this}var t;return e(r,Set),Object.defineProperties(r.prototype,((t={size:{get:function(){return l(this[H]).size},configurable:!0},has:{configurable:!0,writable:!0,value:function(r){var e=this[H];return o(e),e.i?!!e.i.has(r)||!(!e.s.has(r)||!e.i.has(e.s.get(r))):e.u.has(r)}},add:{configurable:!0,writable:!0,value:function(r){var e=this[H];return o(e),this.has(r)||(u(e),E(e),e.i.add(r)),this}},delete:{configurable:!0,writable:!0,value:function(r){if(!this.has(r))return!1;var e=this[H];return o(e),u(e),E(e),e.i.delete(r)||!!e.s.has(r)&&e.i.delete(e.s.get(r))}},clear:{configurable:!0,writable:!0,value:function(){var r=this[H];o(r),l(r).size&&(u(r),E(r),r.i.clear())}},values:{configurable:!0,writable:!0,value:function(){var r=this[H];return o(r),u(r),r.i.values()}},entries:{configurable:!0,writable:!0,value:function(){var r=this[H];return o(r),u(r),r.i.entries()}},keys:{configurable:!0,writable:!0,value:function(){return this.values()}}})[L]={configurable:!0,writable:!0,value:function(){return this.values()}},t.forEach={configurable:!0,writable:!0,value:function(r,e){for(var t=this.values(),n=t.next();!n.done;)r.call(e,n.value,n.value,this),n=t.next()}},t)),r}();y("MapSet",{$:function(r,e){return new f(r,e)},C:function(r,e){return new c(r,e)}})}function C(){function a(r){if(!t(r))return r;if(Array.isArray(r))return r.map(a);if(c(r))return new Map(Array.from(r.entries()).map((function(r){return[r[0],a(r[1])]})));if(v(r))return new Set(Array.from(r).map(a));var e=Object.create(Object.getPrototypeOf(r));for(var n in r)e[n]=a(r[n]);return u(r,G)&&(e[G]=r[G]),e}function f(r){return e(r)?a(r):r}var l="add";y("Patches",{W:function(e,t){return t.forEach((function(t){for(var n=t.path,u=t.op,f=e,c=0;c<n.length-1;c++){var v=i(f),s=""+n[c];0!==v&&1!==v||"__proto__"!==s&&"constructor"!==s||r(24),"function"==typeof f&&"prototype"===s&&r(24),"object"!=typeof(f=o(f,s))&&r(15,n.join("/"))}var p=i(f),b=a(t.value),d=n[n.length-1];switch(u){case"replace":switch(p){case 2:return f.set(d,b);case 3:r(16);default:return f[d]=b}case l:switch(p){case 1:return"-"===d?f.push(b):f.splice(d,0,b);case 2:return f.set(d,b);case 3:return f.add(b);default:return f[d]=b}case"remove":switch(p){case 1:return f.splice(d,1);case 2:return f.delete(d);case 3:return f.delete(t.value);default:return delete f[d]}default:r(17,u)}})),e},F:function(r,e,t,i){switch(r.t){case 0:case 4:case 2:return function(r,e,t,i){var a=r.u,c=r.i;n(r.D,(function(r,n){var v=o(a,r),s=o(c,r),p=n?u(a,r)?"replace":l:"remove";if(v!==s||"replace"!==p){var b=e.concat(r);t.push("remove"===p?{op:p,path:b}:{op:p,path:b,value:s}),i.push(p===l?{op:"remove",path:b}:"remove"===p?{op:l,path:b,value:f(v)}:{op:"replace",path:b,value:f(v)})}}))}(r,e,t,i);case 5:case 1:return function(r,e,t,n){var i=r.u,u=r.D,o=r.i;if(o.length<i.length){var a=[o,i];i=a[0],o=a[1];var c=[n,t];t=c[0],n=c[1]}for(var v=0;v<i.length;v++)if(u[v]&&o[v]!==i[v]){var s=e.concat([v]);t.push({op:"replace",path:s,value:f(o[v])}),n.push({op:"replace",path:s,value:f(i[v])})}for(var p=i.length;p<o.length;p++){var b=e.concat([p]);t.push({op:l,path:b,value:f(o[p])})}i.length<o.length&&n.push({op:"replace",path:e.concat(["length"]),value:i.length})}(r,e,t,i);case 3:return function(r,e,t,n){var i=r.u,u=r.i,o=0;i.forEach((function(r){if(!u.has(r)){var i=e.concat([o]);t.push({op:"remove",path:i,value:r}),n.unshift({op:l,path:i,value:r})}o++})),o=0,u.forEach((function(r){if(!i.has(r)){var u=e.concat([o]);t.push({op:l,path:u,value:r}),n.unshift({op:"remove",path:u,value:r})}o++}))}(r,e,t,i)}},M:function(r,e,t,n){t.push({op:"replace",path:[],value:e===B?void 0:e}),n.push({op:"replace",path:[],value:r})}})}var I;Object.defineProperty(exports,"__esModule",{value:!0});var J,N="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),W="undefined"!=typeof Map,X="undefined"!=typeof Set,q="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,B=N?Symbol.for("immer-nothing"):((I={})["immer-nothing"]=!0,I),G=N?Symbol.for("immer-draftable"):"__$immer_draftable",H=N?Symbol.for("immer-state"):"__$immer_state",L="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",Q=""+Object.prototype.constructor,T="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(r){return Object.getOwnPropertyNames(r).concat(Object.getOwnPropertySymbols(r))}:Object.getOwnPropertyNames,U=Object.getOwnPropertyDescriptors||function(r){var e={};return T(r).forEach((function(t){e[t]=Object.getOwnPropertyDescriptor(r,t)})),e},V={},Y={get:function(r,e){if(e===H)return r;var n=l(r);if(!u(n,e))return function(r,e,t){var n,i=z(e,t);return i?"value"in i?i.value:null===(n=i.get)||void 0===n?void 0:n.call(r.R):void 0}(r,n,e);var i=n[e];return r.k||!t(i)?i:i===A(r.u,e)?(k(r),r.i[e]=R(r.A.h,i,r)):i},has:function(r,e){return e in l(r)},ownKeys:function(r){return Reflect.ownKeys(l(r))},set:function(r,e,t){var n=z(l(r),e);if(null==n?void 0:n.set)return n.set.call(r.R,t),!0;if(!r.P){var i=A(l(r),e),o=null==i?void 0:i[H];if(o&&o.u===t)return r.i[e]=t,r.D[e]=!1,!0;if(f(t,i)&&(void 0!==t||u(r.u,e)))return!0;k(r),E(r)}return r.i[e]===t&&"number"!=typeof t&&(void 0!==t||e in r.i)||(r.i[e]=t,r.D[e]=!0,!0)},deleteProperty:function(r,e){return void 0!==A(r.u,e)||e in r.u?(r.D[e]=!1,k(r),E(r)):delete r.D[e],r.i&&delete r.i[e],!0},getOwnPropertyDescriptor:function(r,e){var t=l(r),n=Reflect.getOwnPropertyDescriptor(t,e);return n?{writable:!0,configurable:1!==r.t||"length"!==e,enumerable:n.enumerable,value:t[e]}:n},defineProperty:function(){r(11)},getPrototypeOf:function(r){return Object.getPrototypeOf(r.u)},setPrototypeOf:function(){r(12)}},Z={};n(Y,(function(r,e){Z[r]=function(){return arguments[0]=arguments[0][0],e.apply(this,arguments)}})),Z.deleteProperty=function(r,e){return Z.set.call(this,r,e,void 0)},Z.set=function(r,e,t){return Y.set.call(this,r[0],e,t,r[0])};var rr=function(){function n(e){var n=this;this.O=q,this.K=!0,this.produce=function(e,i,u){if("function"==typeof e&&"function"!=typeof i){var o=i;i=e;var a=n;return function(r){var e=this;void 0===r&&(r=o);for(var t=arguments.length,n=Array(t>1?t-1:0),u=1;u<t;u++)n[u-1]=arguments[u];return a.produce(r,(function(r){var t;return(t=i).call.apply(t,[e,r].concat(n))}))}}var f;if("function"!=typeof i&&r(6),void 0!==u&&"function"!=typeof u&&r(7),t(e)){var c=j(n),v=R(n,e,void 0),l=!0;try{f=i(v),l=!1}finally{l?m(c):g(c)}return"undefined"!=typeof Promise&&f instanceof Promise?f.then((function(r){return w(c,u),x(r,c)}),(function(r){throw m(c),r})):(w(c,u),x(f,c))}if(!e||"object"!=typeof e){if(void 0===(f=i(e))&&(f=e),f===B&&(f=void 0),n.K&&p(f,!0),u){var s=[],b=[];h("Patches").M(e,f,s,b),u(s,b)}return f}r(21,e)},this.produceWithPatches=function(r,e){if("function"==typeof r)return function(e){for(var t=arguments.length,i=Array(t>1?t-1:0),u=1;u<t;u++)i[u-1]=arguments[u];return n.produceWithPatches(e,(function(e){return r.apply(void 0,[e].concat(i))}))};var t,i,u=n.produce(r,e,(function(r,e){t=r,i=e}));return"undefined"!=typeof Promise&&u instanceof Promise?u.then((function(r){return[r,t,i]})):[u,t,i]},"boolean"==typeof(null==e?void 0:e.useProxies)&&this.setUseProxies(e.useProxies),"boolean"==typeof(null==e?void 0:e.autoFreeze)&&this.setAutoFreeze(e.autoFreeze)}var i=n.prototype;return i.createDraft=function(n){t(n)||r(8),e(n)&&(n=F(n));var i=j(this),u=R(this,n,void 0);return u[H].I=!0,g(i),u},i.finishDraft=function(r,e){var t=(r&&r[H]).A;return w(t,e),x(void 0,t)},i.setAutoFreeze=function(r){this.K=r},i.setUseProxies=function(e){e&&!q&&r(20),this.O=e},i.applyPatches=function(r,t){var n;for(n=t.length-1;n>=0;n--){var i=t[n];if(0===i.path.length&&"replace"===i.op){r=i.value;break}}n>-1&&(t=t.slice(n+1));var u=h("Patches").W;return e(r)?u(r,t):this.produce(r,(function(r){return u(r,t)}))},n}(),er=new rr,tr=er.produce,nr=er.produceWithPatches.bind(er),ir=er.setAutoFreeze.bind(er),ur=er.setUseProxies.bind(er),or=er.applyPatches.bind(er),ar=er.createDraft.bind(er),fr=er.finishDraft.bind(er);exports.Immer=rr,exports.applyPatches=or,exports.castDraft=function(r){return r},exports.castImmutable=function(r){return r},exports.createDraft=ar,exports.current=F,exports.default=tr,exports.enableAllPlugins=function(){K(),$(),C()},exports.enableES5=K,exports.enableMapSet=$,exports.enablePatches=C,exports.finishDraft=fr,exports.freeze=p,exports.immerable=G,exports.isDraft=e,exports.isDraftable=t,exports.nothing=B,exports.original=function(t){return e(t)||r(23,t),t[H].u},exports.produce=tr,exports.produceWithPatches=nr,exports.setAutoFreeze=ir,exports.setUseProxies=ur;
 //# sourceMappingURL=immer.cjs.production.min.js.map
diff --git a/dist/immer.cjs.production.min.js.map b/dist/immer.cjs.production.min.js.map
index 663ca4ecc2a853e14526fd64117f2484ca6b6316..ec69c8970d2bace2c7b891c860798da80d5af1ea 100644
--- a/dist/immer.cjs.production.min.js.map
+++ b/dist/immer.cjs.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"immer.cjs.production.min.js","sources":["../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/patches.ts","../src/plugins/mapset.ts","../src/utils/env.ts","../src/immer.ts","../src/plugins/all.ts"],"sourcesContent":["const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tthis.constructor = d\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: false,\n\t\t\t// configurable: true\n\t\t})\n\n\t\tp.has = function(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tp.set = function(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.forEach = function(\n\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\tthisArg?: any\n\t\t) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tp.get = function(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp.entries = function(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.entries()\n\t\t}\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: true,\n\t\t})\n\n\t\tp.has = function(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tp.add = function(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tp.entries = function entries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp.forEach = function forEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n"],"names":["die","error","args","Error","length","map","s","join","isDraft","value","DRAFT_STATE","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","toString","objectCtorString","Array","isArray","DRAFTABLE","isMap","isSet","each","obj","iter","enumerableOnly","getArchtype","keys","ownKeys","forEach","key","entry","index","thing","state","type_","has","prop","prototype","get","set","propOrOldValue","t","delete","add","is","x","y","target","hasMap","Map","hasSet","Set","latest","copy_","base_","shallowCopy","base","slice","descriptors","getOwnPropertyDescriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","loadPlugin","implementation","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","push","current","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","proxyProperty","this","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","defineProperty","markChangesRecursively","object","min","Math","enablePatches","deepClonePatchValue","entries","cloned","immerable","clonePatchValueIfNeeded","ADD","applyPatches_","patches","patch","op","parentType","p","type","splice","basePath","inversePatches","assignedValue","origValue","unshift","replacement","enableMapSet","__extends","d","b","__","extendStatics","prepareMapCopy","prepareSetCopy","assertUnrevoked","JSON","stringify","setPrototypeOf","__proto__","DraftMap","size","cb","thisArg","_value","_this","values","iterator","iteratorSymbol","_this2","next","r","done","_this3","DraftSet","hasSymbol","Symbol","hasProxies","Reflect","for","getOwnPropertySymbols","getOwnPropertyNames","_desc$get","currentState","deleteProperty","owner","fn","arguments","apply","Immer","config","recipe","defaultBase","self","produce","hasError","Promise","then","ip","arg1","arg2","produceWithPatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","applyPatchesImpl","bind"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"immer.cjs.production.min.js","sources":["../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/mapset.ts","../src/plugins/patches.ts","../src/utils/env.ts","../src/immer.ts","../src/plugins/all.ts"],"sourcesContent":["const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tconst desc: PropertyDescriptor = {\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: dontMutateFrozenCollections\n\t\t}\n\t\tObject.defineProperties(obj, {\n\t\t\tset: desc,\n\t\t\tadd: desc,\n\t\t\tclear: desc,\n\t\t\tdelete: desc\n\t\t})\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tObject.defineProperty(this, \"constructor\", {\n\t\t\t\tvalue: d\n\t\t\t})\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperties(p, {\n\t\t\tsize: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\thas: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): boolean {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t\t\t}\n\t\t\t},\n\t\t\tset: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any, value: any) {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\t\t}\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelete: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): boolean {\n\t\t\t\t\tif (!this.has(key)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\tif (state.base_.has(key)) {\n\t\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t\t\t}\n\t\t\t\t\tstate.copy_!.delete(key)\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t},\n\t\t\tclear: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (latest(state).size) {\n\t\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\t\t\teach(state.base_, key => {\n\t\t\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tstate.copy_!.clear()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tforEach: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(\n\t\t\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\t\t\tthisArg?: any\n\t\t\t\t) {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t},\n\t\t\tget: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): any {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tconst value = latest(state).get(key)\n\t\t\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\t\t\treturn value\n\t\t\t\t\t}\n\t\t\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t\t\t}\n\t\t\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\tstate.copy_!.set(key, draft)\n\t\t\t\t\treturn draft\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalues: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\tconst iterator = this.keys()\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\t\t\tnext: () => {\n\t\t\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\t\tif (r.done) return r\n\t\t\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\t\t\t\t}\n\t\t\t},\n\t\t\tentries: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<[any, any]> {\n\t\t\t\t\tconst iterator = this.keys()\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\t\t\tnext: () => {\n\t\t\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\t\tif (r.done) return r\n\t\t\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\t\t\t\t}\n\t\t\t},\n\t\t\t[iteratorSymbol]: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\treturn this.entries()\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperties(p, {\n\t\t\tsize: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\thas: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): boolean {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\t\t\tif (!state.copy_) {\n\t\t\t\t\t\treturn state.base_.has(value)\n\t\t\t\t\t}\n\t\t\t\t\tif (state.copy_.has(value)) return true\n\t\t\t\t\tif (\n\t\t\t\t\t\tstate.drafts_.has(value) &&\n\t\t\t\t\t\tstate.copy_.has(state.drafts_.get(value))\n\t\t\t\t\t)\n\t\t\t\t\t\treturn true\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t},\n\t\t\tadd: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): any {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (!this.has(value)) {\n\t\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t\t}\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelete: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): any {\n\t\t\t\t\tif (!this.has(value)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\treturn (\n\t\t\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t},\n\t\t\tclear: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (latest(state).size) {\n\t\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.copy_!.clear()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalues: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\treturn state.copy_!.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\tentries: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function entries(): IterableIterator<[any, any]> {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\treturn state.copy_!.entries()\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\treturn this.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\t[iteratorSymbol]: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\treturn this.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\tforEach: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function forEach(cb: any, thisArg?: any) {\n\t\t\t\t\tconst iterator = this.values()\n\t\t\t\t\tlet result = iterator.next()\n\t\t\t\t\twhile (!result.done) {\n\t\t\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\t\t\tresult = iterator.next()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n"],"names":["die","error","args","Error","length","map","s","join","isDraft","value","DRAFT_STATE","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","toString","objectCtorString","Array","isArray","DRAFTABLE","isMap","isSet","each","obj","iter","enumerableOnly","getArchtype","keys","ownKeys","forEach","key","entry","index","thing","state","type_","has","prop","prototype","get","set","propOrOldValue","t","delete","add","is","x","y","target","hasMap","Map","hasSet","Set","latest","copy_","base_","shallowCopy","base","slice","descriptors","getOwnPropertyDescriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","dontMutateFrozenCollections","defineProperties","clear","getPlugin","pluginKey","plugin","plugins","loadPlugin","implementation","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","push","current","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","proxyProperty","this","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","defineProperty","markChangesRecursively","object","min","Math","enableMapSet","__extends","d","b","__","extendStatics","prepareMapCopy","prepareSetCopy","assertUnrevoked","JSON","stringify","setPrototypeOf","__proto__","p","DraftMap","size","cb","thisArg","_value","_this","values","iterator","iteratorSymbol","_this2","next","r","done","entries","_this3","DraftSet","enablePatches","deepClonePatchValue","cloned","immerable","clonePatchValueIfNeeded","ADD","applyPatches_","patches","patch","op","parentType","type","splice","basePath","inversePatches","assignedValue","origValue","unshift","replacement","hasSymbol","Symbol","hasProxies","Reflect","for","getOwnPropertySymbols","getOwnPropertyNames","_desc$get","currentState","deleteProperty","owner","fn","arguments","apply","Immer","config","recipe","defaultBase","self","produce","hasError","Promise","then","ip","arg1","arg2","produceWithPatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","applyPatchesImpl","bind"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/immer.esm.js b/dist/immer.esm.js
index 66717386bfb3c349bb9dad4b6d4b70ee4c7277a8..5a3d2580c2d01207c35e8f71ba8838785eb88644 100644
--- a/dist/immer.esm.js
+++ b/dist/immer.esm.js
@@ -1,2 +1,2 @@
-function n(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];if("production"!==process.env.NODE_ENV){var i=Y[n],o=i?"function"==typeof i?i.apply(null,t):i:"unknown error nr: "+n;throw Error("[Immer] "+o)}throw Error("[Immer] minified error nr: "+n+(t.length?" "+t.map((function(n){return"'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r(n){return!!n&&!!n[Q]}function t(n){return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var r=Object.getPrototypeOf(n);if(null===r)return!0;var t=Object.hasOwnProperty.call(r,"constructor")&&r.constructor;return t===Object||"function"==typeof t&&Function.toString.call(t)===Z}(n)||Array.isArray(n)||!!n[L]||!!n.constructor[L]||s(n)||v(n))}function e(t){return r(t)||n(23,t),t[Q].t}function i(n,r,t){void 0===t&&(t=!1),0===o(n)?(t?Object.keys:nn)(n).forEach((function(e){t&&"symbol"==typeof e||r(e,n[e],n)})):n.forEach((function(t,e){return r(e,t,n)}))}function o(n){var r=n[Q];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:s(n)?2:v(n)?3:0}function u(n,r){return 2===o(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a(n,r){return 2===o(n)?n.get(r):n[r]}function f(n,r,t){var e=o(n);2===e?n.set(r,t):3===e?(n.delete(r),n.add(t)):n[r]=t}function c(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function s(n){return X&&n instanceof Map}function v(n){return q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=rn(n);delete r[Q];for(var t=nn(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),r)}function d(n,e){return void 0===e&&(e=!1),y(n)||r(n)||!t(n)?n:(o(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&i(n,(function(n,r){return d(r,!0)}),!0),n)}function h(){n(2)}function y(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function b(r){var t=tn[r];return t||n(18,r),t}function m(n,r){tn[n]||(tn[n]=r)}function _(){return"production"===process.env.NODE_ENV||U||n(0),U}function j(n,r){r&&(b("Patches"),n.u=[],n.s=[],n.v=r)}function O(n){g(n),n.p.forEach(S),n.p=null}function g(n){n===U&&(U=n.l)}function w(n){return U={p:[],l:U,h:n,m:!0,_:0}}function S(n){var r=n[Q];0===r.i||1===r.i?r.j():r.O=!0}function P(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.g||b("ES5").S(e,r,o),o?(i[Q].P&&(O(e),n(4)),t(r)&&(r=M(e,r),e.l||x(e,r)),e.u&&b("Patches").M(i[Q].t,r,e.u,e.s)):r=M(e,i,[]),O(e),e.u&&e.v(e.u,e.s),r!==H?r:void 0}function M(n,r,t){if(y(r))return r;var e=r[Q];if(!e)return i(r,(function(i,o){return A(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o;i(3===e.i?new Set(o):o,(function(r,i){return A(n,e,o,r,i,t)})),x(n,o,!1),t&&n.u&&b("Patches").R(e,t,n.u,n.s)}return e.o}function A(e,i,o,a,c,s){if("production"!==process.env.NODE_ENV&&c===o&&n(5),r(c)){var v=M(e,c,s&&i&&3!==i.i&&!u(i.D,a)?s.concat(a):void 0);if(f(o,a,v),!r(v))return;e.m=!1}if(t(c)&&!y(c)){if(!e.h.F&&e._<1)return;M(e,c),i&&i.A.l||x(e,c)}}function x(n,r,t){void 0===t&&(t=!1),n.h.F&&n.m&&d(r,t)}function z(n,r){var t=n[Q];return(t?p(t):n)[r]}function I(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t)}}function k(n){n.P||(n.P=!0,n.l&&k(n.l))}function E(n){n.o||(n.o=l(n.t))}function R(n,r,t){var e=s(r)?b("MapSet").N(r,t):v(r)?b("MapSet").T(r,t):n.g?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=en;t&&(i=[e],o=on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):b("ES5").J(r,t);return(t?t.A:_()).p.push(e),e}function D(e){return r(e)||n(22,e),function n(r){if(!t(r))return r;var e,u=r[Q],c=o(r);if(u){if(!u.P&&(u.i<4||!b("ES5").K(u)))return u.t;u.I=!0,e=F(r,c),u.I=!1}else e=F(r,c);return i(e,(function(r,t){u&&a(u.t,r)===t||f(e,r,n(t))})),3===c?new Set(e):e}(e)}function F(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}function N(){function t(n,r){var t=s[n];return t?t.enumerable=r:s[n]=t={configurable:!0,enumerable:r,get:function(){var r=this[Q];return"production"!==process.env.NODE_ENV&&f(r),en.get(r,n)},set:function(r){var t=this[Q];"production"!==process.env.NODE_ENV&&f(t),en.set(t,n,r)}},t}function e(n){for(var r=n.length-1;r>=0;r--){var t=n[r][Q];if(!t.P)switch(t.i){case 5:a(t)&&k(t);break;case 4:o(t)&&k(t)}}}function o(n){for(var r=n.t,t=n.k,e=nn(t),i=e.length-1;i>=0;i--){var o=e[i];if(o!==Q){var a=r[o];if(void 0===a&&!u(r,o))return!0;var f=t[o],s=f&&f[Q];if(s?s.t!==a:!c(f,a))return!0}}var v=!!r[Q];return e.length!==nn(r).length+(v?0:1)}function a(n){var r=n.k;if(r.length!==n.t.length)return!0;var t=Object.getOwnPropertyDescriptor(r,r.length-1);if(t&&!t.get)return!0;for(var e=0;e<r.length;e++)if(!r.hasOwnProperty(e))return!0;return!1}function f(r){r.O&&n(3,JSON.stringify(p(r)))}var s={};m("ES5",{J:function(n,r){var e=Array.isArray(n),i=function(n,r){if(n){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,""+i,t(i,!0));return e}var o=rn(r);delete o[Q];for(var u=nn(o),a=0;a<u.length;a++){var f=u[a];o[f]=t(f,n||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(r),o)}(e,n),o={i:e?5:4,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:i,o:null,O:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(n,t,o){o?r(t)&&t[Q].A===n&&e(n.p):(n.u&&function n(r){if(r&&"object"==typeof r){var t=r[Q];if(t){var e=t.t,o=t.k,f=t.D,c=t.i;if(4===c)i(o,(function(r){r!==Q&&(void 0!==e[r]||u(e,r)?f[r]||n(o[r]):(f[r]=!0,k(t)))})),i(e,(function(n){void 0!==o[n]||u(o,n)||(f[n]=!1,k(t))}));else if(5===c){if(a(t)&&(k(t),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)o.hasOwnProperty(l)||(f[l]=!0),void 0===f[l]&&n(o[l])}}}}(n.p[0]),e(n.p))},K:function(n){return 4===n.i?o(n):a(n)}})}function T(){function e(n){if(!t(n))return n;if(Array.isArray(n))return n.map(e);if(s(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(v(n))return new Set(Array.from(n).map(e));var r=Object.create(Object.getPrototypeOf(n));for(var i in n)r[i]=e(n[i]);return u(n,L)&&(r[L]=n[L]),r}function f(n){return r(n)?e(n):n}var c="add";m("Patches",{$:function(r,t){return t.forEach((function(t){for(var i=t.path,u=t.op,f=r,s=0;s<i.length-1;s++){var v=o(f),p=""+i[s];0!==v&&1!==v||"__proto__"!==p&&"constructor"!==p||n(24),"function"==typeof f&&"prototype"===p&&n(24),"object"!=typeof(f=a(f,p))&&n(15,i.join("/"))}var l=o(f),d=e(t.value),h=i[i.length-1];switch(u){case"replace":switch(l){case 2:return f.set(h,d);case 3:n(16);default:return f[h]=d}case c:switch(l){case 1:return"-"===h?f.push(d):f.splice(h,0,d);case 2:return f.set(h,d);case 3:return f.add(d);default:return f[h]=d}case"remove":switch(l){case 1:return f.splice(h,1);case 2:return f.delete(h);case 3:return f.delete(t.value);default:return delete f[h]}default:n(17,u)}})),r},R:function(n,r,t,e){switch(n.i){case 0:case 4:case 2:return function(n,r,t,e){var o=n.t,s=n.o;i(n.D,(function(n,i){var v=a(o,n),p=a(s,n),l=i?u(o,n)?"replace":c:"remove";if(v!==p||"replace"!==l){var d=r.concat(n);t.push("remove"===l?{op:l,path:d}:{op:l,path:d,value:p}),e.push(l===c?{op:"remove",path:d}:"remove"===l?{op:c,path:d,value:f(v)}:{op:"replace",path:d,value:f(v)})}}))}(n,r,t,e);case 5:case 1:return function(n,r,t,e){var i=n.t,o=n.D,u=n.o;if(u.length<i.length){var a=[u,i];i=a[0],u=a[1];var s=[e,t];t=s[0],e=s[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=r.concat([v]);t.push({op:"replace",path:p,value:f(u[v])}),e.push({op:"replace",path:p,value:f(i[v])})}for(var l=i.length;l<u.length;l++){var d=r.concat([l]);t.push({op:c,path:d,value:f(u[l])})}i.length<u.length&&e.push({op:"replace",path:r.concat(["length"]),value:i.length})}(n,r,t,e);case 3:return function(n,r,t,e){var i=n.t,o=n.o,u=0;i.forEach((function(n){if(!o.has(n)){var i=r.concat([u]);t.push({op:"remove",path:i,value:n}),e.unshift({op:c,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=r.concat([u]);t.push({op:c,path:o,value:n}),e.unshift({op:"remove",path:o,value:n})}u++}))}(n,r,t,e)}},M:function(n,r,t,e){t.push({op:"replace",path:[],value:r===H?void 0:r}),e.push({op:"replace",path:[],value:n})}})}function C(){function r(n,r){function t(){this.constructor=n}a(n,r),n.prototype=(t.prototype=r.prototype,new t)}function e(n){n.o||(n.D=new Map,n.o=new Map(n.t))}function o(n){n.o||(n.o=new Set,n.t.forEach((function(r){if(t(r)){var e=R(n.A.h,r,n);n.p.set(r,e),n.o.add(e)}else n.o.add(r)})))}function u(r){r.O&&n(3,JSON.stringify(p(r)))}var a=function(n,r){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t])})(n,r)},f=function(){function n(n,r){return this[Q]={i:2,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,D:void 0,t:n,k:this,C:!1,O:!1},this}r(n,Map);var o=n.prototype;return Object.defineProperty(o,"size",{get:function(){return p(this[Q]).size}}),o.has=function(n){return p(this[Q]).has(n)},o.set=function(n,r){var t=this[Q];return u(t),p(t).has(n)&&p(t).get(n)===r||(e(t),k(t),t.D.set(n,!0),t.o.set(n,r),t.D.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),e(r),k(r),r.t.has(n)?r.D.set(n,!1):r.D.delete(n),r.o.delete(n),!0},o.clear=function(){var n=this[Q];u(n),p(n).size&&(e(n),k(n),n.D=new Map,i(n.t,(function(r){n.D.set(r,!1)})),n.o.clear())},o.forEach=function(n,r){var t=this;p(this[Q]).forEach((function(e,i){n.call(r,t.get(i),i,t)}))},o.get=function(n){var r=this[Q];u(r);var i=p(r).get(n);if(r.I||!t(i))return i;if(i!==r.t.get(n))return i;var o=R(r.A.h,i,r);return e(r),r.o.set(n,o),o},o.keys=function(){return p(this[Q]).keys()},o.values=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.values()},n.next=function(){var n=t.next();return n.done?n:{done:!1,value:r.get(n.value)}},n},o.entries=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.entries()},n.next=function(){var n=t.next();if(n.done)return n;var e=r.get(n.value);return{done:!1,value:[n.value,e]}},n},o[V]=function(){return this.entries()},n}(),c=function(){function n(n,r){return this[Q]={i:3,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,t:n,k:this,p:new Map,O:!1,C:!1},this}r(n,Set);var t=n.prototype;return Object.defineProperty(t,"size",{get:function(){return p(this[Q]).size}}),t.has=function(n){var r=this[Q];return u(r),r.o?!!r.o.has(n)||!(!r.p.has(n)||!r.o.has(r.p.get(n))):r.t.has(n)},t.add=function(n){var r=this[Q];return u(r),this.has(n)||(o(r),k(r),r.o.add(n)),this},t.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),o(r),k(r),r.o.delete(n)||!!r.p.has(n)&&r.o.delete(r.p.get(n))},t.clear=function(){var n=this[Q];u(n),p(n).size&&(o(n),k(n),n.o.clear())},t.values=function(){var n=this[Q];return u(n),o(n),n.o.values()},t.entries=function(){var n=this[Q];return u(n),o(n),n.o.entries()},t.keys=function(){return this.values()},t[V]=function(){return this.values()},t.forEach=function(n,r){for(var t=this.values(),e=t.next();!e.done;)n.call(r,e.value,e.value,this),e=t.next()},n}();m("MapSet",{N:function(n,r){return new f(n,r)},T:function(n,r){return new c(n,r)}})}function J(){N(),C(),T()}function K(n){return n}function $(n){return n}var G,U,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H=W?Symbol.for("immer-nothing"):((G={})["immer-nothing"]=!0,G),L=W?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W?Symbol.for("immer-state"):"__$immer_state",V="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",Y={0:"Illegal state",1:"Immer drafts cannot have computed properties",2:"This object has been frozen and should not be mutated",3:function(n){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+n},4:"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",5:"Immer forbids circular references",6:"The first or second argument to `produce` must be a function",7:"The third argument to `produce` must be a function or undefined",8:"First argument to `createDraft` must be a plain object, an array, or an immerable object",9:"First argument to `finishDraft` must be a draft returned by `createDraft`",10:"The given draft is already finalized",11:"Object.defineProperty() cannot be used on an Immer draft",12:"Object.setPrototypeOf() cannot be used on an Immer draft",13:"Immer only supports deleting array indices",14:"Immer only supports setting array indices and the 'length' property",15:function(n){return"Cannot apply patch, path doesn't resolve: "+n},16:'Sets cannot have "replace" patches.',17:function(n){return"Unsupported patch operation: "+n},18:function(n){return"The plugin for '"+n+"' has not been loaded into Immer. To enable the plugin, import and call `enable"+n+"()` when initializing your application."},20:"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",21:function(n){return"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '"+n+"'"},22:function(n){return"'current' expects a draft, got: "+n},23:function(n){return"'original' expects a draft, got: "+n},24:"Patching reserved attributes like __proto__, prototype and constructor is not allowed"},Z=""+Object.prototype.constructor,nn="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,rn=Object.getOwnPropertyDescriptors||function(n){var r={};return nn(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t)})),r},tn={},en={get:function(n,r){if(r===Q)return n;var e=p(n);if(!u(e,r))return function(n,r,t){var e,i=I(r,t);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!t(i)?i:i===z(n.t,r)?(E(n),n.o[r]=R(n.A.h,i,n)):i},has:function(n,r){return r in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,r,t){var e=I(p(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=z(p(n),r),o=null==i?void 0:i[Q];if(o&&o.t===t)return n.o[r]=t,n.D[r]=!1,!0;if(c(t,i)&&(void 0!==t||u(n.t,r)))return!0;E(n),k(n)}return n.o[r]===t&&"number"!=typeof t&&(void 0!==t||r in n.o)||(n.o[r]=t,n.D[r]=!0,!0)},deleteProperty:function(n,r){return void 0!==z(n.t,r)||r in n.t?(n.D[r]=!1,E(n),k(n)):delete n.D[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=p(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||"length"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n(12)}},on={};i(en,(function(n,r){on[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)}})),on.deleteProperty=function(r,t){return"production"!==process.env.NODE_ENV&&isNaN(parseInt(t))&&n(13),on.set.call(this,r,t,void 0)},on.set=function(r,t,e){return"production"!==process.env.NODE_ENV&&"length"!==t&&isNaN(parseInt(t))&&n(14),en.set.call(this,r[0],t,e,r[0])};var un=function(){function e(r){var e=this;this.g=B,this.F=!0,this.produce=function(r,i,o){if("function"==typeof r&&"function"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return(t=i).call.apply(t,[r,n].concat(e))}))}}var f;if("function"!=typeof i&&n(6),void 0!==o&&"function"!=typeof o&&n(7),t(r)){var c=w(e),s=R(e,r,void 0),v=!0;try{f=i(s),v=!1}finally{v?O(c):g(c)}return"undefined"!=typeof Promise&&f instanceof Promise?f.then((function(n){return j(c,o),P(n,c)}),(function(n){throw O(c),n})):(j(c,o),P(f,c))}if(!r||"object"!=typeof r){if(void 0===(f=i(r))&&(f=r),f===H&&(f=void 0),e.F&&d(f,!0),o){var p=[],l=[];b("Patches").M(r,f,p,l),o(p,l)}return f}n(21,r)},this.produceWithPatches=function(n,r){if("function"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,o=e.produce(n,r,(function(n,r){t=n,i=r}));return"undefined"!=typeof Promise&&o instanceof Promise?o.then((function(n){return[n,t,i]})):[o,t,i]},"boolean"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),"boolean"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze)}var i=e.prototype;return i.createDraft=function(e){t(e)||n(8),r(e)&&(e=D(e));var i=w(this),o=R(this,e,void 0);return o[Q].C=!0,g(i),o},i.finishDraft=function(r,t){var e=r&&r[Q];"production"!==process.env.NODE_ENV&&(e&&e.C||n(9),e.I&&n(10));var i=e.A;return j(i,t),P(void 0,i)},i.setAutoFreeze=function(n){this.F=n},i.setUseProxies=function(r){r&&!B&&n(20),this.g=r},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var o=b("Patches").$;return r(n)?o(n,t):this.produce(n,(function(n){return o(n,t)}))},e}(),an=new un,fn=an.produce,cn=an.produceWithPatches.bind(an),sn=an.setAutoFreeze.bind(an),vn=an.setUseProxies.bind(an),pn=an.applyPatches.bind(an),ln=an.createDraft.bind(an),dn=an.finishDraft.bind(an);export default fn;export{un as Immer,pn as applyPatches,K as castDraft,$ as castImmutable,ln as createDraft,D as current,J as enableAllPlugins,N as enableES5,C as enableMapSet,T as enablePatches,dn as finishDraft,d as freeze,L as immerable,r as isDraft,t as isDraftable,H as nothing,e as original,fn as produce,cn as produceWithPatches,sn as setAutoFreeze,vn as setUseProxies};
+function r(r){for(var e=arguments.length,n=Array(e>1?e-1:0),t=1;t<e;t++)n[t-1]=arguments[t];if("production"!==process.env.NODE_ENV){var i=Y[r],o=i?"function"==typeof i?i.apply(null,n):i:"unknown error nr: "+r;throw Error("[Immer] "+o)}throw Error("[Immer] minified error nr: "+r+(n.length?" "+n.map((function(r){return"'"+r+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function e(r){return!!r&&!!r[Q]}function n(r){return!!r&&(function(r){if(!r||"object"!=typeof r)return!1;var e=Object.getPrototypeOf(r);if(null===e)return!0;var n=Object.hasOwnProperty.call(e,"constructor")&&e.constructor;return n===Object||"function"==typeof n&&Function.toString.call(n)===Z}(r)||Array.isArray(r)||!!r[L]||!!r.constructor[L]||l(r)||s(r))}function t(n){return e(n)||r(23,n),n[Q].t}function i(r,e,n){void 0===n&&(n=!1),0===o(r)?(n?Object.keys:rr)(r).forEach((function(t){n&&"symbol"==typeof t||e(t,r[t],r)})):r.forEach((function(n,t){return e(t,n,r)}))}function o(r){var e=r[Q];return e?e.i>3?e.i-4:e.i:Array.isArray(r)?1:l(r)?2:s(r)?3:0}function a(r,e){return 2===o(r)?r.has(e):Object.prototype.hasOwnProperty.call(r,e)}function u(r,e){return 2===o(r)?r.get(e):r[e]}function f(r,e,n){var t=o(r);2===t?r.set(e,n):3===t?(r.delete(e),r.add(n)):r[e]=n}function c(r,e){return r===e?0!==r||1/r==1/e:r!=r&&e!=e}function l(r){return X&&r instanceof Map}function s(r){return q&&r instanceof Set}function v(r){return r.o||r.t}function p(r){if(Array.isArray(r))return Array.prototype.slice.call(r);var e=er(r);delete e[Q];for(var n=rr(e),t=0;t<n.length;t++){var i=n[t],o=e[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(e[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:r[i]})}return Object.create(Object.getPrototypeOf(r),e)}function d(r,t){if(void 0===t&&(t=!1),h(r)||e(r)||!n(r))return r;if(o(r)>1){var a={configurable:!0,writable:!0,value:b};Object.defineProperties(r,{set:a,add:a,clear:a,delete:a})}return Object.freeze(r),t&&i(r,(function(r,e){return d(e,!0)}),!0),r}function b(){r(2)}function h(r){return null==r||"object"!=typeof r||Object.isFrozen(r)}function y(e){var n=nr[e];return n||r(18,e),n}function m(r,e){nr[r]||(nr[r]=e)}function _(){return"production"===process.env.NODE_ENV||U||r(0),U}function g(r,e){e&&(y("Patches"),r.u=[],r.l=[],r.s=e)}function w(r){j(r),r.v.forEach(S),r.v=null}function j(r){r===U&&(U=r.p)}function O(r){return U={v:[],p:U,h:r,m:!0,_:0}}function S(r){var e=r[Q];0===e.i||1===e.i?e.g():e.j=!0}function P(e,t){t._=t.v.length;var i=t.v[0],o=void 0!==e&&e!==i;return t.h.O||y("ES5").S(t,e,o),o?(i[Q].P&&(w(t),r(4)),n(e)&&(e=M(t,e),t.p||x(t,e)),t.u&&y("Patches").M(i[Q].t,e,t.u,t.l)):e=M(t,i,[]),w(t),t.u&&t.s(t.u,t.l),e!==H?e:void 0}function M(r,e,n){if(h(e))return e;var t=e[Q];if(!t)return i(e,(function(i,o){return A(r,t,e,i,o,n)}),!0),e;if(t.A!==r)return e;if(!t.P)return x(r,t.t,!0),t.t;if(!t.k){t.k=!0,t.A._--;var o=4===t.i||5===t.i?t.o=p(t.I):t.o;i(3===t.i?new Set(o):o,(function(e,i){return A(r,t,o,e,i,n)})),x(r,o,!1),n&&r.u&&y("Patches").R(t,n,r.u,r.l)}return t.o}function A(t,i,o,u,c,l){if("production"!==process.env.NODE_ENV&&c===o&&r(5),e(c)){var s=M(t,c,l&&i&&3!==i.i&&!a(i.D,u)?l.concat(u):void 0);if(f(o,u,s),!e(s))return;t.m=!1}if(n(c)&&!h(c)){if(!t.h.F&&t._<1)return;M(t,c),i&&i.A.p||x(t,c)}}function x(r,e,n){void 0===n&&(n=!1),r.h.F&&r.m&&d(e,n)}function k(r,e){var n=r[Q];return(n?v(n):r)[e]}function z(r,e){if(e in r)for(var n=Object.getPrototypeOf(r);n;){var t=Object.getOwnPropertyDescriptor(n,e);if(t)return t;n=Object.getPrototypeOf(n)}}function I(r){r.P||(r.P=!0,r.p&&I(r.p))}function E(r){r.o||(r.o=p(r.t))}function R(r,e,n){var t=l(e)?y("MapSet").N(e,n):s(e)?y("MapSet").T(e,n):r.O?function(r,e){var n=Array.isArray(r),t={i:n?1:0,A:e?e.A:_(),P:!1,k:!1,D:{},p:e,t:r,I:null,o:null,g:null,C:!1},i=t,o=tr;n&&(i=[t],o=ir);var a=Proxy.revocable(i,o),u=a.revoke,f=a.proxy;return t.I=f,t.g=u,f}(e,n):y("ES5").J(e,n);return(n?n.A:_()).v.push(t),t}function D(t){return e(t)||r(22,t),function r(e){if(!n(e))return e;var t,a=e[Q],c=o(e);if(a){if(!a.P&&(a.i<4||!y("ES5").K(a)))return a.t;a.k=!0,t=F(e,c),a.k=!1}else t=F(e,c);return i(t,(function(e,n){a&&u(a.t,e)===n||f(t,e,r(n))})),3===c?new Set(t):t}(t)}function F(r,e){switch(e){case 2:return new Map(r);case 3:return Array.from(r)}return p(r)}function N(){function n(r,e){var n=l[r];return n?n.enumerable=e:l[r]=n={configurable:!0,enumerable:e,get:function(){var e=this[Q];return"production"!==process.env.NODE_ENV&&f(e),tr.get(e,r)},set:function(e){var n=this[Q];"production"!==process.env.NODE_ENV&&f(n),tr.set(n,r,e)}},n}function t(r){for(var e=r.length-1;e>=0;e--){var n=r[e][Q];if(!n.P)switch(n.i){case 5:u(n)&&I(n);break;case 4:o(n)&&I(n)}}}function o(r){for(var e=r.t,n=r.I,t=rr(n),i=t.length-1;i>=0;i--){var o=t[i];if(o!==Q){var u=e[o];if(void 0===u&&!a(e,o))return!0;var f=n[o],l=f&&f[Q];if(l?l.t!==u:!c(f,u))return!0}}var s=!!e[Q];return t.length!==rr(e).length+(s?0:1)}function u(r){var e=r.I;if(e.length!==r.t.length)return!0;var n=Object.getOwnPropertyDescriptor(e,e.length-1);if(n&&!n.get)return!0;for(var t=0;t<e.length;t++)if(!e.hasOwnProperty(t))return!0;return!1}function f(e){e.j&&r(3,JSON.stringify(v(e)))}var l={};m("ES5",{J:function(r,e){var t=Array.isArray(r),i=function(r,e){if(r){for(var t=Array(e.length),i=0;i<e.length;i++)Object.defineProperty(t,""+i,n(i,!0));return t}var o=er(e);delete o[Q];for(var a=rr(o),u=0;u<a.length;u++){var f=a[u];o[f]=n(f,r||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(e),o)}(t,r),o={i:t?5:4,A:e?e.A:_(),P:!1,k:!1,D:{},p:e,t:r,I:i,o:null,j:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(r,n,o){o?e(n)&&n[Q].A===r&&t(r.v):(r.u&&function r(e){if(e&&"object"==typeof e){var n=e[Q];if(n){var t=n.t,o=n.I,f=n.D,c=n.i;if(4===c)i(o,(function(e){e!==Q&&(void 0!==t[e]||a(t,e)?f[e]||r(o[e]):(f[e]=!0,I(n)))})),i(t,(function(r){void 0!==o[r]||a(o,r)||(f[r]=!1,I(n))}));else if(5===c){if(u(n)&&(I(n),f.length=!0),o.length<t.length)for(var l=o.length;l<t.length;l++)f[l]=!1;else for(var s=t.length;s<o.length;s++)f[s]=!0;for(var v=Math.min(o.length,t.length),p=0;p<v;p++)o.hasOwnProperty(p)||(f[p]=!0),void 0===f[p]&&r(o[p])}}}}(r.v[0]),t(r.v))},K:function(r){return 4===r.i?o(r):u(r)}})}function T(){function e(r,e){function n(){Object.defineProperty(this,"constructor",{value:r})}u(r,e),r.prototype=(n.prototype=e.prototype,new n)}function t(r){r.o||(r.D=new Map,r.o=new Map(r.t))}function o(r){r.o||(r.o=new Set,r.t.forEach((function(e){if(n(e)){var t=R(r.A.h,e,r);r.v.set(e,t),r.o.add(t)}else r.o.add(e)})))}function a(e){e.j&&r(3,JSON.stringify(v(e)))}var u=function(r,e){return(u=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(r,e){r.__proto__=e}||function(r,e){for(var n in e)e.hasOwnProperty(n)&&(r[n]=e[n])})(r,e)},f=function(){function r(r,e){return this[Q]={i:2,p:e,A:e?e.A:_(),P:!1,k:!1,o:void 0,D:void 0,t:r,I:this,C:!1,j:!1},this}var o;return e(r,Map),Object.defineProperties(r.prototype,((o={size:{get:function(){return v(this[Q]).size},configurable:!0},has:{configurable:!0,writable:!0,value:function(r){return v(this[Q]).has(r)}},set:{configurable:!0,writable:!0,value:function(r,e){var n=this[Q];return a(n),v(n).has(r)&&v(n).get(r)===e||(t(n),I(n),n.D.set(r,!0),n.o.set(r,e),n.D.set(r,!0)),this}},delete:{configurable:!0,writable:!0,value:function(r){if(!this.has(r))return!1;var e=this[Q];return a(e),t(e),I(e),e.t.has(r)?e.D.set(r,!1):e.D.delete(r),e.o.delete(r),!0}},clear:{configurable:!0,writable:!0,value:function(){var r=this[Q];a(r),v(r).size&&(t(r),I(r),r.D=new Map,i(r.t,(function(e){r.D.set(e,!1)})),r.o.clear())}},forEach:{configurable:!0,writable:!0,value:function(r,e){var n=this;v(this[Q]).forEach((function(t,i){r.call(e,n.get(i),i,n)}))}},get:{configurable:!0,writable:!0,value:function(r){var e=this[Q];a(e);var i=v(e).get(r);if(e.k||!n(i))return i;if(i!==e.t.get(r))return i;var o=R(e.A.h,i,e);return t(e),e.o.set(r,o),o}},keys:{configurable:!0,writable:!0,value:function(){return v(this[Q]).keys()}},values:{configurable:!0,writable:!0,value:function(){var r,e=this,n=this.keys();return(r={})[V]=function(){return e.values()},r.next=function(){var r=n.next();return r.done?r:{done:!1,value:e.get(r.value)}},r}},entries:{configurable:!0,writable:!0,value:function(){var r,e=this,n=this.keys();return(r={})[V]=function(){return e.entries()},r.next=function(){var r=n.next();if(r.done)return r;var t=e.get(r.value);return{done:!1,value:[r.value,t]}},r}}})[V]={configurable:!0,writable:!0,value:function(){return this.entries()}},o)),r}(),c=function(){function r(r,e){return this[Q]={i:3,p:e,A:e?e.A:_(),P:!1,k:!1,o:void 0,t:r,I:this,v:new Map,j:!1,C:!1},this}var n;return e(r,Set),Object.defineProperties(r.prototype,((n={size:{get:function(){return v(this[Q]).size},configurable:!0},has:{configurable:!0,writable:!0,value:function(r){var e=this[Q];return a(e),e.o?!!e.o.has(r)||!(!e.v.has(r)||!e.o.has(e.v.get(r))):e.t.has(r)}},add:{configurable:!0,writable:!0,value:function(r){var e=this[Q];return a(e),this.has(r)||(o(e),I(e),e.o.add(r)),this}},delete:{configurable:!0,writable:!0,value:function(r){if(!this.has(r))return!1;var e=this[Q];return a(e),o(e),I(e),e.o.delete(r)||!!e.v.has(r)&&e.o.delete(e.v.get(r))}},clear:{configurable:!0,writable:!0,value:function(){var r=this[Q];a(r),v(r).size&&(o(r),I(r),r.o.clear())}},values:{configurable:!0,writable:!0,value:function(){var r=this[Q];return a(r),o(r),r.o.values()}},entries:{configurable:!0,writable:!0,value:function(){var r=this[Q];return a(r),o(r),r.o.entries()}},keys:{configurable:!0,writable:!0,value:function(){return this.values()}}})[V]={configurable:!0,writable:!0,value:function(){return this.values()}},n.forEach={configurable:!0,writable:!0,value:function(r,e){for(var n=this.values(),t=n.next();!t.done;)r.call(e,t.value,t.value,this),t=n.next()}},n)),r}();m("MapSet",{N:function(r,e){return new f(r,e)},T:function(r,e){return new c(r,e)}})}function C(){N(),T(),J()}function J(){function t(r){if(!n(r))return r;if(Array.isArray(r))return r.map(t);if(l(r))return new Map(Array.from(r.entries()).map((function(r){return[r[0],t(r[1])]})));if(s(r))return new Set(Array.from(r).map(t));var e=Object.create(Object.getPrototypeOf(r));for(var i in r)e[i]=t(r[i]);return a(r,L)&&(e[L]=r[L]),e}function f(r){return e(r)?t(r):r}var c="add";m("Patches",{$:function(e,n){return n.forEach((function(n){for(var i=n.path,a=n.op,f=e,l=0;l<i.length-1;l++){var s=o(f),v=""+i[l];0!==s&&1!==s||"__proto__"!==v&&"constructor"!==v||r(24),"function"==typeof f&&"prototype"===v&&r(24),"object"!=typeof(f=u(f,v))&&r(15,i.join("/"))}var p=o(f),d=t(n.value),b=i[i.length-1];switch(a){case"replace":switch(p){case 2:return f.set(b,d);case 3:r(16);default:return f[b]=d}case c:switch(p){case 1:return"-"===b?f.push(d):f.splice(b,0,d);case 2:return f.set(b,d);case 3:return f.add(d);default:return f[b]=d}case"remove":switch(p){case 1:return f.splice(b,1);case 2:return f.delete(b);case 3:return f.delete(n.value);default:return delete f[b]}default:r(17,a)}})),e},R:function(r,e,n,t){switch(r.i){case 0:case 4:case 2:return function(r,e,n,t){var o=r.t,l=r.o;i(r.D,(function(r,i){var s=u(o,r),v=u(l,r),p=i?a(o,r)?"replace":c:"remove";if(s!==v||"replace"!==p){var d=e.concat(r);n.push("remove"===p?{op:p,path:d}:{op:p,path:d,value:v}),t.push(p===c?{op:"remove",path:d}:"remove"===p?{op:c,path:d,value:f(s)}:{op:"replace",path:d,value:f(s)})}}))}(r,e,n,t);case 5:case 1:return function(r,e,n,t){var i=r.t,o=r.D,a=r.o;if(a.length<i.length){var u=[a,i];i=u[0],a=u[1];var l=[t,n];n=l[0],t=l[1]}for(var s=0;s<i.length;s++)if(o[s]&&a[s]!==i[s]){var v=e.concat([s]);n.push({op:"replace",path:v,value:f(a[s])}),t.push({op:"replace",path:v,value:f(i[s])})}for(var p=i.length;p<a.length;p++){var d=e.concat([p]);n.push({op:c,path:d,value:f(a[p])})}i.length<a.length&&t.push({op:"replace",path:e.concat(["length"]),value:i.length})}(r,e,n,t);case 3:return function(r,e,n,t){var i=r.t,o=r.o,a=0;i.forEach((function(r){if(!o.has(r)){var i=e.concat([a]);n.push({op:"remove",path:i,value:r}),t.unshift({op:c,path:i,value:r})}a++})),a=0,o.forEach((function(r){if(!i.has(r)){var o=e.concat([a]);n.push({op:c,path:o,value:r}),t.unshift({op:"remove",path:o,value:r})}a++}))}(r,e,n,t)}},M:function(r,e,n,t){n.push({op:"replace",path:[],value:e===H?void 0:e}),t.push({op:"replace",path:[],value:r})}})}function K(r){return r}function $(r){return r}var G,U,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H=W?Symbol.for("immer-nothing"):((G={})["immer-nothing"]=!0,G),L=W?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W?Symbol.for("immer-state"):"__$immer_state",V="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",Y={0:"Illegal state",1:"Immer drafts cannot have computed properties",2:"This object has been frozen and should not be mutated",3:function(r){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+r},4:"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",5:"Immer forbids circular references",6:"The first or second argument to `produce` must be a function",7:"The third argument to `produce` must be a function or undefined",8:"First argument to `createDraft` must be a plain object, an array, or an immerable object",9:"First argument to `finishDraft` must be a draft returned by `createDraft`",10:"The given draft is already finalized",11:"Object.defineProperty() cannot be used on an Immer draft",12:"Object.setPrototypeOf() cannot be used on an Immer draft",13:"Immer only supports deleting array indices",14:"Immer only supports setting array indices and the 'length' property",15:function(r){return"Cannot apply patch, path doesn't resolve: "+r},16:'Sets cannot have "replace" patches.',17:function(r){return"Unsupported patch operation: "+r},18:function(r){return"The plugin for '"+r+"' has not been loaded into Immer. To enable the plugin, import and call `enable"+r+"()` when initializing your application."},20:"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",21:function(r){return"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '"+r+"'"},22:function(r){return"'current' expects a draft, got: "+r},23:function(r){return"'original' expects a draft, got: "+r},24:"Patching reserved attributes like __proto__, prototype and constructor is not allowed"},Z=""+Object.prototype.constructor,rr="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(r){return Object.getOwnPropertyNames(r).concat(Object.getOwnPropertySymbols(r))}:Object.getOwnPropertyNames,er=Object.getOwnPropertyDescriptors||function(r){var e={};return rr(r).forEach((function(n){e[n]=Object.getOwnPropertyDescriptor(r,n)})),e},nr={},tr={get:function(r,e){if(e===Q)return r;var t=v(r);if(!a(t,e))return function(r,e,n){var t,i=z(e,n);return i?"value"in i?i.value:null===(t=i.get)||void 0===t?void 0:t.call(r.I):void 0}(r,t,e);var i=t[e];return r.k||!n(i)?i:i===k(r.t,e)?(E(r),r.o[e]=R(r.A.h,i,r)):i},has:function(r,e){return e in v(r)},ownKeys:function(r){return Reflect.ownKeys(v(r))},set:function(r,e,n){var t=z(v(r),e);if(null==t?void 0:t.set)return t.set.call(r.I,n),!0;if(!r.P){var i=k(v(r),e),o=null==i?void 0:i[Q];if(o&&o.t===n)return r.o[e]=n,r.D[e]=!1,!0;if(c(n,i)&&(void 0!==n||a(r.t,e)))return!0;E(r),I(r)}return r.o[e]===n&&"number"!=typeof n&&(void 0!==n||e in r.o)||(r.o[e]=n,r.D[e]=!0,!0)},deleteProperty:function(r,e){return void 0!==k(r.t,e)||e in r.t?(r.D[e]=!1,E(r),I(r)):delete r.D[e],r.o&&delete r.o[e],!0},getOwnPropertyDescriptor:function(r,e){var n=v(r),t=Reflect.getOwnPropertyDescriptor(n,e);return t?{writable:!0,configurable:1!==r.i||"length"!==e,enumerable:t.enumerable,value:n[e]}:t},defineProperty:function(){r(11)},getPrototypeOf:function(r){return Object.getPrototypeOf(r.t)},setPrototypeOf:function(){r(12)}},ir={};i(tr,(function(r,e){ir[r]=function(){return arguments[0]=arguments[0][0],e.apply(this,arguments)}})),ir.deleteProperty=function(e,n){return"production"!==process.env.NODE_ENV&&isNaN(parseInt(n))&&r(13),ir.set.call(this,e,n,void 0)},ir.set=function(e,n,t){return"production"!==process.env.NODE_ENV&&"length"!==n&&isNaN(parseInt(n))&&r(14),tr.set.call(this,e[0],n,t,e[0])};var or=function(){function t(e){var t=this;this.O=B,this.F=!0,this.produce=function(e,i,o){if("function"==typeof e&&"function"!=typeof i){var a=i;i=e;var u=t;return function(r){var e=this;void 0===r&&(r=a);for(var n=arguments.length,t=Array(n>1?n-1:0),o=1;o<n;o++)t[o-1]=arguments[o];return u.produce(r,(function(r){var n;return(n=i).call.apply(n,[e,r].concat(t))}))}}var f;if("function"!=typeof i&&r(6),void 0!==o&&"function"!=typeof o&&r(7),n(e)){var c=O(t),l=R(t,e,void 0),s=!0;try{f=i(l),s=!1}finally{s?w(c):j(c)}return"undefined"!=typeof Promise&&f instanceof Promise?f.then((function(r){return g(c,o),P(r,c)}),(function(r){throw w(c),r})):(g(c,o),P(f,c))}if(!e||"object"!=typeof e){if(void 0===(f=i(e))&&(f=e),f===H&&(f=void 0),t.F&&d(f,!0),o){var v=[],p=[];y("Patches").M(e,f,v,p),o(v,p)}return f}r(21,e)},this.produceWithPatches=function(r,e){if("function"==typeof r)return function(e){for(var n=arguments.length,i=Array(n>1?n-1:0),o=1;o<n;o++)i[o-1]=arguments[o];return t.produceWithPatches(e,(function(e){return r.apply(void 0,[e].concat(i))}))};var n,i,o=t.produce(r,e,(function(r,e){n=r,i=e}));return"undefined"!=typeof Promise&&o instanceof Promise?o.then((function(r){return[r,n,i]})):[o,n,i]},"boolean"==typeof(null==e?void 0:e.useProxies)&&this.setUseProxies(e.useProxies),"boolean"==typeof(null==e?void 0:e.autoFreeze)&&this.setAutoFreeze(e.autoFreeze)}var i=t.prototype;return i.createDraft=function(t){n(t)||r(8),e(t)&&(t=D(t));var i=O(this),o=R(this,t,void 0);return o[Q].C=!0,j(i),o},i.finishDraft=function(e,n){var t=e&&e[Q];"production"!==process.env.NODE_ENV&&(t&&t.C||r(9),t.k&&r(10));var i=t.A;return g(i,n),P(void 0,i)},i.setAutoFreeze=function(r){this.F=r},i.setUseProxies=function(e){e&&!B&&r(20),this.O=e},i.applyPatches=function(r,n){var t;for(t=n.length-1;t>=0;t--){var i=n[t];if(0===i.path.length&&"replace"===i.op){r=i.value;break}}t>-1&&(n=n.slice(t+1));var o=y("Patches").$;return e(r)?o(r,n):this.produce(r,(function(r){return o(r,n)}))},t}(),ar=new or,ur=ar.produce,fr=ar.produceWithPatches.bind(ar),cr=ar.setAutoFreeze.bind(ar),lr=ar.setUseProxies.bind(ar),sr=ar.applyPatches.bind(ar),vr=ar.createDraft.bind(ar),pr=ar.finishDraft.bind(ar);export default ur;export{or as Immer,sr as applyPatches,K as castDraft,$ as castImmutable,vr as createDraft,D as current,C as enableAllPlugins,N as enableES5,T as enableMapSet,J as enablePatches,pr as finishDraft,d as freeze,L as immerable,e as isDraft,n as isDraftable,H as nothing,t as original,ur as produce,fr as produceWithPatches,cr as setAutoFreeze,lr as setUseProxies};
 //# sourceMappingURL=immer.esm.js.map
diff --git a/dist/immer.esm.js.map b/dist/immer.esm.js.map
index 93c30d80e38fd987cbd62c2cc8b698ee8813dca9..b5a42cdd63c25f007082b5eb96f557e73e17d71b 100644
--- a/dist/immer.esm.js.map
+++ b/dist/immer.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"immer.esm.js","sources":["../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/patches.ts","../src/plugins/mapset.ts","../src/plugins/all.ts","../src/immer.ts","../src/utils/env.ts"],"sourcesContent":["const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tthis.constructor = d\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: false,\n\t\t\t// configurable: true\n\t\t})\n\n\t\tp.has = function(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tp.set = function(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.forEach = function(\n\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\tthisArg?: any\n\t\t) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tp.get = function(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp.entries = function(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.entries()\n\t\t}\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: true,\n\t\t})\n\n\t\tp.has = function(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tp.add = function(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tp.entries = function entries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp.forEach = function forEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n"],"names":["die","error","args","e","errors","msg","apply","Error","length","map","s","join","isDraft","value","DRAFT_STATE","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","toString","objectCtorString","isPlainObject","Array","isArray","DRAFTABLE","isMap","isSet","original","base_","each","obj","iter","enumerableOnly","getArchtype","keys","ownKeys","forEach","key","entry","index","thing","state","type_","has","prop","prototype","get","set","propOrOldValue","t","delete","add","is","x","y","target","hasMap","Map","hasSet","Set","latest","copy_","shallowCopy","base","slice","descriptors","getOwnPropertyDescriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","loadPlugin","implementation","getCurrentScope","process","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createProxyProxy","createES5Proxy_","push","current","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","proxyProperty","this","assertUnrevoked","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","JSON","stringify","defineProperty","createES5Draft","markChangesRecursively","object","min","Math","enablePatches","deepClonePatchValue","entries","cloned","immerable","clonePatchValueIfNeeded","ADD","applyPatches_","patches","patch","op","parentType","p","type","splice","basePath","inversePatches","assignedValue","origValue","generatePatchesFromAssigned","generateArrayPatches","unshift","generateSetPatches","replacement","enableMapSet","__extends","d","b","__","extendStatics","prepareMapCopy","prepareSetCopy","setPrototypeOf","__proto__","DraftMap","size","cb","thisArg","_value","_this","values","iterator","iteratorSymbol","_this2","next","r","done","_this3","DraftSet","enableAllPlugins","castDraft","castImmutable","hasSymbol","Symbol","hasProxies","Reflect","for","data","getOwnPropertySymbols","getOwnPropertyNames","_desc$get","readPropFromProto","currentState","deleteProperty","owner","fn","arguments","isNaN","parseInt","Immer","config","recipe","defaultBase","self","produce","hasError","Promise","then","ip","arg1","arg2","produceWithPatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","applyPatchesImpl","bind"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"immer.esm.js","sources":["../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/mapset.ts","../src/plugins/all.ts","../src/plugins/patches.ts","../src/immer.ts","../src/utils/env.ts"],"sourcesContent":["const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tconst desc: PropertyDescriptor = {\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: dontMutateFrozenCollections\n\t\t}\n\t\tObject.defineProperties(obj, {\n\t\t\tset: desc,\n\t\t\tadd: desc,\n\t\t\tclear: desc,\n\t\t\tdelete: desc\n\t\t})\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tObject.defineProperty(this, \"constructor\", {\n\t\t\t\tvalue: d\n\t\t\t})\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperties(p, {\n\t\t\tsize: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\thas: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): boolean {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t\t\t}\n\t\t\t},\n\t\t\tset: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any, value: any) {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\t\t}\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelete: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): boolean {\n\t\t\t\t\tif (!this.has(key)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\tif (state.base_.has(key)) {\n\t\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t\t\t}\n\t\t\t\t\tstate.copy_!.delete(key)\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t},\n\t\t\tclear: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (latest(state).size) {\n\t\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\t\t\teach(state.base_, key => {\n\t\t\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tstate.copy_!.clear()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tforEach: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(\n\t\t\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\t\t\tthisArg?: any\n\t\t\t\t) {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t},\n\t\t\tget: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): any {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tconst value = latest(state).get(key)\n\t\t\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\t\t\treturn value\n\t\t\t\t\t}\n\t\t\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t\t\t}\n\t\t\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\tstate.copy_!.set(key, draft)\n\t\t\t\t\treturn draft\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalues: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\tconst iterator = this.keys()\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\t\t\tnext: () => {\n\t\t\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\t\tif (r.done) return r\n\t\t\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\t\t\t\t}\n\t\t\t},\n\t\t\tentries: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<[any, any]> {\n\t\t\t\t\tconst iterator = this.keys()\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\t\t\tnext: () => {\n\t\t\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\t\tif (r.done) return r\n\t\t\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\t\t\t\t}\n\t\t\t},\n\t\t\t[iteratorSymbol]: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\treturn this.entries()\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperties(p, {\n\t\t\tsize: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\thas: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): boolean {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\t\t\tif (!state.copy_) {\n\t\t\t\t\t\treturn state.base_.has(value)\n\t\t\t\t\t}\n\t\t\t\t\tif (state.copy_.has(value)) return true\n\t\t\t\t\tif (\n\t\t\t\t\t\tstate.drafts_.has(value) &&\n\t\t\t\t\t\tstate.copy_.has(state.drafts_.get(value))\n\t\t\t\t\t)\n\t\t\t\t\t\treturn true\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t},\n\t\t\tadd: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): any {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (!this.has(value)) {\n\t\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t\t}\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelete: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): any {\n\t\t\t\t\tif (!this.has(value)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\treturn (\n\t\t\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t},\n\t\t\tclear: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (latest(state).size) {\n\t\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.copy_!.clear()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalues: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\treturn state.copy_!.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\tentries: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function entries(): IterableIterator<[any, any]> {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\treturn state.copy_!.entries()\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\treturn this.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\t[iteratorSymbol]: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\treturn this.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\tforEach: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function forEach(cb: any, thisArg?: any) {\n\t\t\t\t\tconst iterator = this.values()\n\t\t\t\t\tlet result = iterator.next()\n\t\t\t\t\twhile (!result.done) {\n\t\t\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\t\t\tresult = iterator.next()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n"],"names":["die","error","args","e","errors","msg","apply","Error","length","map","s","join","isDraft","value","DRAFT_STATE","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","toString","objectCtorString","isPlainObject","Array","isArray","DRAFTABLE","isMap","isSet","original","base_","each","obj","iter","enumerableOnly","getArchtype","keys","ownKeys","forEach","key","entry","index","thing","state","type_","has","prop","prototype","get","set","propOrOldValue","t","delete","add","is","x","y","target","hasMap","Map","hasSet","Set","latest","copy_","shallowCopy","base","slice","descriptors","getOwnPropertyDescriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","dontMutateFrozenCollections","defineProperties","clear","getPlugin","pluginKey","plugin","plugins","loadPlugin","implementation","getCurrentScope","process","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createProxyProxy","createES5Proxy_","push","current","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","proxyProperty","this","assertUnrevoked","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","JSON","stringify","defineProperty","createES5Draft","markChangesRecursively","object","min","Math","enableMapSet","__extends","d","b","__","extendStatics","prepareMapCopy","prepareSetCopy","setPrototypeOf","__proto__","p","DraftMap","size","cb","thisArg","_value","_this","values","iterator","iteratorSymbol","_this2","next","r","done","entries","_this3","DraftSet","enableAllPlugins","enablePatches","deepClonePatchValue","cloned","immerable","clonePatchValueIfNeeded","ADD","applyPatches_","patches","patch","op","parentType","type","splice","basePath","inversePatches","assignedValue","origValue","generatePatchesFromAssigned","generateArrayPatches","unshift","generateSetPatches","replacement","castDraft","castImmutable","hasSymbol","Symbol","hasProxies","Reflect","for","data","getOwnPropertySymbols","getOwnPropertyNames","_desc$get","readPropFromProto","currentState","deleteProperty","owner","fn","arguments","isNaN","parseInt","Immer","config","recipe","defaultBase","self","produce","hasError","Promise","then","ip","arg1","arg2","produceWithPatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","applyPatchesImpl","bind"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/immer.esm.mjs b/dist/immer.esm.mjs
index 66717386bfb3c349bb9dad4b6d4b70ee4c7277a8..5a3d2580c2d01207c35e8f71ba8838785eb88644 100644
--- a/dist/immer.esm.mjs
+++ b/dist/immer.esm.mjs
@@ -1,2 +1,2 @@
-function n(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];if("production"!==process.env.NODE_ENV){var i=Y[n],o=i?"function"==typeof i?i.apply(null,t):i:"unknown error nr: "+n;throw Error("[Immer] "+o)}throw Error("[Immer] minified error nr: "+n+(t.length?" "+t.map((function(n){return"'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r(n){return!!n&&!!n[Q]}function t(n){return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var r=Object.getPrototypeOf(n);if(null===r)return!0;var t=Object.hasOwnProperty.call(r,"constructor")&&r.constructor;return t===Object||"function"==typeof t&&Function.toString.call(t)===Z}(n)||Array.isArray(n)||!!n[L]||!!n.constructor[L]||s(n)||v(n))}function e(t){return r(t)||n(23,t),t[Q].t}function i(n,r,t){void 0===t&&(t=!1),0===o(n)?(t?Object.keys:nn)(n).forEach((function(e){t&&"symbol"==typeof e||r(e,n[e],n)})):n.forEach((function(t,e){return r(e,t,n)}))}function o(n){var r=n[Q];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:s(n)?2:v(n)?3:0}function u(n,r){return 2===o(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a(n,r){return 2===o(n)?n.get(r):n[r]}function f(n,r,t){var e=o(n);2===e?n.set(r,t):3===e?(n.delete(r),n.add(t)):n[r]=t}function c(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function s(n){return X&&n instanceof Map}function v(n){return q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=rn(n);delete r[Q];for(var t=nn(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),r)}function d(n,e){return void 0===e&&(e=!1),y(n)||r(n)||!t(n)?n:(o(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&i(n,(function(n,r){return d(r,!0)}),!0),n)}function h(){n(2)}function y(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function b(r){var t=tn[r];return t||n(18,r),t}function m(n,r){tn[n]||(tn[n]=r)}function _(){return"production"===process.env.NODE_ENV||U||n(0),U}function j(n,r){r&&(b("Patches"),n.u=[],n.s=[],n.v=r)}function O(n){g(n),n.p.forEach(S),n.p=null}function g(n){n===U&&(U=n.l)}function w(n){return U={p:[],l:U,h:n,m:!0,_:0}}function S(n){var r=n[Q];0===r.i||1===r.i?r.j():r.O=!0}function P(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.g||b("ES5").S(e,r,o),o?(i[Q].P&&(O(e),n(4)),t(r)&&(r=M(e,r),e.l||x(e,r)),e.u&&b("Patches").M(i[Q].t,r,e.u,e.s)):r=M(e,i,[]),O(e),e.u&&e.v(e.u,e.s),r!==H?r:void 0}function M(n,r,t){if(y(r))return r;var e=r[Q];if(!e)return i(r,(function(i,o){return A(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o;i(3===e.i?new Set(o):o,(function(r,i){return A(n,e,o,r,i,t)})),x(n,o,!1),t&&n.u&&b("Patches").R(e,t,n.u,n.s)}return e.o}function A(e,i,o,a,c,s){if("production"!==process.env.NODE_ENV&&c===o&&n(5),r(c)){var v=M(e,c,s&&i&&3!==i.i&&!u(i.D,a)?s.concat(a):void 0);if(f(o,a,v),!r(v))return;e.m=!1}if(t(c)&&!y(c)){if(!e.h.F&&e._<1)return;M(e,c),i&&i.A.l||x(e,c)}}function x(n,r,t){void 0===t&&(t=!1),n.h.F&&n.m&&d(r,t)}function z(n,r){var t=n[Q];return(t?p(t):n)[r]}function I(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t)}}function k(n){n.P||(n.P=!0,n.l&&k(n.l))}function E(n){n.o||(n.o=l(n.t))}function R(n,r,t){var e=s(r)?b("MapSet").N(r,t):v(r)?b("MapSet").T(r,t):n.g?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=en;t&&(i=[e],o=on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):b("ES5").J(r,t);return(t?t.A:_()).p.push(e),e}function D(e){return r(e)||n(22,e),function n(r){if(!t(r))return r;var e,u=r[Q],c=o(r);if(u){if(!u.P&&(u.i<4||!b("ES5").K(u)))return u.t;u.I=!0,e=F(r,c),u.I=!1}else e=F(r,c);return i(e,(function(r,t){u&&a(u.t,r)===t||f(e,r,n(t))})),3===c?new Set(e):e}(e)}function F(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}function N(){function t(n,r){var t=s[n];return t?t.enumerable=r:s[n]=t={configurable:!0,enumerable:r,get:function(){var r=this[Q];return"production"!==process.env.NODE_ENV&&f(r),en.get(r,n)},set:function(r){var t=this[Q];"production"!==process.env.NODE_ENV&&f(t),en.set(t,n,r)}},t}function e(n){for(var r=n.length-1;r>=0;r--){var t=n[r][Q];if(!t.P)switch(t.i){case 5:a(t)&&k(t);break;case 4:o(t)&&k(t)}}}function o(n){for(var r=n.t,t=n.k,e=nn(t),i=e.length-1;i>=0;i--){var o=e[i];if(o!==Q){var a=r[o];if(void 0===a&&!u(r,o))return!0;var f=t[o],s=f&&f[Q];if(s?s.t!==a:!c(f,a))return!0}}var v=!!r[Q];return e.length!==nn(r).length+(v?0:1)}function a(n){var r=n.k;if(r.length!==n.t.length)return!0;var t=Object.getOwnPropertyDescriptor(r,r.length-1);if(t&&!t.get)return!0;for(var e=0;e<r.length;e++)if(!r.hasOwnProperty(e))return!0;return!1}function f(r){r.O&&n(3,JSON.stringify(p(r)))}var s={};m("ES5",{J:function(n,r){var e=Array.isArray(n),i=function(n,r){if(n){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,""+i,t(i,!0));return e}var o=rn(r);delete o[Q];for(var u=nn(o),a=0;a<u.length;a++){var f=u[a];o[f]=t(f,n||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(r),o)}(e,n),o={i:e?5:4,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:i,o:null,O:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(n,t,o){o?r(t)&&t[Q].A===n&&e(n.p):(n.u&&function n(r){if(r&&"object"==typeof r){var t=r[Q];if(t){var e=t.t,o=t.k,f=t.D,c=t.i;if(4===c)i(o,(function(r){r!==Q&&(void 0!==e[r]||u(e,r)?f[r]||n(o[r]):(f[r]=!0,k(t)))})),i(e,(function(n){void 0!==o[n]||u(o,n)||(f[n]=!1,k(t))}));else if(5===c){if(a(t)&&(k(t),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)o.hasOwnProperty(l)||(f[l]=!0),void 0===f[l]&&n(o[l])}}}}(n.p[0]),e(n.p))},K:function(n){return 4===n.i?o(n):a(n)}})}function T(){function e(n){if(!t(n))return n;if(Array.isArray(n))return n.map(e);if(s(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(v(n))return new Set(Array.from(n).map(e));var r=Object.create(Object.getPrototypeOf(n));for(var i in n)r[i]=e(n[i]);return u(n,L)&&(r[L]=n[L]),r}function f(n){return r(n)?e(n):n}var c="add";m("Patches",{$:function(r,t){return t.forEach((function(t){for(var i=t.path,u=t.op,f=r,s=0;s<i.length-1;s++){var v=o(f),p=""+i[s];0!==v&&1!==v||"__proto__"!==p&&"constructor"!==p||n(24),"function"==typeof f&&"prototype"===p&&n(24),"object"!=typeof(f=a(f,p))&&n(15,i.join("/"))}var l=o(f),d=e(t.value),h=i[i.length-1];switch(u){case"replace":switch(l){case 2:return f.set(h,d);case 3:n(16);default:return f[h]=d}case c:switch(l){case 1:return"-"===h?f.push(d):f.splice(h,0,d);case 2:return f.set(h,d);case 3:return f.add(d);default:return f[h]=d}case"remove":switch(l){case 1:return f.splice(h,1);case 2:return f.delete(h);case 3:return f.delete(t.value);default:return delete f[h]}default:n(17,u)}})),r},R:function(n,r,t,e){switch(n.i){case 0:case 4:case 2:return function(n,r,t,e){var o=n.t,s=n.o;i(n.D,(function(n,i){var v=a(o,n),p=a(s,n),l=i?u(o,n)?"replace":c:"remove";if(v!==p||"replace"!==l){var d=r.concat(n);t.push("remove"===l?{op:l,path:d}:{op:l,path:d,value:p}),e.push(l===c?{op:"remove",path:d}:"remove"===l?{op:c,path:d,value:f(v)}:{op:"replace",path:d,value:f(v)})}}))}(n,r,t,e);case 5:case 1:return function(n,r,t,e){var i=n.t,o=n.D,u=n.o;if(u.length<i.length){var a=[u,i];i=a[0],u=a[1];var s=[e,t];t=s[0],e=s[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=r.concat([v]);t.push({op:"replace",path:p,value:f(u[v])}),e.push({op:"replace",path:p,value:f(i[v])})}for(var l=i.length;l<u.length;l++){var d=r.concat([l]);t.push({op:c,path:d,value:f(u[l])})}i.length<u.length&&e.push({op:"replace",path:r.concat(["length"]),value:i.length})}(n,r,t,e);case 3:return function(n,r,t,e){var i=n.t,o=n.o,u=0;i.forEach((function(n){if(!o.has(n)){var i=r.concat([u]);t.push({op:"remove",path:i,value:n}),e.unshift({op:c,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=r.concat([u]);t.push({op:c,path:o,value:n}),e.unshift({op:"remove",path:o,value:n})}u++}))}(n,r,t,e)}},M:function(n,r,t,e){t.push({op:"replace",path:[],value:r===H?void 0:r}),e.push({op:"replace",path:[],value:n})}})}function C(){function r(n,r){function t(){this.constructor=n}a(n,r),n.prototype=(t.prototype=r.prototype,new t)}function e(n){n.o||(n.D=new Map,n.o=new Map(n.t))}function o(n){n.o||(n.o=new Set,n.t.forEach((function(r){if(t(r)){var e=R(n.A.h,r,n);n.p.set(r,e),n.o.add(e)}else n.o.add(r)})))}function u(r){r.O&&n(3,JSON.stringify(p(r)))}var a=function(n,r){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t])})(n,r)},f=function(){function n(n,r){return this[Q]={i:2,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,D:void 0,t:n,k:this,C:!1,O:!1},this}r(n,Map);var o=n.prototype;return Object.defineProperty(o,"size",{get:function(){return p(this[Q]).size}}),o.has=function(n){return p(this[Q]).has(n)},o.set=function(n,r){var t=this[Q];return u(t),p(t).has(n)&&p(t).get(n)===r||(e(t),k(t),t.D.set(n,!0),t.o.set(n,r),t.D.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),e(r),k(r),r.t.has(n)?r.D.set(n,!1):r.D.delete(n),r.o.delete(n),!0},o.clear=function(){var n=this[Q];u(n),p(n).size&&(e(n),k(n),n.D=new Map,i(n.t,(function(r){n.D.set(r,!1)})),n.o.clear())},o.forEach=function(n,r){var t=this;p(this[Q]).forEach((function(e,i){n.call(r,t.get(i),i,t)}))},o.get=function(n){var r=this[Q];u(r);var i=p(r).get(n);if(r.I||!t(i))return i;if(i!==r.t.get(n))return i;var o=R(r.A.h,i,r);return e(r),r.o.set(n,o),o},o.keys=function(){return p(this[Q]).keys()},o.values=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.values()},n.next=function(){var n=t.next();return n.done?n:{done:!1,value:r.get(n.value)}},n},o.entries=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.entries()},n.next=function(){var n=t.next();if(n.done)return n;var e=r.get(n.value);return{done:!1,value:[n.value,e]}},n},o[V]=function(){return this.entries()},n}(),c=function(){function n(n,r){return this[Q]={i:3,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,t:n,k:this,p:new Map,O:!1,C:!1},this}r(n,Set);var t=n.prototype;return Object.defineProperty(t,"size",{get:function(){return p(this[Q]).size}}),t.has=function(n){var r=this[Q];return u(r),r.o?!!r.o.has(n)||!(!r.p.has(n)||!r.o.has(r.p.get(n))):r.t.has(n)},t.add=function(n){var r=this[Q];return u(r),this.has(n)||(o(r),k(r),r.o.add(n)),this},t.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),o(r),k(r),r.o.delete(n)||!!r.p.has(n)&&r.o.delete(r.p.get(n))},t.clear=function(){var n=this[Q];u(n),p(n).size&&(o(n),k(n),n.o.clear())},t.values=function(){var n=this[Q];return u(n),o(n),n.o.values()},t.entries=function(){var n=this[Q];return u(n),o(n),n.o.entries()},t.keys=function(){return this.values()},t[V]=function(){return this.values()},t.forEach=function(n,r){for(var t=this.values(),e=t.next();!e.done;)n.call(r,e.value,e.value,this),e=t.next()},n}();m("MapSet",{N:function(n,r){return new f(n,r)},T:function(n,r){return new c(n,r)}})}function J(){N(),C(),T()}function K(n){return n}function $(n){return n}var G,U,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H=W?Symbol.for("immer-nothing"):((G={})["immer-nothing"]=!0,G),L=W?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W?Symbol.for("immer-state"):"__$immer_state",V="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",Y={0:"Illegal state",1:"Immer drafts cannot have computed properties",2:"This object has been frozen and should not be mutated",3:function(n){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+n},4:"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",5:"Immer forbids circular references",6:"The first or second argument to `produce` must be a function",7:"The third argument to `produce` must be a function or undefined",8:"First argument to `createDraft` must be a plain object, an array, or an immerable object",9:"First argument to `finishDraft` must be a draft returned by `createDraft`",10:"The given draft is already finalized",11:"Object.defineProperty() cannot be used on an Immer draft",12:"Object.setPrototypeOf() cannot be used on an Immer draft",13:"Immer only supports deleting array indices",14:"Immer only supports setting array indices and the 'length' property",15:function(n){return"Cannot apply patch, path doesn't resolve: "+n},16:'Sets cannot have "replace" patches.',17:function(n){return"Unsupported patch operation: "+n},18:function(n){return"The plugin for '"+n+"' has not been loaded into Immer. To enable the plugin, import and call `enable"+n+"()` when initializing your application."},20:"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",21:function(n){return"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '"+n+"'"},22:function(n){return"'current' expects a draft, got: "+n},23:function(n){return"'original' expects a draft, got: "+n},24:"Patching reserved attributes like __proto__, prototype and constructor is not allowed"},Z=""+Object.prototype.constructor,nn="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,rn=Object.getOwnPropertyDescriptors||function(n){var r={};return nn(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t)})),r},tn={},en={get:function(n,r){if(r===Q)return n;var e=p(n);if(!u(e,r))return function(n,r,t){var e,i=I(r,t);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!t(i)?i:i===z(n.t,r)?(E(n),n.o[r]=R(n.A.h,i,n)):i},has:function(n,r){return r in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,r,t){var e=I(p(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=z(p(n),r),o=null==i?void 0:i[Q];if(o&&o.t===t)return n.o[r]=t,n.D[r]=!1,!0;if(c(t,i)&&(void 0!==t||u(n.t,r)))return!0;E(n),k(n)}return n.o[r]===t&&"number"!=typeof t&&(void 0!==t||r in n.o)||(n.o[r]=t,n.D[r]=!0,!0)},deleteProperty:function(n,r){return void 0!==z(n.t,r)||r in n.t?(n.D[r]=!1,E(n),k(n)):delete n.D[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=p(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||"length"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n(12)}},on={};i(en,(function(n,r){on[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)}})),on.deleteProperty=function(r,t){return"production"!==process.env.NODE_ENV&&isNaN(parseInt(t))&&n(13),on.set.call(this,r,t,void 0)},on.set=function(r,t,e){return"production"!==process.env.NODE_ENV&&"length"!==t&&isNaN(parseInt(t))&&n(14),en.set.call(this,r[0],t,e,r[0])};var un=function(){function e(r){var e=this;this.g=B,this.F=!0,this.produce=function(r,i,o){if("function"==typeof r&&"function"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return(t=i).call.apply(t,[r,n].concat(e))}))}}var f;if("function"!=typeof i&&n(6),void 0!==o&&"function"!=typeof o&&n(7),t(r)){var c=w(e),s=R(e,r,void 0),v=!0;try{f=i(s),v=!1}finally{v?O(c):g(c)}return"undefined"!=typeof Promise&&f instanceof Promise?f.then((function(n){return j(c,o),P(n,c)}),(function(n){throw O(c),n})):(j(c,o),P(f,c))}if(!r||"object"!=typeof r){if(void 0===(f=i(r))&&(f=r),f===H&&(f=void 0),e.F&&d(f,!0),o){var p=[],l=[];b("Patches").M(r,f,p,l),o(p,l)}return f}n(21,r)},this.produceWithPatches=function(n,r){if("function"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,o=e.produce(n,r,(function(n,r){t=n,i=r}));return"undefined"!=typeof Promise&&o instanceof Promise?o.then((function(n){return[n,t,i]})):[o,t,i]},"boolean"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),"boolean"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze)}var i=e.prototype;return i.createDraft=function(e){t(e)||n(8),r(e)&&(e=D(e));var i=w(this),o=R(this,e,void 0);return o[Q].C=!0,g(i),o},i.finishDraft=function(r,t){var e=r&&r[Q];"production"!==process.env.NODE_ENV&&(e&&e.C||n(9),e.I&&n(10));var i=e.A;return j(i,t),P(void 0,i)},i.setAutoFreeze=function(n){this.F=n},i.setUseProxies=function(r){r&&!B&&n(20),this.g=r},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var o=b("Patches").$;return r(n)?o(n,t):this.produce(n,(function(n){return o(n,t)}))},e}(),an=new un,fn=an.produce,cn=an.produceWithPatches.bind(an),sn=an.setAutoFreeze.bind(an),vn=an.setUseProxies.bind(an),pn=an.applyPatches.bind(an),ln=an.createDraft.bind(an),dn=an.finishDraft.bind(an);export default fn;export{un as Immer,pn as applyPatches,K as castDraft,$ as castImmutable,ln as createDraft,D as current,J as enableAllPlugins,N as enableES5,C as enableMapSet,T as enablePatches,dn as finishDraft,d as freeze,L as immerable,r as isDraft,t as isDraftable,H as nothing,e as original,fn as produce,cn as produceWithPatches,sn as setAutoFreeze,vn as setUseProxies};
+function r(r){for(var e=arguments.length,n=Array(e>1?e-1:0),t=1;t<e;t++)n[t-1]=arguments[t];if("production"!==process.env.NODE_ENV){var i=Y[r],o=i?"function"==typeof i?i.apply(null,n):i:"unknown error nr: "+r;throw Error("[Immer] "+o)}throw Error("[Immer] minified error nr: "+r+(n.length?" "+n.map((function(r){return"'"+r+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function e(r){return!!r&&!!r[Q]}function n(r){return!!r&&(function(r){if(!r||"object"!=typeof r)return!1;var e=Object.getPrototypeOf(r);if(null===e)return!0;var n=Object.hasOwnProperty.call(e,"constructor")&&e.constructor;return n===Object||"function"==typeof n&&Function.toString.call(n)===Z}(r)||Array.isArray(r)||!!r[L]||!!r.constructor[L]||l(r)||s(r))}function t(n){return e(n)||r(23,n),n[Q].t}function i(r,e,n){void 0===n&&(n=!1),0===o(r)?(n?Object.keys:rr)(r).forEach((function(t){n&&"symbol"==typeof t||e(t,r[t],r)})):r.forEach((function(n,t){return e(t,n,r)}))}function o(r){var e=r[Q];return e?e.i>3?e.i-4:e.i:Array.isArray(r)?1:l(r)?2:s(r)?3:0}function a(r,e){return 2===o(r)?r.has(e):Object.prototype.hasOwnProperty.call(r,e)}function u(r,e){return 2===o(r)?r.get(e):r[e]}function f(r,e,n){var t=o(r);2===t?r.set(e,n):3===t?(r.delete(e),r.add(n)):r[e]=n}function c(r,e){return r===e?0!==r||1/r==1/e:r!=r&&e!=e}function l(r){return X&&r instanceof Map}function s(r){return q&&r instanceof Set}function v(r){return r.o||r.t}function p(r){if(Array.isArray(r))return Array.prototype.slice.call(r);var e=er(r);delete e[Q];for(var n=rr(e),t=0;t<n.length;t++){var i=n[t],o=e[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(e[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:r[i]})}return Object.create(Object.getPrototypeOf(r),e)}function d(r,t){if(void 0===t&&(t=!1),h(r)||e(r)||!n(r))return r;if(o(r)>1){var a={configurable:!0,writable:!0,value:b};Object.defineProperties(r,{set:a,add:a,clear:a,delete:a})}return Object.freeze(r),t&&i(r,(function(r,e){return d(e,!0)}),!0),r}function b(){r(2)}function h(r){return null==r||"object"!=typeof r||Object.isFrozen(r)}function y(e){var n=nr[e];return n||r(18,e),n}function m(r,e){nr[r]||(nr[r]=e)}function _(){return"production"===process.env.NODE_ENV||U||r(0),U}function g(r,e){e&&(y("Patches"),r.u=[],r.l=[],r.s=e)}function w(r){j(r),r.v.forEach(S),r.v=null}function j(r){r===U&&(U=r.p)}function O(r){return U={v:[],p:U,h:r,m:!0,_:0}}function S(r){var e=r[Q];0===e.i||1===e.i?e.g():e.j=!0}function P(e,t){t._=t.v.length;var i=t.v[0],o=void 0!==e&&e!==i;return t.h.O||y("ES5").S(t,e,o),o?(i[Q].P&&(w(t),r(4)),n(e)&&(e=M(t,e),t.p||x(t,e)),t.u&&y("Patches").M(i[Q].t,e,t.u,t.l)):e=M(t,i,[]),w(t),t.u&&t.s(t.u,t.l),e!==H?e:void 0}function M(r,e,n){if(h(e))return e;var t=e[Q];if(!t)return i(e,(function(i,o){return A(r,t,e,i,o,n)}),!0),e;if(t.A!==r)return e;if(!t.P)return x(r,t.t,!0),t.t;if(!t.k){t.k=!0,t.A._--;var o=4===t.i||5===t.i?t.o=p(t.I):t.o;i(3===t.i?new Set(o):o,(function(e,i){return A(r,t,o,e,i,n)})),x(r,o,!1),n&&r.u&&y("Patches").R(t,n,r.u,r.l)}return t.o}function A(t,i,o,u,c,l){if("production"!==process.env.NODE_ENV&&c===o&&r(5),e(c)){var s=M(t,c,l&&i&&3!==i.i&&!a(i.D,u)?l.concat(u):void 0);if(f(o,u,s),!e(s))return;t.m=!1}if(n(c)&&!h(c)){if(!t.h.F&&t._<1)return;M(t,c),i&&i.A.p||x(t,c)}}function x(r,e,n){void 0===n&&(n=!1),r.h.F&&r.m&&d(e,n)}function k(r,e){var n=r[Q];return(n?v(n):r)[e]}function z(r,e){if(e in r)for(var n=Object.getPrototypeOf(r);n;){var t=Object.getOwnPropertyDescriptor(n,e);if(t)return t;n=Object.getPrototypeOf(n)}}function I(r){r.P||(r.P=!0,r.p&&I(r.p))}function E(r){r.o||(r.o=p(r.t))}function R(r,e,n){var t=l(e)?y("MapSet").N(e,n):s(e)?y("MapSet").T(e,n):r.O?function(r,e){var n=Array.isArray(r),t={i:n?1:0,A:e?e.A:_(),P:!1,k:!1,D:{},p:e,t:r,I:null,o:null,g:null,C:!1},i=t,o=tr;n&&(i=[t],o=ir);var a=Proxy.revocable(i,o),u=a.revoke,f=a.proxy;return t.I=f,t.g=u,f}(e,n):y("ES5").J(e,n);return(n?n.A:_()).v.push(t),t}function D(t){return e(t)||r(22,t),function r(e){if(!n(e))return e;var t,a=e[Q],c=o(e);if(a){if(!a.P&&(a.i<4||!y("ES5").K(a)))return a.t;a.k=!0,t=F(e,c),a.k=!1}else t=F(e,c);return i(t,(function(e,n){a&&u(a.t,e)===n||f(t,e,r(n))})),3===c?new Set(t):t}(t)}function F(r,e){switch(e){case 2:return new Map(r);case 3:return Array.from(r)}return p(r)}function N(){function n(r,e){var n=l[r];return n?n.enumerable=e:l[r]=n={configurable:!0,enumerable:e,get:function(){var e=this[Q];return"production"!==process.env.NODE_ENV&&f(e),tr.get(e,r)},set:function(e){var n=this[Q];"production"!==process.env.NODE_ENV&&f(n),tr.set(n,r,e)}},n}function t(r){for(var e=r.length-1;e>=0;e--){var n=r[e][Q];if(!n.P)switch(n.i){case 5:u(n)&&I(n);break;case 4:o(n)&&I(n)}}}function o(r){for(var e=r.t,n=r.I,t=rr(n),i=t.length-1;i>=0;i--){var o=t[i];if(o!==Q){var u=e[o];if(void 0===u&&!a(e,o))return!0;var f=n[o],l=f&&f[Q];if(l?l.t!==u:!c(f,u))return!0}}var s=!!e[Q];return t.length!==rr(e).length+(s?0:1)}function u(r){var e=r.I;if(e.length!==r.t.length)return!0;var n=Object.getOwnPropertyDescriptor(e,e.length-1);if(n&&!n.get)return!0;for(var t=0;t<e.length;t++)if(!e.hasOwnProperty(t))return!0;return!1}function f(e){e.j&&r(3,JSON.stringify(v(e)))}var l={};m("ES5",{J:function(r,e){var t=Array.isArray(r),i=function(r,e){if(r){for(var t=Array(e.length),i=0;i<e.length;i++)Object.defineProperty(t,""+i,n(i,!0));return t}var o=er(e);delete o[Q];for(var a=rr(o),u=0;u<a.length;u++){var f=a[u];o[f]=n(f,r||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(e),o)}(t,r),o={i:t?5:4,A:e?e.A:_(),P:!1,k:!1,D:{},p:e,t:r,I:i,o:null,j:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(r,n,o){o?e(n)&&n[Q].A===r&&t(r.v):(r.u&&function r(e){if(e&&"object"==typeof e){var n=e[Q];if(n){var t=n.t,o=n.I,f=n.D,c=n.i;if(4===c)i(o,(function(e){e!==Q&&(void 0!==t[e]||a(t,e)?f[e]||r(o[e]):(f[e]=!0,I(n)))})),i(t,(function(r){void 0!==o[r]||a(o,r)||(f[r]=!1,I(n))}));else if(5===c){if(u(n)&&(I(n),f.length=!0),o.length<t.length)for(var l=o.length;l<t.length;l++)f[l]=!1;else for(var s=t.length;s<o.length;s++)f[s]=!0;for(var v=Math.min(o.length,t.length),p=0;p<v;p++)o.hasOwnProperty(p)||(f[p]=!0),void 0===f[p]&&r(o[p])}}}}(r.v[0]),t(r.v))},K:function(r){return 4===r.i?o(r):u(r)}})}function T(){function e(r,e){function n(){Object.defineProperty(this,"constructor",{value:r})}u(r,e),r.prototype=(n.prototype=e.prototype,new n)}function t(r){r.o||(r.D=new Map,r.o=new Map(r.t))}function o(r){r.o||(r.o=new Set,r.t.forEach((function(e){if(n(e)){var t=R(r.A.h,e,r);r.v.set(e,t),r.o.add(t)}else r.o.add(e)})))}function a(e){e.j&&r(3,JSON.stringify(v(e)))}var u=function(r,e){return(u=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(r,e){r.__proto__=e}||function(r,e){for(var n in e)e.hasOwnProperty(n)&&(r[n]=e[n])})(r,e)},f=function(){function r(r,e){return this[Q]={i:2,p:e,A:e?e.A:_(),P:!1,k:!1,o:void 0,D:void 0,t:r,I:this,C:!1,j:!1},this}var o;return e(r,Map),Object.defineProperties(r.prototype,((o={size:{get:function(){return v(this[Q]).size},configurable:!0},has:{configurable:!0,writable:!0,value:function(r){return v(this[Q]).has(r)}},set:{configurable:!0,writable:!0,value:function(r,e){var n=this[Q];return a(n),v(n).has(r)&&v(n).get(r)===e||(t(n),I(n),n.D.set(r,!0),n.o.set(r,e),n.D.set(r,!0)),this}},delete:{configurable:!0,writable:!0,value:function(r){if(!this.has(r))return!1;var e=this[Q];return a(e),t(e),I(e),e.t.has(r)?e.D.set(r,!1):e.D.delete(r),e.o.delete(r),!0}},clear:{configurable:!0,writable:!0,value:function(){var r=this[Q];a(r),v(r).size&&(t(r),I(r),r.D=new Map,i(r.t,(function(e){r.D.set(e,!1)})),r.o.clear())}},forEach:{configurable:!0,writable:!0,value:function(r,e){var n=this;v(this[Q]).forEach((function(t,i){r.call(e,n.get(i),i,n)}))}},get:{configurable:!0,writable:!0,value:function(r){var e=this[Q];a(e);var i=v(e).get(r);if(e.k||!n(i))return i;if(i!==e.t.get(r))return i;var o=R(e.A.h,i,e);return t(e),e.o.set(r,o),o}},keys:{configurable:!0,writable:!0,value:function(){return v(this[Q]).keys()}},values:{configurable:!0,writable:!0,value:function(){var r,e=this,n=this.keys();return(r={})[V]=function(){return e.values()},r.next=function(){var r=n.next();return r.done?r:{done:!1,value:e.get(r.value)}},r}},entries:{configurable:!0,writable:!0,value:function(){var r,e=this,n=this.keys();return(r={})[V]=function(){return e.entries()},r.next=function(){var r=n.next();if(r.done)return r;var t=e.get(r.value);return{done:!1,value:[r.value,t]}},r}}})[V]={configurable:!0,writable:!0,value:function(){return this.entries()}},o)),r}(),c=function(){function r(r,e){return this[Q]={i:3,p:e,A:e?e.A:_(),P:!1,k:!1,o:void 0,t:r,I:this,v:new Map,j:!1,C:!1},this}var n;return e(r,Set),Object.defineProperties(r.prototype,((n={size:{get:function(){return v(this[Q]).size},configurable:!0},has:{configurable:!0,writable:!0,value:function(r){var e=this[Q];return a(e),e.o?!!e.o.has(r)||!(!e.v.has(r)||!e.o.has(e.v.get(r))):e.t.has(r)}},add:{configurable:!0,writable:!0,value:function(r){var e=this[Q];return a(e),this.has(r)||(o(e),I(e),e.o.add(r)),this}},delete:{configurable:!0,writable:!0,value:function(r){if(!this.has(r))return!1;var e=this[Q];return a(e),o(e),I(e),e.o.delete(r)||!!e.v.has(r)&&e.o.delete(e.v.get(r))}},clear:{configurable:!0,writable:!0,value:function(){var r=this[Q];a(r),v(r).size&&(o(r),I(r),r.o.clear())}},values:{configurable:!0,writable:!0,value:function(){var r=this[Q];return a(r),o(r),r.o.values()}},entries:{configurable:!0,writable:!0,value:function(){var r=this[Q];return a(r),o(r),r.o.entries()}},keys:{configurable:!0,writable:!0,value:function(){return this.values()}}})[V]={configurable:!0,writable:!0,value:function(){return this.values()}},n.forEach={configurable:!0,writable:!0,value:function(r,e){for(var n=this.values(),t=n.next();!t.done;)r.call(e,t.value,t.value,this),t=n.next()}},n)),r}();m("MapSet",{N:function(r,e){return new f(r,e)},T:function(r,e){return new c(r,e)}})}function C(){N(),T(),J()}function J(){function t(r){if(!n(r))return r;if(Array.isArray(r))return r.map(t);if(l(r))return new Map(Array.from(r.entries()).map((function(r){return[r[0],t(r[1])]})));if(s(r))return new Set(Array.from(r).map(t));var e=Object.create(Object.getPrototypeOf(r));for(var i in r)e[i]=t(r[i]);return a(r,L)&&(e[L]=r[L]),e}function f(r){return e(r)?t(r):r}var c="add";m("Patches",{$:function(e,n){return n.forEach((function(n){for(var i=n.path,a=n.op,f=e,l=0;l<i.length-1;l++){var s=o(f),v=""+i[l];0!==s&&1!==s||"__proto__"!==v&&"constructor"!==v||r(24),"function"==typeof f&&"prototype"===v&&r(24),"object"!=typeof(f=u(f,v))&&r(15,i.join("/"))}var p=o(f),d=t(n.value),b=i[i.length-1];switch(a){case"replace":switch(p){case 2:return f.set(b,d);case 3:r(16);default:return f[b]=d}case c:switch(p){case 1:return"-"===b?f.push(d):f.splice(b,0,d);case 2:return f.set(b,d);case 3:return f.add(d);default:return f[b]=d}case"remove":switch(p){case 1:return f.splice(b,1);case 2:return f.delete(b);case 3:return f.delete(n.value);default:return delete f[b]}default:r(17,a)}})),e},R:function(r,e,n,t){switch(r.i){case 0:case 4:case 2:return function(r,e,n,t){var o=r.t,l=r.o;i(r.D,(function(r,i){var s=u(o,r),v=u(l,r),p=i?a(o,r)?"replace":c:"remove";if(s!==v||"replace"!==p){var d=e.concat(r);n.push("remove"===p?{op:p,path:d}:{op:p,path:d,value:v}),t.push(p===c?{op:"remove",path:d}:"remove"===p?{op:c,path:d,value:f(s)}:{op:"replace",path:d,value:f(s)})}}))}(r,e,n,t);case 5:case 1:return function(r,e,n,t){var i=r.t,o=r.D,a=r.o;if(a.length<i.length){var u=[a,i];i=u[0],a=u[1];var l=[t,n];n=l[0],t=l[1]}for(var s=0;s<i.length;s++)if(o[s]&&a[s]!==i[s]){var v=e.concat([s]);n.push({op:"replace",path:v,value:f(a[s])}),t.push({op:"replace",path:v,value:f(i[s])})}for(var p=i.length;p<a.length;p++){var d=e.concat([p]);n.push({op:c,path:d,value:f(a[p])})}i.length<a.length&&t.push({op:"replace",path:e.concat(["length"]),value:i.length})}(r,e,n,t);case 3:return function(r,e,n,t){var i=r.t,o=r.o,a=0;i.forEach((function(r){if(!o.has(r)){var i=e.concat([a]);n.push({op:"remove",path:i,value:r}),t.unshift({op:c,path:i,value:r})}a++})),a=0,o.forEach((function(r){if(!i.has(r)){var o=e.concat([a]);n.push({op:c,path:o,value:r}),t.unshift({op:"remove",path:o,value:r})}a++}))}(r,e,n,t)}},M:function(r,e,n,t){n.push({op:"replace",path:[],value:e===H?void 0:e}),t.push({op:"replace",path:[],value:r})}})}function K(r){return r}function $(r){return r}var G,U,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H=W?Symbol.for("immer-nothing"):((G={})["immer-nothing"]=!0,G),L=W?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W?Symbol.for("immer-state"):"__$immer_state",V="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",Y={0:"Illegal state",1:"Immer drafts cannot have computed properties",2:"This object has been frozen and should not be mutated",3:function(r){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+r},4:"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",5:"Immer forbids circular references",6:"The first or second argument to `produce` must be a function",7:"The third argument to `produce` must be a function or undefined",8:"First argument to `createDraft` must be a plain object, an array, or an immerable object",9:"First argument to `finishDraft` must be a draft returned by `createDraft`",10:"The given draft is already finalized",11:"Object.defineProperty() cannot be used on an Immer draft",12:"Object.setPrototypeOf() cannot be used on an Immer draft",13:"Immer only supports deleting array indices",14:"Immer only supports setting array indices and the 'length' property",15:function(r){return"Cannot apply patch, path doesn't resolve: "+r},16:'Sets cannot have "replace" patches.',17:function(r){return"Unsupported patch operation: "+r},18:function(r){return"The plugin for '"+r+"' has not been loaded into Immer. To enable the plugin, import and call `enable"+r+"()` when initializing your application."},20:"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",21:function(r){return"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '"+r+"'"},22:function(r){return"'current' expects a draft, got: "+r},23:function(r){return"'original' expects a draft, got: "+r},24:"Patching reserved attributes like __proto__, prototype and constructor is not allowed"},Z=""+Object.prototype.constructor,rr="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(r){return Object.getOwnPropertyNames(r).concat(Object.getOwnPropertySymbols(r))}:Object.getOwnPropertyNames,er=Object.getOwnPropertyDescriptors||function(r){var e={};return rr(r).forEach((function(n){e[n]=Object.getOwnPropertyDescriptor(r,n)})),e},nr={},tr={get:function(r,e){if(e===Q)return r;var t=v(r);if(!a(t,e))return function(r,e,n){var t,i=z(e,n);return i?"value"in i?i.value:null===(t=i.get)||void 0===t?void 0:t.call(r.I):void 0}(r,t,e);var i=t[e];return r.k||!n(i)?i:i===k(r.t,e)?(E(r),r.o[e]=R(r.A.h,i,r)):i},has:function(r,e){return e in v(r)},ownKeys:function(r){return Reflect.ownKeys(v(r))},set:function(r,e,n){var t=z(v(r),e);if(null==t?void 0:t.set)return t.set.call(r.I,n),!0;if(!r.P){var i=k(v(r),e),o=null==i?void 0:i[Q];if(o&&o.t===n)return r.o[e]=n,r.D[e]=!1,!0;if(c(n,i)&&(void 0!==n||a(r.t,e)))return!0;E(r),I(r)}return r.o[e]===n&&"number"!=typeof n&&(void 0!==n||e in r.o)||(r.o[e]=n,r.D[e]=!0,!0)},deleteProperty:function(r,e){return void 0!==k(r.t,e)||e in r.t?(r.D[e]=!1,E(r),I(r)):delete r.D[e],r.o&&delete r.o[e],!0},getOwnPropertyDescriptor:function(r,e){var n=v(r),t=Reflect.getOwnPropertyDescriptor(n,e);return t?{writable:!0,configurable:1!==r.i||"length"!==e,enumerable:t.enumerable,value:n[e]}:t},defineProperty:function(){r(11)},getPrototypeOf:function(r){return Object.getPrototypeOf(r.t)},setPrototypeOf:function(){r(12)}},ir={};i(tr,(function(r,e){ir[r]=function(){return arguments[0]=arguments[0][0],e.apply(this,arguments)}})),ir.deleteProperty=function(e,n){return"production"!==process.env.NODE_ENV&&isNaN(parseInt(n))&&r(13),ir.set.call(this,e,n,void 0)},ir.set=function(e,n,t){return"production"!==process.env.NODE_ENV&&"length"!==n&&isNaN(parseInt(n))&&r(14),tr.set.call(this,e[0],n,t,e[0])};var or=function(){function t(e){var t=this;this.O=B,this.F=!0,this.produce=function(e,i,o){if("function"==typeof e&&"function"!=typeof i){var a=i;i=e;var u=t;return function(r){var e=this;void 0===r&&(r=a);for(var n=arguments.length,t=Array(n>1?n-1:0),o=1;o<n;o++)t[o-1]=arguments[o];return u.produce(r,(function(r){var n;return(n=i).call.apply(n,[e,r].concat(t))}))}}var f;if("function"!=typeof i&&r(6),void 0!==o&&"function"!=typeof o&&r(7),n(e)){var c=O(t),l=R(t,e,void 0),s=!0;try{f=i(l),s=!1}finally{s?w(c):j(c)}return"undefined"!=typeof Promise&&f instanceof Promise?f.then((function(r){return g(c,o),P(r,c)}),(function(r){throw w(c),r})):(g(c,o),P(f,c))}if(!e||"object"!=typeof e){if(void 0===(f=i(e))&&(f=e),f===H&&(f=void 0),t.F&&d(f,!0),o){var v=[],p=[];y("Patches").M(e,f,v,p),o(v,p)}return f}r(21,e)},this.produceWithPatches=function(r,e){if("function"==typeof r)return function(e){for(var n=arguments.length,i=Array(n>1?n-1:0),o=1;o<n;o++)i[o-1]=arguments[o];return t.produceWithPatches(e,(function(e){return r.apply(void 0,[e].concat(i))}))};var n,i,o=t.produce(r,e,(function(r,e){n=r,i=e}));return"undefined"!=typeof Promise&&o instanceof Promise?o.then((function(r){return[r,n,i]})):[o,n,i]},"boolean"==typeof(null==e?void 0:e.useProxies)&&this.setUseProxies(e.useProxies),"boolean"==typeof(null==e?void 0:e.autoFreeze)&&this.setAutoFreeze(e.autoFreeze)}var i=t.prototype;return i.createDraft=function(t){n(t)||r(8),e(t)&&(t=D(t));var i=O(this),o=R(this,t,void 0);return o[Q].C=!0,j(i),o},i.finishDraft=function(e,n){var t=e&&e[Q];"production"!==process.env.NODE_ENV&&(t&&t.C||r(9),t.k&&r(10));var i=t.A;return g(i,n),P(void 0,i)},i.setAutoFreeze=function(r){this.F=r},i.setUseProxies=function(e){e&&!B&&r(20),this.O=e},i.applyPatches=function(r,n){var t;for(t=n.length-1;t>=0;t--){var i=n[t];if(0===i.path.length&&"replace"===i.op){r=i.value;break}}t>-1&&(n=n.slice(t+1));var o=y("Patches").$;return e(r)?o(r,n):this.produce(r,(function(r){return o(r,n)}))},t}(),ar=new or,ur=ar.produce,fr=ar.produceWithPatches.bind(ar),cr=ar.setAutoFreeze.bind(ar),lr=ar.setUseProxies.bind(ar),sr=ar.applyPatches.bind(ar),vr=ar.createDraft.bind(ar),pr=ar.finishDraft.bind(ar);export default ur;export{or as Immer,sr as applyPatches,K as castDraft,$ as castImmutable,vr as createDraft,D as current,C as enableAllPlugins,N as enableES5,T as enableMapSet,J as enablePatches,pr as finishDraft,d as freeze,L as immerable,e as isDraft,n as isDraftable,H as nothing,t as original,ur as produce,fr as produceWithPatches,cr as setAutoFreeze,lr as setUseProxies};
 //# sourceMappingURL=immer.esm.js.map
diff --git a/dist/immer.umd.development.js b/dist/immer.umd.development.js
index bd16b65cd460124260b514040f7348fe63deb241..e3adbfaa4ec860575753efdfe11c6adbacfed1fc 100644
--- a/dist/immer.umd.development.js
+++ b/dist/immer.umd.development.js
@@ -270,7 +270,17 @@
 	  if (getArchtype(obj) > 1
 	  /* Map or Set */
 	  ) {
-	      obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
+	      var desc = {
+	        configurable: true,
+	        writable: true,
+	        value: dontMutateFrozenCollections
+	      };
+	      Object.defineProperties(obj, {
+	        set: desc,
+	        add: desc,
+	        clear: desc,
+	        delete: desc
+	      });
 	    }
 
 	  Object.freeze(obj);
@@ -1272,6 +1282,434 @@
 	  });
 	}
 
+	// types only!
+	function enableMapSet() {
+	  /* istanbul ignore next */
+	  var _extendStatics = function extendStatics(d, b) {
+	    _extendStatics = Object.setPrototypeOf || {
+	      __proto__: []
+	    } instanceof Array && function (d, b) {
+	      d.__proto__ = b;
+	    } || function (d, b) {
+	      for (var p in b) {
+	        if (b.hasOwnProperty(p)) d[p] = b[p];
+	      }
+	    };
+
+	    return _extendStatics(d, b);
+	  }; // Ugly hack to resolve #502 and inherit built in Map / Set
+
+
+	  function __extends(d, b) {
+	    _extendStatics(d, b);
+
+	    function __() {
+	      Object.defineProperty(this, "constructor", {
+	        value: d
+	      });
+	    }
+
+	    d.prototype = ( // @ts-ignore
+	    __.prototype = b.prototype, new __());
+	  }
+
+	  var DraftMap = function (_super) {
+	    var _Object$definePropert;
+
+	    __extends(DraftMap, _super); // Create class manually, cause #502
+
+
+	    function DraftMap(target, parent) {
+	      this[DRAFT_STATE] = {
+	        type_: 2
+	        /* Map */
+	        ,
+	        parent_: parent,
+	        scope_: parent ? parent.scope_ : getCurrentScope(),
+	        modified_: false,
+	        finalized_: false,
+	        copy_: undefined,
+	        assigned_: undefined,
+	        base_: target,
+	        draft_: this,
+	        isManual_: false,
+	        revoked_: false
+	      };
+	      return this;
+	    }
+
+	    var p = DraftMap.prototype;
+	    Object.defineProperties(p, (_Object$definePropert = {
+	      size: {
+	        get: function get() {
+	          return latest(this[DRAFT_STATE]).size;
+	        },
+	        configurable: true
+	      },
+	      has: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(key) {
+	          return latest(this[DRAFT_STATE]).has(key);
+	        }
+	      },
+	      set: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(key, _value2) {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+
+	          if (!latest(state).has(key) || latest(state).get(key) !== _value2) {
+	            prepareMapCopy(state);
+	            markChanged(state);
+	            state.assigned_.set(key, true);
+	            state.copy_.set(key, _value2);
+	            state.assigned_.set(key, true);
+	          }
+
+	          return this;
+	        }
+	      },
+	      delete: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(key) {
+	          if (!this.has(key)) {
+	            return false;
+	          }
+
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+	          prepareMapCopy(state);
+	          markChanged(state);
+
+	          if (state.base_.has(key)) {
+	            state.assigned_.set(key, false);
+	          } else {
+	            state.assigned_.delete(key);
+	          }
+
+	          state.copy_.delete(key);
+	          return true;
+	        }
+	      },
+	      clear: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+
+	          if (latest(state).size) {
+	            prepareMapCopy(state);
+	            markChanged(state);
+	            state.assigned_ = new Map();
+	            each(state.base_, function (key) {
+	              state.assigned_.set(key, false);
+	            });
+	            state.copy_.clear();
+	          }
+	        }
+	      },
+	      forEach: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(cb, thisArg) {
+	          var _this = this;
+
+	          var state = this[DRAFT_STATE];
+	          latest(state).forEach(function (_value, key, _map) {
+	            cb.call(thisArg, _this.get(key), key, _this);
+	          });
+	        }
+	      },
+	      get: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(key) {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+	          var value = latest(state).get(key);
+
+	          if (state.finalized_ || !isDraftable(value)) {
+	            return value;
+	          }
+
+	          if (value !== state.base_.get(key)) {
+	            return value; // either already drafted or reassigned
+	          } // despite what it looks, this creates a draft only once, see above condition
+
+
+	          var draft = createProxy(state.scope_.immer_, value, state);
+	          prepareMapCopy(state);
+	          state.copy_.set(key, draft);
+	          return draft;
+	        }
+	      },
+	      keys: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          return latest(this[DRAFT_STATE]).keys();
+	        }
+	      },
+	      values: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          var _this2 = this,
+	              _ref;
+
+	          var iterator = this.keys();
+	          return _ref = {}, _ref[iteratorSymbol] = function () {
+	            return _this2.values();
+	          }, _ref.next = function next() {
+	            var r = iterator.next();
+	            /* istanbul ignore next */
+
+	            if (r.done) return r;
+
+	            var value = _this2.get(r.value);
+
+	            return {
+	              done: false,
+	              value: value
+	            };
+	          }, _ref;
+	        }
+	      },
+	      entries: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          var _this3 = this,
+	              _ref2;
+
+	          var iterator = this.keys();
+	          return _ref2 = {}, _ref2[iteratorSymbol] = function () {
+	            return _this3.entries();
+	          }, _ref2.next = function next() {
+	            var r = iterator.next();
+	            /* istanbul ignore next */
+
+	            if (r.done) return r;
+
+	            var value = _this3.get(r.value);
+
+	            return {
+	              done: false,
+	              value: [r.value, value]
+	            };
+	          }, _ref2;
+	        }
+	      }
+	    }, _Object$definePropert[iteratorSymbol] = {
+	      configurable: true,
+	      writable: true,
+	      value: function value() {
+	        return this.entries();
+	      }
+	    }, _Object$definePropert));
+	    return DraftMap;
+	  }(Map);
+
+	  function proxyMap_(target, parent) {
+	    // @ts-ignore
+	    return new DraftMap(target, parent);
+	  }
+
+	  function prepareMapCopy(state) {
+	    if (!state.copy_) {
+	      state.assigned_ = new Map();
+	      state.copy_ = new Map(state.base_);
+	    }
+	  }
+
+	  var DraftSet = function (_super) {
+	    var _Object$definePropert2;
+
+	    __extends(DraftSet, _super); // Create class manually, cause #502
+
+
+	    function DraftSet(target, parent) {
+	      this[DRAFT_STATE] = {
+	        type_: 3
+	        /* Set */
+	        ,
+	        parent_: parent,
+	        scope_: parent ? parent.scope_ : getCurrentScope(),
+	        modified_: false,
+	        finalized_: false,
+	        copy_: undefined,
+	        base_: target,
+	        draft_: this,
+	        drafts_: new Map(),
+	        revoked_: false,
+	        isManual_: false
+	      };
+	      return this;
+	    }
+
+	    var p = DraftSet.prototype;
+	    Object.defineProperties(p, (_Object$definePropert2 = {
+	      size: {
+	        get: function get() {
+	          return latest(this[DRAFT_STATE]).size;
+	        },
+	        configurable: true
+	      },
+	      has: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(_value3) {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value
+
+	          if (!state.copy_) {
+	            return state.base_.has(_value3);
+	          }
+
+	          if (state.copy_.has(_value3)) return true;
+	          if (state.drafts_.has(_value3) && state.copy_.has(state.drafts_.get(_value3))) return true;
+	          return false;
+	        }
+	      },
+	      add: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(_value4) {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+
+	          if (!this.has(_value4)) {
+	            prepareSetCopy(state);
+	            markChanged(state);
+	            state.copy_.add(_value4);
+	          }
+
+	          return this;
+	        }
+	      },
+	      delete: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(_value5) {
+	          if (!this.has(_value5)) {
+	            return false;
+	          }
+
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+	          prepareSetCopy(state);
+	          markChanged(state);
+	          return state.copy_.delete(_value5) || (state.drafts_.has(_value5) ? state.copy_.delete(state.drafts_.get(_value5)) :
+	          /* istanbul ignore next */
+	          false);
+	        }
+	      },
+	      clear: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+
+	          if (latest(state).size) {
+	            prepareSetCopy(state);
+	            markChanged(state);
+	            state.copy_.clear();
+	          }
+	        }
+	      },
+	      values: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+	          prepareSetCopy(state);
+	          return state.copy_.values();
+	        }
+	      },
+	      entries: {
+	        configurable: true,
+	        writable: true,
+	        value: function entries() {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+	          prepareSetCopy(state);
+	          return state.copy_.entries();
+	        }
+	      },
+	      keys: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          return this.values();
+	        }
+	      }
+	    }, _Object$definePropert2[iteratorSymbol] = {
+	      configurable: true,
+	      writable: true,
+	      value: function value() {
+	        return this.values();
+	      }
+	    }, _Object$definePropert2.forEach = {
+	      configurable: true,
+	      writable: true,
+	      value: function forEach(cb, thisArg) {
+	        var iterator = this.values();
+	        var result = iterator.next();
+
+	        while (!result.done) {
+	          cb.call(thisArg, result.value, result.value, this);
+	          result = iterator.next();
+	        }
+	      }
+	    }, _Object$definePropert2));
+	    return DraftSet;
+	  }(Set);
+
+	  function proxySet_(target, parent) {
+	    // @ts-ignore
+	    return new DraftSet(target, parent);
+	  }
+
+	  function prepareSetCopy(state) {
+	    if (!state.copy_) {
+	      // create drafts for all entries to preserve insertion order
+	      state.copy_ = new Set();
+	      state.base_.forEach(function (value) {
+	        if (isDraftable(value)) {
+	          var draft = createProxy(state.scope_.immer_, value, state);
+	          state.drafts_.set(value, draft);
+	          state.copy_.add(draft);
+	        } else {
+	          state.copy_.add(value);
+	        }
+	      });
+	    }
+	  }
+
+	  function assertUnrevoked(state
+	  /*ES5State | MapState | SetState*/
+	  ) {
+	    if (state.revoked_) die(3, JSON.stringify(latest(state)));
+	  }
+
+	  loadPlugin("MapSet", {
+	    proxyMap_: proxyMap_,
+	    proxySet_: proxySet_
+	  });
+	}
+
+	function enableAllPlugins() {
+	  enableES5();
+	  enableMapSet();
+	  enablePatches();
+	}
+
 	function enablePatches() {
 	  var REPLACE = "replace";
 	  var ADD = "add";
@@ -1576,373 +2014,6 @@
 	  });
 	}
 
-	// types only!
-	function enableMapSet() {
-	  /* istanbul ignore next */
-	  var _extendStatics = function extendStatics(d, b) {
-	    _extendStatics = Object.setPrototypeOf || {
-	      __proto__: []
-	    } instanceof Array && function (d, b) {
-	      d.__proto__ = b;
-	    } || function (d, b) {
-	      for (var p in b) {
-	        if (b.hasOwnProperty(p)) d[p] = b[p];
-	      }
-	    };
-
-	    return _extendStatics(d, b);
-	  }; // Ugly hack to resolve #502 and inherit built in Map / Set
-
-
-	  function __extends(d, b) {
-	    _extendStatics(d, b);
-
-	    function __() {
-	      this.constructor = d;
-	    }
-
-	    d.prototype = ( // @ts-ignore
-	    __.prototype = b.prototype, new __());
-	  }
-
-	  var DraftMap = function (_super) {
-	    __extends(DraftMap, _super); // Create class manually, cause #502
-
-
-	    function DraftMap(target, parent) {
-	      this[DRAFT_STATE] = {
-	        type_: 2
-	        /* Map */
-	        ,
-	        parent_: parent,
-	        scope_: parent ? parent.scope_ : getCurrentScope(),
-	        modified_: false,
-	        finalized_: false,
-	        copy_: undefined,
-	        assigned_: undefined,
-	        base_: target,
-	        draft_: this,
-	        isManual_: false,
-	        revoked_: false
-	      };
-	      return this;
-	    }
-
-	    var p = DraftMap.prototype;
-	    Object.defineProperty(p, "size", {
-	      get: function get() {
-	        return latest(this[DRAFT_STATE]).size;
-	      } // enumerable: false,
-	      // configurable: true
-
-	    });
-
-	    p.has = function (key) {
-	      return latest(this[DRAFT_STATE]).has(key);
-	    };
-
-	    p.set = function (key, value) {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-
-	      if (!latest(state).has(key) || latest(state).get(key) !== value) {
-	        prepareMapCopy(state);
-	        markChanged(state);
-	        state.assigned_.set(key, true);
-	        state.copy_.set(key, value);
-	        state.assigned_.set(key, true);
-	      }
-
-	      return this;
-	    };
-
-	    p.delete = function (key) {
-	      if (!this.has(key)) {
-	        return false;
-	      }
-
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-	      prepareMapCopy(state);
-	      markChanged(state);
-
-	      if (state.base_.has(key)) {
-	        state.assigned_.set(key, false);
-	      } else {
-	        state.assigned_.delete(key);
-	      }
-
-	      state.copy_.delete(key);
-	      return true;
-	    };
-
-	    p.clear = function () {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-
-	      if (latest(state).size) {
-	        prepareMapCopy(state);
-	        markChanged(state);
-	        state.assigned_ = new Map();
-	        each(state.base_, function (key) {
-	          state.assigned_.set(key, false);
-	        });
-	        state.copy_.clear();
-	      }
-	    };
-
-	    p.forEach = function (cb, thisArg) {
-	      var _this = this;
-
-	      var state = this[DRAFT_STATE];
-	      latest(state).forEach(function (_value, key, _map) {
-	        cb.call(thisArg, _this.get(key), key, _this);
-	      });
-	    };
-
-	    p.get = function (key) {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-	      var value = latest(state).get(key);
-
-	      if (state.finalized_ || !isDraftable(value)) {
-	        return value;
-	      }
-
-	      if (value !== state.base_.get(key)) {
-	        return value; // either already drafted or reassigned
-	      } // despite what it looks, this creates a draft only once, see above condition
-
-
-	      var draft = createProxy(state.scope_.immer_, value, state);
-	      prepareMapCopy(state);
-	      state.copy_.set(key, draft);
-	      return draft;
-	    };
-
-	    p.keys = function () {
-	      return latest(this[DRAFT_STATE]).keys();
-	    };
-
-	    p.values = function () {
-	      var _this2 = this,
-	          _ref;
-
-	      var iterator = this.keys();
-	      return _ref = {}, _ref[iteratorSymbol] = function () {
-	        return _this2.values();
-	      }, _ref.next = function next() {
-	        var r = iterator.next();
-	        /* istanbul ignore next */
-
-	        if (r.done) return r;
-
-	        var value = _this2.get(r.value);
-
-	        return {
-	          done: false,
-	          value: value
-	        };
-	      }, _ref;
-	    };
-
-	    p.entries = function () {
-	      var _this3 = this,
-	          _ref2;
-
-	      var iterator = this.keys();
-	      return _ref2 = {}, _ref2[iteratorSymbol] = function () {
-	        return _this3.entries();
-	      }, _ref2.next = function next() {
-	        var r = iterator.next();
-	        /* istanbul ignore next */
-
-	        if (r.done) return r;
-
-	        var value = _this3.get(r.value);
-
-	        return {
-	          done: false,
-	          value: [r.value, value]
-	        };
-	      }, _ref2;
-	    };
-
-	    p[iteratorSymbol] = function () {
-	      return this.entries();
-	    };
-
-	    return DraftMap;
-	  }(Map);
-
-	  function proxyMap_(target, parent) {
-	    // @ts-ignore
-	    return new DraftMap(target, parent);
-	  }
-
-	  function prepareMapCopy(state) {
-	    if (!state.copy_) {
-	      state.assigned_ = new Map();
-	      state.copy_ = new Map(state.base_);
-	    }
-	  }
-
-	  var DraftSet = function (_super) {
-	    __extends(DraftSet, _super); // Create class manually, cause #502
-
-
-	    function DraftSet(target, parent) {
-	      this[DRAFT_STATE] = {
-	        type_: 3
-	        /* Set */
-	        ,
-	        parent_: parent,
-	        scope_: parent ? parent.scope_ : getCurrentScope(),
-	        modified_: false,
-	        finalized_: false,
-	        copy_: undefined,
-	        base_: target,
-	        draft_: this,
-	        drafts_: new Map(),
-	        revoked_: false,
-	        isManual_: false
-	      };
-	      return this;
-	    }
-
-	    var p = DraftSet.prototype;
-	    Object.defineProperty(p, "size", {
-	      get: function get() {
-	        return latest(this[DRAFT_STATE]).size;
-	      } // enumerable: true,
-
-	    });
-
-	    p.has = function (value) {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value
-
-	      if (!state.copy_) {
-	        return state.base_.has(value);
-	      }
-
-	      if (state.copy_.has(value)) return true;
-	      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
-	      return false;
-	    };
-
-	    p.add = function (value) {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-
-	      if (!this.has(value)) {
-	        prepareSetCopy(state);
-	        markChanged(state);
-	        state.copy_.add(value);
-	      }
-
-	      return this;
-	    };
-
-	    p.delete = function (value) {
-	      if (!this.has(value)) {
-	        return false;
-	      }
-
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-	      prepareSetCopy(state);
-	      markChanged(state);
-	      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) :
-	      /* istanbul ignore next */
-	      false);
-	    };
-
-	    p.clear = function () {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-
-	      if (latest(state).size) {
-	        prepareSetCopy(state);
-	        markChanged(state);
-	        state.copy_.clear();
-	      }
-	    };
-
-	    p.values = function () {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-	      prepareSetCopy(state);
-	      return state.copy_.values();
-	    };
-
-	    p.entries = function entries() {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-	      prepareSetCopy(state);
-	      return state.copy_.entries();
-	    };
-
-	    p.keys = function () {
-	      return this.values();
-	    };
-
-	    p[iteratorSymbol] = function () {
-	      return this.values();
-	    };
-
-	    p.forEach = function forEach(cb, thisArg) {
-	      var iterator = this.values();
-	      var result = iterator.next();
-
-	      while (!result.done) {
-	        cb.call(thisArg, result.value, result.value, this);
-	        result = iterator.next();
-	      }
-	    };
-
-	    return DraftSet;
-	  }(Set);
-
-	  function proxySet_(target, parent) {
-	    // @ts-ignore
-	    return new DraftSet(target, parent);
-	  }
-
-	  function prepareSetCopy(state) {
-	    if (!state.copy_) {
-	      // create drafts for all entries to preserve insertion order
-	      state.copy_ = new Set();
-	      state.base_.forEach(function (value) {
-	        if (isDraftable(value)) {
-	          var draft = createProxy(state.scope_.immer_, value, state);
-	          state.drafts_.set(value, draft);
-	          state.copy_.add(draft);
-	        } else {
-	          state.copy_.add(value);
-	        }
-	      });
-	    }
-	  }
-
-	  function assertUnrevoked(state
-	  /*ES5State | MapState | SetState*/
-	  ) {
-	    if (state.revoked_) die(3, JSON.stringify(latest(state)));
-	  }
-
-	  loadPlugin("MapSet", {
-	    proxyMap_: proxyMap_,
-	    proxySet_: proxySet_
-	  });
-	}
-
-	function enableAllPlugins() {
-	  enableES5();
-	  enableMapSet();
-	  enablePatches();
-	}
-
 	var immer =
 	/*#__PURE__*/
 	new Immer();
diff --git a/dist/immer.umd.development.js.map b/dist/immer.umd.development.js.map
index b71373ffe2922b78978c0217a62f983455445531..91340b5e0226c956e4776ad783510ecaa99c2c67 100644
--- a/dist/immer.umd.development.js.map
+++ b/dist/immer.umd.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"immer.umd.development.js","sources":["../src/utils/env.ts","../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/patches.ts","../src/plugins/mapset.ts","../src/plugins/all.ts","../src/immer.ts"],"sourcesContent":["// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tthis.constructor = d\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: false,\n\t\t\t// configurable: true\n\t\t})\n\n\t\tp.has = function(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tp.set = function(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.forEach = function(\n\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\tthisArg?: any\n\t\t) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tp.get = function(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp.entries = function(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.entries()\n\t\t}\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: true,\n\t\t})\n\n\t\tp.has = function(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tp.add = function(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tp.entries = function entries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp.forEach = function forEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n"],"names":["hasSymbol","Symbol","hasMap","Map","hasSet","Set","hasProxies","Proxy","revocable","Reflect","NOTHING","for","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","errors","data","path","op","plugin","thing","die","error","args","e","msg","apply","Error","isDraft","value","isDraftable","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","Object","prototype","toString","proto","getPrototypeOf","Ctor","hasOwnProperty","call","Function","original","base_","ownKeys","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","getOwnPropertyDescriptors","target","res","forEach","key","getOwnPropertyDescriptor","each","iter","enumerableOnly","getArchtype","keys","entry","index","state","type_","has","prop","get","set","propOrOldValue","t","delete","add","is","x","y","latest","copy_","shallowCopy","base","slice","descriptors","i","length","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","plugins","getPlugin","pluginKey","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","autoFreeze_","createProxyProxy","parent","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","source","readPropFromProto","peek","prepareCopy","createProxy","getDescriptorFromProto","current","currentState","markChanged","deleteProperty","owner","defineProperty","setPrototypeOf","fn","arguments","isNaN","parseInt","Immer","config","recipe","defaultBase","self","curriedProduce","produce","hasError","Promise","then","p","ip","arg1","arg2","arg3","produceWithPatches","patches","inversePatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","createES5Proxy_","push","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","markChangesRecursively","markChangesSweep","createES5Draft","proxyProperty","assertUnrevoked","drafts","hasArrayChanges","hasObjectChanges","object","min","Math","baseValue","baseIsDraft","descriptor","JSON","stringify","enablePatches","REPLACE","ADD","REMOVE","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","clonePatchValueIfNeeded","assignedValue","origValue","unshift","replacement","parentType","join","type","deepClonePatchValue","splice","map","entries","k","v","cloned","immerable","enableMapSet","extendStatics","d","b","__proto__","__extends","__","DraftMap","_super","size","prepareMapCopy","cb","thisArg","_value","_map","values","next","r","done","DraftSet","prepareSetCopy","enableAllPlugins","bind","castDraft","castImmutable"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"immer.umd.development.js","sources":["../src/utils/env.ts","../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/mapset.ts","../src/plugins/all.ts","../src/plugins/patches.ts","../src/immer.ts"],"sourcesContent":["// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tconst desc: PropertyDescriptor = {\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: dontMutateFrozenCollections\n\t\t}\n\t\tObject.defineProperties(obj, {\n\t\t\tset: desc,\n\t\t\tadd: desc,\n\t\t\tclear: desc,\n\t\t\tdelete: desc\n\t\t})\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tObject.defineProperty(this, \"constructor\", {\n\t\t\t\tvalue: d\n\t\t\t})\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperties(p, {\n\t\t\tsize: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\thas: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): boolean {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t\t\t}\n\t\t\t},\n\t\t\tset: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any, value: any) {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\t\t}\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelete: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): boolean {\n\t\t\t\t\tif (!this.has(key)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\tif (state.base_.has(key)) {\n\t\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t\t\t}\n\t\t\t\t\tstate.copy_!.delete(key)\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t},\n\t\t\tclear: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (latest(state).size) {\n\t\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\t\t\teach(state.base_, key => {\n\t\t\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tstate.copy_!.clear()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tforEach: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(\n\t\t\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\t\t\tthisArg?: any\n\t\t\t\t) {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t},\n\t\t\tget: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): any {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tconst value = latest(state).get(key)\n\t\t\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\t\t\treturn value\n\t\t\t\t\t}\n\t\t\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t\t\t}\n\t\t\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\tstate.copy_!.set(key, draft)\n\t\t\t\t\treturn draft\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalues: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\tconst iterator = this.keys()\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\t\t\tnext: () => {\n\t\t\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\t\tif (r.done) return r\n\t\t\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\t\t\t\t}\n\t\t\t},\n\t\t\tentries: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<[any, any]> {\n\t\t\t\t\tconst iterator = this.keys()\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\t\t\tnext: () => {\n\t\t\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\t\tif (r.done) return r\n\t\t\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\t\t\t\t}\n\t\t\t},\n\t\t\t[iteratorSymbol]: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\treturn this.entries()\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperties(p, {\n\t\t\tsize: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\thas: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): boolean {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\t\t\tif (!state.copy_) {\n\t\t\t\t\t\treturn state.base_.has(value)\n\t\t\t\t\t}\n\t\t\t\t\tif (state.copy_.has(value)) return true\n\t\t\t\t\tif (\n\t\t\t\t\t\tstate.drafts_.has(value) &&\n\t\t\t\t\t\tstate.copy_.has(state.drafts_.get(value))\n\t\t\t\t\t)\n\t\t\t\t\t\treturn true\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t},\n\t\t\tadd: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): any {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (!this.has(value)) {\n\t\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t\t}\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelete: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): any {\n\t\t\t\t\tif (!this.has(value)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\treturn (\n\t\t\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t},\n\t\t\tclear: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (latest(state).size) {\n\t\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.copy_!.clear()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalues: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\treturn state.copy_!.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\tentries: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function entries(): IterableIterator<[any, any]> {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\treturn state.copy_!.entries()\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\treturn this.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\t[iteratorSymbol]: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\treturn this.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\tforEach: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function forEach(cb: any, thisArg?: any) {\n\t\t\t\t\tconst iterator = this.values()\n\t\t\t\t\tlet result = iterator.next()\n\t\t\t\t\twhile (!result.done) {\n\t\t\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\t\t\tresult = iterator.next()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n"],"names":["hasSymbol","Symbol","hasMap","Map","hasSet","Set","hasProxies","Proxy","revocable","Reflect","NOTHING","for","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","errors","data","path","op","plugin","thing","die","error","args","e","msg","apply","Error","isDraft","value","isDraftable","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","Object","prototype","toString","proto","getPrototypeOf","Ctor","hasOwnProperty","call","Function","original","base_","ownKeys","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","getOwnPropertyDescriptors","target","res","forEach","key","getOwnPropertyDescriptor","each","iter","enumerableOnly","getArchtype","keys","entry","index","state","type_","has","prop","get","set","propOrOldValue","t","delete","add","is","x","y","latest","copy_","shallowCopy","base","slice","descriptors","i","length","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","dontMutateFrozenCollections","defineProperties","clear","plugins","getPlugin","pluginKey","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","autoFreeze_","createProxyProxy","parent","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","source","readPropFromProto","peek","prepareCopy","createProxy","getDescriptorFromProto","current","currentState","markChanged","deleteProperty","owner","defineProperty","setPrototypeOf","fn","arguments","isNaN","parseInt","Immer","config","recipe","defaultBase","self","curriedProduce","produce","hasError","Promise","then","p","ip","arg1","arg2","arg3","produceWithPatches","patches","inversePatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","createES5Proxy_","push","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","markChangesRecursively","markChangesSweep","createES5Draft","proxyProperty","assertUnrevoked","drafts","hasArrayChanges","hasObjectChanges","object","min","Math","baseValue","baseIsDraft","descriptor","JSON","stringify","enableMapSet","extendStatics","d","b","__proto__","__extends","__","DraftMap","_super","size","prepareMapCopy","cb","thisArg","_value","_map","values","next","r","done","entries","DraftSet","prepareSetCopy","enableAllPlugins","enablePatches","REPLACE","ADD","REMOVE","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","clonePatchValueIfNeeded","assignedValue","origValue","unshift","replacement","parentType","join","type","deepClonePatchValue","splice","map","k","v","cloned","immerable","bind","castDraft","castImmutable"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/immer.umd.production.min.js b/dist/immer.umd.production.min.js
index 96600d089ce9b0769a6a0c8549c4c84c2ef73aa9..96230109b4ffa49aaee2ed21b5d4a7f6bd6c559d 100644
--- a/dist/immer.umd.production.min.js
+++ b/dist/immer.umd.production.min.js
@@ -1,2 +1,2 @@
-!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((n=n||self).immer={})}(this,(function(n){function t(n){for(var t=arguments.length,r=Array(t>1?t-1:0),e=1;e<t;e++)r[e-1]=arguments[e];throw Error("[Immer] minified error nr: "+n+(r.length?" "+r.map((function(n){return"'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r(n){return!!n&&!!n[L]}function e(n){return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var t=Object.getPrototypeOf(n);if(null===t)return!0;var r=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return r===Object||"function"==typeof r&&Function.toString.call(r)===T}(n)||Array.isArray(n)||!!n[H]||!!n.constructor[H]||v(n)||s(n))}function i(n,t,r){void 0===r&&(r=!1),0===u(n)?(r?Object.keys:U)(n).forEach((function(e){r&&"symbol"==typeof e||t(e,n[e],n)})):n.forEach((function(r,e){return t(e,r,n)}))}function u(n){var t=n[L];return t?t.t>3?t.t-4:t.t:Array.isArray(n)?1:v(n)?2:s(n)?3:0}function o(n,t){return 2===u(n)?n.has(t):Object.prototype.hasOwnProperty.call(n,t)}function f(n,t){return 2===u(n)?n.get(t):n[t]}function a(n,t,r){var e=u(n);2===e?n.set(t,r):3===e?(n.delete(t),n.add(r)):n[t]=r}function c(n,t){return n===t?0!==n||1/n==1/t:n!=n&&t!=t}function v(n){return X&&n instanceof Map}function s(n){return q&&n instanceof Set}function l(n){return n.i||n.u}function p(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var t=V(n);delete t[L];for(var r=U(t),e=0;e<r.length;e++){var i=r[e],u=t[i];!1===u.writable&&(u.writable=!0,u.configurable=!0),(u.get||u.set)&&(t[i]={configurable:!0,writable:!0,enumerable:u.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),t)}function d(n,t){return void 0===t&&(t=!1),y(n)||r(n)||!e(n)?n:(u(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),t&&i(n,(function(n,t){return d(t,!0)}),!0),n)}function h(){t(2)}function y(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function _(n){var r=Y[n];return r||t(18,n),r}function b(n,t){Y[n]||(Y[n]=t)}function m(){return N}function j(n,t){t&&(_("Patches"),n.o=[],n.v=[],n.s=t)}function O(n){w(n),n.l.forEach(P),n.l=null}function w(n){n===N&&(N=n.p)}function S(n){return N={l:[],p:N,h:n,_:!0,m:0}}function P(n){var t=n[L];0===t.t||1===t.t?t.j():t.O=!0}function M(n,r){r.m=r.l.length;var i=r.l[0],u=void 0!==n&&n!==i;return r.h.S||_("ES5").P(r,n,u),u?(i[L].M&&(O(r),t(4)),e(n)&&(n=g(r,n),r.p||x(r,n)),r.o&&_("Patches").g(i[L].u,n,r.o,r.v)):n=g(r,i,[]),O(r),r.o&&r.s(r.o,r.v),n!==G?n:void 0}function g(n,t,r){if(y(t))return t;var e=t[L];if(!e)return i(t,(function(i,u){return A(n,e,t,i,u,r)}),!0),t;if(e.A!==n)return t;if(!e.M)return x(n,e.u,!0),e.u;if(!e.R){e.R=!0,e.A.m--;var u=4===e.t||5===e.t?e.i=p(e.k):e.i;i(3===e.t?new Set(u):u,(function(t,i){return A(n,e,u,t,i,r)})),x(n,u,!1),r&&n.o&&_("Patches").F(e,r,n.o,n.v)}return e.i}function A(n,t,i,u,f,c){if(r(f)){var v=g(n,f,c&&t&&3!==t.t&&!o(t.D,u)?c.concat(u):void 0);if(a(i,u,v),!r(v))return;n._=!1}if(e(f)&&!y(f)){if(!n.h.K&&n.m<1)return;g(n,f),t&&t.A.p||x(n,f)}}function x(n,t,r){void 0===r&&(r=!1),n.h.K&&n._&&d(t,r)}function z(n,t){var r=n[L];return(r?l(r):n)[t]}function E(n,t){if(t in n)for(var r=Object.getPrototypeOf(n);r;){var e=Object.getOwnPropertyDescriptor(r,t);if(e)return e;r=Object.getPrototypeOf(r)}}function R(n){n.M||(n.M=!0,n.p&&R(n.p))}function k(n){n.i||(n.i=p(n.u))}function F(n,t,r){var e=v(t)?_("MapSet").$(t,r):s(t)?_("MapSet").C(t,r):n.S?function(n,t){var r=Array.isArray(n),e={t:r?1:0,A:t?t.A:m(),M:!1,R:!1,D:{},p:t,u:n,k:null,i:null,j:null,I:!1},i=e,u=Z;r&&(i=[e],u=nn);var o=Proxy.revocable(i,u),f=o.revoke,a=o.proxy;return e.k=a,e.j=f,a}(t,r):_("ES5").J(t,r);return(r?r.A:m()).l.push(e),e}function D(n){return r(n)||t(22,n),function n(t){if(!e(t))return t;var r,o=t[L],c=u(t);if(o){if(!o.M&&(o.t<4||!_("ES5").N(o)))return o.u;o.R=!0,r=K(t,c),o.R=!1}else r=K(t,c);return i(r,(function(t,e){o&&f(o.u,t)===e||a(r,t,n(e))})),3===c?new Set(r):r}(n)}function K(n,t){switch(t){case 2:return new Map(n);case 3:return Array.from(n)}return p(n)}function $(){function n(n,t){var r=f[n];return r?r.enumerable=t:f[n]=r={configurable:!0,enumerable:t,get:function(){return Z.get(this[L],n)},set:function(t){Z.set(this[L],n,t)}},r}function t(n){for(var t=n.length-1;t>=0;t--){var r=n[t][L];if(!r.M)switch(r.t){case 5:u(r)&&R(r);break;case 4:e(r)&&R(r)}}}function e(n){for(var t=n.u,r=n.k,e=U(r),i=e.length-1;i>=0;i--){var u=e[i];if(u!==L){var f=t[u];if(void 0===f&&!o(t,u))return!0;var a=r[u],v=a&&a[L];if(v?v.u!==f:!c(a,f))return!0}}var s=!!t[L];return e.length!==U(t).length+(s?0:1)}function u(n){var t=n.k;if(t.length!==n.u.length)return!0;var r=Object.getOwnPropertyDescriptor(t,t.length-1);if(r&&!r.get)return!0;for(var e=0;e<t.length;e++)if(!t.hasOwnProperty(e))return!0;return!1}var f={};b("ES5",{J:function(t,r){var e=Array.isArray(t),i=function(t,r){if(t){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,""+i,n(i,!0));return e}var u=V(r);delete u[L];for(var o=U(u),f=0;f<o.length;f++){var a=o[f];u[a]=n(a,t||!!u[a].enumerable)}return Object.create(Object.getPrototypeOf(r),u)}(e,t),u={t:e?5:4,A:r?r.A:m(),M:!1,R:!1,D:{},p:r,u:t,k:i,i:null,O:!1,I:!1};return Object.defineProperty(i,L,{value:u,writable:!0}),i},P:function(n,e,f){f?r(e)&&e[L].A===n&&t(n.l):(n.o&&function n(t){if(t&&"object"==typeof t){var r=t[L];if(r){var e=r.u,f=r.k,a=r.D,c=r.t;if(4===c)i(f,(function(t){t!==L&&(void 0!==e[t]||o(e,t)?a[t]||n(f[t]):(a[t]=!0,R(r)))})),i(e,(function(n){void 0!==f[n]||o(f,n)||(a[n]=!1,R(r))}));else if(5===c){if(u(r)&&(R(r),a.length=!0),f.length<e.length)for(var v=f.length;v<e.length;v++)a[v]=!1;else for(var s=e.length;s<f.length;s++)a[s]=!0;for(var l=Math.min(f.length,e.length),p=0;p<l;p++)f.hasOwnProperty(p)||(a[p]=!0),void 0===a[p]&&n(f[p])}}}}(n.l[0]),t(n.l))},N:function(n){return 4===n.t?e(n):u(n)}})}function C(){function n(t){if(!e(t))return t;if(Array.isArray(t))return t.map(n);if(v(t))return new Map(Array.from(t.entries()).map((function(t){return[t[0],n(t[1])]})));if(s(t))return new Set(Array.from(t).map(n));var r=Object.create(Object.getPrototypeOf(t));for(var i in t)r[i]=n(t[i]);return o(t,H)&&(r[H]=t[H]),r}function a(t){return r(t)?n(t):t}var c="add";b("Patches",{W:function(r,e){return e.forEach((function(e){for(var i=e.path,o=e.op,a=r,v=0;v<i.length-1;v++){var s=u(a),l=""+i[v];0!==s&&1!==s||"__proto__"!==l&&"constructor"!==l||t(24),"function"==typeof a&&"prototype"===l&&t(24),"object"!=typeof(a=f(a,l))&&t(15,i.join("/"))}var p=u(a),d=n(e.value),h=i[i.length-1];switch(o){case"replace":switch(p){case 2:return a.set(h,d);case 3:t(16);default:return a[h]=d}case c:switch(p){case 1:return"-"===h?a.push(d):a.splice(h,0,d);case 2:return a.set(h,d);case 3:return a.add(d);default:return a[h]=d}case"remove":switch(p){case 1:return a.splice(h,1);case 2:return a.delete(h);case 3:return a.delete(e.value);default:return delete a[h]}default:t(17,o)}})),r},F:function(n,t,r,e){switch(n.t){case 0:case 4:case 2:return function(n,t,r,e){var u=n.u,v=n.i;i(n.D,(function(n,i){var s=f(u,n),l=f(v,n),p=i?o(u,n)?"replace":c:"remove";if(s!==l||"replace"!==p){var d=t.concat(n);r.push("remove"===p?{op:p,path:d}:{op:p,path:d,value:l}),e.push(p===c?{op:"remove",path:d}:"remove"===p?{op:c,path:d,value:a(s)}:{op:"replace",path:d,value:a(s)})}}))}(n,t,r,e);case 5:case 1:return function(n,t,r,e){var i=n.u,u=n.D,o=n.i;if(o.length<i.length){var f=[o,i];i=f[0],o=f[1];var v=[e,r];r=v[0],e=v[1]}for(var s=0;s<i.length;s++)if(u[s]&&o[s]!==i[s]){var l=t.concat([s]);r.push({op:"replace",path:l,value:a(o[s])}),e.push({op:"replace",path:l,value:a(i[s])})}for(var p=i.length;p<o.length;p++){var d=t.concat([p]);r.push({op:c,path:d,value:a(o[p])})}i.length<o.length&&e.push({op:"replace",path:t.concat(["length"]),value:i.length})}(n,t,r,e);case 3:return function(n,t,r,e){var i=n.u,u=n.i,o=0;i.forEach((function(n){if(!u.has(n)){var i=t.concat([o]);r.push({op:"remove",path:i,value:n}),e.unshift({op:c,path:i,value:n})}o++})),o=0,u.forEach((function(n){if(!i.has(n)){var u=t.concat([o]);r.push({op:c,path:u,value:n}),e.unshift({op:"remove",path:u,value:n})}o++}))}(n,t,r,e)}},g:function(n,t,r,e){r.push({op:"replace",path:[],value:t===G?void 0:t}),e.push({op:"replace",path:[],value:n})}})}function I(){function n(n,t){function r(){this.constructor=n}f(n,t),n.prototype=(r.prototype=t.prototype,new r)}function r(n){n.i||(n.D=new Map,n.i=new Map(n.u))}function u(n){n.i||(n.i=new Set,n.u.forEach((function(t){if(e(t)){var r=F(n.A.h,t,n);n.l.set(t,r),n.i.add(r)}else n.i.add(t)})))}function o(n){n.O&&t(3,JSON.stringify(l(n)))}var f=function(n,t){return(f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,t){n.__proto__=t}||function(n,t){for(var r in t)t.hasOwnProperty(r)&&(n[r]=t[r])})(n,t)},a=function(){function t(n,t){return this[L]={t:2,p:t,A:t?t.A:m(),M:!1,R:!1,i:void 0,D:void 0,u:n,k:this,I:!1,O:!1},this}n(t,Map);var u=t.prototype;return Object.defineProperty(u,"size",{get:function(){return l(this[L]).size}}),u.has=function(n){return l(this[L]).has(n)},u.set=function(n,t){var e=this[L];return o(e),l(e).has(n)&&l(e).get(n)===t||(r(e),R(e),e.D.set(n,!0),e.i.set(n,t),e.D.set(n,!0)),this},u.delete=function(n){if(!this.has(n))return!1;var t=this[L];return o(t),r(t),R(t),t.u.has(n)?t.D.set(n,!1):t.D.delete(n),t.i.delete(n),!0},u.clear=function(){var n=this[L];o(n),l(n).size&&(r(n),R(n),n.D=new Map,i(n.u,(function(t){n.D.set(t,!1)})),n.i.clear())},u.forEach=function(n,t){var r=this;l(this[L]).forEach((function(e,i){n.call(t,r.get(i),i,r)}))},u.get=function(n){var t=this[L];o(t);var i=l(t).get(n);if(t.R||!e(i))return i;if(i!==t.u.get(n))return i;var u=F(t.A.h,i,t);return r(t),t.i.set(n,u),u},u.keys=function(){return l(this[L]).keys()},u.values=function(){var n,t=this,r=this.keys();return(n={})[Q]=function(){return t.values()},n.next=function(){var n=r.next();return n.done?n:{done:!1,value:t.get(n.value)}},n},u.entries=function(){var n,t=this,r=this.keys();return(n={})[Q]=function(){return t.entries()},n.next=function(){var n=r.next();if(n.done)return n;var e=t.get(n.value);return{done:!1,value:[n.value,e]}},n},u[Q]=function(){return this.entries()},t}(),c=function(){function t(n,t){return this[L]={t:3,p:t,A:t?t.A:m(),M:!1,R:!1,i:void 0,u:n,k:this,l:new Map,O:!1,I:!1},this}n(t,Set);var r=t.prototype;return Object.defineProperty(r,"size",{get:function(){return l(this[L]).size}}),r.has=function(n){var t=this[L];return o(t),t.i?!!t.i.has(n)||!(!t.l.has(n)||!t.i.has(t.l.get(n))):t.u.has(n)},r.add=function(n){var t=this[L];return o(t),this.has(n)||(u(t),R(t),t.i.add(n)),this},r.delete=function(n){if(!this.has(n))return!1;var t=this[L];return o(t),u(t),R(t),t.i.delete(n)||!!t.l.has(n)&&t.i.delete(t.l.get(n))},r.clear=function(){var n=this[L];o(n),l(n).size&&(u(n),R(n),n.i.clear())},r.values=function(){var n=this[L];return o(n),u(n),n.i.values()},r.entries=function(){var n=this[L];return o(n),u(n),n.i.entries()},r.keys=function(){return this.values()},r[Q]=function(){return this.values()},r.forEach=function(n,t){for(var r=this.values(),e=r.next();!e.done;)n.call(t,e.value,e.value,this),e=r.next()},t}();b("MapSet",{$:function(n,t){return new a(n,t)},C:function(n,t){return new c(n,t)}})}var J,N,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,G=W?Symbol.for("immer-nothing"):((J={})["immer-nothing"]=!0,J),H=W?Symbol.for("immer-draftable"):"__$immer_draftable",L=W?Symbol.for("immer-state"):"__$immer_state",Q="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",T=""+Object.prototype.constructor,U="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,V=Object.getOwnPropertyDescriptors||function(n){var t={};return U(n).forEach((function(r){t[r]=Object.getOwnPropertyDescriptor(n,r)})),t},Y={},Z={get:function(n,t){if(t===L)return n;var r=l(n);if(!o(r,t))return function(n,t,r){var e,i=E(t,r);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,r,t);var i=r[t];return n.R||!e(i)?i:i===z(n.u,t)?(k(n),n.i[t]=F(n.A.h,i,n)):i},has:function(n,t){return t in l(n)},ownKeys:function(n){return Reflect.ownKeys(l(n))},set:function(n,t,r){var e=E(l(n),t);if(null==e?void 0:e.set)return e.set.call(n.k,r),!0;if(!n.M){var i=z(l(n),t),u=null==i?void 0:i[L];if(u&&u.u===r)return n.i[t]=r,n.D[t]=!1,!0;if(c(r,i)&&(void 0!==r||o(n.u,t)))return!0;k(n),R(n)}return n.i[t]===r&&"number"!=typeof r&&(void 0!==r||t in n.i)||(n.i[t]=r,n.D[t]=!0,!0)},deleteProperty:function(n,t){return void 0!==z(n.u,t)||t in n.u?(n.D[t]=!1,k(n),R(n)):delete n.D[t],n.i&&delete n.i[t],!0},getOwnPropertyDescriptor:function(n,t){var r=l(n),e=Reflect.getOwnPropertyDescriptor(r,t);return e?{writable:!0,configurable:1!==n.t||"length"!==t,enumerable:e.enumerable,value:r[t]}:e},defineProperty:function(){t(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.u)},setPrototypeOf:function(){t(12)}},nn={};i(Z,(function(n,t){nn[n]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),nn.deleteProperty=function(n,t){return nn.set.call(this,n,t,void 0)},nn.set=function(n,t,r){return Z.set.call(this,n[0],t,r,n[0])};var tn=function(){function n(n){var r=this;this.S=B,this.K=!0,this.produce=function(n,i,u){if("function"==typeof n&&"function"!=typeof i){var o=i;i=n;var f=r;return function(n){var t=this;void 0===n&&(n=o);for(var r=arguments.length,e=Array(r>1?r-1:0),u=1;u<r;u++)e[u-1]=arguments[u];return f.produce(n,(function(n){var r;return(r=i).call.apply(r,[t,n].concat(e))}))}}var a;if("function"!=typeof i&&t(6),void 0!==u&&"function"!=typeof u&&t(7),e(n)){var c=S(r),v=F(r,n,void 0),s=!0;try{a=i(v),s=!1}finally{s?O(c):w(c)}return"undefined"!=typeof Promise&&a instanceof Promise?a.then((function(n){return j(c,u),M(n,c)}),(function(n){throw O(c),n})):(j(c,u),M(a,c))}if(!n||"object"!=typeof n){if(void 0===(a=i(n))&&(a=n),a===G&&(a=void 0),r.K&&d(a,!0),u){var l=[],p=[];_("Patches").g(n,a,l,p),u(l,p)}return a}t(21,n)},this.produceWithPatches=function(n,t){if("function"==typeof n)return function(t){for(var e=arguments.length,i=Array(e>1?e-1:0),u=1;u<e;u++)i[u-1]=arguments[u];return r.produceWithPatches(t,(function(t){return n.apply(void 0,[t].concat(i))}))};var e,i,u=r.produce(n,t,(function(n,t){e=n,i=t}));return"undefined"!=typeof Promise&&u instanceof Promise?u.then((function(n){return[n,e,i]})):[u,e,i]},"boolean"==typeof(null==n?void 0:n.useProxies)&&this.setUseProxies(n.useProxies),"boolean"==typeof(null==n?void 0:n.autoFreeze)&&this.setAutoFreeze(n.autoFreeze)}var i=n.prototype;return i.createDraft=function(n){e(n)||t(8),r(n)&&(n=D(n));var i=S(this),u=F(this,n,void 0);return u[L].I=!0,w(i),u},i.finishDraft=function(n,t){var r=(n&&n[L]).A;return j(r,t),M(void 0,r)},i.setAutoFreeze=function(n){this.K=n},i.setUseProxies=function(n){n&&!B&&t(20),this.S=n},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var u=_("Patches").W;return r(n)?u(n,t):this.produce(n,(function(n){return u(n,t)}))},n}(),rn=new tn,en=rn.produce,un=rn.produceWithPatches.bind(rn),on=rn.setAutoFreeze.bind(rn),fn=rn.setUseProxies.bind(rn),an=rn.applyPatches.bind(rn),cn=rn.createDraft.bind(rn),vn=rn.finishDraft.bind(rn);n.Immer=tn,n.applyPatches=an,n.castDraft=function(n){return n},n.castImmutable=function(n){return n},n.createDraft=cn,n.current=D,n.default=en,n.enableAllPlugins=function(){$(),I(),C()},n.enableES5=$,n.enableMapSet=I,n.enablePatches=C,n.finishDraft=vn,n.freeze=d,n.immerable=H,n.isDraft=r,n.isDraftable=e,n.nothing=G,n.original=function(n){return r(n)||t(23,n),n[L].u},n.produce=en,n.produceWithPatches=un,n.setAutoFreeze=on,n.setUseProxies=fn,Object.defineProperty(n,"__esModule",{value:!0})}));
+!function(n,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((n=n||self).immer={})}(this,(function(n){function r(n){for(var r=arguments.length,e=Array(r>1?r-1:0),t=1;t<r;t++)e[t-1]=arguments[t];throw Error("[Immer] minified error nr: "+n+(e.length?" "+e.map((function(n){return"'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function e(n){return!!n&&!!n[L]}function t(n){return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var r=Object.getPrototypeOf(n);if(null===r)return!0;var e=Object.hasOwnProperty.call(r,"constructor")&&r.constructor;return e===Object||"function"==typeof e&&Function.toString.call(e)===T}(n)||Array.isArray(n)||!!n[H]||!!n.constructor[H]||v(n)||l(n))}function i(n,r,e){void 0===e&&(e=!1),0===u(n)?(e?Object.keys:U)(n).forEach((function(t){e&&"symbol"==typeof t||r(t,n[t],n)})):n.forEach((function(e,t){return r(t,e,n)}))}function u(n){var r=n[L];return r?r.t>3?r.t-4:r.t:Array.isArray(n)?1:v(n)?2:l(n)?3:0}function o(n,r){return 2===u(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a(n,r){return 2===u(n)?n.get(r):n[r]}function f(n,r,e){var t=u(n);2===t?n.set(r,e):3===t?(n.delete(r),n.add(e)):n[r]=e}function c(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function v(n){return X&&n instanceof Map}function l(n){return q&&n instanceof Set}function s(n){return n.i||n.u}function p(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=V(n);delete r[L];for(var e=U(r),t=0;t<e.length;t++){var i=e[t],u=r[i];!1===u.writable&&(u.writable=!0,u.configurable=!0),(u.get||u.set)&&(r[i]={configurable:!0,writable:!0,enumerable:u.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),r)}function b(n,r){if(void 0===r&&(r=!1),h(n)||e(n)||!t(n))return n;if(u(n)>1){var o={configurable:!0,writable:!0,value:d};Object.defineProperties(n,{set:o,add:o,clear:o,delete:o})}return Object.freeze(n),r&&i(n,(function(n,r){return b(r,!0)}),!0),n}function d(){r(2)}function h(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function y(n){var e=Y[n];return e||r(18,n),e}function _(n,r){Y[n]||(Y[n]=r)}function w(){return N}function m(n,r){r&&(y("Patches"),n.o=[],n.v=[],n.l=r)}function g(n){j(n),n.s.forEach(S),n.s=null}function j(n){n===N&&(N=n.p)}function O(n){return N={s:[],p:N,h:n,_:!0,m:0}}function S(n){var r=n[L];0===r.t||1===r.t?r.g():r.j=!0}function P(n,e){e.m=e.s.length;var i=e.s[0],u=void 0!==n&&n!==i;return e.h.O||y("ES5").S(e,n,u),u?(i[L].P&&(g(e),r(4)),t(n)&&(n=M(e,n),e.p||x(e,n)),e.o&&y("Patches").M(i[L].u,n,e.o,e.v)):n=M(e,i,[]),g(e),e.o&&e.l(e.o,e.v),n!==G?n:void 0}function M(n,r,e){if(h(r))return r;var t=r[L];if(!t)return i(r,(function(i,u){return A(n,t,r,i,u,e)}),!0),r;if(t.A!==n)return r;if(!t.P)return x(n,t.u,!0),t.u;if(!t.k){t.k=!0,t.A.m--;var u=4===t.t||5===t.t?t.i=p(t.R):t.i;i(3===t.t?new Set(u):u,(function(r,i){return A(n,t,u,r,i,e)})),x(n,u,!1),e&&n.o&&y("Patches").F(t,e,n.o,n.v)}return t.i}function A(n,r,i,u,a,c){if(e(a)){var v=M(n,a,c&&r&&3!==r.t&&!o(r.D,u)?c.concat(u):void 0);if(f(i,u,v),!e(v))return;n._=!1}if(t(a)&&!h(a)){if(!n.h.K&&n.m<1)return;M(n,a),r&&r.A.p||x(n,a)}}function x(n,r,e){void 0===e&&(e=!1),n.h.K&&n._&&b(r,e)}function z(n,r){var e=n[L];return(e?s(e):n)[r]}function E(n,r){if(r in n)for(var e=Object.getPrototypeOf(n);e;){var t=Object.getOwnPropertyDescriptor(e,r);if(t)return t;e=Object.getPrototypeOf(e)}}function k(n){n.P||(n.P=!0,n.p&&k(n.p))}function R(n){n.i||(n.i=p(n.u))}function F(n,r,e){var t=v(r)?y("MapSet").$(r,e):l(r)?y("MapSet").C(r,e):n.O?function(n,r){var e=Array.isArray(n),t={t:e?1:0,A:r?r.A:w(),P:!1,k:!1,D:{},p:r,u:n,R:null,i:null,g:null,I:!1},i=t,u=Z;e&&(i=[t],u=nn);var o=Proxy.revocable(i,u),a=o.revoke,f=o.proxy;return t.R=f,t.g=a,f}(r,e):y("ES5").J(r,e);return(e?e.A:w()).s.push(t),t}function D(n){return e(n)||r(22,n),function n(r){if(!t(r))return r;var e,o=r[L],c=u(r);if(o){if(!o.P&&(o.t<4||!y("ES5").N(o)))return o.u;o.k=!0,e=K(r,c),o.k=!1}else e=K(r,c);return i(e,(function(r,t){o&&a(o.u,r)===t||f(e,r,n(t))})),3===c?new Set(e):e}(n)}function K(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return p(n)}function $(){function n(n,r){var e=a[n];return e?e.enumerable=r:a[n]=e={configurable:!0,enumerable:r,get:function(){return Z.get(this[L],n)},set:function(r){Z.set(this[L],n,r)}},e}function r(n){for(var r=n.length-1;r>=0;r--){var e=n[r][L];if(!e.P)switch(e.t){case 5:u(e)&&k(e);break;case 4:t(e)&&k(e)}}}function t(n){for(var r=n.u,e=n.R,t=U(e),i=t.length-1;i>=0;i--){var u=t[i];if(u!==L){var a=r[u];if(void 0===a&&!o(r,u))return!0;var f=e[u],v=f&&f[L];if(v?v.u!==a:!c(f,a))return!0}}var l=!!r[L];return t.length!==U(r).length+(l?0:1)}function u(n){var r=n.R;if(r.length!==n.u.length)return!0;var e=Object.getOwnPropertyDescriptor(r,r.length-1);if(e&&!e.get)return!0;for(var t=0;t<r.length;t++)if(!r.hasOwnProperty(t))return!0;return!1}var a={};_("ES5",{J:function(r,e){var t=Array.isArray(r),i=function(r,e){if(r){for(var t=Array(e.length),i=0;i<e.length;i++)Object.defineProperty(t,""+i,n(i,!0));return t}var u=V(e);delete u[L];for(var o=U(u),a=0;a<o.length;a++){var f=o[a];u[f]=n(f,r||!!u[f].enumerable)}return Object.create(Object.getPrototypeOf(e),u)}(t,r),u={t:t?5:4,A:e?e.A:w(),P:!1,k:!1,D:{},p:e,u:r,R:i,i:null,j:!1,I:!1};return Object.defineProperty(i,L,{value:u,writable:!0}),i},S:function(n,t,a){a?e(t)&&t[L].A===n&&r(n.s):(n.o&&function n(r){if(r&&"object"==typeof r){var e=r[L];if(e){var t=e.u,a=e.R,f=e.D,c=e.t;if(4===c)i(a,(function(r){r!==L&&(void 0!==t[r]||o(t,r)?f[r]||n(a[r]):(f[r]=!0,k(e)))})),i(t,(function(n){void 0!==a[n]||o(a,n)||(f[n]=!1,k(e))}));else if(5===c){if(u(e)&&(k(e),f.length=!0),a.length<t.length)for(var v=a.length;v<t.length;v++)f[v]=!1;else for(var l=t.length;l<a.length;l++)f[l]=!0;for(var s=Math.min(a.length,t.length),p=0;p<s;p++)a.hasOwnProperty(p)||(f[p]=!0),void 0===f[p]&&n(a[p])}}}}(n.s[0]),r(n.s))},N:function(n){return 4===n.t?t(n):u(n)}})}function C(){function n(n,r){function e(){Object.defineProperty(this,"constructor",{value:n})}a(n,r),n.prototype=(e.prototype=r.prototype,new e)}function e(n){n.i||(n.D=new Map,n.i=new Map(n.u))}function u(n){n.i||(n.i=new Set,n.u.forEach((function(r){if(t(r)){var e=F(n.A.h,r,n);n.s.set(r,e),n.i.add(e)}else n.i.add(r)})))}function o(n){n.j&&r(3,JSON.stringify(s(n)))}var a=function(n,r){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var e in r)r.hasOwnProperty(e)&&(n[e]=r[e])})(n,r)},f=function(){function r(n,r){return this[L]={t:2,p:r,A:r?r.A:w(),P:!1,k:!1,i:void 0,D:void 0,u:n,R:this,I:!1,j:!1},this}var u;return n(r,Map),Object.defineProperties(r.prototype,((u={size:{get:function(){return s(this[L]).size},configurable:!0},has:{configurable:!0,writable:!0,value:function(n){return s(this[L]).has(n)}},set:{configurable:!0,writable:!0,value:function(n,r){var t=this[L];return o(t),s(t).has(n)&&s(t).get(n)===r||(e(t),k(t),t.D.set(n,!0),t.i.set(n,r),t.D.set(n,!0)),this}},delete:{configurable:!0,writable:!0,value:function(n){if(!this.has(n))return!1;var r=this[L];return o(r),e(r),k(r),r.u.has(n)?r.D.set(n,!1):r.D.delete(n),r.i.delete(n),!0}},clear:{configurable:!0,writable:!0,value:function(){var n=this[L];o(n),s(n).size&&(e(n),k(n),n.D=new Map,i(n.u,(function(r){n.D.set(r,!1)})),n.i.clear())}},forEach:{configurable:!0,writable:!0,value:function(n,r){var e=this;s(this[L]).forEach((function(t,i){n.call(r,e.get(i),i,e)}))}},get:{configurable:!0,writable:!0,value:function(n){var r=this[L];o(r);var i=s(r).get(n);if(r.k||!t(i))return i;if(i!==r.u.get(n))return i;var u=F(r.A.h,i,r);return e(r),r.i.set(n,u),u}},keys:{configurable:!0,writable:!0,value:function(){return s(this[L]).keys()}},values:{configurable:!0,writable:!0,value:function(){var n,r=this,e=this.keys();return(n={})[Q]=function(){return r.values()},n.next=function(){var n=e.next();return n.done?n:{done:!1,value:r.get(n.value)}},n}},entries:{configurable:!0,writable:!0,value:function(){var n,r=this,e=this.keys();return(n={})[Q]=function(){return r.entries()},n.next=function(){var n=e.next();if(n.done)return n;var t=r.get(n.value);return{done:!1,value:[n.value,t]}},n}}})[Q]={configurable:!0,writable:!0,value:function(){return this.entries()}},u)),r}(),c=function(){function r(n,r){return this[L]={t:3,p:r,A:r?r.A:w(),P:!1,k:!1,i:void 0,u:n,R:this,s:new Map,j:!1,I:!1},this}var e;return n(r,Set),Object.defineProperties(r.prototype,((e={size:{get:function(){return s(this[L]).size},configurable:!0},has:{configurable:!0,writable:!0,value:function(n){var r=this[L];return o(r),r.i?!!r.i.has(n)||!(!r.s.has(n)||!r.i.has(r.s.get(n))):r.u.has(n)}},add:{configurable:!0,writable:!0,value:function(n){var r=this[L];return o(r),this.has(n)||(u(r),k(r),r.i.add(n)),this}},delete:{configurable:!0,writable:!0,value:function(n){if(!this.has(n))return!1;var r=this[L];return o(r),u(r),k(r),r.i.delete(n)||!!r.s.has(n)&&r.i.delete(r.s.get(n))}},clear:{configurable:!0,writable:!0,value:function(){var n=this[L];o(n),s(n).size&&(u(n),k(n),n.i.clear())}},values:{configurable:!0,writable:!0,value:function(){var n=this[L];return o(n),u(n),n.i.values()}},entries:{configurable:!0,writable:!0,value:function(){var n=this[L];return o(n),u(n),n.i.entries()}},keys:{configurable:!0,writable:!0,value:function(){return this.values()}}})[Q]={configurable:!0,writable:!0,value:function(){return this.values()}},e.forEach={configurable:!0,writable:!0,value:function(n,r){for(var e=this.values(),t=e.next();!t.done;)n.call(r,t.value,t.value,this),t=e.next()}},e)),r}();_("MapSet",{$:function(n,r){return new f(n,r)},C:function(n,r){return new c(n,r)}})}function I(){function n(r){if(!t(r))return r;if(Array.isArray(r))return r.map(n);if(v(r))return new Map(Array.from(r.entries()).map((function(r){return[r[0],n(r[1])]})));if(l(r))return new Set(Array.from(r).map(n));var e=Object.create(Object.getPrototypeOf(r));for(var i in r)e[i]=n(r[i]);return o(r,H)&&(e[H]=r[H]),e}function f(r){return e(r)?n(r):r}var c="add";_("Patches",{W:function(e,t){return t.forEach((function(t){for(var i=t.path,o=t.op,f=e,v=0;v<i.length-1;v++){var l=u(f),s=""+i[v];0!==l&&1!==l||"__proto__"!==s&&"constructor"!==s||r(24),"function"==typeof f&&"prototype"===s&&r(24),"object"!=typeof(f=a(f,s))&&r(15,i.join("/"))}var p=u(f),b=n(t.value),d=i[i.length-1];switch(o){case"replace":switch(p){case 2:return f.set(d,b);case 3:r(16);default:return f[d]=b}case c:switch(p){case 1:return"-"===d?f.push(b):f.splice(d,0,b);case 2:return f.set(d,b);case 3:return f.add(b);default:return f[d]=b}case"remove":switch(p){case 1:return f.splice(d,1);case 2:return f.delete(d);case 3:return f.delete(t.value);default:return delete f[d]}default:r(17,o)}})),e},F:function(n,r,e,t){switch(n.t){case 0:case 4:case 2:return function(n,r,e,t){var u=n.u,v=n.i;i(n.D,(function(n,i){var l=a(u,n),s=a(v,n),p=i?o(u,n)?"replace":c:"remove";if(l!==s||"replace"!==p){var b=r.concat(n);e.push("remove"===p?{op:p,path:b}:{op:p,path:b,value:s}),t.push(p===c?{op:"remove",path:b}:"remove"===p?{op:c,path:b,value:f(l)}:{op:"replace",path:b,value:f(l)})}}))}(n,r,e,t);case 5:case 1:return function(n,r,e,t){var i=n.u,u=n.D,o=n.i;if(o.length<i.length){var a=[o,i];i=a[0],o=a[1];var v=[t,e];e=v[0],t=v[1]}for(var l=0;l<i.length;l++)if(u[l]&&o[l]!==i[l]){var s=r.concat([l]);e.push({op:"replace",path:s,value:f(o[l])}),t.push({op:"replace",path:s,value:f(i[l])})}for(var p=i.length;p<o.length;p++){var b=r.concat([p]);e.push({op:c,path:b,value:f(o[p])})}i.length<o.length&&t.push({op:"replace",path:r.concat(["length"]),value:i.length})}(n,r,e,t);case 3:return function(n,r,e,t){var i=n.u,u=n.i,o=0;i.forEach((function(n){if(!u.has(n)){var i=r.concat([o]);e.push({op:"remove",path:i,value:n}),t.unshift({op:c,path:i,value:n})}o++})),o=0,u.forEach((function(n){if(!i.has(n)){var u=r.concat([o]);e.push({op:c,path:u,value:n}),t.unshift({op:"remove",path:u,value:n})}o++}))}(n,r,e,t)}},M:function(n,r,e,t){e.push({op:"replace",path:[],value:r===G?void 0:r}),t.push({op:"replace",path:[],value:n})}})}var J,N,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,G=W?Symbol.for("immer-nothing"):((J={})["immer-nothing"]=!0,J),H=W?Symbol.for("immer-draftable"):"__$immer_draftable",L=W?Symbol.for("immer-state"):"__$immer_state",Q="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",T=""+Object.prototype.constructor,U="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,V=Object.getOwnPropertyDescriptors||function(n){var r={};return U(n).forEach((function(e){r[e]=Object.getOwnPropertyDescriptor(n,e)})),r},Y={},Z={get:function(n,r){if(r===L)return n;var e=s(n);if(!o(e,r))return function(n,r,e){var t,i=E(r,e);return i?"value"in i?i.value:null===(t=i.get)||void 0===t?void 0:t.call(n.R):void 0}(n,e,r);var i=e[r];return n.k||!t(i)?i:i===z(n.u,r)?(R(n),n.i[r]=F(n.A.h,i,n)):i},has:function(n,r){return r in s(n)},ownKeys:function(n){return Reflect.ownKeys(s(n))},set:function(n,r,e){var t=E(s(n),r);if(null==t?void 0:t.set)return t.set.call(n.R,e),!0;if(!n.P){var i=z(s(n),r),u=null==i?void 0:i[L];if(u&&u.u===e)return n.i[r]=e,n.D[r]=!1,!0;if(c(e,i)&&(void 0!==e||o(n.u,r)))return!0;R(n),k(n)}return n.i[r]===e&&"number"!=typeof e&&(void 0!==e||r in n.i)||(n.i[r]=e,n.D[r]=!0,!0)},deleteProperty:function(n,r){return void 0!==z(n.u,r)||r in n.u?(n.D[r]=!1,R(n),k(n)):delete n.D[r],n.i&&delete n.i[r],!0},getOwnPropertyDescriptor:function(n,r){var e=s(n),t=Reflect.getOwnPropertyDescriptor(e,r);return t?{writable:!0,configurable:1!==n.t||"length"!==r,enumerable:t.enumerable,value:e[r]}:t},defineProperty:function(){r(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.u)},setPrototypeOf:function(){r(12)}},nn={};i(Z,(function(n,r){nn[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)}})),nn.deleteProperty=function(n,r){return nn.set.call(this,n,r,void 0)},nn.set=function(n,r,e){return Z.set.call(this,n[0],r,e,n[0])};var rn=function(){function n(n){var e=this;this.O=B,this.K=!0,this.produce=function(n,i,u){if("function"==typeof n&&"function"!=typeof i){var o=i;i=n;var a=e;return function(n){var r=this;void 0===n&&(n=o);for(var e=arguments.length,t=Array(e>1?e-1:0),u=1;u<e;u++)t[u-1]=arguments[u];return a.produce(n,(function(n){var e;return(e=i).call.apply(e,[r,n].concat(t))}))}}var f;if("function"!=typeof i&&r(6),void 0!==u&&"function"!=typeof u&&r(7),t(n)){var c=O(e),v=F(e,n,void 0),l=!0;try{f=i(v),l=!1}finally{l?g(c):j(c)}return"undefined"!=typeof Promise&&f instanceof Promise?f.then((function(n){return m(c,u),P(n,c)}),(function(n){throw g(c),n})):(m(c,u),P(f,c))}if(!n||"object"!=typeof n){if(void 0===(f=i(n))&&(f=n),f===G&&(f=void 0),e.K&&b(f,!0),u){var s=[],p=[];y("Patches").M(n,f,s,p),u(s,p)}return f}r(21,n)},this.produceWithPatches=function(n,r){if("function"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),u=1;u<t;u++)i[u-1]=arguments[u];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,u=e.produce(n,r,(function(n,r){t=n,i=r}));return"undefined"!=typeof Promise&&u instanceof Promise?u.then((function(n){return[n,t,i]})):[u,t,i]},"boolean"==typeof(null==n?void 0:n.useProxies)&&this.setUseProxies(n.useProxies),"boolean"==typeof(null==n?void 0:n.autoFreeze)&&this.setAutoFreeze(n.autoFreeze)}var i=n.prototype;return i.createDraft=function(n){t(n)||r(8),e(n)&&(n=D(n));var i=O(this),u=F(this,n,void 0);return u[L].I=!0,j(i),u},i.finishDraft=function(n,r){var e=(n&&n[L]).A;return m(e,r),P(void 0,e)},i.setAutoFreeze=function(n){this.K=n},i.setUseProxies=function(n){n&&!B&&r(20),this.O=n},i.applyPatches=function(n,r){var t;for(t=r.length-1;t>=0;t--){var i=r[t];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}t>-1&&(r=r.slice(t+1));var u=y("Patches").W;return e(n)?u(n,r):this.produce(n,(function(n){return u(n,r)}))},n}(),en=new rn,tn=en.produce,un=en.produceWithPatches.bind(en),on=en.setAutoFreeze.bind(en),an=en.setUseProxies.bind(en),fn=en.applyPatches.bind(en),cn=en.createDraft.bind(en),vn=en.finishDraft.bind(en);n.Immer=rn,n.applyPatches=fn,n.castDraft=function(n){return n},n.castImmutable=function(n){return n},n.createDraft=cn,n.current=D,n.default=tn,n.enableAllPlugins=function(){$(),C(),I()},n.enableES5=$,n.enableMapSet=C,n.enablePatches=I,n.finishDraft=vn,n.freeze=b,n.immerable=H,n.isDraft=e,n.isDraftable=t,n.nothing=G,n.original=function(n){return e(n)||r(23,n),n[L].u},n.produce=tn,n.produceWithPatches=un,n.setAutoFreeze=on,n.setUseProxies=an,Object.defineProperty(n,"__esModule",{value:!0})}));
 //# sourceMappingURL=immer.umd.production.min.js.map
diff --git a/dist/immer.umd.production.min.js.map b/dist/immer.umd.production.min.js.map
index 1e6bf4d2da29105bf2b75e0dc04d0c06971fcef1..552e5de0f4a6848134fa156cc57e8fccd9e09002 100644
--- a/dist/immer.umd.production.min.js.map
+++ b/dist/immer.umd.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"immer.umd.production.min.js","sources":["../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/patches.ts","../src/plugins/mapset.ts","../src/utils/env.ts","../src/immer.ts","../src/plugins/all.ts"],"sourcesContent":["const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tthis.constructor = d\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: false,\n\t\t\t// configurable: true\n\t\t})\n\n\t\tp.has = function(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tp.set = function(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.forEach = function(\n\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\tthisArg?: any\n\t\t) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tp.get = function(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp.entries = function(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.entries()\n\t\t}\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: true,\n\t\t})\n\n\t\tp.has = function(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tp.add = function(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tp.entries = function entries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp.forEach = function forEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n"],"names":["die","error","args","Error","length","map","s","join","isDraft","value","DRAFT_STATE","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","toString","objectCtorString","Array","isArray","DRAFTABLE","isMap","isSet","each","obj","iter","enumerableOnly","getArchtype","keys","ownKeys","forEach","key","entry","index","thing","state","type_","has","prop","prototype","get","set","propOrOldValue","t","delete","add","is","x","y","target","hasMap","Map","hasSet","Set","latest","copy_","base_","shallowCopy","base","slice","descriptors","getOwnPropertyDescriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","loadPlugin","implementation","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","push","current","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","proxyProperty","this","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","defineProperty","markChangesRecursively","object","min","Math","enablePatches","deepClonePatchValue","entries","cloned","immerable","clonePatchValueIfNeeded","ADD","applyPatches_","patches","patch","op","parentType","p","type","splice","basePath","inversePatches","assignedValue","origValue","unshift","replacement","enableMapSet","__extends","d","b","__","extendStatics","prepareMapCopy","prepareSetCopy","assertUnrevoked","JSON","stringify","setPrototypeOf","__proto__","DraftMap","size","cb","thisArg","_value","_this","values","iterator","iteratorSymbol","_this2","next","r","done","_this3","DraftSet","hasSymbol","Symbol","hasProxies","Reflect","for","getOwnPropertySymbols","getOwnPropertyNames","_desc$get","currentState","deleteProperty","owner","fn","arguments","apply","Immer","config","recipe","defaultBase","self","produce","hasError","Promise","then","ip","arg1","arg2","produceWithPatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","applyPatchesImpl","bind"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"immer.umd.production.min.js","sources":["../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/mapset.ts","../src/plugins/patches.ts","../src/utils/env.ts","../src/immer.ts","../src/plugins/all.ts"],"sourcesContent":["const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tconst desc: PropertyDescriptor = {\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: dontMutateFrozenCollections\n\t\t}\n\t\tObject.defineProperties(obj, {\n\t\t\tset: desc,\n\t\t\tadd: desc,\n\t\t\tclear: desc,\n\t\t\tdelete: desc\n\t\t})\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tObject.defineProperty(this, \"constructor\", {\n\t\t\t\tvalue: d\n\t\t\t})\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperties(p, {\n\t\t\tsize: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\thas: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): boolean {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t\t\t}\n\t\t\t},\n\t\t\tset: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any, value: any) {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\t\t}\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelete: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): boolean {\n\t\t\t\t\tif (!this.has(key)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\tif (state.base_.has(key)) {\n\t\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t\t\t}\n\t\t\t\t\tstate.copy_!.delete(key)\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t},\n\t\t\tclear: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (latest(state).size) {\n\t\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\t\t\teach(state.base_, key => {\n\t\t\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tstate.copy_!.clear()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tforEach: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(\n\t\t\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\t\t\tthisArg?: any\n\t\t\t\t) {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t},\n\t\t\tget: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(key: any): any {\n\t\t\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tconst value = latest(state).get(key)\n\t\t\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\t\t\treturn value\n\t\t\t\t\t}\n\t\t\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t\t\t}\n\t\t\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tprepareMapCopy(state)\n\t\t\t\t\tstate.copy_!.set(key, draft)\n\t\t\t\t\treturn draft\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalues: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\tconst iterator = this.keys()\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\t\t\tnext: () => {\n\t\t\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\t\tif (r.done) return r\n\t\t\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\t\t\t\t}\n\t\t\t},\n\t\t\tentries: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<[any, any]> {\n\t\t\t\t\tconst iterator = this.keys()\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\t\t\tnext: () => {\n\t\t\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\t\tif (r.done) return r\n\t\t\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\t\t\t\t}\n\t\t\t},\n\t\t\t[iteratorSymbol]: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\treturn this.entries()\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperties(p, {\n\t\t\tsize: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\thas: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): boolean {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\t\t\tif (!state.copy_) {\n\t\t\t\t\t\treturn state.base_.has(value)\n\t\t\t\t\t}\n\t\t\t\t\tif (state.copy_.has(value)) return true\n\t\t\t\t\tif (\n\t\t\t\t\t\tstate.drafts_.has(value) &&\n\t\t\t\t\t\tstate.copy_.has(state.drafts_.get(value))\n\t\t\t\t\t)\n\t\t\t\t\t\treturn true\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t},\n\t\t\tadd: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): any {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (!this.has(value)) {\n\t\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t\t}\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelete: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(value: any): any {\n\t\t\t\t\tif (!this.has(value)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\treturn (\n\t\t\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t},\n\t\t\tclear: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tif (latest(state).size) {\n\t\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\t\tmarkChanged(state)\n\t\t\t\t\t\tstate.copy_!.clear()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalues: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\treturn state.copy_!.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\tentries: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function entries(): IterableIterator<[any, any]> {\n\t\t\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\t\t\tassertUnrevoked(state)\n\t\t\t\t\tprepareSetCopy(state)\n\t\t\t\t\treturn state.copy_!.entries()\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function(): IterableIterator<any> {\n\t\t\t\t\treturn this.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\t[iteratorSymbol]: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function() {\n\t\t\t\t\treturn this.values()\n\t\t\t\t}\n\t\t\t},\n\t\t\tforEach: {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: function forEach(cb: any, thisArg?: any) {\n\t\t\t\t\tconst iterator = this.values()\n\t\t\t\t\tlet result = iterator.next()\n\t\t\t\t\twhile (!result.done) {\n\t\t\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\t\t\tresult = iterator.next()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n"],"names":["die","error","args","Error","length","map","s","join","isDraft","value","DRAFT_STATE","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","toString","objectCtorString","Array","isArray","DRAFTABLE","isMap","isSet","each","obj","iter","enumerableOnly","getArchtype","keys","ownKeys","forEach","key","entry","index","thing","state","type_","has","prop","prototype","get","set","propOrOldValue","t","delete","add","is","x","y","target","hasMap","Map","hasSet","Set","latest","copy_","base_","shallowCopy","base","slice","descriptors","getOwnPropertyDescriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","dontMutateFrozenCollections","defineProperties","clear","getPlugin","pluginKey","plugin","plugins","loadPlugin","implementation","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","push","current","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","proxyProperty","this","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","defineProperty","markChangesRecursively","object","min","Math","enableMapSet","__extends","d","b","__","extendStatics","prepareMapCopy","prepareSetCopy","assertUnrevoked","JSON","stringify","setPrototypeOf","__proto__","p","DraftMap","size","cb","thisArg","_value","_this","values","iterator","iteratorSymbol","_this2","next","r","done","entries","_this3","DraftSet","enablePatches","deepClonePatchValue","cloned","immerable","clonePatchValueIfNeeded","ADD","applyPatches_","patches","patch","op","parentType","type","splice","basePath","inversePatches","assignedValue","origValue","unshift","replacement","hasSymbol","Symbol","hasProxies","Reflect","for","getOwnPropertySymbols","getOwnPropertyNames","_desc$get","currentState","deleteProperty","owner","fn","arguments","apply","Immer","config","recipe","defaultBase","self","produce","hasError","Promise","then","ip","arg1","arg2","produceWithPatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","applyPatchesImpl","bind"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/plugins/mapset.d.ts.map b/dist/plugins/mapset.d.ts.map
index 6e88bba075cff0f8c659e0a85b1d076e916f2b58..77c199ee20d13a508d54efd2aae3bd9c49fd3e17 100644
--- a/dist/plugins/mapset.d.ts.map
+++ b/dist/plugins/mapset.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"mapset.d.ts","sourceRoot":"","sources":["../src/plugins/mapset.ts"],"names":[],"mappings":"AAoBA,wBAAgB,YAAY,SAuU3B"}
\ No newline at end of file
+{"version":3,"file":"mapset.d.ts","sourceRoot":"","sources":["../src/plugins/mapset.ts"],"names":[],"mappings":"AAoBA,wBAAgB,YAAY,SAwY3B"}
\ No newline at end of file
diff --git a/dist/utils/common.d.ts.map b/dist/utils/common.d.ts.map
index 88c931a2de8854a777a726038f0ac8d81034a2a6..2192ffa780cba18fcdaa04e88a2bf6d0e32745b0 100644
--- a/dist/utils/common.d.ts.map
+++ b/dist/utils/common.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"common.d.ts","sourceRoot":"","sources":["../src/utils/common.ts"],"names":[],"mappings":"AAAA,OAAO,EAIN,SAAS,EAET,SAAS,EACT,MAAM,EACN,MAAM,EACN,UAAU,EAEV,QAAQ,EAER,MAAM,aAAa,CAAA;AAEpB,wDAAwD;AAExD,wBAAgB,OAAO,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAE3C;AAED,8DAA8D;AAE9D,wBAAgB,WAAW,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAU/C;AAID,wBAAgB,aAAa,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAejD;AAED,uEAAuE;AAEvE,wBAAgB,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,CAAC,GAAG,SAAS,CAAA;AAOpD,eAAO,MAAM,OAAO,EAAE,CAAC,MAAM,EAAE,SAAS,KAAK,WAAW,EAQC,CAAA;AAEzD,eAAO,MAAM,yBAAyB;;CASpC,CAAA;AAEF,wBAAgB,IAAI,CAAC,CAAC,SAAS,SAAS,EACvC,GAAG,EAAE,CAAC,EACN,IAAI,EAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,CAAC,KAAK,IAAI,EAC3D,cAAc,CAAC,EAAE,OAAO,GACtB,IAAI,CAAA;AAYP,wBAAgB,WAAW,CAAC,KAAK,EAAE,GAAG,GAAG,QAAQ,CAchD;AAGD,wBAAgB,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,WAAW,GAAG,OAAO,CAI1D;AAGD,wBAAgB,GAAG,CAAC,KAAK,EAAE,MAAM,GAAG,SAAS,EAAE,IAAI,EAAE,WAAW,GAAG,GAAG,CAGrE;AAGD,wBAAgB,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,cAAc,EAAE,WAAW,EAAE,KAAK,EAAE,GAAG,QAOtE;AAGD,wBAAgB,EAAE,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,GAAG,OAAO,CAO1C;AAGD,wBAAgB,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,MAAM,IAAI,MAAM,CAEnD;AAGD,wBAAgB,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,MAAM,IAAI,MAAM,CAEnD;AAED,wBAAgB,MAAM,CAAC,KAAK,EAAE,UAAU,GAAG,GAAG,CAE7C;AAGD,wBAAgB,WAAW,CAAC,IAAI,EAAE,GAAG,OAwBpC;AAED;;;;;;GAMG;AACH,wBAAgB,MAAM,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE,OAAO,GAAG,CAAC,CAAA;AAepD,wBAAgB,QAAQ,CAAC,GAAG,EAAE,GAAG,GAAG,OAAO,CAI1C"}
\ No newline at end of file
+{"version":3,"file":"common.d.ts","sourceRoot":"","sources":["../src/utils/common.ts"],"names":[],"mappings":"AAAA,OAAO,EAIN,SAAS,EAET,SAAS,EACT,MAAM,EACN,MAAM,EACN,UAAU,EAEV,QAAQ,EAER,MAAM,aAAa,CAAA;AAEpB,wDAAwD;AAExD,wBAAgB,OAAO,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAE3C;AAED,8DAA8D;AAE9D,wBAAgB,WAAW,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAU/C;AAID,wBAAgB,aAAa,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAejD;AAED,uEAAuE;AAEvE,wBAAgB,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,CAAC,GAAG,SAAS,CAAA;AAOpD,eAAO,MAAM,OAAO,EAAE,CAAC,MAAM,EAAE,SAAS,KAAK,WAAW,EAQC,CAAA;AAEzD,eAAO,MAAM,yBAAyB;;CASpC,CAAA;AAEF,wBAAgB,IAAI,CAAC,CAAC,SAAS,SAAS,EACvC,GAAG,EAAE,CAAC,EACN,IAAI,EAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,CAAC,KAAK,IAAI,EAC3D,cAAc,CAAC,EAAE,OAAO,GACtB,IAAI,CAAA;AAYP,wBAAgB,WAAW,CAAC,KAAK,EAAE,GAAG,GAAG,QAAQ,CAchD;AAGD,wBAAgB,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,WAAW,GAAG,OAAO,CAI1D;AAGD,wBAAgB,GAAG,CAAC,KAAK,EAAE,MAAM,GAAG,SAAS,EAAE,IAAI,EAAE,WAAW,GAAG,GAAG,CAGrE;AAGD,wBAAgB,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,cAAc,EAAE,WAAW,EAAE,KAAK,EAAE,GAAG,QAOtE;AAGD,wBAAgB,EAAE,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,GAAG,OAAO,CAO1C;AAGD,wBAAgB,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,MAAM,IAAI,MAAM,CAEnD;AAGD,wBAAgB,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,MAAM,IAAI,MAAM,CAEnD;AAED,wBAAgB,MAAM,CAAC,KAAK,EAAE,UAAU,GAAG,GAAG,CAE7C;AAGD,wBAAgB,WAAW,CAAC,IAAI,EAAE,GAAG,OAwBpC;AAED;;;;;;GAMG;AACH,wBAAgB,MAAM,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE,OAAO,GAAG,CAAC,CAAA;AAyBpD,wBAAgB,QAAQ,CAAC,GAAG,EAAE,GAAG,GAAG,OAAO,CAI1C"}
\ No newline at end of file
diff --git a/src/plugins/mapset.ts b/src/plugins/mapset.ts
index 17dc5ddb80a18964c092c6b15363294c9319cda6..40e5dd83b30cd5a51310554f58c48b6af8f690f4 100644
--- a/src/plugins/mapset.ts
+++ b/src/plugins/mapset.ts
@@ -37,7 +37,9 @@ export function enableMapSet() {
 	function __extends(d: any, b: any): any {
 		extendStatics(d, b)
 		function __(this: any): any {
-			this.constructor = d
+			Object.defineProperty(this, "constructor", {
+				value: d
+			})
 		}
 		d.prototype =
 			// @ts-ignore
@@ -65,131 +67,162 @@ export function enableMapSet() {
 		}
 		const p = DraftMap.prototype
 
-		Object.defineProperty(p, "size", {
-			get: function() {
-				return latest(this[DRAFT_STATE]).size
-			}
-			// enumerable: false,
-			// configurable: true
-		})
-
-		p.has = function(key: any): boolean {
-			return latest(this[DRAFT_STATE]).has(key)
-		}
-
-		p.set = function(key: any, value: any) {
-			const state: MapState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			if (!latest(state).has(key) || latest(state).get(key) !== value) {
-				prepareMapCopy(state)
-				markChanged(state)
-				state.assigned_!.set(key, true)
-				state.copy_!.set(key, value)
-				state.assigned_!.set(key, true)
-			}
-			return this
-		}
-
-		p.delete = function(key: any): boolean {
-			if (!this.has(key)) {
-				return false
-			}
-
-			const state: MapState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			prepareMapCopy(state)
-			markChanged(state)
-			if (state.base_.has(key)) {
-				state.assigned_!.set(key, false)
-			} else {
-				state.assigned_!.delete(key)
-			}
-			state.copy_!.delete(key)
-			return true
-		}
-
-		p.clear = function() {
-			const state: MapState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			if (latest(state).size) {
-				prepareMapCopy(state)
-				markChanged(state)
-				state.assigned_ = new Map()
-				each(state.base_, key => {
-					state.assigned_!.set(key, false)
-				})
-				state.copy_!.clear()
-			}
-		}
-
-		p.forEach = function(
-			cb: (value: any, key: any, self: any) => void,
-			thisArg?: any
-		) {
-			const state: MapState = this[DRAFT_STATE]
-			latest(state).forEach((_value: any, key: any, _map: any) => {
-				cb.call(thisArg, this.get(key), key, this)
-			})
-		}
-
-		p.get = function(key: any): any {
-			const state: MapState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			const value = latest(state).get(key)
-			if (state.finalized_ || !isDraftable(value)) {
-				return value
-			}
-			if (value !== state.base_.get(key)) {
-				return value // either already drafted or reassigned
-			}
-			// despite what it looks, this creates a draft only once, see above condition
-			const draft = createProxy(state.scope_.immer_, value, state)
-			prepareMapCopy(state)
-			state.copy_!.set(key, draft)
-			return draft
-		}
-
-		p.keys = function(): IterableIterator<any> {
-			return latest(this[DRAFT_STATE]).keys()
-		}
-
-		p.values = function(): IterableIterator<any> {
-			const iterator = this.keys()
-			return {
-				[iteratorSymbol]: () => this.values(),
-				next: () => {
-					const r = iterator.next()
-					/* istanbul ignore next */
-					if (r.done) return r
-					const value = this.get(r.value)
-					return {
-						done: false,
-						value
+		Object.defineProperties(p, {
+			size: {
+				get: function() {
+					return latest(this[DRAFT_STATE]).size
+				},
+				configurable: true
+			},
+			has: {
+				configurable: true,
+				writable: true,
+				value: function(key: any): boolean {
+					return latest(this[DRAFT_STATE]).has(key)
+				}
+			},
+			set: {
+				configurable: true,
+				writable: true,
+				value: function(key: any, value: any) {
+					const state: MapState = this[DRAFT_STATE]
+					assertUnrevoked(state)
+					if (!latest(state).has(key) || latest(state).get(key) !== value) {
+						prepareMapCopy(state)
+						markChanged(state)
+						state.assigned_!.set(key, true)
+						state.copy_!.set(key, value)
+						state.assigned_!.set(key, true)
 					}
+					return this
 				}
-			} as any
-		}
+			},
+			delete: {
+				configurable: true,
+				writable: true,
+				value: function(key: any): boolean {
+					if (!this.has(key)) {
+						return false
+					}
 
-		p.entries = function(): IterableIterator<[any, any]> {
-			const iterator = this.keys()
-			return {
-				[iteratorSymbol]: () => this.entries(),
-				next: () => {
-					const r = iterator.next()
-					/* istanbul ignore next */
-					if (r.done) return r
-					const value = this.get(r.value)
-					return {
-						done: false,
-						value: [r.value, value]
+					const state: MapState = this[DRAFT_STATE]
+					assertUnrevoked(state)
+					prepareMapCopy(state)
+					markChanged(state)
+					if (state.base_.has(key)) {
+						state.assigned_!.set(key, false)
+					} else {
+						state.assigned_!.delete(key)
 					}
+					state.copy_!.delete(key)
+					return true
 				}
-			} as any
-		}
-
-		p[iteratorSymbol] = function() {
-			return this.entries()
-		}
+			},
+			clear: {
+				configurable: true,
+				writable: true,
+				value: function() {
+					const state: MapState = this[DRAFT_STATE]
+					assertUnrevoked(state)
+					if (latest(state).size) {
+						prepareMapCopy(state)
+						markChanged(state)
+						state.assigned_ = new Map()
+						each(state.base_, key => {
+							state.assigned_!.set(key, false)
+						})
+						state.copy_!.clear()
+					}
+				}
+			},
+			forEach: {
+				configurable: true,
+				writable: true,
+				value: function(
+					cb: (value: any, key: any, self: any) => void,
+					thisArg?: any
+				) {
+					const state: MapState = this[DRAFT_STATE]
+					latest(state).forEach((_value: any, key: any, _map: any) => {
+						cb.call(thisArg, this.get(key), key, this)
+					})
+				}
+			},
+			get: {
+				configurable: true,
+				writable: true,
+				value: function(key: any): any {
+					const state: MapState = this[DRAFT_STATE]
+					assertUnrevoked(state)
+					const value = latest(state).get(key)
+					if (state.finalized_ || !isDraftable(value)) {
+						return value
+					}
+					if (value !== state.base_.get(key)) {
+						return value // either already drafted or reassigned
+					}
+					// despite what it looks, this creates a draft only once, see above condition
+					const draft = createProxy(state.scope_.immer_, value, state)
+					prepareMapCopy(state)
+					state.copy_!.set(key, draft)
+					return draft
+				}
+			},
+			keys: {
+				configurable: true,
+				writable: true,
+				value: function(): IterableIterator<any> {
+					return latest(this[DRAFT_STATE]).keys()
+				}
+			},
+			values: {
+				configurable: true,
+				writable: true,
+				value: function(): IterableIterator<any> {
+					const iterator = this.keys()
+					return {
+						[iteratorSymbol]: () => this.values(),
+						next: () => {
+							const r = iterator.next()
+							/* istanbul ignore next */
+							if (r.done) return r
+							const value = this.get(r.value)
+							return {
+								done: false,
+								value
+							}
+						}
+					} as any
+				}
+			},
+			entries: {
+				configurable: true,
+				writable: true,
+				value: function(): IterableIterator<[any, any]> {
+					const iterator = this.keys()
+					return {
+						[iteratorSymbol]: () => this.entries(),
+						next: () => {
+							const r = iterator.next()
+							/* istanbul ignore next */
+							if (r.done) return r
+							const value = this.get(r.value)
+							return {
+								done: false,
+								value: [r.value, value]
+							}
+						}
+					} as any
+				}
+			},
+			[iteratorSymbol]: {
+				configurable: true,
+				writable: true,
+				value: function() {
+					return this.entries()
+				}
+			}
+		})
 
 		return DraftMap
 	})(Map)
@@ -227,94 +260,126 @@ export function enableMapSet() {
 		}
 		const p = DraftSet.prototype
 
-		Object.defineProperty(p, "size", {
-			get: function() {
-				return latest(this[DRAFT_STATE]).size
-			}
-			// enumerable: true,
-		})
-
-		p.has = function(value: any): boolean {
-			const state: SetState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			// bit of trickery here, to be able to recognize both the value, and the draft of its value
-			if (!state.copy_) {
-				return state.base_.has(value)
-			}
-			if (state.copy_.has(value)) return true
-			if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))
-				return true
-			return false
-		}
-
-		p.add = function(value: any): any {
-			const state: SetState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			if (!this.has(value)) {
-				prepareSetCopy(state)
-				markChanged(state)
-				state.copy_!.add(value)
-			}
-			return this
-		}
-
-		p.delete = function(value: any): any {
-			if (!this.has(value)) {
-				return false
-			}
-
-			const state: SetState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			prepareSetCopy(state)
-			markChanged(state)
-			return (
-				state.copy_!.delete(value) ||
-				(state.drafts_.has(value)
-					? state.copy_!.delete(state.drafts_.get(value))
-					: /* istanbul ignore next */ false)
-			)
-		}
-
-		p.clear = function() {
-			const state: SetState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			if (latest(state).size) {
-				prepareSetCopy(state)
-				markChanged(state)
-				state.copy_!.clear()
-			}
-		}
-
-		p.values = function(): IterableIterator<any> {
-			const state: SetState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			prepareSetCopy(state)
-			return state.copy_!.values()
-		}
-
-		p.entries = function entries(): IterableIterator<[any, any]> {
-			const state: SetState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			prepareSetCopy(state)
-			return state.copy_!.entries()
-		}
-
-		p.keys = function(): IterableIterator<any> {
-			return this.values()
-		}
-
-		p[iteratorSymbol] = function() {
-			return this.values()
-		}
+		Object.defineProperties(p, {
+			size: {
+				get: function() {
+					return latest(this[DRAFT_STATE]).size
+				},
+				configurable: true
+			},
+			has: {
+				configurable: true,
+				writable: true,
+				value: function(value: any): boolean {
+					const state: SetState = this[DRAFT_STATE]
+					assertUnrevoked(state)
+					// bit of trickery here, to be able to recognize both the value, and the draft of its value
+					if (!state.copy_) {
+						return state.base_.has(value)
+					}
+					if (state.copy_.has(value)) return true
+					if (
+						state.drafts_.has(value) &&
+						state.copy_.has(state.drafts_.get(value))
+					)
+						return true
+					return false
+				}
+			},
+			add: {
+				configurable: true,
+				writable: true,
+				value: function(value: any): any {
+					const state: SetState = this[DRAFT_STATE]
+					assertUnrevoked(state)
+					if (!this.has(value)) {
+						prepareSetCopy(state)
+						markChanged(state)
+						state.copy_!.add(value)
+					}
+					return this
+				}
+			},
+			delete: {
+				configurable: true,
+				writable: true,
+				value: function(value: any): any {
+					if (!this.has(value)) {
+						return false
+					}
 
-		p.forEach = function forEach(cb: any, thisArg?: any) {
-			const iterator = this.values()
-			let result = iterator.next()
-			while (!result.done) {
-				cb.call(thisArg, result.value, result.value, this)
-				result = iterator.next()
+					const state: SetState = this[DRAFT_STATE]
+					assertUnrevoked(state)
+					prepareSetCopy(state)
+					markChanged(state)
+					return (
+						state.copy_!.delete(value) ||
+						(state.drafts_.has(value)
+							? state.copy_!.delete(state.drafts_.get(value))
+							: /* istanbul ignore next */ false)
+					)
+				}
+			},
+			clear: {
+				configurable: true,
+				writable: true,
+				value: function() {
+					const state: SetState = this[DRAFT_STATE]
+					assertUnrevoked(state)
+					if (latest(state).size) {
+						prepareSetCopy(state)
+						markChanged(state)
+						state.copy_!.clear()
+					}
+				}
+			},
+			values: {
+				configurable: true,
+				writable: true,
+				value: function(): IterableIterator<any> {
+					const state: SetState = this[DRAFT_STATE]
+					assertUnrevoked(state)
+					prepareSetCopy(state)
+					return state.copy_!.values()
+				}
+			},
+			entries: {
+				configurable: true,
+				writable: true,
+				value: function entries(): IterableIterator<[any, any]> {
+					const state: SetState = this[DRAFT_STATE]
+					assertUnrevoked(state)
+					prepareSetCopy(state)
+					return state.copy_!.entries()
+				}
+			},
+			keys: {
+				configurable: true,
+				writable: true,
+				value: function(): IterableIterator<any> {
+					return this.values()
+				}
+			},
+			[iteratorSymbol]: {
+				configurable: true,
+				writable: true,
+				value: function() {
+					return this.values()
+				}
+			},
+			forEach: {
+				configurable: true,
+				writable: true,
+				value: function forEach(cb: any, thisArg?: any) {
+					const iterator = this.values()
+					let result = iterator.next()
+					while (!result.done) {
+						cb.call(thisArg, result.value, result.value, this)
+						result = iterator.next()
+					}
+				}
 			}
-		}
+		})
 
 		return DraftSet
 	})(Set)
diff --git a/src/utils/common.ts b/src/utils/common.ts
index dae5064eb40eb661d0023d2e4e814e70f4e426ec..9586de0b96575c3603ca9a7018b001a333e2efd1 100644
--- a/src/utils/common.ts
+++ b/src/utils/common.ts
@@ -199,7 +199,17 @@ export function freeze<T>(obj: T, deep?: boolean): T
 export function freeze<T>(obj: any, deep: boolean = false): T {
 	if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj
 	if (getArchtype(obj) > 1 /* Map or Set */) {
-		obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any
+		const desc: PropertyDescriptor = {
+			configurable: true,
+			writable: true,
+			value: dontMutateFrozenCollections
+		}
+		Object.defineProperties(obj, {
+			set: desc,
+			add: desc,
+			clear: desc,
+			delete: desc
+		})
 	}
 	Object.freeze(obj)
 	if (deep) each(obj, (key, value) => freeze(value, true), true)