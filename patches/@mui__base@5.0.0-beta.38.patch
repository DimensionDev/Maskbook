diff --git a/ClickAwayListener/ClickAwayListener.d.ts b/ClickAwayListener/ClickAwayListener.d.ts
index 477ee12c6af5be2a4dcfcf7e732906381e24ae17..565ad74838fd0861495f1cb4e3d7f5727ec435da 100644
--- a/ClickAwayListener/ClickAwayListener.d.ts
+++ b/ClickAwayListener/ClickAwayListener.d.ts
@@ -1,31 +1,41 @@
-import * as React from 'react';
-type ClickAwayMouseEventHandler = 'onClick' | 'onMouseDown' | 'onMouseUp' | 'onPointerDown' | 'onPointerUp';
-type ClickAwayTouchEventHandler = 'onTouchStart' | 'onTouchEnd';
+import * as React from "react";
+type ClickAwayMouseEventHandler =
+  | "onClick"
+  | "onMouseDown"
+  | "onMouseUp"
+  | "onPointerDown"
+  | "onPointerUp";
+type ClickAwayTouchEventHandler = "onTouchStart" | "onTouchEnd";
 export interface ClickAwayListenerProps {
-    /**
-     * The wrapped element.
-     */
-    children: React.ReactElement;
-    /**
-     * If `true`, the React tree is ignored and only the DOM tree is considered.
-     * This prop changes how portaled elements are handled.
-     * @default false
-     */
-    disableReactTree?: boolean;
-    /**
-     * The mouse event to listen to. You can disable the listener by providing `false`.
-     * @default 'onClick'
-     */
-    mouseEvent?: ClickAwayMouseEventHandler | false;
-    /**
-     * Callback fired when a "click away" event is detected.
-     */
-    onClickAway: (event: MouseEvent | TouchEvent) => void;
-    /**
-     * The touch event to listen to. You can disable the listener by providing `false`.
-     * @default 'onTouchEnd'
-     */
-    touchEvent?: ClickAwayTouchEventHandler | false;
+  /**
+   * The wrapped element.
+   */
+  children: React.ReactElement;
+  /**
+   * If `true`, the React tree is ignored and only the DOM tree is considered.
+   * This prop changes how portaled elements are handled.
+   * @default false
+   */
+  disableReactTree?: boolean;
+  /**
+   * The mouse event to listen to. You can disable the listener by providing `false`.
+   * @default 'onClick'
+   */
+  mouseEvent?: ClickAwayMouseEventHandler | false;
+  /**
+   * Callback fired when a "click away" event is detected.
+   */
+  onClickAway: (event: MouseEvent | TouchEvent) => void;
+  /**
+   * The touch event to listen to. You can disable the listener by providing `false`.
+   * @default 'onTouchEnd'
+   */
+  touchEvent?: ClickAwayTouchEventHandler | false;
+  /**
+   * Patched prop
+   * @default false
+   */
+  useCapture?: boolean;
 }
 /**
  * Listen for click events that occur somewhere in the document, outside of the element itself.
@@ -41,6 +51,6 @@ export interface ClickAwayListenerProps {
  */
 declare function ClickAwayListener(props: ClickAwayListenerProps): JSX.Element;
 declare namespace ClickAwayListener {
-    var propTypes: any;
+  var propTypes: any;
 }
 export { ClickAwayListener };
diff --git a/ClickAwayListener/ClickAwayListener.js b/ClickAwayListener/ClickAwayListener.js
index f8abfb89d9371bd5f7cb7850be7aec1a4d82bb44..55ff15c7fe6da03dbe4650291dd105df63ae16ce 100644
--- a/ClickAwayListener/ClickAwayListener.js
+++ b/ClickAwayListener/ClickAwayListener.js
@@ -1,8 +1,14 @@
-'use client';
+"use client";
 
-import * as React from 'react';
-import PropTypes from 'prop-types';
-import { elementAcceptingRef, exactProp, unstable_ownerDocument as ownerDocument, unstable_useForkRef as useForkRef, unstable_useEventCallback as useEventCallback } from '@mui/utils';
+import * as React from "react";
+import PropTypes from "prop-types";
+import {
+  elementAcceptingRef,
+  exactProp,
+  unstable_ownerDocument as ownerDocument,
+  unstable_useForkRef as useForkRef,
+  unstable_useEventCallback as useEventCallback,
+} from "@mui/utils";
 
 // TODO: return `EventHandlerName extends `on${infer EventName}` ? Lowercase<EventName> : never` once generatePropTypes runs with TS 4.1
 import { jsx as _jsx } from "react/jsx-runtime";
@@ -10,7 +16,10 @@ function mapEventPropToEvent(eventProp) {
   return eventProp.substring(2).toLowerCase();
 }
 function clickedRootScrollbar(event, doc) {
-  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
+  return (
+    doc.documentElement.clientWidth < event.clientX ||
+    doc.documentElement.clientHeight < event.clientY
+  );
 }
 /**
  * Listen for click events that occur somewhere in the document, outside of the element itself.
@@ -28,9 +37,10 @@ function ClickAwayListener(props) {
   const {
     children,
     disableReactTree = false,
-    mouseEvent = 'onClick',
+    mouseEvent = "onClick",
     onClickAway,
-    touchEvent = 'onTouchEnd'
+    touchEvent = "onTouchEnd",
+    useCapture = false,
   } = props;
   const movedRef = React.useRef(false);
   const nodeRef = React.useRef(null);
@@ -47,8 +57,10 @@ function ClickAwayListener(props) {
     };
   }, []);
   const handleRef = useForkRef(
-  // @ts-expect-error TODO upstream fix
-  children.ref, nodeRef);
+    // @ts-expect-error TODO upstream fix
+    children.ref,
+    nodeRef
+  );
 
   // The handler doesn't take event.defaultPrevented into account:
   //
@@ -56,44 +68,54 @@ function ClickAwayListener(props) {
   // clicking a checkbox to check it, hitting a button to submit a form,
   // and hitting left arrow to move the cursor in a text input etc.
   // Only special HTML elements have these default behaviors.
-  const handleClickAway = useEventCallback(event => {
-    // Given developers can stop the propagation of the synthetic event,
-    // we can only be confident with a positive value.
-    const insideReactTree = syntheticEventRef.current;
-    syntheticEventRef.current = false;
-    const doc = ownerDocument(nodeRef.current);
+  const handleClickAway = useEventCallback((event) => {
+    const check = () => {
+      // Given developers can stop the propagation of the synthetic event,
+      // we can only be confident with a positive value.
+      const insideReactTree = syntheticEventRef.current;
+      syntheticEventRef.current = false;
+      const doc = ownerDocument(nodeRef.current); // 1. IE11 support, which trigger the handleClickAway even after the unbind
+      // 2. The child might render null.
+      // 3. Behave like a blur listener.
 
-    // 1. IE11 support, which trigger the handleClickAway even after the unbind
-    // 2. The child might render null.
-    // 3. Behave like a blur listener.
-    if (!activatedRef.current || !nodeRef.current || 'clientX' in event && clickedRootScrollbar(event, doc)) {
-      return;
-    }
+      if (!activatedRef.current || !nodeRef.current || ("clientX" in event && clickedRootScrollbar(event, doc))) {
+        return;
+      } // Do not act if user performed touchmove
 
-    // Do not act if user performed touchmove
-    if (movedRef.current) {
-      movedRef.current = false;
-      return;
-    }
-    let insideDOM;
+      if (movedRef.current) {
+        movedRef.current = false;
+        return;
+      }
+      let insideDOM;
 
-    // If not enough, can use https://github.com/DieterHolvoet/event-propagation-path/blob/master/propagationPath.js
-    if (event.composedPath) {
-      insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
+      // If not enough, can use https://github.com/DieterHolvoet/event-propagation-path/blob/master/propagationPath.js
+      if (event.composedPath) {
+        insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
+      } else {
+        insideDOM = !doc.documentElement.contains(
+            // @ts-expect-error returns `false` as intended when not dispatched from a Node
+            event.target) || nodeRef.current.contains(
+            // @ts-expect-error returns `false` as intended when not dispatched from a Node
+            event.target);
+      }
+      if (!insideDOM && (disableReactTree || !insideReactTree)) {
+        onClickAway(event);
+      }
+    };
+
+    // If useCapture is true, `childrenPropsHandler` created by
+    // `createHandleSynthetic` will fire after `handleClickAway`,
+    // `syntheticEventRef.current` (or `insideReactTree`) will always be false
+    // at the first checking
+    if (useCapture) {
+      setTimeout(check);
     } else {
-      insideDOM = !doc.documentElement.contains(
-      // @ts-expect-error returns `false` as intended when not dispatched from a Node
-      event.target) || nodeRef.current.contains(
-      // @ts-expect-error returns `false` as intended when not dispatched from a Node
-      event.target);
-    }
-    if (!insideDOM && (disableReactTree || !insideReactTree)) {
-      onClickAway(event);
+      check();
     }
   });
 
   // Keep track of mouse/touch events that bubbled up through the portal.
-  const createHandleSynthetic = handlerName => event => {
+  const createHandleSynthetic = (handlerName) => (event) => {
     syntheticEventRef.current = true;
     const childrenPropsHandler = children.props[handlerName];
     if (childrenPropsHandler) {
@@ -101,7 +123,7 @@ function ClickAwayListener(props) {
     }
   };
   const childrenProps = {
-    ref: handleRef
+    ref: handleRef,
   };
   if (touchEvent !== false) {
     childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
@@ -113,15 +135,15 @@ function ClickAwayListener(props) {
       const handleTouchMove = () => {
         movedRef.current = true;
       };
-      doc.addEventListener(mappedTouchEvent, handleClickAway);
-      doc.addEventListener('touchmove', handleTouchMove);
+      doc.addEventListener(mappedTouchEvent, handleClickAway, useCapture);
+      doc.addEventListener("touchmove", handleTouchMove, useCapture);
       return () => {
-        doc.removeEventListener(mappedTouchEvent, handleClickAway);
-        doc.removeEventListener('touchmove', handleTouchMove);
+        doc.removeEventListener(mappedTouchEvent, handleClickAway, useCapture);
+        doc.removeEventListener("touchmove", handleTouchMove, useCapture);
       };
     }
     return undefined;
-  }, [handleClickAway, touchEvent]);
+  }, [handleClickAway, touchEvent, useCapture]);
   if (mouseEvent !== false) {
     childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
   }
@@ -129,49 +151,63 @@ function ClickAwayListener(props) {
     if (mouseEvent !== false) {
       const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
       const doc = ownerDocument(nodeRef.current);
-      doc.addEventListener(mappedMouseEvent, handleClickAway);
+      doc.addEventListener(mappedMouseEvent, handleClickAway, useCapture);
       return () => {
-        doc.removeEventListener(mappedMouseEvent, handleClickAway);
+        doc.removeEventListener(mappedMouseEvent, handleClickAway, useCapture);
       };
     }
     return undefined;
-  }, [handleClickAway, mouseEvent]);
-  return /*#__PURE__*/_jsx(React.Fragment, {
-    children: /*#__PURE__*/React.cloneElement(children, childrenProps)
+  }, [handleClickAway, mouseEvent, useCapture]);
+  return /*#__PURE__*/ _jsx(React.Fragment, {
+    children: /*#__PURE__*/ React.cloneElement(children, childrenProps),
   });
 }
-process.env.NODE_ENV !== "production" ? ClickAwayListener.propTypes /* remove-proptypes */ = {
-  // ┌────────────────────────────── Warning ──────────────────────────────┐
-  // │ These PropTypes are generated from the TypeScript type definitions. │
-  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
-  // └─────────────────────────────────────────────────────────────────────┘
-  /**
-   * The wrapped element.
-   */
-  children: elementAcceptingRef.isRequired,
-  /**
-   * If `true`, the React tree is ignored and only the DOM tree is considered.
-   * This prop changes how portaled elements are handled.
-   * @default false
-   */
-  disableReactTree: PropTypes.bool,
-  /**
-   * The mouse event to listen to. You can disable the listener by providing `false`.
-   * @default 'onClick'
-   */
-  mouseEvent: PropTypes.oneOf(['onClick', 'onMouseDown', 'onMouseUp', 'onPointerDown', 'onPointerUp', false]),
-  /**
-   * Callback fired when a "click away" event is detected.
-   */
-  onClickAway: PropTypes.func.isRequired,
-  /**
-   * The touch event to listen to. You can disable the listener by providing `false`.
-   * @default 'onTouchEnd'
-   */
-  touchEvent: PropTypes.oneOf(['onTouchEnd', 'onTouchStart', false])
-} : void 0;
-if (process.env.NODE_ENV !== 'production') {
+process.env.NODE_ENV !== "production"
+  ? (ClickAwayListener.propTypes /* remove-proptypes */ = {
+      // ┌────────────────────────────── Warning ──────────────────────────────┐
+      // │ These PropTypes are generated from the TypeScript type definitions. │
+      // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
+      // └─────────────────────────────────────────────────────────────────────┘
+      /**
+       * The wrapped element.
+       */
+      children: elementAcceptingRef.isRequired,
+      /**
+       * If `true`, the React tree is ignored and only the DOM tree is considered.
+       * This prop changes how portaled elements are handled.
+       * @default false
+       */
+      disableReactTree: PropTypes.bool,
+      /**
+       * The mouse event to listen to. You can disable the listener by providing `false`.
+       * @default 'onClick'
+       */
+      mouseEvent: PropTypes.oneOf([
+        "onClick",
+        "onMouseDown",
+        "onMouseUp",
+        "onPointerDown",
+        "onPointerUp",
+        false,
+      ]),
+      /**
+       * Callback fired when a "click away" event is detected.
+       */
+      onClickAway: PropTypes.func.isRequired,
+      /**
+       * The touch event to listen to. You can disable the listener by providing `false`.
+       * @default 'onTouchEnd'
+       */
+      touchEvent: PropTypes.oneOf(["onTouchEnd", "onTouchStart", false]),
+      /**
+       * Patched prop
+       * @default false
+       */
+      useCapture: PropTypes.bool,
+    })
+  : void 0;
+if (process.env.NODE_ENV !== "production") {
   // eslint-disable-next-line
-  ClickAwayListener['propTypes' + ''] = exactProp(ClickAwayListener.propTypes);
+  ClickAwayListener["propTypes" + ""] = exactProp(ClickAwayListener.propTypes);
 }
 export { ClickAwayListener };
diff --git a/Modal/Modal.js b/Modal/Modal.js
index 507fb16dca9257e308e7a03a1618ddc0802292f7..df801781f87de034291cb08e08610c74f92f8443 100644
--- a/Modal/Modal.js
+++ b/Modal/Modal.js
@@ -1,28 +1,49 @@
-'use client';
+"use client";
 
 import _extends from "@babel/runtime/helpers/esm/extends";
 import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
-const _excluded = ["children", "closeAfterTransition", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited", "slotProps", "slots"];
-import * as React from 'react';
-import PropTypes from 'prop-types';
-import { elementAcceptingRef, HTMLElementType } from '@mui/utils';
-import { useSlotProps } from '../utils';
-import { useClassNamesOverride } from '../utils/ClassNameConfigurator';
-import { unstable_composeClasses as composeClasses } from '../composeClasses';
-import { Portal } from '../Portal';
-import { unstable_useModal as useModal } from '../unstable_useModal';
-import { FocusTrap } from '../FocusTrap';
-import { getModalUtilityClass } from './modalClasses';
+const _excluded = [
+  "children",
+  "classes",
+  "closeAfterTransition",
+  "component",
+  "components",
+  "componentsProps",
+  "container",
+  "disableAutoFocus",
+  "disableEnforceFocus",
+  "disableEscapeKeyDown",
+  "disablePortal",
+  "disableRestoreFocus",
+  "disableScrollLock",
+  "scrollContainer",
+  "hideBackdrop",
+  "keepMounted",
+  "manager",
+  "onBackdropClick",
+  "onClose",
+  "onKeyDown",
+  "open",
+  "onTransitionEnter",
+  "onTransitionExited",
+];
+import * as React from "react";
+import PropTypes from "prop-types";
+import { elementAcceptingRef, HTMLElementType } from "@mui/utils";
+import { useSlotProps } from "../utils";
+import { useClassNamesOverride } from "../utils/ClassNameConfigurator";
+import { unstable_composeClasses as composeClasses } from "../composeClasses";
+import { Portal } from "../Portal";
+import { unstable_useModal as useModal } from "../unstable_useModal";
+import { FocusTrap } from "../FocusTrap";
+import { getModalUtilityClass } from "./modalClasses";
 import { jsx as _jsx } from "react/jsx-runtime";
 import { jsxs as _jsxs } from "react/jsx-runtime";
-const useUtilityClasses = ownerState => {
-  const {
-    open,
-    exited
-  } = ownerState;
+const useUtilityClasses = (ownerState) => {
+  const { open, exited } = ownerState;
   const slots = {
-    root: ['root', !open && exited && 'hidden'],
-    backdrop: ['backdrop']
+    root: ["root", !open && exited && "hidden"],
+    backdrop: ["backdrop"],
   };
   return composeClasses(slots, useClassNamesOverride(getModalUtilityClass));
 };
@@ -48,7 +69,10 @@ const useUtilityClasses = ownerState => {
  *
  * - [Modal API](https://mui.com/base-ui/react-modal/components-api/#modal)
  */
-const Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef) {
+const Modal = /*#__PURE__*/ React.forwardRef(function Modal(
+  props,
+  forwardedRef
+) {
   var _slots$root;
   const {
       children,
@@ -60,12 +84,13 @@ const Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef)
       disablePortal = false,
       disableRestoreFocus = false,
       disableScrollLock = false,
+      scrollContainer,
       hideBackdrop = false,
       keepMounted = false,
       onBackdropClick,
       open,
       slotProps = {},
-      slots = {}
+      slots = {},
     } = props,
     other = _objectWithoutPropertiesLoose(props, _excluded);
   const propsWithDefaults = _extends({}, props, {
@@ -77,7 +102,7 @@ const Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef)
     disableRestoreFocus,
     disableScrollLock,
     hideBackdrop,
-    keepMounted
+    keepMounted,
   });
   const {
     getRootProps,
@@ -86,193 +111,208 @@ const Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef)
     portalRef,
     isTopModal,
     exited,
-    hasTransition
-  } = useModal(_extends({}, propsWithDefaults, {
-    rootRef: forwardedRef
-  }));
+    hasTransition,
+  } = useModal(
+    _extends({}, propsWithDefaults, {
+      rootRef: forwardedRef,
+    })
+  );
   const ownerState = _extends({}, propsWithDefaults, {
     exited,
-    hasTransition
+    hasTransition,
   });
   const classes = useUtilityClasses(ownerState);
   const childProps = {};
   if (children.props.tabIndex === undefined) {
-    childProps.tabIndex = '-1';
+    childProps.tabIndex = "-1";
   }
 
   // It's a Transition like component
   if (hasTransition) {
-    const {
-      onEnter,
-      onExited
-    } = getTransitionProps();
+    const { onEnter, onExited } = getTransitionProps();
     childProps.onEnter = onEnter;
     childProps.onExited = onExited;
   }
-  const Root = (_slots$root = slots.root) != null ? _slots$root : 'div';
+  const Root = (_slots$root = slots.root) != null ? _slots$root : "div";
   const rootProps = useSlotProps({
     elementType: Root,
     externalSlotProps: slotProps.root,
     externalForwardedProps: other,
     getSlotProps: getRootProps,
     className: classes.root,
-    ownerState
+    ownerState,
   });
   const BackdropComponent = slots.backdrop;
   const backdropProps = useSlotProps({
     elementType: BackdropComponent,
     externalSlotProps: slotProps.backdrop,
-    getSlotProps: otherHandlers => {
-      return getBackdropProps(_extends({}, otherHandlers, {
-        onClick: e => {
-          if (onBackdropClick) {
-            onBackdropClick(e);
-          }
-          if (otherHandlers != null && otherHandlers.onClick) {
-            otherHandlers.onClick(e);
-          }
-        }
-      }));
+    getSlotProps: (otherHandlers) => {
+      return getBackdropProps(
+        _extends({}, otherHandlers, {
+          onClick: (e) => {
+            if (onBackdropClick) {
+              onBackdropClick(e);
+            }
+            if (otherHandlers != null && otherHandlers.onClick) {
+              otherHandlers.onClick(e);
+            }
+          },
+        })
+      );
     },
     className: classes.backdrop,
-    ownerState
+    ownerState,
   });
   if (!keepMounted && !open && (!hasTransition || exited)) {
     return null;
   }
-  return /*#__PURE__*/_jsx(Portal, {
+  return /*#__PURE__*/ _jsx(Portal, {
     ref: portalRef,
     container: container,
     disablePortal: disablePortal,
-    children: /*#__PURE__*/_jsxs(Root, _extends({}, rootProps, {
-      children: [!hideBackdrop && BackdropComponent ? /*#__PURE__*/_jsx(BackdropComponent, _extends({}, backdropProps)) : null, /*#__PURE__*/_jsx(FocusTrap, {
-        disableEnforceFocus: disableEnforceFocus,
-        disableAutoFocus: disableAutoFocus,
-        disableRestoreFocus: disableRestoreFocus,
-        isEnabled: isTopModal,
-        open: open,
-        children: /*#__PURE__*/React.cloneElement(children, childProps)
-      })]
-    }))
+    children: /*#__PURE__*/ _jsxs(
+      Root,
+      _extends({}, rootProps, {
+        children: [
+          !hideBackdrop && BackdropComponent
+            ? /*#__PURE__*/ _jsx(BackdropComponent, _extends({}, backdropProps))
+            : null,
+          /*#__PURE__*/ _jsx(FocusTrap, {
+            disableEnforceFocus: disableEnforceFocus,
+            disableAutoFocus: disableAutoFocus,
+            disableRestoreFocus: disableRestoreFocus,
+            isEnabled: isTopModal,
+            open: open,
+            children: /*#__PURE__*/ React.cloneElement(children, childProps),
+          }),
+        ],
+      })
+    ),
   });
 });
-process.env.NODE_ENV !== "production" ? Modal.propTypes /* remove-proptypes */ = {
-  // ┌────────────────────────────── Warning ──────────────────────────────┐
-  // │ These PropTypes are generated from the TypeScript type definitions. │
-  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
-  // └─────────────────────────────────────────────────────────────────────┘
-  /**
-   * A single child content element.
-   */
-  children: elementAcceptingRef.isRequired,
-  /**
-   * When set to true the Modal waits until a nested Transition is completed before closing.
-   * @default false
-   */
-  closeAfterTransition: PropTypes.bool,
-  /**
-   * An HTML element or function that returns one.
-   * The `container` will have the portal children appended to it.
-   *
-   * You can also provide a callback, which is called in a React layout effect.
-   * This lets you set the container from a ref, and also makes server-side rendering possible.
-   *
-   * By default, it uses the body of the top-level document object,
-   * so it's simply `document.body` most of the time.
-   */
-  container: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, PropTypes.func]),
-  /**
-   * If `true`, the modal will not automatically shift focus to itself when it opens, and
-   * replace it to the last focused element when it closes.
-   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
-   *
-   * Generally this should never be set to `true` as it makes the modal less
-   * accessible to assistive technologies, like screen readers.
-   * @default false
-   */
-  disableAutoFocus: PropTypes.bool,
-  /**
-   * If `true`, the modal will not prevent focus from leaving the modal while open.
-   *
-   * Generally this should never be set to `true` as it makes the modal less
-   * accessible to assistive technologies, like screen readers.
-   * @default false
-   */
-  disableEnforceFocus: PropTypes.bool,
-  /**
-   * If `true`, hitting escape will not fire the `onClose` callback.
-   * @default false
-   */
-  disableEscapeKeyDown: PropTypes.bool,
-  /**
-   * The `children` will be under the DOM hierarchy of the parent component.
-   * @default false
-   */
-  disablePortal: PropTypes.bool,
-  /**
-   * If `true`, the modal will not restore focus to previously focused element once
-   * modal is hidden or unmounted.
-   * @default false
-   */
-  disableRestoreFocus: PropTypes.bool,
-  /**
-   * Disable the scroll lock behavior.
-   * @default false
-   */
-  disableScrollLock: PropTypes.bool,
-  /**
-   * If `true`, the backdrop is not rendered.
-   * @default false
-   */
-  hideBackdrop: PropTypes.bool,
-  /**
-   * Always keep the children in the DOM.
-   * This prop can be useful in SEO situation or
-   * when you want to maximize the responsiveness of the Modal.
-   * @default false
-   */
-  keepMounted: PropTypes.bool,
-  /**
-   * Callback fired when the backdrop is clicked.
-   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
-   */
-  onBackdropClick: PropTypes.func,
-  /**
-   * Callback fired when the component requests to be closed.
-   * The `reason` parameter can optionally be used to control the response to `onClose`.
-   *
-   * @param {object} event The event source of the callback.
-   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
-   */
-  onClose: PropTypes.func,
-  /**
-   * A function called when a transition enters.
-   */
-  onTransitionEnter: PropTypes.func,
-  /**
-   * A function called when a transition has exited.
-   */
-  onTransitionExited: PropTypes.func,
-  /**
-   * If `true`, the component is shown.
-   */
-  open: PropTypes.bool.isRequired,
-  /**
-   * The props used for each slot inside the Modal.
-   * @default {}
-   */
-  slotProps: PropTypes.shape({
-    backdrop: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
-    root: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
-  }),
-  /**
-   * The components used for each slot inside the Modal.
-   * Either a string to use a HTML element or a component.
-   * @default {}
-   */
-  slots: PropTypes.shape({
-    backdrop: PropTypes.elementType,
-    root: PropTypes.elementType
-  })
-} : void 0;
+process.env.NODE_ENV !== "production"
+  ? (Modal.propTypes /* remove-proptypes */ = {
+      // ┌────────────────────────────── Warning ──────────────────────────────┐
+      // │ These PropTypes are generated from the TypeScript type definitions. │
+      // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
+      // └─────────────────────────────────────────────────────────────────────┘
+      /**
+       * A single child content element.
+       */
+      children: elementAcceptingRef.isRequired,
+      /**
+       * When set to true the Modal waits until a nested Transition is completed before closing.
+       * @default false
+       */
+      closeAfterTransition: PropTypes.bool,
+      /**
+       * An HTML element or function that returns one.
+       * The `container` will have the portal children appended to it.
+       *
+       * You can also provide a callback, which is called in a React layout effect.
+       * This lets you set the container from a ref, and also makes server-side rendering possible.
+       *
+       * By default, it uses the body of the top-level document object,
+       * so it's simply `document.body` most of the time.
+       */
+      container: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([
+        HTMLElementType,
+        PropTypes.func,
+      ]),
+
+      /**
+       * If `true`, the modal will not automatically shift focus to itself when it opens, and
+       * replace it to the last focused element when it closes.
+       * This also works correctly with any modal children that have the `disableAutoFocus` prop.
+       *
+       * Generally this should never be set to `true` as it makes the modal less
+       * accessible to assistive technologies, like screen readers.
+       * @default false
+       */
+      disableAutoFocus: PropTypes.bool,
+      /**
+       * If `true`, the modal will not prevent focus from leaving the modal while open.
+       *
+       * Generally this should never be set to `true` as it makes the modal less
+       * accessible to assistive technologies, like screen readers.
+       * @default false
+       */
+      disableEnforceFocus: PropTypes.bool,
+      /**
+       * If `true`, hitting escape will not fire the `onClose` callback.
+       * @default false
+       */
+      disableEscapeKeyDown: PropTypes.bool,
+      /**
+       * The `children` will be under the DOM hierarchy of the parent component.
+       * @default false
+       */
+      disablePortal: PropTypes.bool,
+      /**
+       * If `true`, the modal will not restore focus to previously focused element once
+       * modal is hidden or unmounted.
+       * @default false
+       */
+      disableRestoreFocus: PropTypes.bool,
+      /**
+       * Disable the scroll lock behavior.
+       * @default false
+       */
+      disableScrollLock: PropTypes.bool,
+      /**
+       * If `true`, the backdrop is not rendered.
+       * @default false
+       */
+      hideBackdrop: PropTypes.bool,
+      /**
+       * Always keep the children in the DOM.
+       * This prop can be useful in SEO situation or
+       * when you want to maximize the responsiveness of the Modal.
+       * @default false
+       */
+      keepMounted: PropTypes.bool,
+      /**
+       * Callback fired when the backdrop is clicked.
+       * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
+       */
+      onBackdropClick: PropTypes.func,
+      /**
+       * Callback fired when the component requests to be closed.
+       * The `reason` parameter can optionally be used to control the response to `onClose`.
+       *
+       * @param {object} event The event source of the callback.
+       * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
+       */
+      onClose: PropTypes.func,
+      /**
+       * A function called when a transition enters.
+       */
+      onTransitionEnter: PropTypes.func,
+      /**
+       * A function called when a transition has exited.
+       */
+      onTransitionExited: PropTypes.func,
+      /**
+       * If `true`, the component is shown.
+       */
+      open: PropTypes.bool.isRequired,
+      /**
+       * The props used for each slot inside the Modal.
+       * @default {}
+       */
+      slotProps: PropTypes.shape({
+        backdrop: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
+        root: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
+      }),
+      /**
+       * The components used for each slot inside the Modal.
+       * Either a string to use a HTML element or a component.
+       * @default {}
+       */
+      slots: PropTypes.shape({
+        backdrop: PropTypes.elementType,
+        root: PropTypes.elementType,
+      }),
+    })
+  : void 0;
 export { Modal };
\ No newline at end of file
diff --git a/Modal/Modal.types.d.ts b/Modal/Modal.types.d.ts
index 02b3627201170f1c32ebb644504e7a18008a4269..876cfec5412eac2d3ea923012faaa08a5532f4e4 100644
--- a/Modal/Modal.types.d.ts
+++ b/Modal/Modal.types.d.ts
@@ -1,142 +1,155 @@
-import * as React from 'react';
-import { Simplify } from '@mui/types';
-import { PortalProps } from '../Portal';
-import { PolymorphicProps, SlotComponentProps } from '../utils';
-export interface ModalRootSlotPropsOverrides {
-}
-export interface ModalBackdropSlotPropsOverrides {
-}
+import * as React from "react";
+import { Simplify } from "@mui/types";
+import { PortalProps } from "../Portal";
+import { PolymorphicProps, SlotComponentProps } from "../utils";
+export interface ModalRootSlotPropsOverrides {}
+export interface ModalBackdropSlotPropsOverrides {}
 export interface ModalOwnProps {
-    /**
-     * A single child content element.
-     */
-    children: React.ReactElement;
-    /**
-     * When set to true the Modal waits until a nested Transition is completed before closing.
-     * @default false
-     */
-    closeAfterTransition?: boolean;
-    /**
-     * An HTML element or function that returns one.
-     * The `container` will have the portal children appended to it.
-     *
-     * You can also provide a callback, which is called in a React layout effect.
-     * This lets you set the container from a ref, and also makes server-side rendering possible.
-     *
-     * By default, it uses the body of the top-level document object,
-     * so it's simply `document.body` most of the time.
-     */
-    container?: PortalProps['container'];
-    /**
-     * If `true`, the modal will not automatically shift focus to itself when it opens, and
-     * replace it to the last focused element when it closes.
-     * This also works correctly with any modal children that have the `disableAutoFocus` prop.
-     *
-     * Generally this should never be set to `true` as it makes the modal less
-     * accessible to assistive technologies, like screen readers.
-     * @default false
-     */
-    disableAutoFocus?: boolean;
-    /**
-     * If `true`, the modal will not prevent focus from leaving the modal while open.
-     *
-     * Generally this should never be set to `true` as it makes the modal less
-     * accessible to assistive technologies, like screen readers.
-     * @default false
-     */
-    disableEnforceFocus?: boolean;
-    /**
-     * If `true`, hitting escape will not fire the `onClose` callback.
-     * @default false
-     */
-    disableEscapeKeyDown?: boolean;
-    /**
-     * The `children` will be under the DOM hierarchy of the parent component.
-     * @default false
-     */
-    disablePortal?: PortalProps['disablePortal'];
-    /**
-     * If `true`, the modal will not restore focus to previously focused element once
-     * modal is hidden or unmounted.
-     * @default false
-     */
-    disableRestoreFocus?: boolean;
-    /**
-     * Disable the scroll lock behavior.
-     * @default false
-     */
-    disableScrollLock?: boolean;
-    /**
-     * If `true`, the backdrop is not rendered.
-     * @default false
-     */
-    hideBackdrop?: boolean;
-    /**
-     * Always keep the children in the DOM.
-     * This prop can be useful in SEO situation or
-     * when you want to maximize the responsiveness of the Modal.
-     * @default false
-     */
-    keepMounted?: boolean;
-    /**
-     * Callback fired when the backdrop is clicked.
-     * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
-     */
-    onBackdropClick?: React.ReactEventHandler<{}>;
-    /**
-     * Callback fired when the component requests to be closed.
-     * The `reason` parameter can optionally be used to control the response to `onClose`.
-     *
-     * @param {object} event The event source of the callback.
-     * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
-     */
-    onClose?: {
-        bivarianceHack(event: {}, reason: 'backdropClick' | 'escapeKeyDown'): void;
-    }['bivarianceHack'];
-    /**
-     * A function called when a transition enters.
-     */
-    onTransitionEnter?: () => void;
-    /**
-     * A function called when a transition has exited.
-     */
-    onTransitionExited?: () => void;
-    /**
-     * If `true`, the component is shown.
-     */
-    open: boolean;
-    /**
-     * The props used for each slot inside the Modal.
-     * @default {}
-     */
-    slotProps?: {
-        root?: SlotComponentProps<'div', ModalRootSlotPropsOverrides, ModalOwnerState>;
-        backdrop?: SlotComponentProps<'div', ModalBackdropSlotPropsOverrides, ModalOwnerState>;
-    };
-    /**
-     * The components used for each slot inside the Modal.
-     * Either a string to use a HTML element or a component.
-     * @default {}
-     */
-    slots?: ModalSlots;
+  /**
+   * A single child content element.
+   */
+  children: React.ReactElement;
+  /**
+   * When set to true the Modal waits until a nested Transition is completed before closing.
+   * @default false
+   */
+  closeAfterTransition?: boolean;
+  /**
+   * An HTML element or function that returns one.
+   * The `container` will have the portal children appended to it.
+   *
+   * You can also provide a callback, which is called in a React layout effect.
+   * This lets you set the container from a ref, and also makes server-side rendering possible.
+   *
+   * By default, it uses the body of the top-level document object,
+   * so it's simply `document.body` most of the time.
+   */
+  container?: PortalProps["container"];
+  scrollContainer?: Element;
+  /**
+   * If `true`, the modal will not automatically shift focus to itself when it opens, and
+   * replace it to the last focused element when it closes.
+   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
+   *
+   * Generally this should never be set to `true` as it makes the modal less
+   * accessible to assistive technologies, like screen readers.
+   * @default false
+   */
+  disableAutoFocus?: boolean;
+  /**
+   * If `true`, the modal will not prevent focus from leaving the modal while open.
+   *
+   * Generally this should never be set to `true` as it makes the modal less
+   * accessible to assistive technologies, like screen readers.
+   * @default false
+   */
+  disableEnforceFocus?: boolean;
+  /**
+   * If `true`, hitting escape will not fire the `onClose` callback.
+   * @default false
+   */
+  disableEscapeKeyDown?: boolean;
+  /**
+   * The `children` will be under the DOM hierarchy of the parent component.
+   * @default false
+   */
+  disablePortal?: PortalProps["disablePortal"];
+  /**
+   * If `true`, the modal will not restore focus to previously focused element once
+   * modal is hidden or unmounted.
+   * @default false
+   */
+  disableRestoreFocus?: boolean;
+  /**
+   * Disable the scroll lock behavior.
+   * @default false
+   */
+  disableScrollLock?: boolean;
+  /**
+   * If `true`, the backdrop is not rendered.
+   * @default false
+   */
+  hideBackdrop?: boolean;
+  /**
+   * Always keep the children in the DOM.
+   * This prop can be useful in SEO situation or
+   * when you want to maximize the responsiveness of the Modal.
+   * @default false
+   */
+  keepMounted?: boolean;
+  /**
+   * Callback fired when the backdrop is clicked.
+   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
+   */
+  onBackdropClick?: React.ReactEventHandler<{}>;
+  /**
+   * Callback fired when the component requests to be closed.
+   * The `reason` parameter can optionally be used to control the response to `onClose`.
+   *
+   * @param {object} event The event source of the callback.
+   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
+   */
+  onClose?: {
+    bivarianceHack(event: {}, reason: "backdropClick" | "escapeKeyDown"): void;
+  }["bivarianceHack"];
+  /**
+   * A function called when a transition enters.
+   */
+  onTransitionEnter?: () => void;
+  /**
+   * A function called when a transition has exited.
+   */
+  onTransitionExited?: () => void;
+  /**
+   * If `true`, the component is shown.
+   */
+  open: boolean;
+  /**
+   * The props used for each slot inside the Modal.
+   * @default {}
+   */
+  slotProps?: {
+    root?: SlotComponentProps<
+      "div",
+      ModalRootSlotPropsOverrides,
+      ModalOwnerState
+    >;
+    backdrop?: SlotComponentProps<
+      "div",
+      ModalBackdropSlotPropsOverrides,
+      ModalOwnerState
+    >;
+  };
+  /**
+   * The components used for each slot inside the Modal.
+   * Either a string to use a HTML element or a component.
+   * @default {}
+   */
+  slots?: ModalSlots;
 }
 export interface ModalSlots {
-    /**
-     * The component that renders the root.
-     * @default 'div'
-     */
-    root?: React.ElementType;
-    /**
-     * The component that renders the backdrop.
-     */
-    backdrop?: React.ElementType;
+  /**
+   * The component that renders the root.
+   * @default 'div'
+   */
+  root?: React.ElementType;
+  /**
+   * The component that renders the backdrop.
+   */
+  backdrop?: React.ElementType;
 }
-export interface ModalTypeMap<AdditionalProps = {}, RootComponentType extends React.ElementType = 'div'> {
-    props: ModalOwnProps & AdditionalProps;
-    defaultComponent: RootComponentType;
+export interface ModalTypeMap<
+  AdditionalProps = {},
+  RootComponentType extends React.ElementType = "div"
+> {
+  props: ModalOwnProps & AdditionalProps;
+  defaultComponent: RootComponentType;
 }
-export type ModalProps<RootComponentType extends React.ElementType = ModalTypeMap['defaultComponent']> = PolymorphicProps<ModalTypeMap<{}, RootComponentType>, RootComponentType>;
-export type ModalOwnerState = Simplify<ModalOwnProps & {
+export type ModalProps<
+  RootComponentType extends React.ElementType = ModalTypeMap["defaultComponent"]
+> = PolymorphicProps<ModalTypeMap<{}, RootComponentType>, RootComponentType>;
+export type ModalOwnerState = Simplify<
+  ModalOwnProps & {
     closeAfterTransition: boolean;
     disableAutoFocus: boolean;
     disableEnforceFocus: boolean;
@@ -147,18 +160,19 @@ export type ModalOwnerState = Simplify<ModalOwnProps & {
     exited: boolean;
     hideBackdrop: boolean;
     keepMounted: boolean;
-}>;
+  }
+>;
 export interface ModalRootSlotProps {
-    children: React.ReactNode;
-    className?: string;
-    onKeyDown: React.KeyboardEventHandler;
-    ownerState: ModalOwnerState;
-    role: React.AriaRole;
+  children: React.ReactNode;
+  className?: string;
+  onKeyDown: React.KeyboardEventHandler;
+  ownerState: ModalOwnerState;
+  role: React.AriaRole;
 }
 export interface ModalBackdropSlotProps {
-    'aria-hidden': React.AriaAttributes['aria-hidden'];
-    children?: React.ReactNode;
-    onClick: React.MouseEventHandler;
-    open: boolean;
-    ownerState: ModalOwnerState;
+  "aria-hidden": React.AriaAttributes["aria-hidden"];
+  children?: React.ReactNode;
+  onClick: React.MouseEventHandler;
+  open: boolean;
+  ownerState: ModalOwnerState;
 }
diff --git a/legacy/Modal/Modal.js b/legacy/Modal/Modal.js
index de54a4d61385d0f31b16a150e5993cf1fc9b8475..971293a466eace56c91387c2d474dbf4dfefebdd 100644
--- a/legacy/Modal/Modal.js
+++ b/legacy/Modal/Modal.js
@@ -1,25 +1,25 @@
-'use client';
+"use client";
 
 import _extends from "@babel/runtime/helpers/esm/extends";
 import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
-import * as React from 'react';
-import PropTypes from 'prop-types';
-import { elementAcceptingRef, HTMLElementType } from '@mui/utils';
-import { useSlotProps } from '../utils';
-import { useClassNamesOverride } from '../utils/ClassNameConfigurator';
-import { unstable_composeClasses as composeClasses } from '../composeClasses';
-import { Portal } from '../Portal';
-import { unstable_useModal as useModal } from '../unstable_useModal';
-import { FocusTrap } from '../FocusTrap';
-import { getModalUtilityClass } from './modalClasses';
+import * as React from "react";
+import PropTypes from "prop-types";
+import { elementAcceptingRef, HTMLElementType } from "@mui/utils";
+import { useSlotProps } from "../utils";
+import { useClassNamesOverride } from "../utils/ClassNameConfigurator";
+import { unstable_composeClasses as composeClasses } from "../composeClasses";
+import { Portal } from "../Portal";
+import { unstable_useModal as useModal } from "../unstable_useModal";
+import { FocusTrap } from "../FocusTrap";
+import { getModalUtilityClass } from "./modalClasses";
 import { jsx as _jsx } from "react/jsx-runtime";
 import { jsxs as _jsxs } from "react/jsx-runtime";
 var useUtilityClasses = function useUtilityClasses(ownerState) {
   var open = ownerState.open,
     exited = ownerState.exited;
   var slots = {
-    root: ['root', !open && exited && 'hidden'],
-    backdrop: ['backdrop']
+    root: ["root", !open && exited && "hidden"],
+    backdrop: ["backdrop"],
   };
   return composeClasses(slots, useClassNamesOverride(getModalUtilityClass));
 };
@@ -45,24 +45,31 @@ var useUtilityClasses = function useUtilityClasses(ownerState) {
  *
  * - [Modal API](https://mui.com/base-ui/react-modal/components-api/#modal)
  */
-var Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef) {
+var Modal = /*#__PURE__*/ React.forwardRef(function Modal(props, forwardedRef) {
   var _slots$root;
   var children = props.children,
     _props$closeAfterTran = props.closeAfterTransition,
-    closeAfterTransition = _props$closeAfterTran === void 0 ? false : _props$closeAfterTran,
+    closeAfterTransition =
+      _props$closeAfterTran === void 0 ? false : _props$closeAfterTran,
     container = props.container,
     _props$disableAutoFoc = props.disableAutoFocus,
-    disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,
+    disableAutoFocus =
+      _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,
     _props$disableEnforce = props.disableEnforceFocus,
-    disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce,
+    disableEnforceFocus =
+      _props$disableEnforce === void 0 ? false : _props$disableEnforce,
     _props$disableEscapeK = props.disableEscapeKeyDown,
-    disableEscapeKeyDown = _props$disableEscapeK === void 0 ? false : _props$disableEscapeK,
+    disableEscapeKeyDown =
+      _props$disableEscapeK === void 0 ? false : _props$disableEscapeK,
     _props$disablePortal = props.disablePortal,
-    disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,
+    disablePortal =
+      _props$disablePortal === void 0 ? false : _props$disablePortal,
     _props$disableRestore = props.disableRestoreFocus,
-    disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore,
+    disableRestoreFocus =
+      _props$disableRestore === void 0 ? false : _props$disableRestore,
     _props$disableScrollL = props.disableScrollLock,
-    disableScrollLock = _props$disableScrollL === void 0 ? false : _props$disableScrollL,
+    disableScrollLock =
+      _props$disableScrollL === void 0 ? false : _props$disableScrollL,
     _props$hideBackdrop = props.hideBackdrop,
     hideBackdrop = _props$hideBackdrop === void 0 ? false : _props$hideBackdrop,
     _props$keepMounted = props.keepMounted,
@@ -77,7 +84,28 @@ var Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef) {
     slotProps = _props$slotProps === void 0 ? {} : _props$slotProps,
     _props$slots = props.slots,
     slots = _props$slots === void 0 ? {} : _props$slots,
-    other = _objectWithoutProperties(props, ["children", "closeAfterTransition", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited", "slotProps", "slots"]);
+    other = _objectWithoutProperties(props, [
+      "children",
+      "closeAfterTransition",
+      "container",
+      "disableAutoFocus",
+      "disableEnforceFocus",
+      "disableEscapeKeyDown",
+      "disablePortal",
+      "disableRestoreFocus",
+      "disableScrollLock",
+      "hideBackdrop",
+      "keepMounted",
+      "onBackdropClick",
+      "onClose",
+      "onKeyDown",
+      "open",
+      "onTransitionEnter",
+      "onTransitionExited",
+      "slotProps",
+      "slots",
+      "scrollContainer",
+    ]);
   var propsWithDefaults = _extends({}, props, {
     closeAfterTransition: closeAfterTransition,
     disableAutoFocus: disableAutoFocus,
@@ -87,11 +115,13 @@ var Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef) {
     disableRestoreFocus: disableRestoreFocus,
     disableScrollLock: disableScrollLock,
     hideBackdrop: hideBackdrop,
-    keepMounted: keepMounted
+    keepMounted: keepMounted,
   });
-  var _useModal = useModal(_extends({}, propsWithDefaults, {
-      rootRef: forwardedRef
-    })),
+  var _useModal = useModal(
+      _extends({}, propsWithDefaults, {
+        rootRef: forwardedRef,
+      })
+    ),
     getRootProps = _useModal.getRootProps,
     getBackdropProps = _useModal.getBackdropProps,
     getTransitionProps = _useModal.getTransitionProps,
@@ -101,12 +131,12 @@ var Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef) {
     hasTransition = _useModal.hasTransition;
   var ownerState = _extends({}, propsWithDefaults, {
     exited: exited,
-    hasTransition: hasTransition
+    hasTransition: hasTransition,
   });
   var classes = useUtilityClasses(ownerState);
   var childProps = {};
   if (children.props.tabIndex === undefined) {
-    childProps.tabIndex = '-1';
+    childProps.tabIndex = "-1";
   }
 
   // It's a Transition like component
@@ -117,170 +147,185 @@ var Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef) {
     childProps.onEnter = onEnter;
     childProps.onExited = onExited;
   }
-  var Root = (_slots$root = slots.root) != null ? _slots$root : 'div';
+  var Root = (_slots$root = slots.root) != null ? _slots$root : "div";
   var rootProps = useSlotProps({
     elementType: Root,
     externalSlotProps: slotProps.root,
     externalForwardedProps: other,
     getSlotProps: getRootProps,
     className: classes.root,
-    ownerState: ownerState
+    ownerState: ownerState,
   });
   var BackdropComponent = slots.backdrop;
   var backdropProps = useSlotProps({
     elementType: BackdropComponent,
     externalSlotProps: slotProps.backdrop,
     getSlotProps: function getSlotProps(otherHandlers) {
-      return getBackdropProps(_extends({}, otherHandlers, {
-        onClick: function onClick(e) {
-          if (onBackdropClick) {
-            onBackdropClick(e);
-          }
-          if (otherHandlers != null && otherHandlers.onClick) {
-            otherHandlers.onClick(e);
-          }
-        }
-      }));
+      return getBackdropProps(
+        _extends({}, otherHandlers, {
+          onClick: function onClick(e) {
+            if (onBackdropClick) {
+              onBackdropClick(e);
+            }
+            if (otherHandlers != null && otherHandlers.onClick) {
+              otherHandlers.onClick(e);
+            }
+          },
+        })
+      );
     },
     className: classes.backdrop,
-    ownerState: ownerState
+    ownerState: ownerState,
   });
   if (!keepMounted && !open && (!hasTransition || exited)) {
     return null;
   }
-  return /*#__PURE__*/_jsx(Portal, {
+  return /*#__PURE__*/ _jsx(Portal, {
     ref: portalRef,
     container: container,
     disablePortal: disablePortal,
-    children: /*#__PURE__*/_jsxs(Root, _extends({}, rootProps, {
-      children: [!hideBackdrop && BackdropComponent ? /*#__PURE__*/_jsx(BackdropComponent, _extends({}, backdropProps)) : null, /*#__PURE__*/_jsx(FocusTrap, {
-        disableEnforceFocus: disableEnforceFocus,
-        disableAutoFocus: disableAutoFocus,
-        disableRestoreFocus: disableRestoreFocus,
-        isEnabled: isTopModal,
-        open: open,
-        children: /*#__PURE__*/React.cloneElement(children, childProps)
-      })]
-    }))
+    children: /*#__PURE__*/ _jsxs(
+      Root,
+      _extends({}, rootProps, {
+        children: [
+          !hideBackdrop && BackdropComponent
+            ? /*#__PURE__*/ _jsx(BackdropComponent, _extends({}, backdropProps))
+            : null,
+          /*#__PURE__*/ _jsx(FocusTrap, {
+            disableEnforceFocus: disableEnforceFocus,
+            disableAutoFocus: disableAutoFocus,
+            disableRestoreFocus: disableRestoreFocus,
+            isEnabled: isTopModal,
+            open: open,
+            children: /*#__PURE__*/ React.cloneElement(children, childProps),
+          }),
+        ],
+      })
+    ),
   });
 });
-process.env.NODE_ENV !== "production" ? Modal.propTypes /* remove-proptypes */ = {
-  // ┌────────────────────────────── Warning ──────────────────────────────┐
-  // │ These PropTypes are generated from the TypeScript type definitions. │
-  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
-  // └─────────────────────────────────────────────────────────────────────┘
-  /**
-   * A single child content element.
-   */
-  children: elementAcceptingRef.isRequired,
-  /**
-   * When set to true the Modal waits until a nested Transition is completed before closing.
-   * @default false
-   */
-  closeAfterTransition: PropTypes.bool,
-  /**
-   * An HTML element or function that returns one.
-   * The `container` will have the portal children appended to it.
-   *
-   * You can also provide a callback, which is called in a React layout effect.
-   * This lets you set the container from a ref, and also makes server-side rendering possible.
-   *
-   * By default, it uses the body of the top-level document object,
-   * so it's simply `document.body` most of the time.
-   */
-  container: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, PropTypes.func]),
-  /**
-   * If `true`, the modal will not automatically shift focus to itself when it opens, and
-   * replace it to the last focused element when it closes.
-   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
-   *
-   * Generally this should never be set to `true` as it makes the modal less
-   * accessible to assistive technologies, like screen readers.
-   * @default false
-   */
-  disableAutoFocus: PropTypes.bool,
-  /**
-   * If `true`, the modal will not prevent focus from leaving the modal while open.
-   *
-   * Generally this should never be set to `true` as it makes the modal less
-   * accessible to assistive technologies, like screen readers.
-   * @default false
-   */
-  disableEnforceFocus: PropTypes.bool,
-  /**
-   * If `true`, hitting escape will not fire the `onClose` callback.
-   * @default false
-   */
-  disableEscapeKeyDown: PropTypes.bool,
-  /**
-   * The `children` will be under the DOM hierarchy of the parent component.
-   * @default false
-   */
-  disablePortal: PropTypes.bool,
-  /**
-   * If `true`, the modal will not restore focus to previously focused element once
-   * modal is hidden or unmounted.
-   * @default false
-   */
-  disableRestoreFocus: PropTypes.bool,
-  /**
-   * Disable the scroll lock behavior.
-   * @default false
-   */
-  disableScrollLock: PropTypes.bool,
-  /**
-   * If `true`, the backdrop is not rendered.
-   * @default false
-   */
-  hideBackdrop: PropTypes.bool,
-  /**
-   * Always keep the children in the DOM.
-   * This prop can be useful in SEO situation or
-   * when you want to maximize the responsiveness of the Modal.
-   * @default false
-   */
-  keepMounted: PropTypes.bool,
-  /**
-   * Callback fired when the backdrop is clicked.
-   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
-   */
-  onBackdropClick: PropTypes.func,
-  /**
-   * Callback fired when the component requests to be closed.
-   * The `reason` parameter can optionally be used to control the response to `onClose`.
-   *
-   * @param {object} event The event source of the callback.
-   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
-   */
-  onClose: PropTypes.func,
-  /**
-   * A function called when a transition enters.
-   */
-  onTransitionEnter: PropTypes.func,
-  /**
-   * A function called when a transition has exited.
-   */
-  onTransitionExited: PropTypes.func,
-  /**
-   * If `true`, the component is shown.
-   */
-  open: PropTypes.bool.isRequired,
-  /**
-   * The props used for each slot inside the Modal.
-   * @default {}
-   */
-  slotProps: PropTypes.shape({
-    backdrop: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
-    root: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
-  }),
-  /**
-   * The components used for each slot inside the Modal.
-   * Either a string to use a HTML element or a component.
-   * @default {}
-   */
-  slots: PropTypes.shape({
-    backdrop: PropTypes.elementType,
-    root: PropTypes.elementType
-  })
-} : void 0;
+process.env.NODE_ENV !== "production"
+  ? (Modal.propTypes /* remove-proptypes */ = {
+      // ┌────────────────────────────── Warning ──────────────────────────────┐
+      // │ These PropTypes are generated from the TypeScript type definitions. │
+      // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
+      // └─────────────────────────────────────────────────────────────────────┘
+      /**
+       * A single child content element.
+       */
+      children: elementAcceptingRef.isRequired,
+      /**
+       * When set to true the Modal waits until a nested Transition is completed before closing.
+       * @default false
+       */
+      closeAfterTransition: PropTypes.bool,
+      /**
+       * An HTML element or function that returns one.
+       * The `container` will have the portal children appended to it.
+       *
+       * You can also provide a callback, which is called in a React layout effect.
+       * This lets you set the container from a ref, and also makes server-side rendering possible.
+       *
+       * By default, it uses the body of the top-level document object,
+       * so it's simply `document.body` most of the time.
+       */
+      container: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([
+        HTMLElementType,
+        PropTypes.func,
+      ]),
+      /**
+       * If `true`, the modal will not automatically shift focus to itself when it opens, and
+       * replace it to the last focused element when it closes.
+       * This also works correctly with any modal children that have the `disableAutoFocus` prop.
+       *
+       * Generally this should never be set to `true` as it makes the modal less
+       * accessible to assistive technologies, like screen readers.
+       * @default false
+       */
+      disableAutoFocus: PropTypes.bool,
+      /**
+       * If `true`, the modal will not prevent focus from leaving the modal while open.
+       *
+       * Generally this should never be set to `true` as it makes the modal less
+       * accessible to assistive technologies, like screen readers.
+       * @default false
+       */
+      disableEnforceFocus: PropTypes.bool,
+      /**
+       * If `true`, hitting escape will not fire the `onClose` callback.
+       * @default false
+       */
+      disableEscapeKeyDown: PropTypes.bool,
+      /**
+       * The `children` will be under the DOM hierarchy of the parent component.
+       * @default false
+       */
+      disablePortal: PropTypes.bool,
+      /**
+       * If `true`, the modal will not restore focus to previously focused element once
+       * modal is hidden or unmounted.
+       * @default false
+       */
+      disableRestoreFocus: PropTypes.bool,
+      /**
+       * Disable the scroll lock behavior.
+       * @default false
+       */
+      disableScrollLock: PropTypes.bool,
+      /**
+       * If `true`, the backdrop is not rendered.
+       * @default false
+       */
+      hideBackdrop: PropTypes.bool,
+      /**
+       * Always keep the children in the DOM.
+       * This prop can be useful in SEO situation or
+       * when you want to maximize the responsiveness of the Modal.
+       * @default false
+       */
+      keepMounted: PropTypes.bool,
+      /**
+       * Callback fired when the backdrop is clicked.
+       * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
+       */
+      onBackdropClick: PropTypes.func,
+      /**
+       * Callback fired when the component requests to be closed.
+       * The `reason` parameter can optionally be used to control the response to `onClose`.
+       *
+       * @param {object} event The event source of the callback.
+       * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
+       */
+      onClose: PropTypes.func,
+      /**
+       * A function called when a transition enters.
+       */
+      onTransitionEnter: PropTypes.func,
+      /**
+       * A function called when a transition has exited.
+       */
+      onTransitionExited: PropTypes.func,
+      /**
+       * If `true`, the component is shown.
+       */
+      open: PropTypes.bool.isRequired,
+      /**
+       * The props used for each slot inside the Modal.
+       * @default {}
+       */
+      slotProps: PropTypes.shape({
+        backdrop: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
+        root: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
+      }),
+      /**
+       * The components used for each slot inside the Modal.
+       * Either a string to use a HTML element or a component.
+       * @default {}
+       */
+      slots: PropTypes.shape({
+        backdrop: PropTypes.elementType,
+        root: PropTypes.elementType,
+      }),
+    })
+  : void 0;
 export { Modal };
\ No newline at end of file
diff --git a/legacy/unstable_useModal/ModalManager.js b/legacy/unstable_useModal/ModalManager.js
index 208c4ab08d4f6fc6da451ae712e9cacb0c6787b7..bd2f994760e070830d447aa148a05b3942b7ed4e 100644
--- a/legacy/unstable_useModal/ModalManager.js
+++ b/legacy/unstable_useModal/ModalManager.js
@@ -1,7 +1,11 @@
 import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
 import _createClass from "@babel/runtime/helpers/esm/createClass";
 import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
-import { unstable_ownerWindow as ownerWindow, unstable_ownerDocument as ownerDocument, unstable_getScrollbarSize as getScrollbarSize } from '@mui/utils';
+import {
+  unstable_ownerWindow as ownerWindow,
+  unstable_ownerDocument as ownerDocument,
+  unstable_getScrollbarSize as getScrollbarSize,
+} from "@mui/utils";
 // Is a vertical scrollbar displayed?
 function isOverflowing(container) {
   var doc = ownerDocument(container);
@@ -12,25 +16,52 @@ function isOverflowing(container) {
 }
 export function ariaHidden(element, show) {
   if (show) {
-    element.setAttribute('aria-hidden', 'true');
+    element.setAttribute("aria-hidden", "true");
   } else {
-    element.removeAttribute('aria-hidden');
+    element.removeAttribute("aria-hidden");
   }
 }
 function getPaddingRight(element) {
-  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
+  return (
+    parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) ||
+    0
+  );
 }
 function isAriaHiddenForbiddenOnElement(element) {
   // The forbidden HTML tags are the ones from ARIA specification that
   // can be children of body and can't have aria-hidden attribute.
   // cf. https://www.w3.org/TR/html-aria/#docconformance
-  var forbiddenTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'];
+  var forbiddenTagNames = [
+    "TEMPLATE",
+    "SCRIPT",
+    "STYLE",
+    "LINK",
+    "MAP",
+    "META",
+    "NOSCRIPT",
+    "PICTURE",
+    "COL",
+    "COLGROUP",
+    "PARAM",
+    "SLOT",
+    "SOURCE",
+    "TRACK",
+  ];
   var isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
-  var isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';
+  var isInputHidden =
+    element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
   return isForbiddenTagName || isInputHidden;
 }
-function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
-  var blacklist = [mountElement, currentElement].concat(_toConsumableArray(elementsToExclude));
+function ariaHiddenSiblings(
+  container,
+  mountElement,
+  currentElement,
+  elementsToExclude,
+  show
+) {
+  var blacklist = [mountElement, currentElement].concat(
+    _toConsumableArray(elementsToExclude)
+  );
   [].forEach.call(container.children, function (element) {
     var isNotExcludedElement = blacklist.indexOf(element) === -1;
     var isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
@@ -52,57 +83,74 @@ function findIndexOf(items, callback) {
 }
 function handleContainer(containerInfo, props) {
   var restoreStyle = [];
-  var container = containerInfo.container;
+  var container = props.scrollContainer || containerInfo.container;
   if (!props.disableScrollLock) {
     if (isOverflowing(container)) {
       // Compute the size before applying overflow hidden to avoid any scroll jumps.
       var scrollbarSize = getScrollbarSize(ownerDocument(container));
       restoreStyle.push({
         value: container.style.paddingRight,
-        property: 'padding-right',
-        el: container
+        property: "padding-right",
+        el: container,
       });
       // Use computed style, here to get the real padding to add our scrollbar width.
-      container.style.paddingRight = "".concat(getPaddingRight(container) + scrollbarSize, "px");
+      container.style.paddingRight = "".concat(
+        getPaddingRight(container) + scrollbarSize,
+        "px"
+      );
 
       // .mui-fixed is a global helper.
-      var fixedElements = ownerDocument(container).querySelectorAll('.mui-fixed');
+      var fixedElements =
+        ownerDocument(container).querySelectorAll(".mui-fixed");
       [].forEach.call(fixedElements, function (element) {
         restoreStyle.push({
           value: element.style.paddingRight,
-          property: 'padding-right',
-          el: element
+          property: "padding-right",
+          el: element,
         });
-        element.style.paddingRight = "".concat(getPaddingRight(element) + scrollbarSize, "px");
+        element.style.paddingRight = "".concat(
+          getPaddingRight(element) + scrollbarSize,
+          "px"
+        );
       });
     }
     var scrollContainer;
-    if (container.parentNode instanceof DocumentFragment) {
+    if (props.scrollContainer) {
+      scrollContainer = props.scrollContainer;
+    } else if (container.parentNode instanceof DocumentFragment) {
       scrollContainer = ownerDocument(container).body;
     } else {
       // Support html overflow-y: auto for scroll stability between pages
       // https://css-tricks.com/snippets/css/force-vertical-scrollbar/
       var parent = container.parentElement;
       var containerWindow = ownerWindow(container);
-      scrollContainer = (parent == null ? void 0 : parent.nodeName) === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;
+      scrollContainer =
+        (parent == null ? void 0 : parent.nodeName) === "HTML" &&
+        containerWindow.getComputedStyle(parent).overflowY === "scroll"
+          ? parent
+          : container;
     }
 
     // Block the scroll even if no scrollbar is visible to account for mobile keyboard
     // screensize shrink.
-    restoreStyle.push({
-      value: scrollContainer.style.overflow,
-      property: 'overflow',
-      el: scrollContainer
-    }, {
-      value: scrollContainer.style.overflowX,
-      property: 'overflow-x',
-      el: scrollContainer
-    }, {
-      value: scrollContainer.style.overflowY,
-      property: 'overflow-y',
-      el: scrollContainer
-    });
-    scrollContainer.style.overflow = 'hidden';
+    restoreStyle.push(
+      {
+        value: scrollContainer.style.overflow,
+        property: "overflow",
+        el: scrollContainer,
+      },
+      {
+        value: scrollContainer.style.overflowX,
+        property: "overflow-x",
+        el: scrollContainer,
+      },
+      {
+        value: scrollContainer.style.overflowY,
+        property: "overflow-y",
+        el: scrollContainer,
+      }
+    );
+    scrollContainer.style.overflow = "hidden";
   }
   var restore = function restore() {
     restoreStyle.forEach(function (_ref) {
@@ -121,7 +169,7 @@ function handleContainer(containerInfo, props) {
 function getHiddenSiblings(container) {
   var hiddenSiblings = [];
   [].forEach.call(container.children, function (element) {
-    if (element.getAttribute('aria-hidden') === 'true') {
+    if (element.getAttribute("aria-hidden") === "true") {
       hiddenSiblings.push(element);
     }
   });
@@ -134,7 +182,7 @@ function getHiddenSiblings(container) {
  * Simplified, but inspired by react-overlay's ModalManager class.
  * Used by the Modal to ensure proper styling of containers.
  */
-export var ModalManager = /*#__PURE__*/function () {
+export var ModalManager = /*#__PURE__*/ (function () {
   function ModalManager() {
     _classCallCheck(this, ModalManager);
     this.containers = void 0;
@@ -142,92 +190,115 @@ export var ModalManager = /*#__PURE__*/function () {
     this.modals = [];
     this.containers = [];
   }
-  _createClass(ModalManager, [{
-    key: "add",
-    value: function add(modal, container) {
-      var modalIndex = this.modals.indexOf(modal);
-      if (modalIndex !== -1) {
-        return modalIndex;
-      }
-      modalIndex = this.modals.length;
-      this.modals.push(modal);
+  _createClass(ModalManager, [
+    {
+      key: "add",
+      value: function add(modal, container) {
+        var modalIndex = this.modals.indexOf(modal);
+        if (modalIndex !== -1) {
+          return modalIndex;
+        }
+        modalIndex = this.modals.length;
+        this.modals.push(modal);
 
-      // If the modal we are adding is already in the DOM.
-      if (modal.modalRef) {
-        ariaHidden(modal.modalRef, false);
-      }
-      var hiddenSiblings = getHiddenSiblings(container);
-      ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
-      var containerIndex = findIndexOf(this.containers, function (item) {
-        return item.container === container;
-      });
-      if (containerIndex !== -1) {
-        this.containers[containerIndex].modals.push(modal);
-        return modalIndex;
-      }
-      this.containers.push({
-        modals: [modal],
-        container: container,
-        restore: null,
-        hiddenSiblings: hiddenSiblings
-      });
-      return modalIndex;
-    }
-  }, {
-    key: "mount",
-    value: function mount(modal, props) {
-      var containerIndex = findIndexOf(this.containers, function (item) {
-        return item.modals.indexOf(modal) !== -1;
-      });
-      var containerInfo = this.containers[containerIndex];
-      if (!containerInfo.restore) {
-        containerInfo.restore = handleContainer(containerInfo, props);
-      }
-    }
-  }, {
-    key: "remove",
-    value: function remove(modal) {
-      var ariaHiddenState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
-      var modalIndex = this.modals.indexOf(modal);
-      if (modalIndex === -1) {
+        // If the modal we are adding is already in the DOM.
+        if (modal.modalRef) {
+          ariaHidden(modal.modalRef, false);
+        }
+        var hiddenSiblings = getHiddenSiblings(container);
+        ariaHiddenSiblings(
+          container,
+          modal.mount,
+          modal.modalRef,
+          hiddenSiblings,
+          true
+        );
+        var containerIndex = findIndexOf(this.containers, function (item) {
+          return item.container === container;
+        });
+        if (containerIndex !== -1) {
+          this.containers[containerIndex].modals.push(modal);
+          return modalIndex;
+        }
+        this.containers.push({
+          modals: [modal],
+          container: container,
+          restore: null,
+          hiddenSiblings: hiddenSiblings,
+        });
         return modalIndex;
-      }
-      var containerIndex = findIndexOf(this.containers, function (item) {
-        return item.modals.indexOf(modal) !== -1;
-      });
-      var containerInfo = this.containers[containerIndex];
-      containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
-      this.modals.splice(modalIndex, 1);
-
-      // If that was the last modal in a container, clean up the container.
-      if (containerInfo.modals.length === 0) {
-        // The modal might be closed before it had the chance to be mounted in the DOM.
-        if (containerInfo.restore) {
-          containerInfo.restore();
+      },
+    },
+    {
+      key: "mount",
+      value: function mount(modal, props) {
+        var containerIndex = findIndexOf(this.containers, function (item) {
+          return item.modals.indexOf(modal) !== -1;
+        });
+        var containerInfo = this.containers[containerIndex];
+        if (!containerInfo.restore) {
+          containerInfo.restore = handleContainer(containerInfo, props);
         }
-        if (modal.modalRef) {
-          // In case the modal wasn't in the DOM yet.
-          ariaHidden(modal.modalRef, ariaHiddenState);
+      },
+    },
+    {
+      key: "remove",
+      value: function remove(modal) {
+        var ariaHiddenState =
+          arguments.length > 1 && arguments[1] !== undefined
+            ? arguments[1]
+            : true;
+        var modalIndex = this.modals.indexOf(modal);
+        if (modalIndex === -1) {
+          return modalIndex;
         }
-        ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
-        this.containers.splice(containerIndex, 1);
-      } else {
-        // Otherwise make sure the next top modal is visible to a screen reader.
-        var nextTop = containerInfo.modals[containerInfo.modals.length - 1];
-        // as soon as a modal is adding its modalRef is undefined. it can't set
-        // aria-hidden because the dom element doesn't exist either
-        // when modal was unmounted before modalRef gets null
-        if (nextTop.modalRef) {
-          ariaHidden(nextTop.modalRef, false);
+        var containerIndex = findIndexOf(this.containers, function (item) {
+          return item.modals.indexOf(modal) !== -1;
+        });
+        var containerInfo = this.containers[containerIndex];
+        containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
+        this.modals.splice(modalIndex, 1);
+
+        // If that was the last modal in a container, clean up the container.
+        if (containerInfo.modals.length === 0) {
+          // The modal might be closed before it had the chance to be mounted in the DOM.
+          if (containerInfo.restore) {
+            containerInfo.restore();
+          }
+          if (modal.modalRef) {
+            // In case the modal wasn't in the DOM yet.
+            ariaHidden(modal.modalRef, ariaHiddenState);
+          }
+          ariaHiddenSiblings(
+            containerInfo.container,
+            modal.mount,
+            modal.modalRef,
+            containerInfo.hiddenSiblings,
+            false
+          );
+          this.containers.splice(containerIndex, 1);
+        } else {
+          // Otherwise make sure the next top modal is visible to a screen reader.
+          var nextTop = containerInfo.modals[containerInfo.modals.length - 1];
+          // as soon as a modal is adding its modalRef is undefined. it can't set
+          // aria-hidden because the dom element doesn't exist either
+          // when modal was unmounted before modalRef gets null
+          if (nextTop.modalRef) {
+            ariaHidden(nextTop.modalRef, false);
+          }
         }
-      }
-      return modalIndex;
-    }
-  }, {
-    key: "isTopModal",
-    value: function isTopModal(modal) {
-      return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
-    }
-  }]);
+        return modalIndex;
+      },
+    },
+    {
+      key: "isTopModal",
+      value: function isTopModal(modal) {
+        return (
+          this.modals.length > 0 &&
+          this.modals[this.modals.length - 1] === modal
+        );
+      },
+    },
+  ]);
   return ModalManager;
-}();
\ No newline at end of file
+})();
diff --git a/legacy/unstable_useModal/useModal.js b/legacy/unstable_useModal/useModal.js
index b93b3281b99cf9a997e38f7c1c2acf110ba65ee0..ceb0ec10c34b795e68b306db2f5fecaa41d5e916 100644
--- a/legacy/unstable_useModal/useModal.js
+++ b/legacy/unstable_useModal/useModal.js
@@ -1,15 +1,20 @@
-'use client';
+"use client";
 
 import _extends from "@babel/runtime/helpers/esm/extends";
-import * as React from 'react';
-import { unstable_ownerDocument as ownerDocument, unstable_useForkRef as useForkRef, unstable_useEventCallback as useEventCallback, unstable_createChainedFunction as createChainedFunction } from '@mui/utils';
-import { extractEventHandlers } from '../utils';
-import { ModalManager, ariaHidden } from './ModalManager';
+import * as React from "react";
+import {
+  unstable_ownerDocument as ownerDocument,
+  unstable_useForkRef as useForkRef,
+  unstable_useEventCallback as useEventCallback,
+  unstable_createChainedFunction as createChainedFunction,
+} from "@mui/utils";
+import { extractEventHandlers } from "../utils";
+import { ModalManager, ariaHidden } from "./ModalManager";
 function getContainer(container) {
-  return typeof container === 'function' ? container() : container;
+  return typeof container === "function" ? container() : container;
 }
 function getHasTransition(children) {
-  return children ? children.props.hasOwnProperty('in') : false;
+  return children ? children.props.hasOwnProperty("in") : false;
 }
 
 // A modal manager used to track and manage the state of open Modals.
@@ -28,13 +33,17 @@ var defaultManager = new ModalManager();
 export function useModal(parameters) {
   var container = parameters.container,
     _parameters$disableEs = parameters.disableEscapeKeyDown,
-    disableEscapeKeyDown = _parameters$disableEs === void 0 ? false : _parameters$disableEs,
+    disableEscapeKeyDown =
+      _parameters$disableEs === void 0 ? false : _parameters$disableEs,
     _parameters$disableSc = parameters.disableScrollLock,
-    disableScrollLock = _parameters$disableSc === void 0 ? false : _parameters$disableSc,
+    disableScrollLock =
+      _parameters$disableSc === void 0 ? false : _parameters$disableSc,
     _parameters$manager = parameters.manager,
-    manager = _parameters$manager === void 0 ? defaultManager : _parameters$manager,
+    manager =
+      _parameters$manager === void 0 ? defaultManager : _parameters$manager,
     _parameters$closeAfte = parameters.closeAfterTransition,
-    closeAfterTransition = _parameters$closeAfte === void 0 ? false : _parameters$closeAfte,
+    closeAfterTransition =
+      _parameters$closeAfte === void 0 ? false : _parameters$closeAfte,
     onTransitionEnter = parameters.onTransitionEnter,
     onTransitionExited = parameters.onTransitionExited,
     children = parameters.children,
@@ -50,7 +59,10 @@ export function useModal(parameters) {
     setExited = _React$useState[1];
   var hasTransition = getHasTransition(children);
   var ariaHiddenProp = true;
-  if (parameters['aria-hidden'] === 'false' || parameters['aria-hidden'] === false) {
+  if (
+    parameters["aria-hidden"] === "false" ||
+    parameters["aria-hidden"] === false
+  ) {
     ariaHiddenProp = false;
   }
   var getDoc = function getDoc() {
@@ -63,7 +75,8 @@ export function useModal(parameters) {
   };
   var handleMounted = function handleMounted() {
     manager.mount(getModal(), {
-      disableScrollLock: disableScrollLock
+      disableScrollLock: disableScrollLock,
+      scrollContainer: parameters.scrollContainer,
     });
 
     // Fix a bug on Chrome where the scroll isn't initially 0.
@@ -80,9 +93,12 @@ export function useModal(parameters) {
       handleMounted();
     }
   });
-  var isTopModal = React.useCallback(function () {
-    return manager.isTopModal(getModal());
-  }, [manager]);
+  var isTopModal = React.useCallback(
+    function () {
+      return manager.isTopModal(getModal());
+    },
+    [manager]
+  );
   var handlePortalRef = useEventCallback(function (node) {
     mountNodeRef.current = node;
     if (!node) {
@@ -94,25 +110,35 @@ export function useModal(parameters) {
       ariaHidden(modalRef.current, ariaHiddenProp);
     }
   });
-  var handleClose = React.useCallback(function () {
-    manager.remove(getModal(), ariaHiddenProp);
-  }, [ariaHiddenProp, manager]);
-  React.useEffect(function () {
-    return function () {
-      handleClose();
-    };
-  }, [handleClose]);
-  React.useEffect(function () {
-    if (open) {
-      handleOpen();
-    } else if (!hasTransition || !closeAfterTransition) {
-      handleClose();
-    }
-  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
+  var handleClose = React.useCallback(
+    function () {
+      manager.remove(getModal(), ariaHiddenProp);
+    },
+    [ariaHiddenProp, manager]
+  );
+  React.useEffect(
+    function () {
+      return function () {
+        handleClose();
+      };
+    },
+    [handleClose]
+  );
+  React.useEffect(
+    function () {
+      if (open) {
+        handleOpen();
+      } else if (!hasTransition || !closeAfterTransition) {
+        handleClose();
+      }
+    },
+    [open, handleClose, hasTransition, closeAfterTransition, handleOpen]
+  );
   var createHandleKeyDown = function createHandleKeyDown(otherHandlers) {
     return function (event) {
       var _otherHandlers$onKeyD;
-      (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
+      (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ||
+        _otherHandlers$onKeyD.call(otherHandlers, event);
 
       // The handler doesn't take event.defaultPrevented into account:
       //
@@ -120,56 +146,72 @@ export function useModal(parameters) {
       // clicking a checkbox to check it, hitting a button to submit a form,
       // and hitting left arrow to move the cursor in a text input etc.
       // Only special HTML elements have these default behaviors.
-      if (event.key !== 'Escape' || event.which === 229 ||
-      // Wait until IME is settled.
-      !isTopModal()) {
+      if (
+        event.key !== "Escape" ||
+        event.which === 229 ||
+        // Wait until IME is settled.
+        !isTopModal()
+      ) {
         return;
       }
       if (!disableEscapeKeyDown) {
         // Swallow the event, in case someone is listening for the escape key on the body.
         event.stopPropagation();
         if (onClose) {
-          onClose(event, 'escapeKeyDown');
+          onClose(event, "escapeKeyDown");
         }
       }
     };
   };
-  var createHandleBackdropClick = function createHandleBackdropClick(otherHandlers) {
+  var createHandleBackdropClick = function createHandleBackdropClick(
+    otherHandlers
+  ) {
     return function (event) {
       var _otherHandlers$onClic;
-      (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
+      (_otherHandlers$onClic = otherHandlers.onClick) == null ||
+        _otherHandlers$onClic.call(otherHandlers, event);
       if (event.target !== event.currentTarget) {
         return;
       }
       if (onClose) {
-        onClose(event, 'backdropClick');
+        onClose(event, "backdropClick");
       }
     };
   };
   var getRootProps = function getRootProps() {
-    var otherHandlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+    var otherHandlers =
+      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
     var propsEventHandlers = extractEventHandlers(parameters);
 
     // The custom event handlers shouldn't be spread on the root element
     delete propsEventHandlers.onTransitionEnter;
     delete propsEventHandlers.onTransitionExited;
     var externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);
-    return _extends({
-      role: 'presentation'
-    }, externalEventHandlers, {
-      onKeyDown: createHandleKeyDown(externalEventHandlers),
-      ref: handleRef
-    });
+    return _extends(
+      {
+        role: "presentation",
+      },
+      externalEventHandlers,
+      {
+        onKeyDown: createHandleKeyDown(externalEventHandlers),
+        ref: handleRef,
+      }
+    );
   };
   var getBackdropProps = function getBackdropProps() {
-    var otherHandlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+    var otherHandlers =
+      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
     var externalEventHandlers = otherHandlers;
-    return _extends({
-      'aria-hidden': true
-    }, externalEventHandlers, {
-      onClick: createHandleBackdropClick(externalEventHandlers),
-      open: open
-    });
+    return _extends(
+      {
+        "aria-hidden": true,
+      },
+      externalEventHandlers,
+      {
+        onClick: createHandleBackdropClick(externalEventHandlers),
+        open: open,
+      }
+    );
   };
   var getTransitionProps = function getTransitionProps() {
     var handleEnter = function handleEnter() {
@@ -188,8 +230,14 @@ export function useModal(parameters) {
       }
     };
     return {
-      onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
-      onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
+      onEnter: createChainedFunction(
+        handleEnter,
+        children == null ? void 0 : children.props.onEnter
+      ),
+      onExited: createChainedFunction(
+        handleExited,
+        children == null ? void 0 : children.props.onExited
+      ),
     };
   };
   return {
@@ -200,6 +248,6 @@ export function useModal(parameters) {
     portalRef: handlePortalRef,
     isTopModal: isTopModal,
     exited: exited,
-    hasTransition: hasTransition
+    hasTransition: hasTransition,
   };
 }
\ No newline at end of file
diff --git a/modern/Modal/Modal.js b/modern/Modal/Modal.js
index 30b052cdbf52daced08af0bb3041c687ad6c394e..d23ee42c4f4421235543489897c7a02f2dd91952 100644
--- a/modern/Modal/Modal.js
+++ b/modern/Modal/Modal.js
@@ -1,28 +1,46 @@
-'use client';
+"use client";
 
 import _extends from "@babel/runtime/helpers/esm/extends";
 import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
-const _excluded = ["children", "closeAfterTransition", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited", "slotProps", "slots"];
-import * as React from 'react';
-import PropTypes from 'prop-types';
-import { elementAcceptingRef, HTMLElementType } from '@mui/utils';
-import { useSlotProps } from '../utils';
-import { useClassNamesOverride } from '../utils/ClassNameConfigurator';
-import { unstable_composeClasses as composeClasses } from '../composeClasses';
-import { Portal } from '../Portal';
-import { unstable_useModal as useModal } from '../unstable_useModal';
-import { FocusTrap } from '../FocusTrap';
-import { getModalUtilityClass } from './modalClasses';
+const _excluded = [
+  "children",
+  "closeAfterTransition",
+  "container",
+  "disableAutoFocus",
+  "disableEnforceFocus",
+  "disableEscapeKeyDown",
+  "disablePortal",
+  "disableRestoreFocus",
+  "disableScrollLock",
+  "hideBackdrop",
+  "keepMounted",
+  "onBackdropClick",
+  "onClose",
+  "onKeyDown",
+  "open",
+  "onTransitionEnter",
+  "onTransitionExited",
+  "slotProps",
+  "slots",
+  "scrollContainer",
+];
+import * as React from "react";
+import PropTypes from "prop-types";
+import { elementAcceptingRef, HTMLElementType } from "@mui/utils";
+import { useSlotProps } from "../utils";
+import { useClassNamesOverride } from "../utils/ClassNameConfigurator";
+import { unstable_composeClasses as composeClasses } from "../composeClasses";
+import { Portal } from "../Portal";
+import { unstable_useModal as useModal } from "../unstable_useModal";
+import { FocusTrap } from "../FocusTrap";
+import { getModalUtilityClass } from "./modalClasses";
 import { jsx as _jsx } from "react/jsx-runtime";
 import { jsxs as _jsxs } from "react/jsx-runtime";
-const useUtilityClasses = ownerState => {
-  const {
-    open,
-    exited
-  } = ownerState;
+const useUtilityClasses = (ownerState) => {
+  const { open, exited } = ownerState;
   const slots = {
-    root: ['root', !open && exited && 'hidden'],
-    backdrop: ['backdrop']
+    root: ["root", !open && exited && "hidden"],
+    backdrop: ["backdrop"],
   };
   return composeClasses(slots, useClassNamesOverride(getModalUtilityClass));
 };
@@ -48,7 +66,10 @@ const useUtilityClasses = ownerState => {
  *
  * - [Modal API](https://mui.com/base-ui/react-modal/components-api/#modal)
  */
-const Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef) {
+const Modal = /*#__PURE__*/ React.forwardRef(function Modal(
+  props,
+  forwardedRef
+) {
   const {
       children,
       closeAfterTransition = false,
@@ -64,7 +85,7 @@ const Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef)
       onBackdropClick,
       open,
       slotProps = {},
-      slots = {}
+      slots = {},
     } = props,
     other = _objectWithoutPropertiesLoose(props, _excluded);
   const propsWithDefaults = _extends({}, props, {
@@ -76,7 +97,7 @@ const Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef)
     disableRestoreFocus,
     disableScrollLock,
     hideBackdrop,
-    keepMounted
+    keepMounted,
   });
   const {
     getRootProps,
@@ -85,193 +106,207 @@ const Modal = /*#__PURE__*/React.forwardRef(function Modal(props, forwardedRef)
     portalRef,
     isTopModal,
     exited,
-    hasTransition
-  } = useModal(_extends({}, propsWithDefaults, {
-    rootRef: forwardedRef
-  }));
+    hasTransition,
+  } = useModal(
+    _extends({}, propsWithDefaults, {
+      rootRef: forwardedRef,
+    })
+  );
   const ownerState = _extends({}, propsWithDefaults, {
     exited,
-    hasTransition
+    hasTransition,
   });
   const classes = useUtilityClasses(ownerState);
   const childProps = {};
   if (children.props.tabIndex === undefined) {
-    childProps.tabIndex = '-1';
+    childProps.tabIndex = "-1";
   }
 
   // It's a Transition like component
   if (hasTransition) {
-    const {
-      onEnter,
-      onExited
-    } = getTransitionProps();
+    const { onEnter, onExited } = getTransitionProps();
     childProps.onEnter = onEnter;
     childProps.onExited = onExited;
   }
-  const Root = slots.root ?? 'div';
+  const Root = slots.root ?? "div";
   const rootProps = useSlotProps({
     elementType: Root,
     externalSlotProps: slotProps.root,
     externalForwardedProps: other,
     getSlotProps: getRootProps,
     className: classes.root,
-    ownerState
+    ownerState,
   });
   const BackdropComponent = slots.backdrop;
   const backdropProps = useSlotProps({
     elementType: BackdropComponent,
     externalSlotProps: slotProps.backdrop,
-    getSlotProps: otherHandlers => {
-      return getBackdropProps(_extends({}, otherHandlers, {
-        onClick: e => {
-          if (onBackdropClick) {
-            onBackdropClick(e);
-          }
-          if (otherHandlers?.onClick) {
-            otherHandlers.onClick(e);
-          }
-        }
-      }));
+    getSlotProps: (otherHandlers) => {
+      return getBackdropProps(
+        _extends({}, otherHandlers, {
+          onClick: (e) => {
+            if (onBackdropClick) {
+              onBackdropClick(e);
+            }
+            if (otherHandlers?.onClick) {
+              otherHandlers.onClick(e);
+            }
+          },
+        })
+      );
     },
     className: classes.backdrop,
-    ownerState
+    ownerState,
   });
   if (!keepMounted && !open && (!hasTransition || exited)) {
     return null;
   }
-  return /*#__PURE__*/_jsx(Portal, {
+  return /*#__PURE__*/ _jsx(Portal, {
     ref: portalRef,
     container: container,
     disablePortal: disablePortal,
-    children: /*#__PURE__*/_jsxs(Root, _extends({}, rootProps, {
-      children: [!hideBackdrop && BackdropComponent ? /*#__PURE__*/_jsx(BackdropComponent, _extends({}, backdropProps)) : null, /*#__PURE__*/_jsx(FocusTrap, {
-        disableEnforceFocus: disableEnforceFocus,
-        disableAutoFocus: disableAutoFocus,
-        disableRestoreFocus: disableRestoreFocus,
-        isEnabled: isTopModal,
-        open: open,
-        children: /*#__PURE__*/React.cloneElement(children, childProps)
-      })]
-    }))
+    children: /*#__PURE__*/ _jsxs(
+      Root,
+      _extends({}, rootProps, {
+        children: [
+          !hideBackdrop && BackdropComponent
+            ? /*#__PURE__*/ _jsx(BackdropComponent, _extends({}, backdropProps))
+            : null,
+          /*#__PURE__*/ _jsx(FocusTrap, {
+            disableEnforceFocus: disableEnforceFocus,
+            disableAutoFocus: disableAutoFocus,
+            disableRestoreFocus: disableRestoreFocus,
+            isEnabled: isTopModal,
+            open: open,
+            children: /*#__PURE__*/ React.cloneElement(children, childProps),
+          }),
+        ],
+      })
+    ),
   });
 });
-process.env.NODE_ENV !== "production" ? Modal.propTypes /* remove-proptypes */ = {
-  // ┌────────────────────────────── Warning ──────────────────────────────┐
-  // │ These PropTypes are generated from the TypeScript type definitions. │
-  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
-  // └─────────────────────────────────────────────────────────────────────┘
-  /**
-   * A single child content element.
-   */
-  children: elementAcceptingRef.isRequired,
-  /**
-   * When set to true the Modal waits until a nested Transition is completed before closing.
-   * @default false
-   */
-  closeAfterTransition: PropTypes.bool,
-  /**
-   * An HTML element or function that returns one.
-   * The `container` will have the portal children appended to it.
-   *
-   * You can also provide a callback, which is called in a React layout effect.
-   * This lets you set the container from a ref, and also makes server-side rendering possible.
-   *
-   * By default, it uses the body of the top-level document object,
-   * so it's simply `document.body` most of the time.
-   */
-  container: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, PropTypes.func]),
-  /**
-   * If `true`, the modal will not automatically shift focus to itself when it opens, and
-   * replace it to the last focused element when it closes.
-   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
-   *
-   * Generally this should never be set to `true` as it makes the modal less
-   * accessible to assistive technologies, like screen readers.
-   * @default false
-   */
-  disableAutoFocus: PropTypes.bool,
-  /**
-   * If `true`, the modal will not prevent focus from leaving the modal while open.
-   *
-   * Generally this should never be set to `true` as it makes the modal less
-   * accessible to assistive technologies, like screen readers.
-   * @default false
-   */
-  disableEnforceFocus: PropTypes.bool,
-  /**
-   * If `true`, hitting escape will not fire the `onClose` callback.
-   * @default false
-   */
-  disableEscapeKeyDown: PropTypes.bool,
-  /**
-   * The `children` will be under the DOM hierarchy of the parent component.
-   * @default false
-   */
-  disablePortal: PropTypes.bool,
-  /**
-   * If `true`, the modal will not restore focus to previously focused element once
-   * modal is hidden or unmounted.
-   * @default false
-   */
-  disableRestoreFocus: PropTypes.bool,
-  /**
-   * Disable the scroll lock behavior.
-   * @default false
-   */
-  disableScrollLock: PropTypes.bool,
-  /**
-   * If `true`, the backdrop is not rendered.
-   * @default false
-   */
-  hideBackdrop: PropTypes.bool,
-  /**
-   * Always keep the children in the DOM.
-   * This prop can be useful in SEO situation or
-   * when you want to maximize the responsiveness of the Modal.
-   * @default false
-   */
-  keepMounted: PropTypes.bool,
-  /**
-   * Callback fired when the backdrop is clicked.
-   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
-   */
-  onBackdropClick: PropTypes.func,
-  /**
-   * Callback fired when the component requests to be closed.
-   * The `reason` parameter can optionally be used to control the response to `onClose`.
-   *
-   * @param {object} event The event source of the callback.
-   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
-   */
-  onClose: PropTypes.func,
-  /**
-   * A function called when a transition enters.
-   */
-  onTransitionEnter: PropTypes.func,
-  /**
-   * A function called when a transition has exited.
-   */
-  onTransitionExited: PropTypes.func,
-  /**
-   * If `true`, the component is shown.
-   */
-  open: PropTypes.bool.isRequired,
-  /**
-   * The props used for each slot inside the Modal.
-   * @default {}
-   */
-  slotProps: PropTypes.shape({
-    backdrop: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
-    root: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
-  }),
-  /**
-   * The components used for each slot inside the Modal.
-   * Either a string to use a HTML element or a component.
-   * @default {}
-   */
-  slots: PropTypes.shape({
-    backdrop: PropTypes.elementType,
-    root: PropTypes.elementType
-  })
-} : void 0;
+process.env.NODE_ENV !== "production"
+  ? (Modal.propTypes /* remove-proptypes */ = {
+      // ┌────────────────────────────── Warning ──────────────────────────────┐
+      // │ These PropTypes are generated from the TypeScript type definitions. │
+      // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
+      // └─────────────────────────────────────────────────────────────────────┘
+      /**
+       * A single child content element.
+       */
+      children: elementAcceptingRef.isRequired,
+      /**
+       * When set to true the Modal waits until a nested Transition is completed before closing.
+       * @default false
+       */
+      closeAfterTransition: PropTypes.bool,
+      /**
+       * An HTML element or function that returns one.
+       * The `container` will have the portal children appended to it.
+       *
+       * You can also provide a callback, which is called in a React layout effect.
+       * This lets you set the container from a ref, and also makes server-side rendering possible.
+       *
+       * By default, it uses the body of the top-level document object,
+       * so it's simply `document.body` most of the time.
+       */
+      container: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([
+        HTMLElementType,
+        PropTypes.func,
+      ]),
+      /**
+       * If `true`, the modal will not automatically shift focus to itself when it opens, and
+       * replace it to the last focused element when it closes.
+       * This also works correctly with any modal children that have the `disableAutoFocus` prop.
+       *
+       * Generally this should never be set to `true` as it makes the modal less
+       * accessible to assistive technologies, like screen readers.
+       * @default false
+       */
+      disableAutoFocus: PropTypes.bool,
+      /**
+       * If `true`, the modal will not prevent focus from leaving the modal while open.
+       *
+       * Generally this should never be set to `true` as it makes the modal less
+       * accessible to assistive technologies, like screen readers.
+       * @default false
+       */
+      disableEnforceFocus: PropTypes.bool,
+      /**
+       * If `true`, hitting escape will not fire the `onClose` callback.
+       * @default false
+       */
+      disableEscapeKeyDown: PropTypes.bool,
+      /**
+       * The `children` will be under the DOM hierarchy of the parent component.
+       * @default false
+       */
+      disablePortal: PropTypes.bool,
+      /**
+       * If `true`, the modal will not restore focus to previously focused element once
+       * modal is hidden or unmounted.
+       * @default false
+       */
+      disableRestoreFocus: PropTypes.bool,
+      /**
+       * Disable the scroll lock behavior.
+       * @default false
+       */
+      disableScrollLock: PropTypes.bool,
+      /**
+       * If `true`, the backdrop is not rendered.
+       * @default false
+       */
+      hideBackdrop: PropTypes.bool,
+      /**
+       * Always keep the children in the DOM.
+       * This prop can be useful in SEO situation or
+       * when you want to maximize the responsiveness of the Modal.
+       * @default false
+       */
+      keepMounted: PropTypes.bool,
+      /**
+       * Callback fired when the backdrop is clicked.
+       * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
+       */
+      onBackdropClick: PropTypes.func,
+      /**
+       * Callback fired when the component requests to be closed.
+       * The `reason` parameter can optionally be used to control the response to `onClose`.
+       *
+       * @param {object} event The event source of the callback.
+       * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
+       */
+      onClose: PropTypes.func,
+      /**
+       * A function called when a transition enters.
+       */
+      onTransitionEnter: PropTypes.func,
+      /**
+       * A function called when a transition has exited.
+       */
+      onTransitionExited: PropTypes.func,
+      /**
+       * If `true`, the component is shown.
+       */
+      open: PropTypes.bool.isRequired,
+      /**
+       * The props used for each slot inside the Modal.
+       * @default {}
+       */
+      slotProps: PropTypes.shape({
+        backdrop: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
+        root: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
+      }),
+      /**
+       * The components used for each slot inside the Modal.
+       * Either a string to use a HTML element or a component.
+       * @default {}
+       */
+      slots: PropTypes.shape({
+        backdrop: PropTypes.elementType,
+        root: PropTypes.elementType,
+      }),
+    })
+  : void 0;
 export { Modal };
\ No newline at end of file
diff --git a/modern/unstable_useModal/ModalManager.js b/modern/unstable_useModal/ModalManager.js
index 8afc8d2ba4746c2b5cbba43e559b96ed075e1aed..c706cf9c5805ca6356ce94bb73811f02b6bdd85f 100644
--- a/modern/unstable_useModal/ModalManager.js
+++ b/modern/unstable_useModal/ModalManager.js
@@ -1,4 +1,8 @@
-import { unstable_ownerWindow as ownerWindow, unstable_ownerDocument as ownerDocument, unstable_getScrollbarSize as getScrollbarSize } from '@mui/utils';
+import {
+  unstable_ownerWindow as ownerWindow,
+  unstable_ownerDocument as ownerDocument,
+  unstable_getScrollbarSize as getScrollbarSize,
+} from "@mui/utils";
 // Is a vertical scrollbar displayed?
 function isOverflowing(container) {
   const doc = ownerDocument(container);
@@ -9,26 +13,51 @@ function isOverflowing(container) {
 }
 export function ariaHidden(element, show) {
   if (show) {
-    element.setAttribute('aria-hidden', 'true');
+    element.setAttribute("aria-hidden", "true");
   } else {
-    element.removeAttribute('aria-hidden');
+    element.removeAttribute("aria-hidden");
   }
 }
 function getPaddingRight(element) {
-  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
+  return (
+    parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) ||
+    0
+  );
 }
 function isAriaHiddenForbiddenOnElement(element) {
   // The forbidden HTML tags are the ones from ARIA specification that
   // can be children of body and can't have aria-hidden attribute.
   // cf. https://www.w3.org/TR/html-aria/#docconformance
-  const forbiddenTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'];
+  const forbiddenTagNames = [
+    "TEMPLATE",
+    "SCRIPT",
+    "STYLE",
+    "LINK",
+    "MAP",
+    "META",
+    "NOSCRIPT",
+    "PICTURE",
+    "COL",
+    "COLGROUP",
+    "PARAM",
+    "SLOT",
+    "SOURCE",
+    "TRACK",
+  ];
   const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
-  const isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';
+  const isInputHidden =
+    element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
   return isForbiddenTagName || isInputHidden;
 }
-function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
+function ariaHiddenSiblings(
+  container,
+  mountElement,
+  currentElement,
+  elementsToExclude,
+  show
+) {
   const blacklist = [mountElement, currentElement, ...elementsToExclude];
-  [].forEach.call(container.children, element => {
+  [].forEach.call(container.children, (element) => {
     const isNotExcludedElement = blacklist.indexOf(element) === -1;
     const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
     if (isNotExcludedElement && isNotForbiddenElement) {
@@ -49,64 +78,75 @@ function findIndexOf(items, callback) {
 }
 function handleContainer(containerInfo, props) {
   const restoreStyle = [];
-  const container = containerInfo.container;
+  const container = props.scrollContainer || containerInfo.container;
   if (!props.disableScrollLock) {
     if (isOverflowing(container)) {
       // Compute the size before applying overflow hidden to avoid any scroll jumps.
       const scrollbarSize = getScrollbarSize(ownerDocument(container));
       restoreStyle.push({
         value: container.style.paddingRight,
-        property: 'padding-right',
-        el: container
+        property: "padding-right",
+        el: container,
       });
       // Use computed style, here to get the real padding to add our scrollbar width.
-      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
+      container.style.paddingRight = `${
+        getPaddingRight(container) + scrollbarSize
+      }px`;
 
       // .mui-fixed is a global helper.
-      const fixedElements = ownerDocument(container).querySelectorAll('.mui-fixed');
-      [].forEach.call(fixedElements, element => {
+      const fixedElements =
+        ownerDocument(container).querySelectorAll(".mui-fixed");
+      [].forEach.call(fixedElements, (element) => {
         restoreStyle.push({
           value: element.style.paddingRight,
-          property: 'padding-right',
-          el: element
+          property: "padding-right",
+          el: element,
         });
-        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
+        element.style.paddingRight = `${
+          getPaddingRight(element) + scrollbarSize
+        }px`;
       });
     }
     let scrollContainer;
-    if (container.parentNode instanceof DocumentFragment) {
+    if (props.scrollContainer) {
+      scrollContainer = props.scrollContainer;
+    } else if (container.parentNode instanceof DocumentFragment) {
       scrollContainer = ownerDocument(container).body;
     } else {
       // Support html overflow-y: auto for scroll stability between pages
       // https://css-tricks.com/snippets/css/force-vertical-scrollbar/
       const parent = container.parentElement;
       const containerWindow = ownerWindow(container);
-      scrollContainer = parent?.nodeName === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;
+      scrollContainer =
+        parent?.nodeName === "HTML" &&
+        containerWindow.getComputedStyle(parent).overflowY === "scroll"
+          ? parent
+          : container;
     }
 
     // Block the scroll even if no scrollbar is visible to account for mobile keyboard
     // screensize shrink.
-    restoreStyle.push({
-      value: scrollContainer.style.overflow,
-      property: 'overflow',
-      el: scrollContainer
-    }, {
-      value: scrollContainer.style.overflowX,
-      property: 'overflow-x',
-      el: scrollContainer
-    }, {
-      value: scrollContainer.style.overflowY,
-      property: 'overflow-y',
-      el: scrollContainer
-    });
-    scrollContainer.style.overflow = 'hidden';
+    restoreStyle.push(
+      {
+        value: scrollContainer.style.overflow,
+        property: "overflow",
+        el: scrollContainer,
+      },
+      {
+        value: scrollContainer.style.overflowX,
+        property: "overflow-x",
+        el: scrollContainer,
+      },
+      {
+        value: scrollContainer.style.overflowY,
+        property: "overflow-y",
+        el: scrollContainer,
+      }
+    );
+    scrollContainer.style.overflow = "hidden";
   }
   const restore = () => {
-    restoreStyle.forEach(({
-      value,
-      el,
-      property
-    }) => {
+    restoreStyle.forEach(({ value, el, property }) => {
       if (value) {
         el.style.setProperty(property, value);
       } else {
@@ -118,8 +158,8 @@ function handleContainer(containerInfo, props) {
 }
 function getHiddenSiblings(container) {
   const hiddenSiblings = [];
-  [].forEach.call(container.children, element => {
-    if (element.getAttribute('aria-hidden') === 'true') {
+  [].forEach.call(container.children, (element) => {
+    if (element.getAttribute("aria-hidden") === "true") {
       hiddenSiblings.push(element);
     }
   });
@@ -152,8 +192,17 @@ export class ModalManager {
       ariaHidden(modal.modalRef, false);
     }
     const hiddenSiblings = getHiddenSiblings(container);
-    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
-    const containerIndex = findIndexOf(this.containers, item => item.container === container);
+    ariaHiddenSiblings(
+      container,
+      modal.mount,
+      modal.modalRef,
+      hiddenSiblings,
+      true
+    );
+    const containerIndex = findIndexOf(
+      this.containers,
+      (item) => item.container === container
+    );
     if (containerIndex !== -1) {
       this.containers[containerIndex].modals.push(modal);
       return modalIndex;
@@ -162,12 +211,15 @@ export class ModalManager {
       modals: [modal],
       container,
       restore: null,
-      hiddenSiblings
+      hiddenSiblings,
     });
     return modalIndex;
   }
   mount(modal, props) {
-    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);
+    const containerIndex = findIndexOf(
+      this.containers,
+      (item) => item.modals.indexOf(modal) !== -1
+    );
     const containerInfo = this.containers[containerIndex];
     if (!containerInfo.restore) {
       containerInfo.restore = handleContainer(containerInfo, props);
@@ -178,7 +230,10 @@ export class ModalManager {
     if (modalIndex === -1) {
       return modalIndex;
     }
-    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);
+    const containerIndex = findIndexOf(
+      this.containers,
+      (item) => item.modals.indexOf(modal) !== -1
+    );
     const containerInfo = this.containers[containerIndex];
     containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
     this.modals.splice(modalIndex, 1);
@@ -193,7 +248,13 @@ export class ModalManager {
         // In case the modal wasn't in the DOM yet.
         ariaHidden(modal.modalRef, ariaHiddenState);
       }
-      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
+      ariaHiddenSiblings(
+        containerInfo.container,
+        modal.mount,
+        modal.modalRef,
+        containerInfo.hiddenSiblings,
+        false
+      );
       this.containers.splice(containerIndex, 1);
     } else {
       // Otherwise make sure the next top modal is visible to a screen reader.
@@ -208,6 +269,8 @@ export class ModalManager {
     return modalIndex;
   }
   isTopModal(modal) {
-    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
+    return (
+      this.modals.length > 0 && this.modals[this.modals.length - 1] === modal
+    );
   }
 }
\ No newline at end of file
diff --git a/modern/unstable_useModal/useModal.js b/modern/unstable_useModal/useModal.js
index a727b86939976547fa1c92a3066dd8548fa03020..0dd8081f90dc5e7d6506df523095d05972bb659d 100644
--- a/modern/unstable_useModal/useModal.js
+++ b/modern/unstable_useModal/useModal.js
@@ -1,15 +1,20 @@
-'use client';
+"use client";
 
 import _extends from "@babel/runtime/helpers/esm/extends";
-import * as React from 'react';
-import { unstable_ownerDocument as ownerDocument, unstable_useForkRef as useForkRef, unstable_useEventCallback as useEventCallback, unstable_createChainedFunction as createChainedFunction } from '@mui/utils';
-import { extractEventHandlers } from '../utils';
-import { ModalManager, ariaHidden } from './ModalManager';
+import * as React from "react";
+import {
+  unstable_ownerDocument as ownerDocument,
+  unstable_useForkRef as useForkRef,
+  unstable_useEventCallback as useEventCallback,
+  unstable_createChainedFunction as createChainedFunction,
+} from "@mui/utils";
+import { extractEventHandlers } from "../utils";
+import { ModalManager, ariaHidden } from "./ModalManager";
 function getContainer(container) {
-  return typeof container === 'function' ? container() : container;
+  return typeof container === "function" ? container() : container;
 }
 function getHasTransition(children) {
-  return children ? children.props.hasOwnProperty('in') : false;
+  return children ? children.props.hasOwnProperty("in") : false;
 }
 
 // A modal manager used to track and manage the state of open Modals.
@@ -32,13 +37,14 @@ export function useModal(parameters) {
     disableScrollLock = false,
     // @ts-ignore internal logic - Base UI supports the manager as a prop too
     manager = defaultManager,
+    scrollContainer,
     closeAfterTransition = false,
     onTransitionEnter,
     onTransitionExited,
     children,
     onClose,
     open,
-    rootRef
+    rootRef,
   } = parameters;
 
   // @ts-ignore internal logic
@@ -49,7 +55,10 @@ export function useModal(parameters) {
   const [exited, setExited] = React.useState(!open);
   const hasTransition = getHasTransition(children);
   let ariaHiddenProp = true;
-  if (parameters['aria-hidden'] === 'false' || parameters['aria-hidden'] === false) {
+  if (
+    parameters["aria-hidden"] === "false" ||
+    parameters["aria-hidden"] === false
+  ) {
     ariaHiddenProp = false;
   }
   const getDoc = () => ownerDocument(mountNodeRef.current);
@@ -60,7 +69,8 @@ export function useModal(parameters) {
   };
   const handleMounted = () => {
     manager.mount(getModal(), {
-      disableScrollLock
+      disableScrollLock,
+      scrollContainer,
     });
 
     // Fix a bug on Chrome where the scroll isn't initially 0.
@@ -77,8 +87,11 @@ export function useModal(parameters) {
       handleMounted();
     }
   });
-  const isTopModal = React.useCallback(() => manager.isTopModal(getModal()), [manager]);
-  const handlePortalRef = useEventCallback(node => {
+  const isTopModal = React.useCallback(
+    () => manager.isTopModal(getModal()),
+    [manager]
+  );
+  const handlePortalRef = useEventCallback((node) => {
     mountNodeRef.current = node;
     if (!node) {
       return;
@@ -104,7 +117,7 @@ export function useModal(parameters) {
       handleClose();
     }
   }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
-  const createHandleKeyDown = otherHandlers => event => {
+  const createHandleKeyDown = (otherHandlers) => (event) => {
     otherHandlers.onKeyDown?.(event);
 
     // The handler doesn't take event.defaultPrevented into account:
@@ -113,26 +126,29 @@ export function useModal(parameters) {
     // clicking a checkbox to check it, hitting a button to submit a form,
     // and hitting left arrow to move the cursor in a text input etc.
     // Only special HTML elements have these default behaviors.
-    if (event.key !== 'Escape' || event.which === 229 ||
-    // Wait until IME is settled.
-    !isTopModal()) {
+    if (
+      event.key !== "Escape" ||
+      event.which === 229 ||
+      // Wait until IME is settled.
+      !isTopModal()
+    ) {
       return;
     }
     if (!disableEscapeKeyDown) {
       // Swallow the event, in case someone is listening for the escape key on the body.
       event.stopPropagation();
       if (onClose) {
-        onClose(event, 'escapeKeyDown');
+        onClose(event, "escapeKeyDown");
       }
     }
   };
-  const createHandleBackdropClick = otherHandlers => event => {
+  const createHandleBackdropClick = (otherHandlers) => (event) => {
     otherHandlers.onClick?.(event);
     if (event.target !== event.currentTarget) {
       return;
     }
     if (onClose) {
-      onClose(event, 'backdropClick');
+      onClose(event, "backdropClick");
     }
   };
   const getRootProps = (otherHandlers = {}) => {
@@ -141,22 +157,34 @@ export function useModal(parameters) {
     // The custom event handlers shouldn't be spread on the root element
     delete propsEventHandlers.onTransitionEnter;
     delete propsEventHandlers.onTransitionExited;
-    const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);
-    return _extends({
-      role: 'presentation'
-    }, externalEventHandlers, {
-      onKeyDown: createHandleKeyDown(externalEventHandlers),
-      ref: handleRef
-    });
+    const externalEventHandlers = _extends(
+      {},
+      propsEventHandlers,
+      otherHandlers
+    );
+    return _extends(
+      {
+        role: "presentation",
+      },
+      externalEventHandlers,
+      {
+        onKeyDown: createHandleKeyDown(externalEventHandlers),
+        ref: handleRef,
+      }
+    );
   };
   const getBackdropProps = (otherHandlers = {}) => {
     const externalEventHandlers = otherHandlers;
-    return _extends({
-      'aria-hidden': true
-    }, externalEventHandlers, {
-      onClick: createHandleBackdropClick(externalEventHandlers),
-      open
-    });
+    return _extends(
+      {
+        "aria-hidden": true,
+      },
+      externalEventHandlers,
+      {
+        onClick: createHandleBackdropClick(externalEventHandlers),
+        open,
+      }
+    );
   };
   const getTransitionProps = () => {
     const handleEnter = () => {
@@ -176,7 +204,7 @@ export function useModal(parameters) {
     };
     return {
       onEnter: createChainedFunction(handleEnter, children?.props.onEnter),
-      onExited: createChainedFunction(handleExited, children?.props.onExited)
+      onExited: createChainedFunction(handleExited, children?.props.onExited),
     };
   };
   return {
@@ -187,6 +215,6 @@ export function useModal(parameters) {
     portalRef: handlePortalRef,
     isTopModal,
     exited,
-    hasTransition
+    hasTransition,
   };
 }
\ No newline at end of file
diff --git a/node/unstable_useModal/ModalManager.js b/node/unstable_useModal/ModalManager.js
index 953a225520914f90e464b544d83a60e7ed03188e..cd40f58880ceb103e9a253086a49dfee75b7bf18 100644
--- a/node/unstable_useModal/ModalManager.js
+++ b/node/unstable_useModal/ModalManager.js
@@ -1,7 +1,7 @@
 "use strict";
 
 Object.defineProperty(exports, "__esModule", {
-  value: true
+  value: true,
 });
 exports.ModalManager = void 0;
 exports.ariaHidden = ariaHidden;
@@ -10,32 +10,63 @@ var _utils = require("@mui/utils");
 function isOverflowing(container) {
   const doc = (0, _utils.unstable_ownerDocument)(container);
   if (doc.body === container) {
-    return (0, _utils.unstable_ownerWindow)(container).innerWidth > doc.documentElement.clientWidth;
+    return (
+      (0, _utils.unstable_ownerWindow)(container).innerWidth >
+      doc.documentElement.clientWidth
+    );
   }
   return container.scrollHeight > container.clientHeight;
 }
 function ariaHidden(element, show) {
   if (show) {
-    element.setAttribute('aria-hidden', 'true');
+    element.setAttribute("aria-hidden", "true");
   } else {
-    element.removeAttribute('aria-hidden');
+    element.removeAttribute("aria-hidden");
   }
 }
 function getPaddingRight(element) {
-  return parseInt((0, _utils.unstable_ownerWindow)(element).getComputedStyle(element).paddingRight, 10) || 0;
+  return (
+    parseInt(
+      (0, _utils.unstable_ownerWindow)(element).getComputedStyle(element)
+        .paddingRight,
+      10
+    ) || 0
+  );
 }
 function isAriaHiddenForbiddenOnElement(element) {
   // The forbidden HTML tags are the ones from ARIA specification that
   // can be children of body and can't have aria-hidden attribute.
   // cf. https://www.w3.org/TR/html-aria/#docconformance
-  const forbiddenTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'];
+  const forbiddenTagNames = [
+    "TEMPLATE",
+    "SCRIPT",
+    "STYLE",
+    "LINK",
+    "MAP",
+    "META",
+    "NOSCRIPT",
+    "PICTURE",
+    "COL",
+    "COLGROUP",
+    "PARAM",
+    "SLOT",
+    "SOURCE",
+    "TRACK",
+  ];
   const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
-  const isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';
+  const isInputHidden =
+    element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
   return isForbiddenTagName || isInputHidden;
 }
-function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
+function ariaHiddenSiblings(
+  container,
+  mountElement,
+  currentElement,
+  elementsToExclude,
+  show
+) {
   const blacklist = [mountElement, currentElement, ...elementsToExclude];
-  [].forEach.call(container.children, element => {
+  [].forEach.call(container.children, (element) => {
     const isNotExcludedElement = blacklist.indexOf(element) === -1;
     const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
     if (isNotExcludedElement && isNotForbiddenElement) {
@@ -56,28 +87,36 @@ function findIndexOf(items, callback) {
 }
 function handleContainer(containerInfo, props) {
   const restoreStyle = [];
-  const container = containerInfo.container;
+  const container = props.scrollContainer || containerInfo.container;
   if (!props.disableScrollLock) {
     if (isOverflowing(container)) {
       // Compute the size before applying overflow hidden to avoid any scroll jumps.
-      const scrollbarSize = (0, _utils.unstable_getScrollbarSize)((0, _utils.unstable_ownerDocument)(container));
+      const scrollbarSize = (0, _utils.unstable_getScrollbarSize)(
+        (0, _utils.unstable_ownerDocument)(container)
+      );
       restoreStyle.push({
         value: container.style.paddingRight,
-        property: 'padding-right',
-        el: container
+        property: "padding-right",
+        el: container,
       });
       // Use computed style, here to get the real padding to add our scrollbar width.
-      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
+      container.style.paddingRight = `${
+        getPaddingRight(container) + scrollbarSize
+      }px`;
 
       // .mui-fixed is a global helper.
-      const fixedElements = (0, _utils.unstable_ownerDocument)(container).querySelectorAll('.mui-fixed');
-      [].forEach.call(fixedElements, element => {
+      const fixedElements = (0, _utils.unstable_ownerDocument)(
+        container
+      ).querySelectorAll(".mui-fixed");
+      [].forEach.call(fixedElements, (element) => {
         restoreStyle.push({
           value: element.style.paddingRight,
-          property: 'padding-right',
-          el: element
+          property: "padding-right",
+          el: element,
         });
-        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
+        element.style.paddingRight = `${
+          getPaddingRight(element) + scrollbarSize
+        }px`;
       });
     }
     let scrollContainer;
@@ -88,32 +127,36 @@ function handleContainer(containerInfo, props) {
       // https://css-tricks.com/snippets/css/force-vertical-scrollbar/
       const parent = container.parentElement;
       const containerWindow = (0, _utils.unstable_ownerWindow)(container);
-      scrollContainer = (parent == null ? void 0 : parent.nodeName) === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;
+      scrollContainer =
+        (parent == null ? void 0 : parent.nodeName) === "HTML" &&
+        containerWindow.getComputedStyle(parent).overflowY === "scroll"
+          ? parent
+          : container;
     }
 
     // Block the scroll even if no scrollbar is visible to account for mobile keyboard
     // screensize shrink.
-    restoreStyle.push({
-      value: scrollContainer.style.overflow,
-      property: 'overflow',
-      el: scrollContainer
-    }, {
-      value: scrollContainer.style.overflowX,
-      property: 'overflow-x',
-      el: scrollContainer
-    }, {
-      value: scrollContainer.style.overflowY,
-      property: 'overflow-y',
-      el: scrollContainer
-    });
-    scrollContainer.style.overflow = 'hidden';
+    restoreStyle.push(
+      {
+        value: scrollContainer.style.overflow,
+        property: "overflow",
+        el: scrollContainer,
+      },
+      {
+        value: scrollContainer.style.overflowX,
+        property: "overflow-x",
+        el: scrollContainer,
+      },
+      {
+        value: scrollContainer.style.overflowY,
+        property: "overflow-y",
+        el: scrollContainer,
+      }
+    );
+    scrollContainer.style.overflow = "hidden";
   }
   const restore = () => {
-    restoreStyle.forEach(({
-      value,
-      el,
-      property
-    }) => {
+    restoreStyle.forEach(({ value, el, property }) => {
       if (value) {
         el.style.setProperty(property, value);
       } else {
@@ -125,8 +168,8 @@ function handleContainer(containerInfo, props) {
 }
 function getHiddenSiblings(container) {
   const hiddenSiblings = [];
-  [].forEach.call(container.children, element => {
-    if (element.getAttribute('aria-hidden') === 'true') {
+  [].forEach.call(container.children, (element) => {
+    if (element.getAttribute("aria-hidden") === "true") {
       hiddenSiblings.push(element);
     }
   });
@@ -159,8 +202,17 @@ class ModalManager {
       ariaHidden(modal.modalRef, false);
     }
     const hiddenSiblings = getHiddenSiblings(container);
-    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
-    const containerIndex = findIndexOf(this.containers, item => item.container === container);
+    ariaHiddenSiblings(
+      container,
+      modal.mount,
+      modal.modalRef,
+      hiddenSiblings,
+      true
+    );
+    const containerIndex = findIndexOf(
+      this.containers,
+      (item) => item.container === container
+    );
     if (containerIndex !== -1) {
       this.containers[containerIndex].modals.push(modal);
       return modalIndex;
@@ -169,12 +221,15 @@ class ModalManager {
       modals: [modal],
       container,
       restore: null,
-      hiddenSiblings
+      hiddenSiblings,
     });
     return modalIndex;
   }
   mount(modal, props) {
-    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);
+    const containerIndex = findIndexOf(
+      this.containers,
+      (item) => item.modals.indexOf(modal) !== -1
+    );
     const containerInfo = this.containers[containerIndex];
     if (!containerInfo.restore) {
       containerInfo.restore = handleContainer(containerInfo, props);
@@ -185,7 +240,10 @@ class ModalManager {
     if (modalIndex === -1) {
       return modalIndex;
     }
-    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);
+    const containerIndex = findIndexOf(
+      this.containers,
+      (item) => item.modals.indexOf(modal) !== -1
+    );
     const containerInfo = this.containers[containerIndex];
     containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
     this.modals.splice(modalIndex, 1);
@@ -200,7 +258,13 @@ class ModalManager {
         // In case the modal wasn't in the DOM yet.
         ariaHidden(modal.modalRef, ariaHiddenState);
       }
-      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
+      ariaHiddenSiblings(
+        containerInfo.container,
+        modal.mount,
+        modal.modalRef,
+        containerInfo.hiddenSiblings,
+        false
+      );
       this.containers.splice(containerIndex, 1);
     } else {
       // Otherwise make sure the next top modal is visible to a screen reader.
@@ -215,7 +279,9 @@ class ModalManager {
     return modalIndex;
   }
   isTopModal(modal) {
-    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
+    return (
+      this.modals.length > 0 && this.modals[this.modals.length - 1] === modal
+    );
   }
 }
 exports.ModalManager = ModalManager;
\ No newline at end of file
diff --git a/unstable_useModal/ModalManager.d.ts b/unstable_useModal/ModalManager.d.ts
index 478880941a013db273ae72c30f5b3dd3607dde82..993e2d6ae075b9bebb9aedfac6a3e2c93cbdcc39 100644
--- a/unstable_useModal/ModalManager.d.ts
+++ b/unstable_useModal/ModalManager.d.ts
@@ -1,10 +1,11 @@
 export interface ManagedModalProps {
-    disableScrollLock?: boolean;
+  disableScrollLock?: boolean;
+  scrollContainer?: Element;
 }
 export declare function ariaHidden(element: Element, show: boolean): void;
 interface Modal {
-    mount: Element;
-    modalRef: Element;
+  mount: Element;
+  modalRef: Element;
 }
 /**
  * @ignore - do not document.
@@ -14,12 +15,12 @@ interface Modal {
  * Used by the Modal to ensure proper styling of containers.
  */
 export declare class ModalManager {
-    private containers;
-    private modals;
-    constructor();
-    add(modal: Modal, container: HTMLElement): number;
-    mount(modal: Modal, props: ManagedModalProps): void;
-    remove(modal: Modal, ariaHiddenState?: boolean): number;
-    isTopModal(modal: Modal): boolean;
+  private containers;
+  private modals;
+  constructor();
+  add(modal: Modal, container: HTMLElement): number;
+  mount(modal: Modal, props: ManagedModalProps): void;
+  remove(modal: Modal, ariaHiddenState?: boolean): number;
+  isTopModal(modal: Modal): boolean;
 }
 export {};
diff --git a/unstable_useModal/ModalManager.js b/unstable_useModal/ModalManager.js
index 5c7d9c687f778138caf72126abe68e81679474a6..ee2912320fd759ada516238cd3829d7ccd9ec2dc 100644
--- a/unstable_useModal/ModalManager.js
+++ b/unstable_useModal/ModalManager.js
@@ -1,4 +1,8 @@
-import { unstable_ownerWindow as ownerWindow, unstable_ownerDocument as ownerDocument, unstable_getScrollbarSize as getScrollbarSize } from '@mui/utils';
+import {
+  unstable_ownerWindow as ownerWindow,
+  unstable_ownerDocument as ownerDocument,
+  unstable_getScrollbarSize as getScrollbarSize,
+} from "@mui/utils";
 // Is a vertical scrollbar displayed?
 function isOverflowing(container) {
   const doc = ownerDocument(container);
@@ -9,26 +13,51 @@ function isOverflowing(container) {
 }
 export function ariaHidden(element, show) {
   if (show) {
-    element.setAttribute('aria-hidden', 'true');
+    element.setAttribute("aria-hidden", "true");
   } else {
-    element.removeAttribute('aria-hidden');
+    element.removeAttribute("aria-hidden");
   }
 }
 function getPaddingRight(element) {
-  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
+  return (
+    parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) ||
+    0
+  );
 }
 function isAriaHiddenForbiddenOnElement(element) {
   // The forbidden HTML tags are the ones from ARIA specification that
   // can be children of body and can't have aria-hidden attribute.
   // cf. https://www.w3.org/TR/html-aria/#docconformance
-  const forbiddenTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'];
+  const forbiddenTagNames = [
+    "TEMPLATE",
+    "SCRIPT",
+    "STYLE",
+    "LINK",
+    "MAP",
+    "META",
+    "NOSCRIPT",
+    "PICTURE",
+    "COL",
+    "COLGROUP",
+    "PARAM",
+    "SLOT",
+    "SOURCE",
+    "TRACK",
+  ];
   const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
-  const isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';
+  const isInputHidden =
+    element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
   return isForbiddenTagName || isInputHidden;
 }
-function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
+function ariaHiddenSiblings(
+  container,
+  mountElement,
+  currentElement,
+  elementsToExclude,
+  show
+) {
   const blacklist = [mountElement, currentElement, ...elementsToExclude];
-  [].forEach.call(container.children, element => {
+  [].forEach.call(container.children, (element) => {
     const isNotExcludedElement = blacklist.indexOf(element) === -1;
     const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
     if (isNotExcludedElement && isNotForbiddenElement) {
@@ -49,64 +78,75 @@ function findIndexOf(items, callback) {
 }
 function handleContainer(containerInfo, props) {
   const restoreStyle = [];
-  const container = containerInfo.container;
+  const container = props.scrollContainer || containerInfo.container;
   if (!props.disableScrollLock) {
     if (isOverflowing(container)) {
       // Compute the size before applying overflow hidden to avoid any scroll jumps.
       const scrollbarSize = getScrollbarSize(ownerDocument(container));
       restoreStyle.push({
         value: container.style.paddingRight,
-        property: 'padding-right',
-        el: container
+        property: "padding-right",
+        el: container,
       });
       // Use computed style, here to get the real padding to add our scrollbar width.
-      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
+      container.style.paddingRight = `${
+        getPaddingRight(container) + scrollbarSize
+      }px`;
 
       // .mui-fixed is a global helper.
-      const fixedElements = ownerDocument(container).querySelectorAll('.mui-fixed');
-      [].forEach.call(fixedElements, element => {
+      const fixedElements =
+        ownerDocument(container).querySelectorAll(".mui-fixed");
+      [].forEach.call(fixedElements, (element) => {
         restoreStyle.push({
           value: element.style.paddingRight,
-          property: 'padding-right',
-          el: element
+          property: "padding-right",
+          el: element,
         });
-        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
+        element.style.paddingRight = `${
+          getPaddingRight(element) + scrollbarSize
+        }px`;
       });
     }
     let scrollContainer;
-    if (container.parentNode instanceof DocumentFragment) {
+    if (props.container) {
+      scrollContainer = props.scrollContainer;
+    } else if (container.parentNode instanceof DocumentFragment) {
       scrollContainer = ownerDocument(container).body;
     } else {
       // Support html overflow-y: auto for scroll stability between pages
       // https://css-tricks.com/snippets/css/force-vertical-scrollbar/
       const parent = container.parentElement;
       const containerWindow = ownerWindow(container);
-      scrollContainer = (parent == null ? void 0 : parent.nodeName) === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;
+      scrollContainer =
+        (parent == null ? void 0 : parent.nodeName) === "HTML" &&
+        containerWindow.getComputedStyle(parent).overflowY === "scroll"
+          ? parent
+          : container;
     }
 
     // Block the scroll even if no scrollbar is visible to account for mobile keyboard
     // screensize shrink.
-    restoreStyle.push({
-      value: scrollContainer.style.overflow,
-      property: 'overflow',
-      el: scrollContainer
-    }, {
-      value: scrollContainer.style.overflowX,
-      property: 'overflow-x',
-      el: scrollContainer
-    }, {
-      value: scrollContainer.style.overflowY,
-      property: 'overflow-y',
-      el: scrollContainer
-    });
-    scrollContainer.style.overflow = 'hidden';
+    restoreStyle.push(
+      {
+        value: scrollContainer.style.overflow,
+        property: "overflow",
+        el: scrollContainer,
+      },
+      {
+        value: scrollContainer.style.overflowX,
+        property: "overflow-x",
+        el: scrollContainer,
+      },
+      {
+        value: scrollContainer.style.overflowY,
+        property: "overflow-y",
+        el: scrollContainer,
+      }
+    );
+    scrollContainer.style.overflow = "hidden";
   }
   const restore = () => {
-    restoreStyle.forEach(({
-      value,
-      el,
-      property
-    }) => {
+    restoreStyle.forEach(({ value, el, property }) => {
       if (value) {
         el.style.setProperty(property, value);
       } else {
@@ -118,8 +158,8 @@ function handleContainer(containerInfo, props) {
 }
 function getHiddenSiblings(container) {
   const hiddenSiblings = [];
-  [].forEach.call(container.children, element => {
-    if (element.getAttribute('aria-hidden') === 'true') {
+  [].forEach.call(container.children, (element) => {
+    if (element.getAttribute("aria-hidden") === "true") {
       hiddenSiblings.push(element);
     }
   });
@@ -152,8 +192,17 @@ export class ModalManager {
       ariaHidden(modal.modalRef, false);
     }
     const hiddenSiblings = getHiddenSiblings(container);
-    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
-    const containerIndex = findIndexOf(this.containers, item => item.container === container);
+    ariaHiddenSiblings(
+      container,
+      modal.mount,
+      modal.modalRef,
+      hiddenSiblings,
+      true
+    );
+    const containerIndex = findIndexOf(
+      this.containers,
+      (item) => item.container === container
+    );
     if (containerIndex !== -1) {
       this.containers[containerIndex].modals.push(modal);
       return modalIndex;
@@ -162,12 +211,15 @@ export class ModalManager {
       modals: [modal],
       container,
       restore: null,
-      hiddenSiblings
+      hiddenSiblings,
     });
     return modalIndex;
   }
   mount(modal, props) {
-    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);
+    const containerIndex = findIndexOf(
+      this.containers,
+      (item) => item.modals.indexOf(modal) !== -1
+    );
     const containerInfo = this.containers[containerIndex];
     if (!containerInfo.restore) {
       containerInfo.restore = handleContainer(containerInfo, props);
@@ -178,7 +230,10 @@ export class ModalManager {
     if (modalIndex === -1) {
       return modalIndex;
     }
-    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);
+    const containerIndex = findIndexOf(
+      this.containers,
+      (item) => item.modals.indexOf(modal) !== -1
+    );
     const containerInfo = this.containers[containerIndex];
     containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
     this.modals.splice(modalIndex, 1);
@@ -193,7 +248,13 @@ export class ModalManager {
         // In case the modal wasn't in the DOM yet.
         ariaHidden(modal.modalRef, ariaHiddenState);
       }
-      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
+      ariaHiddenSiblings(
+        containerInfo.container,
+        modal.mount,
+        modal.modalRef,
+        containerInfo.hiddenSiblings,
+        false
+      );
       this.containers.splice(containerIndex, 1);
     } else {
       // Otherwise make sure the next top modal is visible to a screen reader.
@@ -208,6 +269,8 @@ export class ModalManager {
     return modalIndex;
   }
   isTopModal(modal) {
-    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
+    return (
+      this.modals.length > 0 && this.modals[this.modals.length - 1] === modal
+    );
   }
 }
\ No newline at end of file
diff --git a/unstable_useModal/useModal.js b/unstable_useModal/useModal.js
index 70f1af1d3514fc4b77b482511b0de5da0375f701..4b9615636ab338117af167a1f2d07ef61413d6a2 100644
--- a/unstable_useModal/useModal.js
+++ b/unstable_useModal/useModal.js
@@ -1,15 +1,20 @@
-'use client';
+"use client";
 
 import _extends from "@babel/runtime/helpers/esm/extends";
-import * as React from 'react';
-import { unstable_ownerDocument as ownerDocument, unstable_useForkRef as useForkRef, unstable_useEventCallback as useEventCallback, unstable_createChainedFunction as createChainedFunction } from '@mui/utils';
-import { extractEventHandlers } from '../utils';
-import { ModalManager, ariaHidden } from './ModalManager';
+import * as React from "react";
+import {
+  unstable_ownerDocument as ownerDocument,
+  unstable_useForkRef as useForkRef,
+  unstable_useEventCallback as useEventCallback,
+  unstable_createChainedFunction as createChainedFunction,
+} from "@mui/utils";
+import { extractEventHandlers } from "../utils";
+import { ModalManager, ariaHidden } from "./ModalManager";
 function getContainer(container) {
-  return typeof container === 'function' ? container() : container;
+  return typeof container === "function" ? container() : container;
 }
 function getHasTransition(children) {
-  return children ? children.props.hasOwnProperty('in') : false;
+  return children ? children.props.hasOwnProperty("in") : false;
 }
 
 // A modal manager used to track and manage the state of open Modals.
@@ -38,7 +43,8 @@ export function useModal(parameters) {
     children,
     onClose,
     open,
-    rootRef
+    rootRef,
+    scrollContainer,
   } = parameters;
 
   // @ts-ignore internal logic
@@ -49,7 +55,10 @@ export function useModal(parameters) {
   const [exited, setExited] = React.useState(!open);
   const hasTransition = getHasTransition(children);
   let ariaHiddenProp = true;
-  if (parameters['aria-hidden'] === 'false' || parameters['aria-hidden'] === false) {
+  if (
+    parameters["aria-hidden"] === "false" ||
+    parameters["aria-hidden"] === false
+  ) {
     ariaHiddenProp = false;
   }
   const getDoc = () => ownerDocument(mountNodeRef.current);
@@ -60,7 +69,8 @@ export function useModal(parameters) {
   };
   const handleMounted = () => {
     manager.mount(getModal(), {
-      disableScrollLock
+      disableScrollLock,
+      scrollContainer,
     });
 
     // Fix a bug on Chrome where the scroll isn't initially 0.
@@ -77,8 +87,11 @@ export function useModal(parameters) {
       handleMounted();
     }
   });
-  const isTopModal = React.useCallback(() => manager.isTopModal(getModal()), [manager]);
-  const handlePortalRef = useEventCallback(node => {
+  const isTopModal = React.useCallback(
+    () => manager.isTopModal(getModal()),
+    [manager]
+  );
+  const handlePortalRef = useEventCallback((node) => {
     mountNodeRef.current = node;
     if (!node) {
       return;
@@ -104,9 +117,10 @@ export function useModal(parameters) {
       handleClose();
     }
   }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
-  const createHandleKeyDown = otherHandlers => event => {
+  const createHandleKeyDown = (otherHandlers) => (event) => {
     var _otherHandlers$onKeyD;
-    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
+    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ||
+      _otherHandlers$onKeyD.call(otherHandlers, event);
 
     // The handler doesn't take event.defaultPrevented into account:
     //
@@ -114,27 +128,31 @@ export function useModal(parameters) {
     // clicking a checkbox to check it, hitting a button to submit a form,
     // and hitting left arrow to move the cursor in a text input etc.
     // Only special HTML elements have these default behaviors.
-    if (event.key !== 'Escape' || event.which === 229 ||
-    // Wait until IME is settled.
-    !isTopModal()) {
+    if (
+      event.key !== "Escape" ||
+      event.which === 229 ||
+      // Wait until IME is settled.
+      !isTopModal()
+    ) {
       return;
     }
     if (!disableEscapeKeyDown) {
       // Swallow the event, in case someone is listening for the escape key on the body.
       event.stopPropagation();
       if (onClose) {
-        onClose(event, 'escapeKeyDown');
+        onClose(event, "escapeKeyDown");
       }
     }
   };
-  const createHandleBackdropClick = otherHandlers => event => {
+  const createHandleBackdropClick = (otherHandlers) => (event) => {
     var _otherHandlers$onClic;
-    (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
+    (_otherHandlers$onClic = otherHandlers.onClick) == null ||
+      _otherHandlers$onClic.call(otherHandlers, event);
     if (event.target !== event.currentTarget) {
       return;
     }
     if (onClose) {
-      onClose(event, 'backdropClick');
+      onClose(event, "backdropClick");
     }
   };
   const getRootProps = (otherHandlers = {}) => {
@@ -143,22 +161,34 @@ export function useModal(parameters) {
     // The custom event handlers shouldn't be spread on the root element
     delete propsEventHandlers.onTransitionEnter;
     delete propsEventHandlers.onTransitionExited;
-    const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);
-    return _extends({
-      role: 'presentation'
-    }, externalEventHandlers, {
-      onKeyDown: createHandleKeyDown(externalEventHandlers),
-      ref: handleRef
-    });
+    const externalEventHandlers = _extends(
+      {},
+      propsEventHandlers,
+      otherHandlers
+    );
+    return _extends(
+      {
+        role: "presentation",
+      },
+      externalEventHandlers,
+      {
+        onKeyDown: createHandleKeyDown(externalEventHandlers),
+        ref: handleRef,
+      }
+    );
   };
   const getBackdropProps = (otherHandlers = {}) => {
     const externalEventHandlers = otherHandlers;
-    return _extends({
-      'aria-hidden': true
-    }, externalEventHandlers, {
-      onClick: createHandleBackdropClick(externalEventHandlers),
-      open
-    });
+    return _extends(
+      {
+        "aria-hidden": true,
+      },
+      externalEventHandlers,
+      {
+        onClick: createHandleBackdropClick(externalEventHandlers),
+        open,
+      }
+    );
   };
   const getTransitionProps = () => {
     const handleEnter = () => {
@@ -177,8 +207,14 @@ export function useModal(parameters) {
       }
     };
     return {
-      onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
-      onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
+      onEnter: createChainedFunction(
+        handleEnter,
+        children == null ? void 0 : children.props.onEnter
+      ),
+      onExited: createChainedFunction(
+        handleExited,
+        children == null ? void 0 : children.props.onExited
+      ),
     };
   };
   return {
@@ -189,6 +225,6 @@ export function useModal(parameters) {
     portalRef: handlePortalRef,
     isTopModal,
     exited,
-    hasTransition
+    hasTransition,
   };
 }
