diff --git a/dist/core/current.d.ts.map b/dist/core/current.d.ts.map
index c11f63b948db4b459cdd1e2508f8324986476279..d5579ec07ad02b01baf5542b5040de5481360996 100644
--- a/dist/core/current.d.ts.map
+++ b/dist/core/current.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"current.d.ts","sourceRoot":"","sources":["../src/core/current.ts"],"names":[],"mappings":"AAeA,mQAAmQ;AACnQ,wBAAgB,OAAO,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,CAAC,CAAA"}
\ No newline at end of file
+{"version":3,"file":"current.d.ts","sourceRoot":"","sources":["../src/core/current.ts"],"names":[],"mappings":"AAEC,mQAAmQ;AACpQ,wBAAgB,OAAO,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,CAAC,CAAC"}
\ No newline at end of file
diff --git a/dist/core/finalize.d.ts b/dist/core/finalize.d.ts
index 58c33caba64ab54e564fad4c791abcb0b82b6d07..218df9fbab784d0795b9ce699ce01924941f7eaa 100644
--- a/dist/core/finalize.d.ts
+++ b/dist/core/finalize.d.ts
@@ -1,3 +1,3 @@
-import { ImmerScope } from "../internal";
+import { ImmerScope } from "../internal.js";
 export declare function processResult(result: any, scope: ImmerScope): any;
 //# sourceMappingURL=finalize.d.ts.map
\ No newline at end of file
diff --git a/dist/core/finalize.d.ts.map b/dist/core/finalize.d.ts.map
index 1839854105872f8036ed0906fa7de7d88707798e..be4b56fc1ef03d77bdcb9d261a67467e250d53c8 100644
--- a/dist/core/finalize.d.ts.map
+++ b/dist/core/finalize.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"finalize.d.ts","sourceRoot":"","sources":["../src/core/finalize.ts"],"names":[],"mappings":"AAAA,OAAO,EACN,UAAU,EAkBV,MAAM,aAAa,CAAA;AAEpB,wBAAgB,aAAa,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,UAAU,OAiC3D"}
\ No newline at end of file
+{"version":3,"file":"finalize.d.ts","sourceRoot":"","sources":["../src/core/finalize.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAsK,MAAM,gBAAgB,CAAC;AAE/M,wBAAgB,aAAa,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,UAAU,OA8B5D"}
\ No newline at end of file
diff --git a/dist/core/immerClass.d.ts b/dist/core/immerClass.d.ts
index 27a4e713fb7dc636ec26b6c2fef9ea7c2cd3d845..5f0d40b3f8c41ecbc73336607793a2336dc446c0 100644
--- a/dist/core/immerClass.d.ts
+++ b/dist/core/immerClass.d.ts
@@ -1,4 +1,4 @@
-import { IProduceWithPatches, IProduce, ImmerState, Drafted, Patch, Objectish, Draft, PatchListener } from "../internal";
+import { IProduceWithPatches, IProduce, ImmerState, Drafted, Patch, Objectish, Draft, PatchListener } from "../internal.js";
 interface ProducersFns {
     produce: IProduce;
     produceWithPatches: IProduceWithPatches;
@@ -11,40 +11,40 @@ export declare class Immer implements ProducersFns {
         autoFreeze?: boolean;
     });
     /**
-     * The `produce` function takes a value and a "recipe function" (whose
-     * return value often depends on the base state). The recipe function is
-     * free to mutate its first argument however it wants. All mutations are
-     * only ever applied to a __copy__ of the base state.
-     *
-     * Pass only a function to create a "curried producer" which relieves you
-     * from passing the recipe function every time.
-     *
-     * Only plain objects and arrays are made mutable. All other objects are
-     * considered uncopyable.
-     *
-     * Note: This function is __bound__ to its `Immer` instance.
-     *
-     * @param {any} base - the initial state
-     * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
-     * @param {Function} patchListener - optional function that will be called with all the patches produced here
-     * @returns {any} a new state, or the initial state if nothing was modified
-     */
+            * The `produce` function takes a value and a "recipe function" (whose
+            * return value often depends on the base state). The recipe function is
+            * free to mutate its first argument however it wants. All mutations are
+            * only ever applied to a __copy__ of the base state.
+            *
+            * Pass only a function to create a "curried producer" which relieves you
+            * from passing the recipe function every time.
+            *
+            * Only plain objects and arrays are made mutable. All other objects are
+            * considered uncopyable.
+            *
+            * Note: This function is __bound__ to its `Immer` instance.
+            *
+            * @param {any} base - the initial state
+            * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+            * @param {Function} patchListener - optional function that will be called with all the patches produced here
+            * @returns {any} a new state, or the initial state if nothing was modified
+            */
     produce: IProduce;
     produceWithPatches: IProduceWithPatches;
     createDraft<T extends Objectish>(base: T): Draft<T>;
     finishDraft<D extends Draft<any>>(draft: D, patchListener?: PatchListener): D extends Draft<infer T> ? T : never;
     /**
-     * Pass true to automatically freeze all copies created by Immer.
-     *
-     * By default, auto-freezing is enabled.
-     */
+            * Pass true to automatically freeze all copies created by Immer.
+            *
+            * By default, auto-freezing is enabled.
+            */
     setAutoFreeze(value: boolean): void;
     /**
-     * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
-     * always faster than using ES5 proxies.
-     *
-     * By default, feature detection is used, so calling this is rarely necessary.
-     */
+            * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+            * always faster than using ES5 proxies.
+            *
+            * By default, feature detection is used, so calling this is rarely necessary.
+            */
     setUseProxies(value: boolean): void;
     applyPatches<T extends Objectish>(base: T, patches: Patch[]): T;
 }
diff --git a/dist/core/immerClass.d.ts.map b/dist/core/immerClass.d.ts.map
index 64c4cb28d649642833841835b29997074101e960..e870e217ccc9927569991a11cdf1ffba48c68382 100644
--- a/dist/core/immerClass.d.ts.map
+++ b/dist/core/immerClass.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"immerClass.d.ts","sourceRoot":"","sources":["../src/core/immerClass.ts"],"names":[],"mappings":"AAAA,OAAO,EACN,mBAAmB,EACnB,QAAQ,EACR,UAAU,EACV,OAAO,EAGP,KAAK,EACL,SAAS,EAET,KAAK,EACL,aAAa,EAgBb,MAAM,aAAa,CAAA;AAEpB,UAAU,YAAY;IACrB,OAAO,EAAE,QAAQ,CAAA;IACjB,kBAAkB,EAAE,mBAAmB,CAAA;CACvC;AAED,qBAAa,KAAM,YAAW,YAAY;IACzC,WAAW,EAAE,OAAO,CAAa;IAEjC,WAAW,EAAE,OAAO,CAAO;gBAEf,MAAM,CAAC,EAAE;QAAC,UAAU,CAAC,EAAE,OAAO,CAAC;QAAC,UAAU,CAAC,EAAE,OAAO,CAAA;KAAC;IAOjE;;;;;;;;;;;;;;;;;;OAkBG;IACH,OAAO,EAAE,QAAQ,CA8DhB;IAED,kBAAkB,EAAE,mBAAmB,CAoBtC;IAED,WAAW,CAAC,CAAC,SAAS,SAAS,EAAE,IAAI,EAAE,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;IAUnD,WAAW,CAAC,CAAC,SAAS,KAAK,CAAC,GAAG,CAAC,EAC/B,KAAK,EAAE,CAAC,EACR,aAAa,CAAC,EAAE,aAAa,GAC3B,CAAC,SAAS,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,KAAK;IAWvC;;;;OAIG;IACH,aAAa,CAAC,KAAK,EAAE,OAAO;IAI5B;;;;;OAKG;IACH,aAAa,CAAC,KAAK,EAAE,OAAO;IAO5B,YAAY,CAAC,CAAC,SAAS,SAAS,EAAE,IAAI,EAAE,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,CAAC;CA2B/D;AAED,wBAAgB,WAAW,CAAC,CAAC,SAAS,SAAS,EAC9C,KAAK,EAAE,KAAK,EACZ,KAAK,EAAE,CAAC,EACR,MAAM,CAAC,EAAE,UAAU,GACjB,OAAO,CAAC,CAAC,EAAE,UAAU,CAAC,CAaxB"}
\ No newline at end of file
+{"version":3,"file":"immerClass.d.ts","sourceRoot":"","sources":["../src/core/immerClass.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,mBAAmB,EAAE,QAAQ,EAAE,UAAU,EAAE,OAAO,EAA8B,KAAK,EAAE,SAAS,EAAe,KAAK,EAAE,aAAa,EAA0K,MAAM,gBAAgB,CAAC;AAE5U,UAAU,YAAY;IACnB,OAAO,EAAE,QAAQ,CAAC;IAClB,kBAAkB,EAAE,mBAAmB,CAAC;CAC3C;AAEA,qBAAa,KAAM,YAAW,YAAY;IACvC,WAAW,EAAE,OAAO,CAAc;IAErC,WAAW,EAAE,OAAO,CAAQ;gBAEhB,MAAM,CAAC,EAAE;QACd,UAAU,CAAC,EAAE,OAAO,CAAC;QACrB,UAAU,CAAC,EAAE,OAAO,CAAC;KACxB;IAOJ;;;;;;;;;;;;;;;;;;cAkBU;IACP,OAAO,EAAE,QAAQ,CAiEf;IAEL,kBAAkB,EAAE,mBAAmB,CAgBlC;IAEL,WAAW,CAAC,CAAC,SAAS,SAAS,EAAE,IAAI,EAAE,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;IAYnD,WAAW,CAAC,CAAC,SAAS,KAAK,CAAC,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,aAAa,CAAC,EAAE,aAAa,GAAG,CAAC,SAAS,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,KAAK;IAahH;;;;cAIU;IACP,aAAa,CAAC,KAAK,EAAE,OAAO;IAI/B;;;;;cAKU;IACP,aAAa,CAAC,KAAK,EAAE,OAAO;IAO/B,YAAY,CAAC,CAAC,SAAS,SAAS,EAAE,IAAI,EAAE,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,CAAC;CAyB/D;AAEA,wBAAgB,WAAW,CAAC,CAAC,SAAS,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE,MAAM,CAAC,EAAE,UAAU,GAAG,OAAO,CAAC,CAAC,EAAE,UAAU,CAAC,CAarH"}
\ No newline at end of file
diff --git a/dist/core/proxy.d.ts b/dist/core/proxy.d.ts
index 077eb9ca149d69f22b66344cf9ebf87d149bd499..a78feba2cafb964239aaad2786736f2b56f3a204 100644
--- a/dist/core/proxy.d.ts
+++ b/dist/core/proxy.d.ts
@@ -1,4 +1,4 @@
-import { ImmerBaseState, ImmerState, Drafted, AnyObject, AnyArray, Objectish, ProxyType } from "../internal";
+import { ImmerBaseState, ImmerState, Drafted, AnyObject, AnyArray, Objectish, ProxyType } from "../internal.js";
 interface ProxyBaseState extends ImmerBaseState {
     assigned_: {
         [property: string]: boolean;
@@ -20,14 +20,14 @@ export interface ProxyArrayState extends ProxyBaseState {
 }
 declare type ProxyState = ProxyObjectState | ProxyArrayState;
 /**
- * Returns a new draft of the `base` object.
- *
- * The second argument is the parent draft-state (used internally).
- */
+* Returns a new draft of the `base` object.
+*
+* The second argument is the parent draft-state (used internally).
+*/
 export declare function createProxyProxy<T extends Objectish>(base: T, parent?: ImmerState): Drafted<T, ProxyState>;
 /**
- * Object drafts
- */
+* Object drafts
+*/
 export declare const objectTraps: ProxyHandler<ProxyState>;
 export declare function markChanged(state: ImmerState): void;
 export declare function prepareCopy(state: {
diff --git a/dist/core/proxy.d.ts.map b/dist/core/proxy.d.ts.map
index c5861a635a5114c1d8042d38d6e1ac4617f59dc3..9ebd9d82b51253bcabf3374ada025e985fea11e7 100644
--- a/dist/core/proxy.d.ts.map
+++ b/dist/core/proxy.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"proxy.d.ts","sourceRoot":"","sources":["../src/core/proxy.ts"],"names":[],"mappings":"AAAA,OAAO,EAON,cAAc,EACd,UAAU,EACV,OAAO,EACP,SAAS,EACT,QAAQ,EACR,SAAS,EAKT,SAAS,EACT,MAAM,aAAa,CAAA;AAEpB,UAAU,cAAe,SAAQ,cAAc;IAC9C,SAAS,EAAE;QACV,CAAC,QAAQ,EAAE,MAAM,GAAG,OAAO,CAAA;KAC3B,CAAA;IACD,OAAO,CAAC,EAAE,UAAU,CAAA;IACpB,OAAO,IAAI,IAAI,CAAA;CACf;AAED,MAAM,WAAW,gBAAiB,SAAQ,cAAc;IACvD,KAAK,EAAE,SAAS,CAAC,WAAW,CAAA;IAC5B,KAAK,EAAE,GAAG,CAAA;IACV,KAAK,EAAE,GAAG,CAAA;IACV,MAAM,EAAE,OAAO,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAA;CAC5C;AAED,MAAM,WAAW,eAAgB,SAAQ,cAAc;IACtD,KAAK,EAAE,SAAS,CAAC,UAAU,CAAA;IAC3B,KAAK,EAAE,QAAQ,CAAA;IACf,KAAK,EAAE,QAAQ,GAAG,IAAI,CAAA;IACtB,MAAM,EAAE,OAAO,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAA;CAC1C;AAED,aAAK,UAAU,GAAG,gBAAgB,GAAG,eAAe,CAAA;AAEpD;;;;GAIG;AACH,wBAAgB,gBAAgB,CAAC,CAAC,SAAS,SAAS,EACnD,IAAI,EAAE,CAAC,EACP,MAAM,CAAC,EAAE,UAAU,GACjB,OAAO,CAAC,CAAC,EAAE,UAAU,CAAC,CA0CxB;AAED;;GAEG;AACH,eAAO,MAAM,WAAW,EAAE,YAAY,CAAC,UAAU,CA8GhD,CAAA;AAyDD,wBAAgB,WAAW,CAAC,KAAK,EAAE,UAAU,QAO5C;AAED,wBAAgB,WAAW,CAAC,KAAK,EAAE;IAAC,KAAK,EAAE,GAAG,CAAC;IAAC,KAAK,EAAE,GAAG,CAAA;CAAC,QAI1D"}
\ No newline at end of file
+{"version":3,"file":"proxy.d.ts","sourceRoot":"","sources":["../src/core/proxy.ts"],"names":[],"mappings":"AAAA,OAAO,EAAmD,cAAc,EAAE,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAkD,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAEhN,UAAU,cAAe,SAAQ,cAAc;IAC5C,SAAS,EAAE;QACP,CAAC,QAAQ,EAAE,MAAM,GAAG,OAAO,CAAC;KAC/B,CAAC;IACF,OAAO,CAAC,EAAE,UAAU,CAAC;IACrB,OAAO,IAAI,IAAI,CAAC;CACnB;AAEA,MAAM,WAAW,gBAAiB,SAAQ,cAAc;IACrD,KAAK,EAAE,SAAS,CAAC,WAAW,CAAC;IAC7B,KAAK,EAAE,GAAG,CAAC;IACX,KAAK,EAAE,GAAG,CAAC;IACX,MAAM,EAAE,OAAO,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;CAChD;AAEA,MAAM,WAAW,eAAgB,SAAQ,cAAc;IACpD,KAAK,EAAE,SAAS,CAAC,UAAU,CAAC;IAC5B,KAAK,EAAE,QAAQ,CAAC;IAChB,KAAK,EAAE,QAAQ,GAAG,IAAI,CAAC;IACvB,MAAM,EAAE,OAAO,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAC;CAC9C;AAEA,aAAK,UAAU,GAAG,gBAAgB,GAAG,eAAe,CAAC;AAErD;;;;EAIE;AACH,wBAAgB,gBAAgB,CAAC,CAAC,SAAS,SAAS,EAAE,IAAI,EAAE,CAAC,EAAE,MAAM,CAAC,EAAE,UAAU,GAAG,OAAO,CAAC,CAAC,EAAE,UAAU,CAAC,CA0C1G;AAEA;;EAEE;AACH,eAAO,MAAM,WAAW,EAAE,YAAY,CAAC,UAAU,CAwGhD,CAAC;AA4DD,wBAAgB,WAAW,CAAC,KAAK,EAAE,UAAU,QAO7C;AAEA,wBAAgB,WAAW,CAAC,KAAK,EAAE;IAChC,KAAK,EAAE,GAAG,CAAC;IACX,KAAK,EAAE,GAAG,CAAC;CACd,QAIA"}
\ No newline at end of file
diff --git a/dist/core/scope.d.ts b/dist/core/scope.d.ts
index 8cbd5667ef574d15cea950987e65d67e31a38dde..da749621a6e2be184be67d80a1256e98c2bb78ba 100644
--- a/dist/core/scope.d.ts
+++ b/dist/core/scope.d.ts
@@ -1,4 +1,4 @@
-import { Patch, PatchListener, Immer } from "../internal";
+import { Patch, PatchListener, Immer } from "../internal.js";
 /** Each scope represents a `produce` call. */
 export interface ImmerScope {
     patches_?: Patch[];
diff --git a/dist/core/scope.d.ts.map b/dist/core/scope.d.ts.map
index 68fc8a3307db5c943dac466a4b16d895740a891e..917060b8b85616d55c89abc10931f226fb52eadf 100644
--- a/dist/core/scope.d.ts.map
+++ b/dist/core/scope.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"scope.d.ts","sourceRoot":"","sources":["../src/core/scope.ts"],"names":[],"mappings":"AAAA,OAAO,EACN,KAAK,EACL,aAAa,EAEb,KAAK,EAKL,MAAM,aAAa,CAAA;AAGpB,8CAA8C;AAE9C,MAAM,WAAW,UAAU;IAC1B,QAAQ,CAAC,EAAE,KAAK,EAAE,CAAA;IAClB,eAAe,CAAC,EAAE,KAAK,EAAE,CAAA;IACzB,cAAc,EAAE,OAAO,CAAA;IACvB,OAAO,EAAE,GAAG,EAAE,CAAA;IACd,OAAO,CAAC,EAAE,UAAU,CAAA;IACpB,cAAc,CAAC,EAAE,aAAa,CAAA;IAC9B,MAAM,EAAE,KAAK,CAAA;IACb,kBAAkB,EAAE,MAAM,CAAA;CAC1B;AAID,wBAAgB,eAAe,eAG9B;AAiBD,wBAAgB,iBAAiB,CAChC,KAAK,EAAE,UAAU,EACjB,aAAa,CAAC,EAAE,aAAa,QAQ7B;AAED,wBAAgB,WAAW,CAAC,KAAK,EAAE,UAAU,QAK5C;AAED,wBAAgB,UAAU,CAAC,KAAK,EAAE,UAAU,QAI3C;AAED,wBAAgB,UAAU,CAAC,KAAK,EAAE,KAAK,cAEtC"}
\ No newline at end of file
+{"version":3,"file":"scope.d.ts","sourceRoot":"","sources":["../src/core/scope.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,aAAa,EAAW,KAAK,EAAiD,MAAM,gBAAgB,CAAC;AAGpH,8CAA8C;AAE9C,MAAM,WAAW,UAAU;IACxB,QAAQ,CAAC,EAAE,KAAK,EAAE,CAAC;IACnB,eAAe,CAAC,EAAE,KAAK,EAAE,CAAC;IAC1B,cAAc,EAAE,OAAO,CAAC;IACxB,OAAO,EAAE,GAAG,EAAE,CAAC;IACf,OAAO,CAAC,EAAE,UAAU,CAAC;IACrB,cAAc,CAAC,EAAE,aAAa,CAAC;IAC/B,MAAM,EAAE,KAAK,CAAC;IACd,kBAAkB,EAAE,MAAM,CAAC;CAC9B;AAIA,wBAAgB,eAAe,eAI/B;AAcA,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,UAAU,EAAE,aAAa,CAAC,EAAE,aAAa,QAOlF;AAEA,wBAAgB,WAAW,CAAC,KAAK,EAAE,UAAU,QAK7C;AAEA,wBAAgB,UAAU,CAAC,KAAK,EAAE,UAAU,QAI5C;AAEA,wBAAgB,UAAU,CAAC,KAAK,EAAE,KAAK,cAEvC"}
\ No newline at end of file
diff --git a/dist/immer.cjs.development.js b/dist/immer.cjs.development.js
index 8cf1f091f27e3684064eccc8d3650bfa3e1fc259..690e9d43f34a8c5a3a9122b6570466128530413f 100644
--- a/dist/immer.cjs.development.js
+++ b/dist/immer.cjs.development.js
@@ -270,7 +270,17 @@ function freeze(obj, deep) {
   if (getArchtype(obj) > 1
   /* Map or Set */
   ) {
-      obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
+      var desc = {
+        configurable: true,
+        writable: true,
+        value: dontMutateFrozenCollections
+      };
+      Object.defineProperties(obj, {
+        set: desc,
+        add: desc,
+        clear: desc,
+        delete: desc
+      });
     }
 
   Object.freeze(obj);
@@ -491,10 +501,10 @@ function maybeFreeze(scope, value, deep) {
 }
 
 /**
- * Returns a new draft of the `base` object.
- *
- * The second argument is the parent draft-state (used internally).
- */
+* Returns a new draft of the `base` object.
+*
+* The second argument is the parent draft-state (used internally).
+*/
 
 function createProxyProxy(base, parent) {
   var isArray = Array.isArray(base);
@@ -547,8 +557,8 @@ function createProxyProxy(base, parent) {
   return proxy;
 }
 /**
- * Object drafts
- */
+* Object drafts
+*/
 
 var objectTraps = {
   get: function get(state, prop) {
@@ -611,9 +621,9 @@ var objectTraps = {
       markChanged(state);
     }
 
-    if (state.copy_[prop] === value && // special case: NaN
-    typeof value !== "number" && ( // special case: handle new props with value 'undefined'
-    value !== undefined || prop in state.copy_)) return true; // @ts-ignore
+    if (state.copy_[prop] === value && ( // special case: handle new props with value 'undefined'
+    value !== undefined || prop in state.copy_) || // special case: NaN
+    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true; // @ts-ignore
 
     state.copy_[prop] = value;
     state.assigned_[prop] = true;
@@ -660,8 +670,8 @@ var objectTraps = {
   }
 };
 /**
- * Array drafts
- */
+* Array drafts
+*/
 
 var arrayTraps = {};
 each(objectTraps, function (key, fn) {
@@ -737,24 +747,24 @@ function () {
     this.useProxies_ = hasProxies;
     this.autoFreeze_ = true;
     /**
-     * The `produce` function takes a value and a "recipe function" (whose
-     * return value often depends on the base state). The recipe function is
-     * free to mutate its first argument however it wants. All mutations are
-     * only ever applied to a __copy__ of the base state.
-     *
-     * Pass only a function to create a "curried producer" which relieves you
-     * from passing the recipe function every time.
-     *
-     * Only plain objects and arrays are made mutable. All other objects are
-     * considered uncopyable.
-     *
-     * Note: This function is __bound__ to its `Immer` instance.
-     *
-     * @param {any} base - the initial state
-     * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
-     * @param {Function} patchListener - optional function that will be called with all the patches produced here
-     * @returns {any} a new state, or the initial state if nothing was modified
-     */
+            * The `produce` function takes a value and a "recipe function" (whose
+            * return value often depends on the base state). The recipe function is
+            * free to mutate its first argument however it wants. All mutations are
+            * only ever applied to a __copy__ of the base state.
+            *
+            * Pass only a function to create a "curried producer" which relieves you
+            * from passing the recipe function every time.
+            *
+            * Only plain objects and arrays are made mutable. All other objects are
+            * considered uncopyable.
+            *
+            * Note: This function is __bound__ to its `Immer` instance.
+            *
+            * @param {any} base - the initial state
+            * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+            * @param {Function} patchListener - optional function that will be called with all the patches produced here
+            * @returns {any} a new state, or the initial state if nothing was modified
+            */
 
     this.produce = function (base, recipe, patchListener) {
       // curried invocation
@@ -886,21 +896,21 @@ function () {
     return processResult(undefined, scope);
   }
   /**
-   * Pass true to automatically freeze all copies created by Immer.
-   *
-   * By default, auto-freezing is enabled.
-   */
+          * Pass true to automatically freeze all copies created by Immer.
+          *
+          * By default, auto-freezing is enabled.
+          */
   ;
 
   _proto.setAutoFreeze = function setAutoFreeze(value) {
     this.autoFreeze_ = value;
   }
   /**
-   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
-   * always faster than using ES5 proxies.
-   *
-   * By default, feature detection is used, so calling this is rarely necessary.
-   */
+          * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+          * always faster than using ES5 proxies.
+          *
+          * By default, feature detection is used, so calling this is rarely necessary.
+          */
   ;
 
   _proto.setUseProxies = function setUseProxies(value) {
@@ -1273,6 +1283,434 @@ function enableES5() {
   });
 }
 
+// types only!
+function enableMapSet() {
+  /* istanbul ignore next */
+  var _extendStatics = function extendStatics(d, b) {
+    _extendStatics = Object.setPrototypeOf || {
+      __proto__: []
+    } instanceof Array && function (d, b) {
+      d.__proto__ = b;
+    } || function (d, b) {
+      for (var p in b) {
+        if (b.hasOwnProperty(p)) d[p] = b[p];
+      }
+    };
+
+    return _extendStatics(d, b);
+  }; // Ugly hack to resolve #502 and inherit built in Map / Set
+
+
+  function __extends(d, b) {
+    _extendStatics(d, b);
+
+    function __() {
+      Object.defineProperty(this, "constructor", {
+        value: d
+      });
+    }
+
+    d.prototype = ( // @ts-ignore
+    __.prototype = b.prototype, new __());
+  }
+
+  var DraftMap = function (_super) {
+    var _Object$definePropert;
+
+    __extends(DraftMap, _super); // Create class manually, cause #502
+
+
+    function DraftMap(target, parent) {
+      this[DRAFT_STATE] = {
+        type_: 2
+        /* Map */
+        ,
+        parent_: parent,
+        scope_: parent ? parent.scope_ : getCurrentScope(),
+        modified_: false,
+        finalized_: false,
+        copy_: undefined,
+        assigned_: undefined,
+        base_: target,
+        draft_: this,
+        isManual_: false,
+        revoked_: false
+      };
+      return this;
+    }
+
+    var p = DraftMap.prototype;
+    Object.defineProperties(p, (_Object$definePropert = {
+      size: {
+        get: function get() {
+          return latest(this[DRAFT_STATE]).size;
+        },
+        configurable: true
+      },
+      has: {
+        configurable: true,
+        writable: true,
+        value: function value(key) {
+          return latest(this[DRAFT_STATE]).has(key);
+        }
+      },
+      set: {
+        configurable: true,
+        writable: true,
+        value: function value(key, _value2) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (!latest(state).has(key) || latest(state).get(key) !== _value2) {
+            prepareMapCopy(state);
+            markChanged(state);
+            state.assigned_.set(key, true);
+            state.copy_.set(key, _value2);
+            state.assigned_.set(key, true);
+          }
+
+          return this;
+        }
+      },
+      delete: {
+        configurable: true,
+        writable: true,
+        value: function value(key) {
+          if (!this.has(key)) {
+            return false;
+          }
+
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareMapCopy(state);
+          markChanged(state);
+
+          if (state.base_.has(key)) {
+            state.assigned_.set(key, false);
+          } else {
+            state.assigned_.delete(key);
+          }
+
+          state.copy_.delete(key);
+          return true;
+        }
+      },
+      clear: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (latest(state).size) {
+            prepareMapCopy(state);
+            markChanged(state);
+            state.assigned_ = new Map();
+            each(state.base_, function (key) {
+              state.assigned_.set(key, false);
+            });
+            state.copy_.clear();
+          }
+        }
+      },
+      forEach: {
+        configurable: true,
+        writable: true,
+        value: function value(cb, thisArg) {
+          var _this = this;
+
+          var state = this[DRAFT_STATE];
+          latest(state).forEach(function (_value, key, _map) {
+            cb.call(thisArg, _this.get(key), key, _this);
+          });
+        }
+      },
+      get: {
+        configurable: true,
+        writable: true,
+        value: function value(key) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          var value = latest(state).get(key);
+
+          if (state.finalized_ || !isDraftable(value)) {
+            return value;
+          }
+
+          if (value !== state.base_.get(key)) {
+            return value; // either already drafted or reassigned
+          } // despite what it looks, this creates a draft only once, see above condition
+
+
+          var draft = createProxy(state.scope_.immer_, value, state);
+          prepareMapCopy(state);
+          state.copy_.set(key, draft);
+          return draft;
+        }
+      },
+      keys: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          return latest(this[DRAFT_STATE]).keys();
+        }
+      },
+      values: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var _this2 = this,
+              _ref;
+
+          var iterator = this.keys();
+          return _ref = {}, _ref[iteratorSymbol] = function () {
+            return _this2.values();
+          }, _ref.next = function next() {
+            var r = iterator.next();
+            /* istanbul ignore next */
+
+            if (r.done) return r;
+
+            var value = _this2.get(r.value);
+
+            return {
+              done: false,
+              value: value
+            };
+          }, _ref;
+        }
+      },
+      entries: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var _this3 = this,
+              _ref2;
+
+          var iterator = this.keys();
+          return _ref2 = {}, _ref2[iteratorSymbol] = function () {
+            return _this3.entries();
+          }, _ref2.next = function next() {
+            var r = iterator.next();
+            /* istanbul ignore next */
+
+            if (r.done) return r;
+
+            var value = _this3.get(r.value);
+
+            return {
+              done: false,
+              value: [r.value, value]
+            };
+          }, _ref2;
+        }
+      }
+    }, _Object$definePropert[iteratorSymbol] = {
+      configurable: true,
+      writable: true,
+      value: function value() {
+        return this.entries();
+      }
+    }, _Object$definePropert));
+    return DraftMap;
+  }(Map);
+
+  function proxyMap_(target, parent) {
+    // @ts-ignore
+    return new DraftMap(target, parent);
+  }
+
+  function prepareMapCopy(state) {
+    if (!state.copy_) {
+      state.assigned_ = new Map();
+      state.copy_ = new Map(state.base_);
+    }
+  }
+
+  var DraftSet = function (_super) {
+    var _Object$definePropert2;
+
+    __extends(DraftSet, _super); // Create class manually, cause #502
+
+
+    function DraftSet(target, parent) {
+      this[DRAFT_STATE] = {
+        type_: 3
+        /* Set */
+        ,
+        parent_: parent,
+        scope_: parent ? parent.scope_ : getCurrentScope(),
+        modified_: false,
+        finalized_: false,
+        copy_: undefined,
+        base_: target,
+        draft_: this,
+        drafts_: new Map(),
+        revoked_: false,
+        isManual_: false
+      };
+      return this;
+    }
+
+    var p = DraftSet.prototype;
+    Object.defineProperties(p, (_Object$definePropert2 = {
+      size: {
+        get: function get() {
+          return latest(this[DRAFT_STATE]).size;
+        },
+        configurable: true
+      },
+      has: {
+        configurable: true,
+        writable: true,
+        value: function value(_value3) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value
+
+          if (!state.copy_) {
+            return state.base_.has(_value3);
+          }
+
+          if (state.copy_.has(_value3)) return true;
+          if (state.drafts_.has(_value3) && state.copy_.has(state.drafts_.get(_value3))) return true;
+          return false;
+        }
+      },
+      add: {
+        configurable: true,
+        writable: true,
+        value: function value(_value4) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (!this.has(_value4)) {
+            prepareSetCopy(state);
+            markChanged(state);
+            state.copy_.add(_value4);
+          }
+
+          return this;
+        }
+      },
+      delete: {
+        configurable: true,
+        writable: true,
+        value: function value(_value5) {
+          if (!this.has(_value5)) {
+            return false;
+          }
+
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareSetCopy(state);
+          markChanged(state);
+          return state.copy_.delete(_value5) || (state.drafts_.has(_value5) ? state.copy_.delete(state.drafts_.get(_value5)) :
+          /* istanbul ignore next */
+          false);
+        }
+      },
+      clear: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (latest(state).size) {
+            prepareSetCopy(state);
+            markChanged(state);
+            state.copy_.clear();
+          }
+        }
+      },
+      values: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareSetCopy(state);
+          return state.copy_.values();
+        }
+      },
+      entries: {
+        configurable: true,
+        writable: true,
+        value: function entries() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareSetCopy(state);
+          return state.copy_.entries();
+        }
+      },
+      keys: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          return this.values();
+        }
+      }
+    }, _Object$definePropert2[iteratorSymbol] = {
+      configurable: true,
+      writable: true,
+      value: function value() {
+        return this.values();
+      }
+    }, _Object$definePropert2.forEach = {
+      configurable: true,
+      writable: true,
+      value: function forEach(cb, thisArg) {
+        var iterator = this.values();
+        var result = iterator.next();
+
+        while (!result.done) {
+          cb.call(thisArg, result.value, result.value, this);
+          result = iterator.next();
+        }
+      }
+    }, _Object$definePropert2));
+    return DraftSet;
+  }(Set);
+
+  function proxySet_(target, parent) {
+    // @ts-ignore
+    return new DraftSet(target, parent);
+  }
+
+  function prepareSetCopy(state) {
+    if (!state.copy_) {
+      // create drafts for all entries to preserve insertion order
+      state.copy_ = new Set();
+      state.base_.forEach(function (value) {
+        if (isDraftable(value)) {
+          var draft = createProxy(state.scope_.immer_, value, state);
+          state.drafts_.set(value, draft);
+          state.copy_.add(draft);
+        } else {
+          state.copy_.add(value);
+        }
+      });
+    }
+  }
+
+  function assertUnrevoked(state
+  /*ES5State | MapState | SetState*/
+  ) {
+    if (state.revoked_) die(3, JSON.stringify(latest(state)));
+  }
+
+  loadPlugin("MapSet", {
+    proxyMap_: proxyMap_,
+    proxySet_: proxySet_
+  });
+}
+
+function enableAllPlugins() {
+  enableES5();
+  enableMapSet();
+  enablePatches();
+}
+
 function enablePatches() {
   var REPLACE = "replace";
   var ADD = "add";
@@ -1577,468 +2015,101 @@ function enablePatches() {
   });
 }
 
-// types only!
-function enableMapSet() {
-  /* istanbul ignore next */
-  var _extendStatics = function extendStatics(d, b) {
-    _extendStatics = Object.setPrototypeOf || {
-      __proto__: []
-    } instanceof Array && function (d, b) {
-      d.__proto__ = b;
-    } || function (d, b) {
-      for (var p in b) {
-        if (b.hasOwnProperty(p)) d[p] = b[p];
-      }
-    };
-
-    return _extendStatics(d, b);
-  }; // Ugly hack to resolve #502 and inherit built in Map / Set
-
-
-  function __extends(d, b) {
-    _extendStatics(d, b);
-
-    function __() {
-      this.constructor = d;
-    }
-
-    d.prototype = ( // @ts-ignore
-    __.prototype = b.prototype, new __());
-  }
-
-  var DraftMap = function (_super) {
-    __extends(DraftMap, _super); // Create class manually, cause #502
-
-
-    function DraftMap(target, parent) {
-      this[DRAFT_STATE] = {
-        type_: 2
-        /* Map */
-        ,
-        parent_: parent,
-        scope_: parent ? parent.scope_ : getCurrentScope(),
-        modified_: false,
-        finalized_: false,
-        copy_: undefined,
-        assigned_: undefined,
-        base_: target,
-        draft_: this,
-        isManual_: false,
-        revoked_: false
-      };
-      return this;
-    }
-
-    var p = DraftMap.prototype;
-    Object.defineProperty(p, "size", {
-      get: function get() {
-        return latest(this[DRAFT_STATE]).size;
-      } // enumerable: false,
-      // configurable: true
-
-    });
-
-    p.has = function (key) {
-      return latest(this[DRAFT_STATE]).has(key);
-    };
-
-    p.set = function (key, value) {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-
-      if (!latest(state).has(key) || latest(state).get(key) !== value) {
-        prepareMapCopy(state);
-        markChanged(state);
-        state.assigned_.set(key, true);
-        state.copy_.set(key, value);
-        state.assigned_.set(key, true);
-      }
-
-      return this;
-    };
-
-    p.delete = function (key) {
-      if (!this.has(key)) {
-        return false;
-      }
-
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-      prepareMapCopy(state);
-      markChanged(state);
-
-      if (state.base_.has(key)) {
-        state.assigned_.set(key, false);
-      } else {
-        state.assigned_.delete(key);
-      }
-
-      state.copy_.delete(key);
-      return true;
-    };
-
-    p.clear = function () {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-
-      if (latest(state).size) {
-        prepareMapCopy(state);
-        markChanged(state);
-        state.assigned_ = new Map();
-        each(state.base_, function (key) {
-          state.assigned_.set(key, false);
-        });
-        state.copy_.clear();
-      }
-    };
-
-    p.forEach = function (cb, thisArg) {
-      var _this = this;
-
-      var state = this[DRAFT_STATE];
-      latest(state).forEach(function (_value, key, _map) {
-        cb.call(thisArg, _this.get(key), key, _this);
-      });
-    };
-
-    p.get = function (key) {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-      var value = latest(state).get(key);
-
-      if (state.finalized_ || !isDraftable(value)) {
-        return value;
-      }
-
-      if (value !== state.base_.get(key)) {
-        return value; // either already drafted or reassigned
-      } // despite what it looks, this creates a draft only once, see above condition
-
-
-      var draft = createProxy(state.scope_.immer_, value, state);
-      prepareMapCopy(state);
-      state.copy_.set(key, draft);
-      return draft;
-    };
-
-    p.keys = function () {
-      return latest(this[DRAFT_STATE]).keys();
-    };
-
-    p.values = function () {
-      var _this2 = this,
-          _ref;
-
-      var iterator = this.keys();
-      return _ref = {}, _ref[iteratorSymbol] = function () {
-        return _this2.values();
-      }, _ref.next = function next() {
-        var r = iterator.next();
-        /* istanbul ignore next */
-
-        if (r.done) return r;
-
-        var value = _this2.get(r.value);
-
-        return {
-          done: false,
-          value: value
-        };
-      }, _ref;
-    };
-
-    p.entries = function () {
-      var _this3 = this,
-          _ref2;
-
-      var iterator = this.keys();
-      return _ref2 = {}, _ref2[iteratorSymbol] = function () {
-        return _this3.entries();
-      }, _ref2.next = function next() {
-        var r = iterator.next();
-        /* istanbul ignore next */
-
-        if (r.done) return r;
-
-        var value = _this3.get(r.value);
-
-        return {
-          done: false,
-          value: [r.value, value]
-        };
-      }, _ref2;
-    };
-
-    p[iteratorSymbol] = function () {
-      return this.entries();
-    };
-
-    return DraftMap;
-  }(Map);
-
-  function proxyMap_(target, parent) {
-    // @ts-ignore
-    return new DraftMap(target, parent);
-  }
-
-  function prepareMapCopy(state) {
-    if (!state.copy_) {
-      state.assigned_ = new Map();
-      state.copy_ = new Map(state.base_);
-    }
-  }
-
-  var DraftSet = function (_super) {
-    __extends(DraftSet, _super); // Create class manually, cause #502
-
-
-    function DraftSet(target, parent) {
-      this[DRAFT_STATE] = {
-        type_: 3
-        /* Set */
-        ,
-        parent_: parent,
-        scope_: parent ? parent.scope_ : getCurrentScope(),
-        modified_: false,
-        finalized_: false,
-        copy_: undefined,
-        base_: target,
-        draft_: this,
-        drafts_: new Map(),
-        revoked_: false,
-        isManual_: false
-      };
-      return this;
-    }
-
-    var p = DraftSet.prototype;
-    Object.defineProperty(p, "size", {
-      get: function get() {
-        return latest(this[DRAFT_STATE]).size;
-      } // enumerable: true,
-
-    });
-
-    p.has = function (value) {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value
-
-      if (!state.copy_) {
-        return state.base_.has(value);
-      }
-
-      if (state.copy_.has(value)) return true;
-      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
-      return false;
-    };
-
-    p.add = function (value) {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-
-      if (!this.has(value)) {
-        prepareSetCopy(state);
-        markChanged(state);
-        state.copy_.add(value);
-      }
-
-      return this;
-    };
-
-    p.delete = function (value) {
-      if (!this.has(value)) {
-        return false;
-      }
-
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-      prepareSetCopy(state);
-      markChanged(state);
-      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) :
-      /* istanbul ignore next */
-      false);
-    };
-
-    p.clear = function () {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-
-      if (latest(state).size) {
-        prepareSetCopy(state);
-        markChanged(state);
-        state.copy_.clear();
-      }
-    };
-
-    p.values = function () {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-      prepareSetCopy(state);
-      return state.copy_.values();
-    };
-
-    p.entries = function entries() {
-      var state = this[DRAFT_STATE];
-      assertUnrevoked(state);
-      prepareSetCopy(state);
-      return state.copy_.entries();
-    };
-
-    p.keys = function () {
-      return this.values();
-    };
-
-    p[iteratorSymbol] = function () {
-      return this.values();
-    };
-
-    p.forEach = function forEach(cb, thisArg) {
-      var iterator = this.values();
-      var result = iterator.next();
-
-      while (!result.done) {
-        cb.call(thisArg, result.value, result.value, this);
-        result = iterator.next();
-      }
-    };
-
-    return DraftSet;
-  }(Set);
-
-  function proxySet_(target, parent) {
-    // @ts-ignore
-    return new DraftSet(target, parent);
-  }
-
-  function prepareSetCopy(state) {
-    if (!state.copy_) {
-      // create drafts for all entries to preserve insertion order
-      state.copy_ = new Set();
-      state.base_.forEach(function (value) {
-        if (isDraftable(value)) {
-          var draft = createProxy(state.scope_.immer_, value, state);
-          state.drafts_.set(value, draft);
-          state.copy_.add(draft);
-        } else {
-          state.copy_.add(value);
-        }
-      });
-    }
-  }
-
-  function assertUnrevoked(state
-  /*ES5State | MapState | SetState*/
-  ) {
-    if (state.revoked_) die(3, JSON.stringify(latest(state)));
-  }
-
-  loadPlugin("MapSet", {
-    proxyMap_: proxyMap_,
-    proxySet_: proxySet_
-  });
-}
-
-function enableAllPlugins() {
-  enableES5();
-  enableMapSet();
-  enablePatches();
-}
-
 var immer =
 /*#__PURE__*/
 new Immer();
 /**
- * The `produce` function takes a value and a "recipe function" (whose
- * return value often depends on the base state). The recipe function is
- * free to mutate its first argument however it wants. All mutations are
- * only ever applied to a __copy__ of the base state.
- *
- * Pass only a function to create a "curried producer" which relieves you
- * from passing the recipe function every time.
- *
- * Only plain objects and arrays are made mutable. All other objects are
- * considered uncopyable.
- *
- * Note: This function is __bound__ to its `Immer` instance.
- *
- * @param {any} base - the initial state
- * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
- * @param {Function} patchListener - optional function that will be called with all the patches produced here
- * @returns {any} a new state, or the initial state if nothing was modified
- */
+* The `produce` function takes a value and a "recipe function" (whose
+* return value often depends on the base state). The recipe function is
+* free to mutate its first argument however it wants. All mutations are
+* only ever applied to a __copy__ of the base state.
+*
+* Pass only a function to create a "curried producer" which relieves you
+* from passing the recipe function every time.
+*
+* Only plain objects and arrays are made mutable. All other objects are
+* considered uncopyable.
+*
+* Note: This function is __bound__ to its `Immer` instance.
+*
+* @param {any} base - the initial state
+* @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+* @param {Function} patchListener - optional function that will be called with all the patches produced here
+* @returns {any} a new state, or the initial state if nothing was modified
+*/
 
 var produce = immer.produce;
 /**
- * Like `produce`, but `produceWithPatches` always returns a tuple
- * [nextState, patches, inversePatches] (instead of just the next state)
- */
+* Like `produce`, but `produceWithPatches` always returns a tuple
+* [nextState, patches, inversePatches] (instead of just the next state)
+*/
 
 var produceWithPatches =
 /*#__PURE__*/
 immer.produceWithPatches.bind(immer);
 /**
- * Pass true to automatically freeze all copies created by Immer.
- *
- * Always freeze by default, even in production mode
- */
+* Pass true to automatically freeze all copies created by Immer.
+*
+* Always freeze by default, even in production mode
+*/
 
 var setAutoFreeze =
 /*#__PURE__*/
 immer.setAutoFreeze.bind(immer);
 /**
- * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
- * always faster than using ES5 proxies.
- *
- * By default, feature detection is used, so calling this is rarely necessary.
- */
+* Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+* always faster than using ES5 proxies.
+*
+* By default, feature detection is used, so calling this is rarely necessary.
+*/
 
 var setUseProxies =
 /*#__PURE__*/
 immer.setUseProxies.bind(immer);
 /**
- * Apply an array of Immer patches to the first argument.
- *
- * This function is a producer, which means copy-on-write is in effect.
- */
+* Apply an array of Immer patches to the first argument.
+*
+* This function is a producer, which means copy-on-write is in effect.
+*/
 
 var applyPatches =
 /*#__PURE__*/
 immer.applyPatches.bind(immer);
 /**
- * Create an Immer draft from the given base state, which may be a draft itself.
- * The draft can be modified until you finalize it with the `finishDraft` function.
- */
+* Create an Immer draft from the given base state, which may be a draft itself.
+* The draft can be modified until you finalize it with the `finishDraft` function.
+*/
 
 var createDraft =
 /*#__PURE__*/
 immer.createDraft.bind(immer);
 /**
- * Finalize an Immer draft from a `createDraft` call, returning the base state
- * (if no changes were made) or a modified copy. The draft must *not* be
- * mutated afterwards.
- *
- * Pass a function as the 2nd argument to generate Immer patches based on the
- * changes that were made.
- */
+* Finalize an Immer draft from a `createDraft` call, returning the base state
+* (if no changes were made) or a modified copy. The draft must *not* be
+* mutated afterwards.
+*
+* Pass a function as the 2nd argument to generate Immer patches based on the
+* changes that were made.
+*/
 
 var finishDraft =
 /*#__PURE__*/
 immer.finishDraft.bind(immer);
 /**
- * This function is actually a no-op, but can be used to cast an immutable type
- * to an draft type and make TypeScript happy
- *
- * @param value
- */
+* This function is actually a no-op, but can be used to cast an immutable type
+* to an draft type and make TypeScript happy
+*
+* @param value
+*/
 
 function castDraft(value) {
   return value;
 }
 /**
- * This function is actually a no-op, but can be used to cast a mutable type
- * to an immutable type and make TypeScript happy
- * @param value
- */
+* This function is actually a no-op, but can be used to cast a mutable type
+* to an immutable type and make TypeScript happy
+* @param value
+*/
 
 function castImmutable(value) {
   return value;
diff --git a/dist/immer.cjs.development.js.map b/dist/immer.cjs.development.js.map
index 27fe456ae0ae895a941f47d5499c4e11c9e836b1..40243bd9ee9d29a847f91a8c6c92da5d8b55fe3c 100644
--- a/dist/immer.cjs.development.js.map
+++ b/dist/immer.cjs.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"immer.cjs.development.js","sources":["../src/utils/env.ts","../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/patches.ts","../src/plugins/mapset.ts","../src/plugins/all.ts","../src/immer.ts"],"sourcesContent":["// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\tbase: any,\n\t\trecipe?: any,\n\t): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tthis.constructor = d\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: false,\n\t\t\t// configurable: true\n\t\t})\n\n\t\tp.has = function(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tp.set = function(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.forEach = function(\n\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\tthisArg?: any\n\t\t) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tp.get = function(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp.entries = function(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.entries()\n\t\t}\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: true,\n\t\t})\n\n\t\tp.has = function(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tp.add = function(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tp.entries = function entries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp.forEach = function forEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n"],"names":["hasSymbol","Symbol","hasMap","Map","hasSet","Set","hasProxies","Proxy","revocable","Reflect","NOTHING","for","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","errors","data","path","op","plugin","thing","die","error","args","e","msg","apply","Error","isDraft","value","isDraftable","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","Object","prototype","toString","proto","getPrototypeOf","Ctor","hasOwnProperty","call","Function","original","base_","ownKeys","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","getOwnPropertyDescriptors","target","res","forEach","key","getOwnPropertyDescriptor","each","iter","enumerableOnly","getArchtype","keys","entry","index","state","type_","has","prop","get","set","propOrOldValue","t","delete","add","is","x","y","latest","copy_","shallowCopy","base","slice","descriptors","i","length","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","plugins","getPlugin","pluginKey","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","autoFreeze_","createProxyProxy","parent","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","source","readPropFromProto","peek","prepareCopy","createProxy","getDescriptorFromProto","current","currentState","markChanged","deleteProperty","owner","defineProperty","setPrototypeOf","fn","arguments","isNaN","parseInt","Immer","config","recipe","defaultBase","self","curriedProduce","produce","hasError","Promise","then","p","ip","produceWithPatches","patches","inversePatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","createES5Proxy_","push","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","markChangesRecursively","markChangesSweep","createES5Draft","proxyProperty","assertUnrevoked","drafts","hasArrayChanges","hasObjectChanges","object","min","Math","baseValue","baseIsDraft","descriptor","JSON","stringify","enablePatches","REPLACE","ADD","REMOVE","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","clonePatchValueIfNeeded","assignedValue","origValue","unshift","replacement","parentType","join","type","deepClonePatchValue","splice","map","entries","k","v","cloned","immerable","enableMapSet","extendStatics","d","b","__proto__","__extends","__","DraftMap","_super","size","prepareMapCopy","cb","thisArg","_value","_map","values","next","r","done","DraftSet","prepareSetCopy","enableAllPlugins","bind","castDraft","castImmutable"],"mappings":";;;;;;AAAA;AAEA;AAEA;AACA,IAAMA,SAAS,GACd,OAAOC,MAAP,KAAkB,WAAlB,IAAiC;AAAA;AAAOA,MAAM,CAAC,GAAD,CAAb,KAAuB,QADzD;AAEO,IAAMC,MAAM,GAAG,OAAOC,GAAP,KAAe,WAA9B;AACA,IAAMC,MAAM,GAAG,OAAOC,GAAP,KAAe,WAA9B;AACA,IAAMC,UAAU,GACtB,OAAOC,KAAP,KAAiB,WAAjB,IACA,OAAOA,KAAK,CAACC,SAAb,KAA2B,WAD3B,IAEA,OAAOC,OAAP,KAAmB,WAHb;AAKP;;;;IAGaC,OAAO,GAAYV,SAAS;AAAA;AACtCC,MAAM,CAACU,GAAP,CAAW,eAAX,CADsC,oBAEnC,eAFmC,IAEjB,IAFiB;AAIzC;;;;;;;;;IAQaC,SAAS,GAAkBZ,SAAS;AAAA;AAC9CC,MAAM,CAACU,GAAP,CAAW,iBAAX,CAD8C,GAE7C;AAEG,IAAME,WAAW,GAAkBb,SAAS;AAAA;AAChDC,MAAM,CAACU,GAAP,CAAW,aAAX,CADgD,GAE/C,gBAFG;;AAKA,IAAMG,cAAc,GACzB,OAAOb,MAAP,IAAiB,WAAjB,IAAgCA,MAAM,CAACc,QAAxC,IAAsD,YADhD;;ACtCP,IAAMC,MAAM,GAAG;AACd,KAAG,eADW;AAEd,KAAG,8CAFW;AAGd,KAAG,uDAHW;AAId,GAJc,aAIZC,IAJY;AAKb,WACC,yHACAA,IAFD;AAIA,GATa;AAUd,KAAG,mHAVW;AAWd,KAAG,mCAXW;AAYd,KAAG,8DAZW;AAad,KAAG,iEAbW;AAcd,KAAG,0FAdW;AAed,KAAG,2EAfW;AAgBd,MAAI,sCAhBU;AAiBd,MAAI,0DAjBU;AAkBd,MAAI,0DAlBU;AAmBd,MAAI,4CAnBU;AAoBd,MAAI,qEApBU;AAqBd,IArBc,aAqBXC,IArBW;AAsBb,WAAO,+CAA+CA,IAAtD;AACA,GAvBa;AAwBd,MAAI,qCAxBU;AAyBd,IAzBc,aAyBXC,EAzBW;AA0Bb,WAAO,kCAAkCA,EAAzC;AACA,GA3Ba;AA4Bd,IA5Bc,aA4BXC,MA5BW;AA6Bb,gCAA0BA,MAA1B,uFAAmHA,MAAnH;AACA,GA9Ba;AA+Bd,MAAI,2EA/BU;AAgCd,IAhCc,aAgCXC,KAhCW;AAiCb,mKAA6JA,KAA7J;AACA,GAlCa;AAmCd,IAnCc,aAmCXA,KAnCW;AAoCb,gDAA0CA,KAA1C;AACA,GArCa;AAsCd,IAtCc,aAsCXA,KAtCW;AAuCb,iDAA2CA,KAA3C;AACA,GAxCa;AAyCd,MAAI;AAzCU,CAAf;AA4CA,SAAgBC,IAAIC;oCAA+BC;AAAAA,IAAAA;;;AAClD,EAAa;AACZ,QAAMC,CAAC,GAAGT,MAAM,CAACO,KAAD,CAAhB;AACA,QAAMG,GAAG,GAAG,CAACD,CAAD,GACT,uBAAuBF,KADd,GAET,OAAOE,CAAP,KAAa,UAAb,GACAA,CAAC,CAACE,KAAF,CAAQ,IAAR,EAAcH,IAAd,CADA,GAEAC,CAJH;AAKA,UAAM,IAAIG,KAAJ,cAAqBF,GAArB,CAAN;AACA;AAMD;;AC5CD;;AACA;;AACA,SAAgBG,QAAQC;AACvB,SAAO,CAAC,CAACA,KAAF,IAAW,CAAC,CAACA,KAAK,CAACjB,WAAD,CAAzB;AACA;AAED;;AACA;;AACA,SAAgBkB,YAAYD;;;AAC3B,MAAI,CAACA,KAAL,EAAY,OAAO,KAAP;AACZ,SACCE,aAAa,CAACF,KAAD,CAAb,IACAG,KAAK,CAACC,OAAN,CAAcJ,KAAd,CADA,IAEA,CAAC,CAACA,KAAK,CAAClB,SAAD,CAFP,IAGA,CAAC,wBAACkB,KAAK,CAACK,WAAP,uDAAC,mBAAoBvB,SAApB,CAAD,CAHD,IAIAwB,KAAK,CAACN,KAAD,CAJL,IAKAO,KAAK,CAACP,KAAD,CANN;AAQA;AAED,IAAMQ,gBAAgB;AAAA;AAAGC,MAAM,CAACC,SAAP,CAAiBL,WAAjB,CAA6BM,QAA7B,EAAzB;AACA;;AACA,SAAgBT,cAAcF;AAC7B,MAAI,CAACA,KAAD,IAAU,OAAOA,KAAP,KAAiB,QAA/B,EAAyC,OAAO,KAAP;AACzC,MAAMY,KAAK,GAAGH,MAAM,CAACI,cAAP,CAAsBb,KAAtB,CAAd;;AACA,MAAIY,KAAK,KAAK,IAAd,EAAoB;AACnB,WAAO,IAAP;AACA;;AACD,MAAME,IAAI,GACTL,MAAM,CAACM,cAAP,CAAsBC,IAAtB,CAA2BJ,KAA3B,EAAkC,aAAlC,KAAoDA,KAAK,CAACP,WAD3D;AAGA,MAAIS,IAAI,KAAKL,MAAb,EAAqB,OAAO,IAAP;AAErB,SACC,OAAOK,IAAP,IAAe,UAAf,IACAG,QAAQ,CAACN,QAAT,CAAkBK,IAAlB,CAAuBF,IAAvB,MAAiCN,gBAFlC;AAIA;AAKD,SAAgBU,SAASlB;AACxB,MAAI,CAACD,OAAO,CAACC,KAAD,CAAZ,EAAqBR,GAAG,CAAC,EAAD,EAAKQ,KAAL,CAAH;AACrB,SAAOA,KAAK,CAACjB,WAAD,CAAL,CAAmBoC,KAA1B;AACA;AAED;;AACA,AAAO,IAAMC,OAAO,GACnB,OAAOzC,OAAP,KAAmB,WAAnB,IAAkCA,OAAO,CAACyC,OAA1C,GACGzC,OAAO,CAACyC,OADX,GAEG,OAAOX,MAAM,CAACY,qBAAd,KAAwC,WAAxC,GACA,UAAAC,GAAG;AAAA,SACHb,MAAM,CAACc,mBAAP,CAA2BD,GAA3B,EAAgCE,MAAhC,CACCf,MAAM,CAACY,qBAAP,CAA6BC,GAA7B,CADD,CADG;AAAA,CADH;AAKA;AAA2Bb,MAAM,CAACc,mBAR/B;AAUP,AAAO,IAAME,yBAAyB,GACrChB,MAAM,CAACgB,yBAAP,IACA,SAASA,yBAAT,CAAmCC,MAAnC;AACC;AACA,MAAMC,GAAG,GAAQ,EAAjB;AACAP,EAAAA,OAAO,CAACM,MAAD,CAAP,CAAgBE,OAAhB,CAAwB,UAAAC,GAAG;AAC1BF,IAAAA,GAAG,CAACE,GAAD,CAAH,GAAWpB,MAAM,CAACqB,wBAAP,CAAgCJ,MAAhC,EAAwCG,GAAxC,CAAX;AACA,GAFD;AAGA,SAAOF,GAAP;AACA,CATK;AAgBP,SAAgBI,KAAKT,KAAUU,MAAWC;MAAAA;AAAAA,IAAAA,iBAAiB;;;AAC1D,MAAIC,WAAW,CAACZ,GAAD,CAAX;;AAAJ,IAA0C;AACzC,AAAC,OAACW,cAAc,GAAGxB,MAAM,CAAC0B,IAAV,GAAiBf,OAAhC,EAAyCE,GAAzC,EAA8CM,OAA9C,CAAsD,UAAAC,GAAG;AACzD,YAAI,CAACI,cAAD,IAAmB,OAAOJ,GAAP,KAAe,QAAtC,EAAgDG,IAAI,CAACH,GAAD,EAAMP,GAAG,CAACO,GAAD,CAAT,EAAgBP,GAAhB,CAAJ;AAChD,OAFA;AAGD,KAJD,MAIO;AACNA,IAAAA,GAAG,CAACM,OAAJ,CAAY,UAACQ,KAAD,EAAaC,KAAb;AAAA,aAA4BL,IAAI,CAACK,KAAD,EAAQD,KAAR,EAAed,GAAf,CAAhC;AAAA,KAAZ;AACA;AACD;AAED;;AACA,SAAgBY,YAAY3C;AAC3B;AACA,MAAM+C,KAAK,GAA2B/C,KAAK,CAACR,WAAD,CAA3C;AACA,SAAOuD,KAAK,GACTA,KAAK,CAACC,KAAN,GAAc,CAAd,GACCD,KAAK,CAACC,KAAN,GAAc,CADf;AAAA,IAEED,KAAK,CAACC,KAHC;AAAA,IAITpC,KAAK,CAACC,OAAN,CAAcb,KAAd;;AAAA,IAEAe,KAAK,CAACf,KAAD,CAAL;;AAAA,IAEAgB,KAAK,CAAChB,KAAD,CAAL;;AAAA;;AARH;AAWA;AAED;;AACA,SAAgBiD,IAAIjD,OAAYkD;AAC/B,SAAOP,WAAW,CAAC3C,KAAD,CAAX;;AAAA,IACJA,KAAK,CAACiD,GAAN,CAAUC,IAAV,CADI,GAEJhC,MAAM,CAACC,SAAP,CAAiBK,cAAjB,CAAgCC,IAAhC,CAAqCzB,KAArC,EAA4CkD,IAA5C,CAFH;AAGA;AAED;;AACA,SAAgBC,IAAInD,OAA2BkD;AAC9C;AACA,SAAOP,WAAW,CAAC3C,KAAD,CAAX;;AAAA,IAAsCA,KAAK,CAACmD,GAAN,CAAUD,IAAV,CAAtC,GAAwDlD,KAAK,CAACkD,IAAD,CAApE;AACA;AAED;;AACA,SAAgBE,IAAIpD,OAAYqD,gBAA6B5C;AAC5D,MAAM6C,CAAC,GAAGX,WAAW,CAAC3C,KAAD,CAArB;AACA,MAAIsD,CAAC;;AAAL,IAAwBtD,KAAK,CAACoD,GAAN,CAAUC,cAAV,EAA0B5C,KAA1B,EAAxB,KACK,IAAI6C,CAAC;;AAAL,IAAwB;AAC5BtD,MAAAA,KAAK,CAACuD,MAAN,CAAaF,cAAb;AACArD,MAAAA,KAAK,CAACwD,GAAN,CAAU/C,KAAV;AACA,KAHI,MAGET,KAAK,CAACqD,cAAD,CAAL,GAAwB5C,KAAxB;AACP;AAED;;AACA,SAAgBgD,GAAGC,GAAQC;AAC1B;AACA,MAAID,CAAC,KAAKC,CAAV,EAAa;AACZ,WAAOD,CAAC,KAAK,CAAN,IAAW,IAAIA,CAAJ,KAAU,IAAIC,CAAhC;AACA,GAFD,MAEO;AACN,WAAOD,CAAC,KAAKA,CAAN,IAAWC,CAAC,KAAKA,CAAxB;AACA;AACD;AAED;;AACA,SAAgB5C,MAAMoB;AACrB,SAAOtD,MAAM,IAAIsD,MAAM,YAAYrD,GAAnC;AACA;AAED;;AACA,SAAgBkC,MAAMmB;AACrB,SAAOpD,MAAM,IAAIoD,MAAM,YAAYnD,GAAnC;AACA;AACD;;AACA,SAAgB4E,OAAOb;AACtB,SAAOA,KAAK,CAACc,KAAN,IAAed,KAAK,CAACnB,KAA5B;AACA;AAED;;AACA,SAAgBkC,YAAYC;AAC3B,MAAInD,KAAK,CAACC,OAAN,CAAckD,IAAd,CAAJ,EAAyB,OAAOnD,KAAK,CAACO,SAAN,CAAgB6C,KAAhB,CAAsBvC,IAAtB,CAA2BsC,IAA3B,CAAP;AACzB,MAAME,WAAW,GAAG/B,yBAAyB,CAAC6B,IAAD,CAA7C;AACA,SAAOE,WAAW,CAACzE,WAAD,CAAlB;AACA,MAAIoD,IAAI,GAAGf,OAAO,CAACoC,WAAD,CAAlB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,IAAI,CAACuB,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACrC,QAAM5B,GAAG,GAAQM,IAAI,CAACsB,CAAD,CAArB;AACA,QAAME,IAAI,GAAGH,WAAW,CAAC3B,GAAD,CAAxB;;AACA,QAAI8B,IAAI,CAACC,QAAL,KAAkB,KAAtB,EAA6B;AAC5BD,MAAAA,IAAI,CAACC,QAAL,GAAgB,IAAhB;AACAD,MAAAA,IAAI,CAACE,YAAL,GAAoB,IAApB;AACA,KANoC;AAQrC;AACA;;;AACA,QAAIF,IAAI,CAACjB,GAAL,IAAYiB,IAAI,CAAChB,GAArB,EACCa,WAAW,CAAC3B,GAAD,CAAX,GAAmB;AAClBgC,MAAAA,YAAY,EAAE,IADI;AAElBD,MAAAA,QAAQ,EAAE,IAFQ;AAGlBE,MAAAA,UAAU,EAAEH,IAAI,CAACG,UAHC;AAIlB9D,MAAAA,KAAK,EAAEsD,IAAI,CAACzB,GAAD;AAJO,KAAnB;AAMD;;AACD,SAAOpB,MAAM,CAACsD,MAAP,CAActD,MAAM,CAACI,cAAP,CAAsByC,IAAtB,CAAd,EAA2CE,WAA3C,CAAP;AACA;AAUD,SAAgBQ,OAAU1C,KAAU2C;MAAAA;AAAAA,IAAAA,OAAgB;;;AACnD,MAAIC,QAAQ,CAAC5C,GAAD,CAAR,IAAiBvB,OAAO,CAACuB,GAAD,CAAxB,IAAiC,CAACrB,WAAW,CAACqB,GAAD,CAAjD,EAAwD,OAAOA,GAAP;;AACxD,MAAIY,WAAW,CAACZ,GAAD,CAAX,GAAmB;AAAE;AAAzB,IAA2C;AAC1CA,MAAAA,GAAG,CAACqB,GAAJ,GAAUrB,GAAG,CAACyB,GAAJ,GAAUzB,GAAG,CAAC6C,KAAJ,GAAY7C,GAAG,CAACwB,MAAJ,GAAasB,2BAA7C;AACA;;AACD3D,EAAAA,MAAM,CAACuD,MAAP,CAAc1C,GAAd;AACA,MAAI2C,IAAJ,EAAUlC,IAAI,CAACT,GAAD,EAAM,UAACO,GAAD,EAAM7B,KAAN;AAAA,WAAgBgE,MAAM,CAAChE,KAAD,EAAQ,IAAR,CAAtB;AAAA,GAAN,EAA2C,IAA3C,CAAJ;AACV,SAAOsB,GAAP;AACA;;AAED,SAAS8C,2BAAT;AACC5E,EAAAA,GAAG,CAAC,CAAD,CAAH;AACA;;AAED,SAAgB0E,SAAS5C;AACxB,MAAIA,GAAG,IAAI,IAAP,IAAe,OAAOA,GAAP,KAAe,QAAlC,EAA4C,OAAO,IAAP;;AAE5C,SAAOb,MAAM,CAACyD,QAAP,CAAgB5C,GAAhB,CAAP;AACA;;AC3MD;;AACA,IAAM+C,OAAO,GA4BT,EA5BJ;AAgCA,SAAgBC,UACfC;AAEA,MAAMjF,MAAM,GAAG+E,OAAO,CAACE,SAAD,CAAtB;;AACA,MAAI,CAACjF,MAAL,EAAa;AACZE,IAAAA,GAAG,CAAC,EAAD,EAAK+E,SAAL,CAAH;AACA;;;AAED,SAAOjF,MAAP;AACA;AAED,SAAgBkF,WACfD,WACAE;AAEA,MAAI,CAACJ,OAAO,CAACE,SAAD,CAAZ,EAAyBF,OAAO,CAACE,SAAD,CAAP,GAAqBE,cAArB;AACzB;;ACrCD,IAAIC,YAAJ;AAEA,SAAgBC;AACf,MAAI,CAAW,CAACD,YAAhB,EAA8BlF,GAAG,CAAC,CAAD,CAAH;AAC9B,SAAOkF,YAAP;AACA;;AAED,SAASE,WAAT,CACCC,OADD,EAECC,MAFD;AAIC,SAAO;AACNC,IAAAA,OAAO,EAAE,EADH;AAENF,IAAAA,OAAO,EAAPA,OAFM;AAGNC,IAAAA,MAAM,EAANA,MAHM;AAIN;AACA;AACAE,IAAAA,cAAc,EAAE,IANV;AAONC,IAAAA,kBAAkB,EAAE;AAPd,GAAP;AASA;;AAED,SAAgBC,kBACfC,OACAC;AAEA,MAAIA,aAAJ,EAAmB;AAClBd,IAAAA,SAAS,CAAC,SAAD,CAAT,CADkB;;AAElBa,IAAAA,KAAK,CAACE,QAAN,GAAiB,EAAjB;AACAF,IAAAA,KAAK,CAACG,eAAN,GAAwB,EAAxB;AACAH,IAAAA,KAAK,CAACI,cAAN,GAAuBH,aAAvB;AACA;AACD;AAED,SAAgBI,YAAYL;AAC3BM,EAAAA,UAAU,CAACN,KAAD,CAAV;AACAA,EAAAA,KAAK,CAACJ,OAAN,CAAcnD,OAAd,CAAsB8D,WAAtB;;AAEAP,EAAAA,KAAK,CAACJ,OAAN,GAAgB,IAAhB;AACA;AAED,SAAgBU,WAAWN;AAC1B,MAAIA,KAAK,KAAKT,YAAd,EAA4B;AAC3BA,IAAAA,YAAY,GAAGS,KAAK,CAACN,OAArB;AACA;AACD;AAED,SAAgBc,WAAWC;AAC1B,SAAQlB,YAAY,GAAGE,WAAW,CAACF,YAAD,EAAekB,KAAf,CAAlC;AACA;;AAED,SAASF,WAAT,CAAqBG,KAArB;AACC,MAAMvD,KAAK,GAAeuD,KAAK,CAAC9G,WAAD,CAA/B;AACA,MACCuD,KAAK,CAACC,KAAN;;AAAA,KACAD,KAAK,CAACC,KAAN;;AAFD,IAICD,KAAK,CAACwD,OAAN,GAJD,KAKKxD,KAAK,CAACyD,QAAN,GAAiB,IAAjB;AACL;;SC/DeC,cAAcC,QAAad;AAC1CA,EAAAA,KAAK,CAACF,kBAAN,GAA2BE,KAAK,CAACJ,OAAN,CAAcrB,MAAzC;AACA,MAAMwC,SAAS,GAAGf,KAAK,CAACJ,OAAN,CAAe,CAAf,CAAlB;AACA,MAAMoB,UAAU,GAAGF,MAAM,KAAKG,SAAX,IAAwBH,MAAM,KAAKC,SAAtD;AACA,MAAI,CAACf,KAAK,CAACL,MAAN,CAAauB,WAAlB,EACC/B,SAAS,CAAC,KAAD,CAAT,CAAiBgC,gBAAjB,CAAkCnB,KAAlC,EAAyCc,MAAzC,EAAiDE,UAAjD;;AACD,MAAIA,UAAJ,EAAgB;AACf,QAAID,SAAS,CAACnH,WAAD,CAAT,CAAuBwH,SAA3B,EAAsC;AACrCf,MAAAA,WAAW,CAACL,KAAD,CAAX;AACA3F,MAAAA,GAAG,CAAC,CAAD,CAAH;AACA;;AACD,QAAIS,WAAW,CAACgG,MAAD,CAAf,EAAyB;AACxB;AACAA,MAAAA,MAAM,GAAGO,QAAQ,CAACrB,KAAD,EAAQc,MAAR,CAAjB;AACA,UAAI,CAACd,KAAK,CAACN,OAAX,EAAoB4B,WAAW,CAACtB,KAAD,EAAQc,MAAR,CAAX;AACpB;;AACD,QAAId,KAAK,CAACE,QAAV,EAAoB;AACnBf,MAAAA,SAAS,CAAC,SAAD,CAAT,CAAqBoC,2BAArB,CACCR,SAAS,CAACnH,WAAD,CAAT,CAAuBoC,KADxB,EAEC8E,MAFD,EAGCd,KAAK,CAACE,QAHP,EAICF,KAAK,CAACG,eAJP;AAMA;AACD,GAlBD,MAkBO;AACN;AACAW,IAAAA,MAAM,GAAGO,QAAQ,CAACrB,KAAD,EAAQe,SAAR,EAAmB,EAAnB,CAAjB;AACA;;AACDV,EAAAA,WAAW,CAACL,KAAD,CAAX;;AACA,MAAIA,KAAK,CAACE,QAAV,EAAoB;AACnBF,IAAAA,KAAK,CAACI,cAAN,CAAsBJ,KAAK,CAACE,QAA5B,EAAsCF,KAAK,CAACG,eAA5C;AACA;;AACD,SAAOW,MAAM,KAAKrH,OAAX,GAAqBqH,MAArB,GAA8BG,SAArC;AACA;;AAED,SAASI,QAAT,CAAkBG,SAAlB,EAAyC3G,KAAzC,EAAqDZ,IAArD;AACC;AACA,MAAI8E,QAAQ,CAAClE,KAAD,CAAZ,EAAqB,OAAOA,KAAP;AAErB,MAAMsC,KAAK,GAAetC,KAAK,CAACjB,WAAD,CAA/B;;AAEA,MAAI,CAACuD,KAAL,EAAY;AACXP,IAAAA,IAAI,CACH/B,KADG,EAEH,UAAC6B,GAAD,EAAM+E,UAAN;AAAA,aACCC,gBAAgB,CAACF,SAAD,EAAYrE,KAAZ,EAAmBtC,KAAnB,EAA0B6B,GAA1B,EAA+B+E,UAA/B,EAA2CxH,IAA3C,CADjB;AAAA,KAFG,EAIH,IAJG;AAAA,KAAJ;AAMA,WAAOY,KAAP;AACA;;;AAED,MAAIsC,KAAK,CAACwE,MAAN,KAAiBH,SAArB,EAAgC,OAAO3G,KAAP;;AAEhC,MAAI,CAACsC,KAAK,CAACiE,SAAX,EAAsB;AACrBE,IAAAA,WAAW,CAACE,SAAD,EAAYrE,KAAK,CAACnB,KAAlB,EAAyB,IAAzB,CAAX;AACA,WAAOmB,KAAK,CAACnB,KAAb;AACA;;;AAED,MAAI,CAACmB,KAAK,CAACyE,UAAX,EAAuB;AACtBzE,IAAAA,KAAK,CAACyE,UAAN,GAAmB,IAAnB;AACAzE,IAAAA,KAAK,CAACwE,MAAN,CAAa7B,kBAAb;AACA,QAAMgB,MAAM;AAEX3D,IAAAA,KAAK,CAACC,KAAN;;AAAA,OAAuCD,KAAK,CAACC,KAAN;;AAAvC,MACID,KAAK,CAACc,KAAN,GAAcC,WAAW,CAACf,KAAK,CAAC0E,MAAP,CAD7B,GAEG1E,KAAK,CAACc,KAJV,CAHsB;AAStB;AACA;AACA;;AACArB,IAAAA,IAAI,CACHO,KAAK,CAACC,KAAN;;AAAA,MAAgC,IAAIhE,GAAJ,CAAQ0H,MAAR,CAAhC,GAAkDA,MAD/C,EAEH,UAACpE,GAAD,EAAM+E,UAAN;AAAA,aACCC,gBAAgB,CAACF,SAAD,EAAYrE,KAAZ,EAAmB2D,MAAnB,EAA2BpE,GAA3B,EAAgC+E,UAAhC,EAA4CxH,IAA5C,CADjB;AAAA,KAFG,CAAJ,CAZsB;;AAkBtBqH,IAAAA,WAAW,CAACE,SAAD,EAAYV,MAAZ,EAAoB,KAApB,CAAX,CAlBsB;;AAoBtB,QAAI7G,IAAI,IAAIuH,SAAS,CAACtB,QAAtB,EAAgC;AAC/Bf,MAAAA,SAAS,CAAC,SAAD,CAAT,CAAqB2C,gBAArB,CACC3E,KADD,EAEClD,IAFD,EAGCuH,SAAS,CAACtB,QAHX,EAICsB,SAAS,CAACrB,eAJX;AAMA;AACD;;AACD,SAAOhD,KAAK,CAACc,KAAb;AACA;;AAED,SAASyD,gBAAT,CACCF,SADD,EAECO,WAFD,EAGCC,YAHD,EAIC1E,IAJD,EAKCmE,UALD,EAMCQ,QAND;AAQC,MAAI,CAAWR,UAAU,KAAKO,YAA9B,EAA4C3H,GAAG,CAAC,CAAD,CAAH;;AAC5C,MAAIO,OAAO,CAAC6G,UAAD,CAAX,EAAyB;AACxB,QAAMxH,IAAI,GACTgI,QAAQ,IACRF,WADA,IAEAA,WAAY,CAAC3E,KAAb;;AAFA;AAGA,KAACC,GAAG,CAAE0E,WAA6C,CAACG,SAAhD,EAA4D5E,IAA5D,CAHJ;AAAA,MAIG2E,QAAS,CAAC5F,MAAV,CAAiBiB,IAAjB,CAJH,GAKG2D,SANJ,CADwB;;AASxB,QAAMzE,GAAG,GAAG6E,QAAQ,CAACG,SAAD,EAAYC,UAAZ,EAAwBxH,IAAxB,CAApB;AACAuD,IAAAA,GAAG,CAACwE,YAAD,EAAe1E,IAAf,EAAqBd,GAArB,CAAH,CAVwB;AAYxB;;AACA,QAAI5B,OAAO,CAAC4B,GAAD,CAAX,EAAkB;AACjBgF,MAAAA,SAAS,CAAC3B,cAAV,GAA2B,KAA3B;AACA,KAFD,MAEO;AACP;;;AAED,MAAI/E,WAAW,CAAC2G,UAAD,CAAX,IAA2B,CAAC1C,QAAQ,CAAC0C,UAAD,CAAxC,EAAsD;AACrD,QAAI,CAACD,SAAS,CAAC7B,MAAV,CAAiBwC,WAAlB,IAAiCX,SAAS,CAAC1B,kBAAV,GAA+B,CAApE,EAAuE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;AACDuB,IAAAA,QAAQ,CAACG,SAAD,EAAYC,UAAZ,CAAR,CATqD;;AAWrD,QAAI,CAACM,WAAD,IAAgB,CAACA,WAAW,CAACJ,MAAZ,CAAmBjC,OAAxC,EACC4B,WAAW,CAACE,SAAD,EAAYC,UAAZ,CAAX;AACD;AACD;;AAED,SAASH,WAAT,CAAqBtB,KAArB,EAAwCnF,KAAxC,EAAoDiE,IAApD;MAAoDA;AAAAA,IAAAA,OAAO;;;AAC1D,MAAIkB,KAAK,CAACL,MAAN,CAAawC,WAAb,IAA4BnC,KAAK,CAACH,cAAtC,EAAsD;AACrDhB,IAAAA,MAAM,CAAChE,KAAD,EAAQiE,IAAR,CAAN;AACA;AACD;;AClHD;;;;;;AAKA,SAAgBsD,iBACfjE,MACAkE;AAEA,MAAMpH,OAAO,GAAGD,KAAK,CAACC,OAAN,CAAckD,IAAd,CAAhB;AACA,MAAMhB,KAAK,GAAe;AACzBC,IAAAA,KAAK,EAAEnC,OAAO;;AAAA,MAA2B;;AADhB;AAEzB;AACA0G,IAAAA,MAAM,EAAEU,MAAM,GAAGA,MAAM,CAACV,MAAV,GAAmBnC,eAAe,EAHvB;AAIzB;AACA4B,IAAAA,SAAS,EAAE,KALc;AAMzB;AACAQ,IAAAA,UAAU,EAAE,KAPa;AAQzB;AACAM,IAAAA,SAAS,EAAE,EATc;AAUzB;AACAxC,IAAAA,OAAO,EAAE2C,MAXgB;AAYzB;AACArG,IAAAA,KAAK,EAAEmC,IAbkB;AAczB;AACA0D,IAAAA,MAAM,EAAE,IAfiB;AAgBzB;AACA5D,IAAAA,KAAK,EAAE,IAjBkB;AAkBzB;AACA0C,IAAAA,OAAO,EAAE,IAnBgB;AAoBzB2B,IAAAA,SAAS,EAAE;AApBc,GAA1B;AAwBA;AACA;AACA;AACA;AACA;;AACA,MAAI/F,MAAM,GAAMY,KAAhB;AACA,MAAIoF,KAAK,GAAsCC,WAA/C;;AACA,MAAIvH,OAAJ,EAAa;AACZsB,IAAAA,MAAM,GAAG,CAACY,KAAD,CAAT;AACAoF,IAAAA,KAAK,GAAGE,UAAR;AACA;;yBAEuBnJ,KAAK,CAACC,SAAN,CAAgBgD,MAAhB,EAAwBgG,KAAxB;MAAjBG,0BAAAA;MAAQC,yBAAAA;;AACfxF,EAAAA,KAAK,CAAC0E,MAAN,GAAec,KAAf;AACAxF,EAAAA,KAAK,CAACwD,OAAN,GAAgB+B,MAAhB;AACA,SAAOC,KAAP;AACA;AAED;;;;AAGA,AAAO,IAAMH,WAAW,GAA6B;AACpDjF,EAAAA,GADoD,eAChDJ,KADgD,EACzCG,IADyC;AAEnD,QAAIA,IAAI,KAAK1D,WAAb,EAA0B,OAAOuD,KAAP;AAE1B,QAAMyF,MAAM,GAAG5E,MAAM,CAACb,KAAD,CAArB;;AACA,QAAI,CAACE,GAAG,CAACuF,MAAD,EAAStF,IAAT,CAAR,EAAwB;AACvB;AACA,aAAOuF,iBAAiB,CAAC1F,KAAD,EAAQyF,MAAR,EAAgBtF,IAAhB,CAAxB;AACA;;AACD,QAAMzC,KAAK,GAAG+H,MAAM,CAACtF,IAAD,CAApB;;AACA,QAAIH,KAAK,CAACyE,UAAN,IAAoB,CAAC9G,WAAW,CAACD,KAAD,CAApC,EAA6C;AAC5C,aAAOA,KAAP;AACA;AAED;;;AACA,QAAIA,KAAK,KAAKiI,IAAI,CAAC3F,KAAK,CAACnB,KAAP,EAAcsB,IAAd,CAAlB,EAAuC;AACtCyF,MAAAA,WAAW,CAAC5F,KAAD,CAAX;AACA,aAAQA,KAAK,CAACc,KAAN,CAAaX,IAAb,IAA4B0F,WAAW,CAC9C7F,KAAK,CAACwE,MAAN,CAAahC,MADiC,EAE9C9E,KAF8C,EAG9CsC,KAH8C,CAA/C;AAKA;;AACD,WAAOtC,KAAP;AACA,GAxBmD;AAyBpDwC,EAAAA,GAzBoD,eAyBhDF,KAzBgD,EAyBzCG,IAzByC;AA0BnD,WAAOA,IAAI,IAAIU,MAAM,CAACb,KAAD,CAArB;AACA,GA3BmD;AA4BpDlB,EAAAA,OA5BoD,mBA4B5CkB,KA5B4C;AA6BnD,WAAO3D,OAAO,CAACyC,OAAR,CAAgB+B,MAAM,CAACb,KAAD,CAAtB,CAAP;AACA,GA9BmD;AA+BpDK,EAAAA,GA/BoD,eAgCnDL,KAhCmD,EAiCnDG;AAAa;AAjCsC,IAkCnDzC,KAlCmD;AAoCnD,QAAM2D,IAAI,GAAGyE,sBAAsB,CAACjF,MAAM,CAACb,KAAD,CAAP,EAAgBG,IAAhB,CAAnC;;AACA,QAAIkB,IAAJ,aAAIA,IAAJ,uBAAIA,IAAI,CAAEhB,GAAV,EAAe;AACd;AACA;AACAgB,MAAAA,IAAI,CAAChB,GAAL,CAAS3B,IAAT,CAAcsB,KAAK,CAAC0E,MAApB,EAA4BhH,KAA5B;AACA,aAAO,IAAP;AACA;;AACD,QAAI,CAACsC,KAAK,CAACiE,SAAX,EAAsB;AACrB;AACA;AACA,UAAM8B,OAAO,GAAGJ,IAAI,CAAC9E,MAAM,CAACb,KAAD,CAAP,EAAgBG,IAAhB,CAApB,CAHqB;;AAKrB,UAAM6F,YAAY,GAAqBD,OAArB,aAAqBA,OAArB,uBAAqBA,OAAO,CAAGtJ,WAAH,CAA9C;;AACA,UAAIuJ,YAAY,IAAIA,YAAY,CAACnH,KAAb,KAAuBnB,KAA3C,EAAkD;AACjDsC,QAAAA,KAAK,CAACc,KAAN,CAAaX,IAAb,IAAqBzC,KAArB;AACAsC,QAAAA,KAAK,CAAC+E,SAAN,CAAgB5E,IAAhB,IAAwB,KAAxB;AACA,eAAO,IAAP;AACA;;AACD,UAAIO,EAAE,CAAChD,KAAD,EAAQqI,OAAR,CAAF,KAAuBrI,KAAK,KAAKoG,SAAV,IAAuB5D,GAAG,CAACF,KAAK,CAACnB,KAAP,EAAcsB,IAAd,CAAjD,CAAJ,EACC,OAAO,IAAP;AACDyF,MAAAA,WAAW,CAAC5F,KAAD,CAAX;AACAiG,MAAAA,WAAW,CAACjG,KAAD,CAAX;AACA;;AAED,QACCA,KAAK,CAACc,KAAN,CAAaX,IAAb,MAAuBzC,KAAvB;AAEA,WAAOA,KAAP,KAAiB,QAFjB;AAICA,IAAAA,KAAK,KAAKoG,SAAV,IAAuB3D,IAAI,IAAIH,KAAK,CAACc,KAJtC,CADD,EAOC,OAAO,IAAP;;AAGDd,IAAAA,KAAK,CAACc,KAAN,CAAaX,IAAb,IAAqBzC,KAArB;AACAsC,IAAAA,KAAK,CAAC+E,SAAN,CAAgB5E,IAAhB,IAAwB,IAAxB;AACA,WAAO,IAAP;AACA,GAzEmD;AA0EpD+F,EAAAA,cA1EoD,0BA0ErClG,KA1EqC,EA0E9BG,IA1E8B;AA2EnD;AACA,QAAIwF,IAAI,CAAC3F,KAAK,CAACnB,KAAP,EAAcsB,IAAd,CAAJ,KAA4B2D,SAA5B,IAAyC3D,IAAI,IAAIH,KAAK,CAACnB,KAA3D,EAAkE;AACjEmB,MAAAA,KAAK,CAAC+E,SAAN,CAAgB5E,IAAhB,IAAwB,KAAxB;AACAyF,MAAAA,WAAW,CAAC5F,KAAD,CAAX;AACAiG,MAAAA,WAAW,CAACjG,KAAD,CAAX;AACA,KAJD,MAIO;AACN;AACA,aAAOA,KAAK,CAAC+E,SAAN,CAAgB5E,IAAhB,CAAP;AACA;;;AAED,QAAIH,KAAK,CAACc,KAAV,EAAiB,OAAOd,KAAK,CAACc,KAAN,CAAYX,IAAZ,CAAP;AACjB,WAAO,IAAP;AACA,GAvFmD;AAwFpD;AACA;AACAX,EAAAA,wBA1FoD,oCA0F3BQ,KA1F2B,EA0FpBG,IA1FoB;AA2FnD,QAAMgG,KAAK,GAAGtF,MAAM,CAACb,KAAD,CAApB;AACA,QAAMqB,IAAI,GAAGhF,OAAO,CAACmD,wBAAR,CAAiC2G,KAAjC,EAAwChG,IAAxC,CAAb;AACA,QAAI,CAACkB,IAAL,EAAW,OAAOA,IAAP;AACX,WAAO;AACNC,MAAAA,QAAQ,EAAE,IADJ;AAENC,MAAAA,YAAY,EAAEvB,KAAK,CAACC,KAAN;;AAAA,SAAwCE,IAAI,KAAK,QAFzD;AAGNqB,MAAAA,UAAU,EAAEH,IAAI,CAACG,UAHX;AAIN9D,MAAAA,KAAK,EAAEyI,KAAK,CAAChG,IAAD;AAJN,KAAP;AAMA,GApGmD;AAqGpDiG,EAAAA,cArGoD;AAsGnDlJ,IAAAA,GAAG,CAAC,EAAD,CAAH;AACA,GAvGmD;AAwGpDqB,EAAAA,cAxGoD,0BAwGrCyB,KAxGqC;AAyGnD,WAAO7B,MAAM,CAACI,cAAP,CAAsByB,KAAK,CAACnB,KAA5B,CAAP;AACA,GA1GmD;AA2GpDwH,EAAAA,cA3GoD;AA4GnDnJ,IAAAA,GAAG,CAAC,EAAD,CAAH;AACA;AA7GmD,CAA9C;AAgHP;;;;AAIA,IAAMoI,UAAU,GAAoC,EAApD;AACA7F,IAAI,CAAC4F,WAAD,EAAc,UAAC9F,GAAD,EAAM+G,EAAN;AACjB;AACAhB,EAAAA,UAAU,CAAC/F,GAAD,CAAV,GAAkB;AACjBgH,IAAAA,SAAS,CAAC,CAAD,CAAT,GAAeA,SAAS,CAAC,CAAD,CAAT,CAAa,CAAb,CAAf;AACA,WAAOD,EAAE,CAAC/I,KAAH,CAAS,IAAT,EAAegJ,SAAf,CAAP;AACA,GAHD;AAIA,CANG,CAAJ;;AAOAjB,UAAU,CAACY,cAAX,GAA4B,UAASlG,KAAT,EAAgBG,IAAhB;AAC3B,MAAI,CAAWqG,KAAK,CAACC,QAAQ,CAACtG,IAAD,CAAT,CAApB,EAA6CjD,GAAG,CAAC,EAAD,CAAH;;AAE7C,SAAOoI,UAAU,CAACjF,GAAX,CAAgB3B,IAAhB,CAAqB,IAArB,EAA2BsB,KAA3B,EAAkCG,IAAlC,EAAwC2D,SAAxC,CAAP;AACA,CAJD;;AAKAwB,UAAU,CAACjF,GAAX,GAAiB,UAASL,KAAT,EAAgBG,IAAhB,EAAsBzC,KAAtB;AAChB,MAAI,CAAWyC,IAAI,KAAK,QAApB,IAAgCqG,KAAK,CAACC,QAAQ,CAACtG,IAAD,CAAT,CAAzC,EAAkEjD,GAAG,CAAC,EAAD,CAAH;AAClE,SAAOmI,WAAW,CAAChF,GAAZ,CAAiB3B,IAAjB,CAAsB,IAAtB,EAA4BsB,KAAK,CAAC,CAAD,CAAjC,EAAsCG,IAAtC,EAA4CzC,KAA5C,EAAmDsC,KAAK,CAAC,CAAD,CAAxD,CAAP;AACA,CAHD;;;AAMA,SAAS2F,IAAT,CAAcpC,KAAd,EAA8BpD,IAA9B;AACC,MAAMH,KAAK,GAAGuD,KAAK,CAAC9G,WAAD,CAAnB;AACA,MAAMgJ,MAAM,GAAGzF,KAAK,GAAGa,MAAM,CAACb,KAAD,CAAT,GAAmBuD,KAAvC;AACA,SAAOkC,MAAM,CAACtF,IAAD,CAAb;AACA;;AAED,SAASuF,iBAAT,CAA2B1F,KAA3B,EAA8CyF,MAA9C,EAA2DtF,IAA3D;;;AACC,MAAMkB,IAAI,GAAGyE,sBAAsB,CAACL,MAAD,EAAStF,IAAT,CAAnC;AACA,SAAOkB,IAAI,GACR,WAAWA,IAAX,GACCA,IAAI,CAAC3D,KADN;AAGC;AAHD,eAIC2D,IAAI,CAACjB,GAJN,8CAIC,UAAU1B,IAAV,CAAesB,KAAK,CAAC0E,MAArB,CALO,GAMRZ,SANH;AAOA;;AAED,SAASgC,sBAAT,CACCL,MADD,EAECtF,IAFD;AAIC;AACA,MAAI,EAAEA,IAAI,IAAIsF,MAAV,CAAJ,EAAuB,OAAO3B,SAAP;AACvB,MAAIxF,KAAK,GAAGH,MAAM,CAACI,cAAP,CAAsBkH,MAAtB,CAAZ;;AACA,SAAOnH,KAAP,EAAc;AACb,QAAM+C,IAAI,GAAGlD,MAAM,CAACqB,wBAAP,CAAgClB,KAAhC,EAAuC6B,IAAvC,CAAb;AACA,QAAIkB,IAAJ,EAAU,OAAOA,IAAP;AACV/C,IAAAA,KAAK,GAAGH,MAAM,CAACI,cAAP,CAAsBD,KAAtB,CAAR;AACA;;AACD,SAAOwF,SAAP;AACA;;AAED,SAAgBmC,YAAYjG;AAC3B,MAAI,CAACA,KAAK,CAACiE,SAAX,EAAsB;AACrBjE,IAAAA,KAAK,CAACiE,SAAN,GAAkB,IAAlB;;AACA,QAAIjE,KAAK,CAACuC,OAAV,EAAmB;AAClB0D,MAAAA,WAAW,CAACjG,KAAK,CAACuC,OAAP,CAAX;AACA;AACD;AACD;AAED,SAAgBqD,YAAY5F;AAC3B,MAAI,CAACA,KAAK,CAACc,KAAX,EAAkB;AACjBd,IAAAA,KAAK,CAACc,KAAN,GAAcC,WAAW,CAACf,KAAK,CAACnB,KAAP,CAAzB;AACA;AACD;;ICrPY6H,KAAb;AAAA;AAAA;AAKC,iBAAYC,MAAZ;;;AAJA,oBAAA,GAAuBzK,UAAvB;AAEA,oBAAA,GAAuB,IAAvB;AASA;;;;;;;;;;;;;;;;;;;;AAmBA,gBAAA,GAAoB,UAAC8E,IAAD,EAAY4F,MAAZ,EAA0B9D,aAA1B;AACnB;AACA,UAAI,OAAO9B,IAAP,KAAgB,UAAhB,IAA8B,OAAO4F,MAAP,KAAkB,UAApD,EAAgE;AAC/D,YAAMC,WAAW,GAAGD,MAApB;AACAA,QAAAA,MAAM,GAAG5F,IAAT;AAEA,YAAM8F,IAAI,GAAG,KAAb;AACA,eAAO,SAASC,cAAT,CAEN/F,IAFM;;;cAENA;AAAAA,YAAAA,OAAO6F;;;4CACJzJ;AAAAA,YAAAA;;;AAEH,iBAAO0J,IAAI,CAACE,OAAL,CAAahG,IAAb,EAAmB,UAACuC,KAAD;AAAA;;AAAA,mBAAoB,WAAAqD,MAAM,EAAClI,IAAP,iBAAY,MAAZ,EAAkB6E,KAAlB,SAA4BnG,IAA5B,EAApB;AAAA,WAAnB,CAAP;AACA,SAND;AAOA;;AAED,UAAI,OAAOwJ,MAAP,KAAkB,UAAtB,EAAkC1J,GAAG,CAAC,CAAD,CAAH;AAClC,UAAI4F,aAAa,KAAKgB,SAAlB,IAA+B,OAAOhB,aAAP,KAAyB,UAA5D,EACC5F,GAAG,CAAC,CAAD,CAAH;AAED,UAAIyG,MAAJ;;AAGA,UAAIhG,WAAW,CAACqD,IAAD,CAAf,EAAuB;AACtB,YAAM6B,KAAK,GAAGQ,UAAU,CAAC,KAAD,CAAxB;AACA,YAAMmC,KAAK,GAAGK,WAAW,CAAC,KAAD,EAAO7E,IAAP,EAAa8C,SAAb,CAAzB;AACA,YAAImD,QAAQ,GAAG,IAAf;;AACA,YAAI;AACHtD,UAAAA,MAAM,GAAGiD,MAAM,CAACpB,KAAD,CAAf;AACAyB,UAAAA,QAAQ,GAAG,KAAX;AACA,SAHD,SAGU;AACT;AACA,cAAIA,QAAJ,EAAc/D,WAAW,CAACL,KAAD,CAAX,CAAd,KACKM,UAAU,CAACN,KAAD,CAAV;AACL;;AACD,YAAI,OAAOqE,OAAP,KAAmB,WAAnB,IAAkCvD,MAAM,YAAYuD,OAAxD,EAAiE;AAChE,iBAAOvD,MAAM,CAACwD,IAAP,CACN,UAAAxD,MAAM;AACLf,YAAAA,iBAAiB,CAACC,KAAD,EAAQC,aAAR,CAAjB;AACA,mBAAOY,aAAa,CAACC,MAAD,EAASd,KAAT,CAApB;AACA,WAJK,EAKN,UAAA1F,KAAK;AACJ+F,YAAAA,WAAW,CAACL,KAAD,CAAX;AACA,kBAAM1F,KAAN;AACA,WARK,CAAP;AAUA;;AACDyF,QAAAA,iBAAiB,CAACC,KAAD,EAAQC,aAAR,CAAjB;AACA,eAAOY,aAAa,CAACC,MAAD,EAASd,KAAT,CAApB;AACA,OA1BD,MA0BO,IAAI,CAAC7B,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAA7B,EAAuC;AAC7C2C,QAAAA,MAAM,GAAGiD,MAAM,CAAC5F,IAAD,CAAf;AACA,YAAI2C,MAAM,KAAKG,SAAf,EAA0BH,MAAM,GAAG3C,IAAT;AAC1B,YAAI2C,MAAM,KAAKrH,OAAf,EAAwBqH,MAAM,GAAGG,SAAT;AACxB,YAAI,KAAI,CAACkB,WAAT,EAAsBtD,MAAM,CAACiC,MAAD,EAAS,IAAT,CAAN;;AACtB,YAAIb,aAAJ,EAAmB;AAClB,cAAMsE,CAAC,GAAY,EAAnB;AACA,cAAMC,EAAE,GAAY,EAApB;AACArF,UAAAA,SAAS,CAAC,SAAD,CAAT,CAAqBoC,2BAArB,CAAiDpD,IAAjD,EAAuD2C,MAAvD,EAA+DyD,CAA/D,EAAkEC,EAAlE;AACAvE,UAAAA,aAAa,CAACsE,CAAD,EAAIC,EAAJ,CAAb;AACA;;AACD,eAAO1D,MAAP;AACA,OAZM,MAYAzG,GAAG,CAAC,EAAD,EAAK8D,IAAL,CAAH;AACP,KA9DD;;AAgEA,2BAAA,GAA0C,UACzCA,IADyC,EAEzC4F,MAFyC;AAIzC;AACA,UAAI,OAAO5F,IAAP,KAAgB,UAApB,EAAgC;AAC/B,eAAO,UAAChB,KAAD;AAAA,6CAAgB5C,IAAhB;AAAgBA,YAAAA,IAAhB;AAAA;;AAAA,iBACN,KAAI,CAACkK,kBAAL,CAAwBtH,KAAxB,EAA+B,UAACuD,KAAD;AAAA,mBAAgBvC,IAAI,MAAJ,UAAKuC,KAAL,SAAenG,IAAf,EAAhB;AAAA,WAA/B,CADM;AAAA,SAAP;AAEA;;AAED,UAAImK,OAAJ,EAAsBC,cAAtB;;AACA,UAAM7D,MAAM,GAAG,KAAI,CAACqD,OAAL,CAAahG,IAAb,EAAmB4F,MAAnB,EAA2B,UAACQ,CAAD,EAAaC,EAAb;AACzCE,QAAAA,OAAO,GAAGH,CAAV;AACAI,QAAAA,cAAc,GAAGH,EAAjB;AACA,OAHc,CAAf;;AAKA,UAAI,OAAOH,OAAP,KAAmB,WAAnB,IAAkCvD,MAAM,YAAYuD,OAAxD,EAAiE;AAChE,eAAOvD,MAAM,CAACwD,IAAP,CAAY,UAAAM,SAAS;AAAA,iBAAI,CAACA,SAAD,EAAYF,OAAZ,EAAsBC,cAAtB,CAAJ;AAAA,SAArB,CAAP;AACA;;AACD,aAAO,CAAC7D,MAAD,EAAS4D,OAAT,EAAmBC,cAAnB,CAAP;AACA,KApBD;;AAzFC,QAAI,QAAOb,MAAP,aAAOA,MAAP,uBAAOA,MAAM,CAAEe,UAAf,MAA8B,SAAlC,EACC,KAAKC,aAAL,CAAmBhB,MAAO,CAACe,UAA3B;AACD,QAAI,QAAOf,MAAP,aAAOA,MAAP,uBAAOA,MAAM,CAAEiB,UAAf,MAA8B,SAAlC,EACC,KAAKC,aAAL,CAAmBlB,MAAO,CAACiB,UAA3B;AACD;;AAVF;;AAAA,SAqHCE,WArHD,GAqHC,qBAAiC9G,IAAjC;AACC,QAAI,CAACrD,WAAW,CAACqD,IAAD,CAAhB,EAAwB9D,GAAG,CAAC,CAAD,CAAH;AACxB,QAAIO,OAAO,CAACuD,IAAD,CAAX,EAAmBA,IAAI,GAAG+E,OAAO,CAAC/E,IAAD,CAAd;AACnB,QAAM6B,KAAK,GAAGQ,UAAU,CAAC,IAAD,CAAxB;AACA,QAAMmC,KAAK,GAAGK,WAAW,CAAC,IAAD,EAAO7E,IAAP,EAAa8C,SAAb,CAAzB;AACA0B,IAAAA,KAAK,CAAC/I,WAAD,CAAL,CAAmB0I,SAAnB,GAA+B,IAA/B;AACAhC,IAAAA,UAAU,CAACN,KAAD,CAAV;AACA,WAAO2C,KAAP;AACA,GA7HF;;AAAA,SA+HCuC,WA/HD,GA+HC,qBACCxE,KADD,EAECT,aAFD;AAIC,QAAM9C,KAAK,GAAeuD,KAAK,IAAKA,KAAa,CAAC9G,WAAD,CAAjD;;AACA,IAAa;AACZ,UAAI,CAACuD,KAAD,IAAU,CAACA,KAAK,CAACmF,SAArB,EAAgCjI,GAAG,CAAC,CAAD,CAAH;AAChC,UAAI8C,KAAK,CAACyE,UAAV,EAAsBvH,GAAG,CAAC,EAAD,CAAH;AACtB;;QACc2F,QAAS7C,MAAjBwE;AACP5B,IAAAA,iBAAiB,CAACC,KAAD,EAAQC,aAAR,CAAjB;AACA,WAAOY,aAAa,CAACI,SAAD,EAAYjB,KAAZ,CAApB;AACA;AAED;;;;;AA7ID;;AAAA,SAkJCgF,aAlJD,GAkJC,uBAAcnK,KAAd;AACC,SAAKsH,WAAL,GAAmBtH,KAAnB;AACA;AAED;;;;;;AAtJD;;AAAA,SA4JCiK,aA5JD,GA4JC,uBAAcjK,KAAd;AACC,QAAIA,KAAK,IAAI,CAACxB,UAAd,EAA0B;AACzBgB,MAAAA,GAAG,CAAC,EAAD,CAAH;AACA;;AACD,SAAK6G,WAAL,GAAmBrG,KAAnB;AACA,GAjKF;;AAAA,SAmKCsK,YAnKD,GAmKC,sBAAkChH,IAAlC,EAA2CuG,OAA3C;AACC;AACA;AACA,QAAIpG,CAAJ;;AACA,SAAKA,CAAC,GAAGoG,OAAO,CAACnG,MAAR,GAAiB,CAA1B,EAA6BD,CAAC,IAAI,CAAlC,EAAqCA,CAAC,EAAtC,EAA0C;AACzC,UAAM8G,KAAK,GAAGV,OAAO,CAACpG,CAAD,CAArB;;AACA,UAAI8G,KAAK,CAACnL,IAAN,CAAWsE,MAAX,KAAsB,CAAtB,IAA2B6G,KAAK,CAAClL,EAAN,KAAa,SAA5C,EAAuD;AACtDiE,QAAAA,IAAI,GAAGiH,KAAK,CAACvK,KAAb;AACA;AACA;AACD;AAED;;;AACA,QAAIyD,CAAC,GAAG,CAAC,CAAT,EAAY;AACXoG,MAAAA,OAAO,GAAGA,OAAO,CAACtG,KAAR,CAAcE,CAAC,GAAG,CAAlB,CAAV;AACA;;AAED,QAAM+G,gBAAgB,GAAGlG,SAAS,CAAC,SAAD,CAAT,CAAqBmG,aAA9C;;AACA,QAAI1K,OAAO,CAACuD,IAAD,CAAX,EAAmB;AAClB;AACA,aAAOkH,gBAAgB,CAAClH,IAAD,EAAOuG,OAAP,CAAvB;AACA;;;AAED,WAAO,KAAKP,OAAL,CAAahG,IAAb,EAAmB,UAACuC,KAAD;AAAA,aACzB2E,gBAAgB,CAAC3E,KAAD,EAAQgE,OAAR,CADS;AAAA,KAAnB,CAAP;AAGA,GA7LF;;AAAA;AAAA;AAgMA,SAAgB1B,YACfvC,OACA5F,OACAwH;AAEA;AACA,MAAM3B,KAAK,GAAYvF,KAAK,CAACN,KAAD,CAAL,GACpBsE,SAAS,CAAC,QAAD,CAAT,CAAoBoG,SAApB,CAA8B1K,KAA9B,EAAqCwH,MAArC,CADoB,GAEpBjH,KAAK,CAACP,KAAD,CAAL,GACAsE,SAAS,CAAC,QAAD,CAAT,CAAoBqG,SAApB,CAA8B3K,KAA9B,EAAqCwH,MAArC,CADA,GAEA5B,KAAK,CAACS,WAAN,GACAkB,gBAAgB,CAACvH,KAAD,EAAQwH,MAAR,CADhB,GAEAlD,SAAS,CAAC,KAAD,CAAT,CAAiBsG,eAAjB,CAAiC5K,KAAjC,EAAwCwH,MAAxC,CANH;AAQA,MAAMrC,KAAK,GAAGqC,MAAM,GAAGA,MAAM,CAACV,MAAV,GAAmBnC,eAAe,EAAtD;AACAQ,EAAAA,KAAK,CAACJ,OAAN,CAAc8F,IAAd,CAAmBhF,KAAnB;AACA,SAAOA,KAAP;AACA;;SClOewC,QAAQrI;AACvB,MAAI,CAACD,OAAO,CAACC,KAAD,CAAZ,EAAqBR,GAAG,CAAC,EAAD,EAAKQ,KAAL,CAAH;AACrB,SAAO8K,WAAW,CAAC9K,KAAD,CAAlB;AACA;;AAED,SAAS8K,WAAT,CAAqB9K,KAArB;AACC,MAAI,CAACC,WAAW,CAACD,KAAD,CAAhB,EAAyB,OAAOA,KAAP;AACzB,MAAMsC,KAAK,GAA2BtC,KAAK,CAACjB,WAAD,CAA3C;AACA,MAAIgM,IAAJ;AACA,MAAMC,QAAQ,GAAG9I,WAAW,CAAClC,KAAD,CAA5B;;AACA,MAAIsC,KAAJ,EAAW;AACV,QACC,CAACA,KAAK,CAACiE,SAAP,KACCjE,KAAK,CAACC,KAAN,GAAc,CAAd,IAAmB,CAAC+B,SAAS,CAAC,KAAD,CAAT,CAAiB2G,WAAjB,CAA6B3I,KAA7B,CADrB,CADD,EAIC,OAAOA,KAAK,CAACnB,KAAb,CALS;;AAOVmB,IAAAA,KAAK,CAACyE,UAAN,GAAmB,IAAnB;AACAgE,IAAAA,IAAI,GAAGG,UAAU,CAAClL,KAAD,EAAQgL,QAAR,CAAjB;AACA1I,IAAAA,KAAK,CAACyE,UAAN,GAAmB,KAAnB;AACA,GAVD,MAUO;AACNgE,IAAAA,IAAI,GAAGG,UAAU,CAAClL,KAAD,EAAQgL,QAAR,CAAjB;AACA;;AAEDjJ,EAAAA,IAAI,CAACgJ,IAAD,EAAO,UAAClJ,GAAD,EAAM+E,UAAN;AACV,QAAItE,KAAK,IAAII,GAAG,CAACJ,KAAK,CAACnB,KAAP,EAAcU,GAAd,CAAH,KAA0B+E,UAAvC,EAAmD;;AACnDjE,IAAAA,GAAG,CAACoI,IAAD,EAAOlJ,GAAP,EAAYiJ,WAAW,CAAClE,UAAD,CAAvB,CAAH;AACA,GAHG,CAAJ;;AAKA,SAAOoE,QAAQ;;AAAR,IAA4B,IAAIzM,GAAJ,CAAQwM,IAAR,CAA5B,GAA4CA,IAAnD;AACA;;AAED,SAASG,UAAT,CAAoBlL,KAApB,EAAgCgL,QAAhC;AACC;AACA,UAAQA,QAAR;AACC;;AAAA;AACC,aAAO,IAAI3M,GAAJ,CAAQ2B,KAAR,CAAP;;AACD;;AAAA;AACC;AACA,aAAOG,KAAK,CAACgL,IAAN,CAAWnL,KAAX,CAAP;AALF;;AAOA,SAAOqD,WAAW,CAACrD,KAAD,CAAlB;AACA;;SCnCeoL;AACf,WAAS9E,gBAAT,CACCnB,KADD,EAECc,MAFD,EAGCE,UAHD;AAKC,QAAI,CAACA,UAAL,EAAiB;AAChB,UAAIhB,KAAK,CAACE,QAAV,EAAoB;AACnBgG,QAAAA,sBAAsB,CAAClG,KAAK,CAACJ,OAAN,CAAe,CAAf,CAAD,CAAtB;AACA,OAHe;;;AAKhBuG,MAAAA,gBAAgB,CAACnG,KAAK,CAACJ,OAAP,CAAhB;AACA,KAND;AAAA,SAQK,IACJhF,OAAO,CAACkG,MAAD,CAAP,IACCA,MAAM,CAAClH,WAAD,CAAN,CAAiC+H,MAAjC,KAA4C3B,KAFzC,EAGH;AACDmG,QAAAA,gBAAgB,CAACnG,KAAK,CAACJ,OAAP,CAAhB;AACA;AACD;;AAED,WAASwG,cAAT,CAAwBnL,OAAxB,EAA0CkD,IAA1C;AACC,QAAIlD,OAAJ,EAAa;AACZ,UAAMyF,KAAK,GAAG,IAAI1F,KAAJ,CAAUmD,IAAI,CAACI,MAAf,CAAd;;AACA,WAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAAI,CAACI,MAAzB,EAAiCD,CAAC,EAAlC;AACChD,QAAAA,MAAM,CAACiI,cAAP,CAAsB7C,KAAtB,EAA6B,KAAKpC,CAAlC,EAAqC+H,aAAa,CAAC/H,CAAD,EAAI,IAAJ,CAAlD;AADD;;AAEA,aAAOoC,KAAP;AACA,KALD,MAKO;AACN,UAAMrC,YAAW,GAAG/B,yBAAyB,CAAC6B,IAAD,CAA7C;;AACA,aAAOE,YAAW,CAACzE,WAAD,CAAlB;AACA,UAAMoD,IAAI,GAAGf,OAAO,CAACoC,YAAD,CAApB;;AACA,WAAK,IAAIC,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGtB,IAAI,CAACuB,MAAzB,EAAiCD,EAAC,EAAlC,EAAsC;AACrC,YAAM5B,GAAG,GAAQM,IAAI,CAACsB,EAAD,CAArB;AACAD,QAAAA,YAAW,CAAC3B,GAAD,CAAX,GAAmB2J,aAAa,CAC/B3J,GAD+B,EAE/BzB,OAAO,IAAI,CAAC,CAACoD,YAAW,CAAC3B,GAAD,CAAX,CAAiBiC,UAFC,CAAhC;AAIA;;AACD,aAAOrD,MAAM,CAACsD,MAAP,CAActD,MAAM,CAACI,cAAP,CAAsByC,IAAtB,CAAd,EAA2CE,YAA3C,CAAP;AACA;AACD;;AAED,WAASoH,eAAT,CACCtH,IADD,EAECkE,MAFD;AAIC,QAAMpH,OAAO,GAAGD,KAAK,CAACC,OAAN,CAAckD,IAAd,CAAhB;AACA,QAAMuC,KAAK,GAAG0F,cAAc,CAACnL,OAAD,EAAUkD,IAAV,CAA5B;AAEA,QAAMhB,KAAK,GAAmC;AAC7CC,MAAAA,KAAK,EAAEnC,OAAO;;AAAA,QAAyB;;AADM;AAE7C0G,MAAAA,MAAM,EAAEU,MAAM,GAAGA,MAAM,CAACV,MAAV,GAAmBnC,eAAe,EAFH;AAG7C4B,MAAAA,SAAS,EAAE,KAHkC;AAI7CQ,MAAAA,UAAU,EAAE,KAJiC;AAK7CM,MAAAA,SAAS,EAAE,EALkC;AAM7CxC,MAAAA,OAAO,EAAE2C,MANoC;AAO7C;AACArG,MAAAA,KAAK,EAAEmC,IARsC;AAS7C;AACA0D,MAAAA,MAAM,EAAEnB,KAVqC;AAW7CzC,MAAAA,KAAK,EAAE,IAXsC;AAY7C2C,MAAAA,QAAQ,EAAE,KAZmC;AAa7C0B,MAAAA,SAAS,EAAE;AAbkC,KAA9C;AAgBAhH,IAAAA,MAAM,CAACiI,cAAP,CAAsB7C,KAAtB,EAA6B9G,WAA7B,EAA0C;AACzCiB,MAAAA,KAAK,EAAEsC,KADkC;AAEzC;AACAsB,MAAAA,QAAQ,EAAE;AAH+B,KAA1C;AAKA,WAAOiC,KAAP;AACA;AAGD;;;AACA,MAAMrC,WAAW,GAAyC,EAA1D;;AAEA,WAASgI,aAAT,CACC/I,IADD,EAECqB,UAFD;AAIC,QAAIH,IAAI,GAAGH,WAAW,CAACf,IAAD,CAAtB;;AACA,QAAIkB,IAAJ,EAAU;AACTA,MAAAA,IAAI,CAACG,UAAL,GAAkBA,UAAlB;AACA,KAFD,MAEO;AACNN,MAAAA,WAAW,CAACf,IAAD,CAAX,GAAoBkB,IAAI,GAAG;AAC1BE,QAAAA,YAAY,EAAE,IADY;AAE1BC,QAAAA,UAAU,EAAVA,UAF0B;AAG1BpB,QAAAA,GAH0B;AAIzB,cAAMJ,KAAK,GAAG,KAAKvD,WAAL,CAAd;AACA,UAAa0M,eAAe,CAACnJ,KAAD,CAAf;;AAEb,iBAAOqF,WAAW,CAACjF,GAAZ,CAAgBJ,KAAhB,EAAuBG,IAAvB,CAAP;AACA,SARyB;AAS1BE,QAAAA,GAT0B,eASX3C,KATW;AAUzB,cAAMsC,KAAK,GAAG,KAAKvD,WAAL,CAAd;AACA,UAAa0M,eAAe,CAACnJ,KAAD,CAAf;;AAEbqF,UAAAA,WAAW,CAAChF,GAAZ,CAAgBL,KAAhB,EAAuBG,IAAvB,EAA6BzC,KAA7B;AACA;AAdyB,OAA3B;AAgBA;;AACD,WAAO2D,IAAP;AACA;;;AAGD,WAAS2H,gBAAT,CAA0BI,MAA1B;AACC;AACA;AACA;AACA;AACA,SAAK,IAAIjI,CAAC,GAAGiI,MAAM,CAAChI,MAAP,GAAgB,CAA7B,EAAgCD,CAAC,IAAI,CAArC,EAAwCA,CAAC,EAAzC,EAA6C;AAC5C,UAAMnB,KAAK,GAAaoJ,MAAM,CAACjI,CAAD,CAAN,CAAU1E,WAAV,CAAxB;;AACA,UAAI,CAACuD,KAAK,CAACiE,SAAX,EAAsB;AACrB,gBAAQjE,KAAK,CAACC,KAAd;AACC;;AAAA;AACC,gBAAIoJ,eAAe,CAACrJ,KAAD,CAAnB,EAA4BiG,WAAW,CAACjG,KAAD,CAAX;AAC5B;;AACD;;AAAA;AACC,gBAAIsJ,gBAAgB,CAACtJ,KAAD,CAApB,EAA6BiG,WAAW,CAACjG,KAAD,CAAX;AAC7B;AANF;AAQA;AACD;AACD;;AAED,WAAS+I,sBAAT,CAAgCQ,MAAhC;AACC,QAAI,CAACA,MAAD,IAAW,OAAOA,MAAP,KAAkB,QAAjC,EAA2C;AAC3C,QAAMvJ,KAAK,GAAyBuJ,MAAM,CAAC9M,WAAD,CAA1C;AACA,QAAI,CAACuD,KAAL,EAAY;QACLnB,QAAmCmB,MAAnCnB;QAAO6F,SAA4B1E,MAA5B0E;QAAQK,YAAoB/E,MAApB+E;QAAW9E,QAASD,MAATC;;AACjC,QAAIA,KAAK;;AAAT,MAAmC;AAClC;AACA;AACA;AACA;AACAR,QAAAA,IAAI,CAACiF,MAAD,EAAS,UAAAnF,GAAG;AACf,cAAKA,GAAW,KAAK9C,WAArB,EAAkC;;AAElC,cAAKoC,KAAa,CAACU,GAAD,CAAb,KAAuBuE,SAAvB,IAAoC,CAAC5D,GAAG,CAACrB,KAAD,EAAQU,GAAR,CAA7C,EAA2D;AAC1DwF,YAAAA,SAAS,CAACxF,GAAD,CAAT,GAAiB,IAAjB;AACA0G,YAAAA,WAAW,CAACjG,KAAD,CAAX;AACA,WAHD,MAGO,IAAI,CAAC+E,SAAS,CAACxF,GAAD,CAAd,EAAqB;AAC3B;AACAwJ,YAAAA,sBAAsB,CAACrE,MAAM,CAACnF,GAAD,CAAP,CAAtB;AACA;AACD,SAVG,CAAJ,CALkC;;AAiBlCE,QAAAA,IAAI,CAACZ,KAAD,EAAQ,UAAAU,GAAG;AACd;AACA,cAAImF,MAAM,CAACnF,GAAD,CAAN,KAAgBuE,SAAhB,IAA6B,CAAC5D,GAAG,CAACwE,MAAD,EAASnF,GAAT,CAArC,EAAoD;AACnDwF,YAAAA,SAAS,CAACxF,GAAD,CAAT,GAAiB,KAAjB;AACA0G,YAAAA,WAAW,CAACjG,KAAD,CAAX;AACA;AACD,SANG,CAAJ;AAOA,OAxBD,MAwBO,IAAIC,KAAK;;AAAT,MAAkC;AACxC,YAAIoJ,eAAe,CAACrJ,KAAD,CAAnB,EAA6C;AAC5CiG,UAAAA,WAAW,CAACjG,KAAD,CAAX;AACA+E,UAAAA,SAAS,CAAC3D,MAAV,GAAmB,IAAnB;AACA;;AAED,YAAIsD,MAAM,CAACtD,MAAP,GAAgBvC,KAAK,CAACuC,MAA1B,EAAkC;AACjC,eAAK,IAAID,CAAC,GAAGuD,MAAM,CAACtD,MAApB,EAA4BD,CAAC,GAAGtC,KAAK,CAACuC,MAAtC,EAA8CD,CAAC,EAA/C;AAAmD4D,YAAAA,SAAS,CAAC5D,CAAD,CAAT,GAAe,KAAf;AAAnD;AACA,SAFD,MAEO;AACN,eAAK,IAAIA,GAAC,GAAGtC,KAAK,CAACuC,MAAnB,EAA2BD,GAAC,GAAGuD,MAAM,CAACtD,MAAtC,EAA8CD,GAAC,EAA/C;AAAmD4D,YAAAA,SAAS,CAAC5D,GAAD,CAAT,GAAe,IAAf;AAAnD;AACA,SAVuC;;;AAaxC,YAAMqI,GAAG,GAAGC,IAAI,CAACD,GAAL,CAAS9E,MAAM,CAACtD,MAAhB,EAAwBvC,KAAK,CAACuC,MAA9B,CAAZ;;AAEA,aAAK,IAAID,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGqI,GAApB,EAAyBrI,GAAC,EAA1B,EAA8B;AAC7B;AACA,cAAI,CAACuD,MAAM,CAACjG,cAAP,CAAsB0C,GAAtB,CAAL,EAA+B;AAC9B4D,YAAAA,SAAS,CAAC5D,GAAD,CAAT,GAAe,IAAf;AACA;;AACD,cAAI4D,SAAS,CAAC5D,GAAD,CAAT,KAAiB2C,SAArB,EAAgCiF,sBAAsB,CAACrE,MAAM,CAACvD,GAAD,CAAP,CAAtB;AAChC;AACD;AACD;;AAED,WAASmI,gBAAT,CAA0BtJ,KAA1B;QACQnB,QAAiBmB,MAAjBnB;QAAO6F,SAAU1E,MAAV0E;AAGd;;AACA,QAAM7E,IAAI,GAAGf,OAAO,CAAC4F,MAAD,CAApB;;AACA,SAAK,IAAIvD,CAAC,GAAGtB,IAAI,CAACuB,MAAL,GAAc,CAA3B,EAA8BD,CAAC,IAAI,CAAnC,EAAsCA,CAAC,EAAvC,EAA2C;AAC1C,UAAM5B,GAAG,GAAQM,IAAI,CAACsB,CAAD,CAArB;AACA,UAAI5B,GAAG,KAAK9C,WAAZ,EAAyB;AACzB,UAAMiN,SAAS,GAAG7K,KAAK,CAACU,GAAD,CAAvB,CAH0C;;AAK1C,UAAImK,SAAS,KAAK5F,SAAd,IAA2B,CAAC5D,GAAG,CAACrB,KAAD,EAAQU,GAAR,CAAnC,EAAiD;AAChD,eAAO,IAAP;AACA,OAFD;AAIA;AAJA,WAKK;AACJ,cAAM7B,KAAK,GAAGgH,MAAM,CAACnF,GAAD,CAApB;;AACA,cAAMS,MAAK,GAAetC,KAAK,IAAIA,KAAK,CAACjB,WAAD,CAAxC;;AACA,cAAIuD,MAAK,GAAGA,MAAK,CAACnB,KAAN,KAAgB6K,SAAnB,GAA+B,CAAChJ,EAAE,CAAChD,KAAD,EAAQgM,SAAR,CAA3C,EAA+D;AAC9D,mBAAO,IAAP;AACA;AACD;AACD;AAGD;;;AACA,QAAMC,WAAW,GAAG,CAAC,CAAC9K,KAAK,CAACpC,WAAD,CAA3B;AACA,WAAOoD,IAAI,CAACuB,MAAL,KAAgBtC,OAAO,CAACD,KAAD,CAAP,CAAeuC,MAAf,IAAyBuI,WAAW,GAAG,CAAH,GAAO,CAA3C,CAAvB;AACA;;AAED,WAASN,eAAT,CAAyBrJ,KAAzB;QACQ0E,SAAU1E,MAAV0E;AACP,QAAIA,MAAM,CAACtD,MAAP,KAAkBpB,KAAK,CAACnB,KAAN,CAAYuC,MAAlC,EAA0C,OAAO,IAAP;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAMwI,UAAU,GAAGzL,MAAM,CAACqB,wBAAP,CAClBkF,MADkB,EAElBA,MAAM,CAACtD,MAAP,GAAgB,CAFE,CAAnB;;AAKA,QAAIwI,UAAU,IAAI,CAACA,UAAU,CAACxJ,GAA9B,EAAmC,OAAO,IAAP;;AAEnC,SAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuD,MAAM,CAACtD,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACvC,UAAI,CAACuD,MAAM,CAACjG,cAAP,CAAsB0C,CAAtB,CAAL,EAA+B,OAAO,IAAP;AAC/B;;;AAED,WAAO,KAAP;AACA;;AAED,WAASwH,WAAT,CAAqB3I,KAArB;AACC,WAAOA,KAAK,CAACC,KAAN;;AAAA,MACJqJ,gBAAgB,CAACtJ,KAAD,CADZ,GAEJqJ,eAAe,CAACrJ,KAAD,CAFlB;AAGA;;AAED,WAASmJ,eAAT,CAAyBnJ;AAAW;AAApC;AACC,QAAIA,KAAK,CAACyD,QAAV,EAAoBvG,GAAG,CAAC,CAAD,EAAI2M,IAAI,CAACC,SAAL,CAAejJ,MAAM,CAACb,KAAD,CAArB,CAAJ,CAAH;AACpB;;AAEDkC,EAAAA,UAAU,CAAC,KAAD,EAAQ;AACjBoG,IAAAA,eAAe,EAAfA,eADiB;AAEjBtE,IAAAA,gBAAgB,EAAhBA,gBAFiB;AAGjB2E,IAAAA,WAAW,EAAXA;AAHiB,GAAR,CAAV;AAKA;;SC1PeoB;AACf,MAAMC,OAAO,GAAG,SAAhB;AACA,MAAMC,GAAG,GAAG,KAAZ;AACA,MAAMC,MAAM,GAAG,QAAf;;AAEA,WAASvF,gBAAT,CACC3E,KADD,EAECmK,QAFD,EAGC5C,OAHD,EAICC,cAJD;AAMC,YAAQxH,KAAK,CAACC,KAAd;AACC;;AAAA;AACA;;AAAA;AACA;;AAAA;AACC,eAAOmK,2BAA2B,CACjCpK,KADiC,EAEjCmK,QAFiC,EAGjC5C,OAHiC,EAIjCC,cAJiC,CAAlC;;AAMD;;AAAA;AACA;;AAAA;AACC,eAAO6C,oBAAoB,CAACrK,KAAD,EAAQmK,QAAR,EAAkB5C,OAAlB,EAA2BC,cAA3B,CAA3B;;AACD;;AAAA;AACC,eAAO8C,kBAAkB,CACvBtK,KADuB,EAExBmK,QAFwB,EAGxB5C,OAHwB,EAIxBC,cAJwB,CAAzB;AAdF;AAqBA;;AAED,WAAS6C,oBAAT,CACCrK,KADD,EAECmK,QAFD,EAGC5C,OAHD,EAICC,cAJD;QAMM3I,QAAoBmB,MAApBnB;QAAOkG,YAAa/E,MAAb+E;AACZ,QAAIjE,KAAK,GAAGd,KAAK,CAACc,KAAlB;;AAGA,QAAIA,KAAK,CAACM,MAAN,GAAevC,KAAK,CAACuC,MAAzB,EAAiC;AAChC,AADgC,iBAEd,CAACN,KAAD,EAAQjC,KAAR,CAFc;AAE9BA,MAAAA,KAF8B;AAEvBiC,MAAAA,KAFuB;AAAA,kBAGH,CAAC0G,cAAD,EAAiBD,OAAjB,CAHG;AAG9BA,MAAAA,OAH8B;AAGrBC,MAAAA,cAHqB;AAIhC;;;AAGD,SAAK,IAAIrG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtC,KAAK,CAACuC,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACtC,UAAI4D,SAAS,CAAC5D,CAAD,CAAT,IAAgBL,KAAK,CAACK,CAAD,CAAL,KAAatC,KAAK,CAACsC,CAAD,CAAtC,EAA2C;AAC1C,YAAMrE,IAAI,GAAGqN,QAAQ,CAACjL,MAAT,CAAgB,CAACiC,CAAD,CAAhB,CAAb;AACAoG,QAAAA,OAAO,CAACgB,IAAR,CAAa;AACZxL,UAAAA,EAAE,EAAEiN,OADQ;AAEZlN,UAAAA,IAAI,EAAJA,IAFY;AAGZ;AACA;AACAY,UAAAA,KAAK,EAAE6M,uBAAuB,CAACzJ,KAAK,CAACK,CAAD,CAAN;AALlB,SAAb;AAOAqG,QAAAA,cAAc,CAACe,IAAf,CAAoB;AACnBxL,UAAAA,EAAE,EAAEiN,OADe;AAEnBlN,UAAAA,IAAI,EAAJA,IAFmB;AAGnBY,UAAAA,KAAK,EAAE6M,uBAAuB,CAAC1L,KAAK,CAACsC,CAAD,CAAN;AAHX,SAApB;AAKA;AACD;;;AAGD,SAAK,IAAIA,EAAC,GAAGtC,KAAK,CAACuC,MAAnB,EAA2BD,EAAC,GAAGL,KAAK,CAACM,MAArC,EAA6CD,EAAC,EAA9C,EAAkD;AACjD,UAAMrE,KAAI,GAAGqN,QAAQ,CAACjL,MAAT,CAAgB,CAACiC,EAAD,CAAhB,CAAb;;AACAoG,MAAAA,OAAO,CAACgB,IAAR,CAAa;AACZxL,QAAAA,EAAE,EAAEkN,GADQ;AAEZnN,QAAAA,IAAI,EAAJA,KAFY;AAGZ;AACA;AACAY,QAAAA,KAAK,EAAE6M,uBAAuB,CAACzJ,KAAK,CAACK,EAAD,CAAN;AALlB,OAAb;AAOA;;AACD,QAAItC,KAAK,CAACuC,MAAN,GAAeN,KAAK,CAACM,MAAzB,EAAiC;AAChCoG,MAAAA,cAAc,CAACe,IAAf,CAAoB;AACnBxL,QAAAA,EAAE,EAAEiN,OADe;AAEnBlN,QAAAA,IAAI,EAAEqN,QAAQ,CAACjL,MAAT,CAAgB,CAAC,QAAD,CAAhB,CAFa;AAGnBxB,QAAAA,KAAK,EAAEmB,KAAK,CAACuC;AAHM,OAApB;AAKA;AACD;;;AAGD,WAASgJ,2BAAT,CACCpK,KADD,EAECmK,QAFD,EAGC5C,OAHD,EAICC,cAJD;QAMQ3I,QAAgBmB,MAAhBnB;QAAOiC,QAASd,MAATc;AACdrB,IAAAA,IAAI,CAACO,KAAK,CAAC+E,SAAP,EAAmB,UAACxF,GAAD,EAAMiL,aAAN;AACtB,UAAMC,SAAS,GAAGrK,GAAG,CAACvB,KAAD,EAAQU,GAAR,CAArB;AACA,UAAM7B,KAAK,GAAG0C,GAAG,CAACU,KAAD,EAASvB,GAAT,CAAjB;AACA,UAAMxC,EAAE,GAAG,CAACyN,aAAD,GAAiBN,MAAjB,GAA0BhK,GAAG,CAACrB,KAAD,EAAQU,GAAR,CAAH,GAAkByK,OAAlB,GAA4BC,GAAjE;AACA,UAAIQ,SAAS,KAAK/M,KAAd,IAAuBX,EAAE,KAAKiN,OAAlC,EAA2C;AAC3C,UAAMlN,IAAI,GAAGqN,QAAQ,CAACjL,MAAT,CAAgBK,GAAhB,CAAb;AACAgI,MAAAA,OAAO,CAACgB,IAAR,CAAaxL,EAAE,KAAKmN,MAAP,GAAgB;AAACnN,QAAAA,EAAE,EAAFA,EAAD;AAAKD,QAAAA,IAAI,EAAJA;AAAL,OAAhB,GAA6B;AAACC,QAAAA,EAAE,EAAFA,EAAD;AAAKD,QAAAA,IAAI,EAAJA,IAAL;AAAWY,QAAAA,KAAK,EAALA;AAAX,OAA1C;AACA8J,MAAAA,cAAc,CAACe,IAAf,CACCxL,EAAE,KAAKkN,GAAP,GACG;AAAClN,QAAAA,EAAE,EAAEmN,MAAL;AAAapN,QAAAA,IAAI,EAAJA;AAAb,OADH,GAEGC,EAAE,KAAKmN,MAAP,GACA;AAACnN,QAAAA,EAAE,EAAEkN,GAAL;AAAUnN,QAAAA,IAAI,EAAJA,IAAV;AAAgBY,QAAAA,KAAK,EAAE6M,uBAAuB,CAACE,SAAD;AAA9C,OADA,GAEA;AAAC1N,QAAAA,EAAE,EAAEiN,OAAL;AAAclN,QAAAA,IAAI,EAAJA,IAAd;AAAoBY,QAAAA,KAAK,EAAE6M,uBAAuB,CAACE,SAAD;AAAlD,OALJ;AAOA,KAdG,CAAJ;AAeA;;AAED,WAASH,kBAAT,CACCtK,KADD,EAECmK,QAFD,EAGC5C,OAHD,EAICC,cAJD;QAMM3I,QAAgBmB,MAAhBnB;QAAOiC,QAASd,MAATc;AAEZ,QAAIK,CAAC,GAAG,CAAR;AACAtC,IAAAA,KAAK,CAACS,OAAN,CAAc,UAAC5B,KAAD;AACb,UAAI,CAACoD,KAAM,CAACZ,GAAP,CAAWxC,KAAX,CAAL,EAAwB;AACvB,YAAMZ,IAAI,GAAGqN,QAAQ,CAACjL,MAAT,CAAgB,CAACiC,CAAD,CAAhB,CAAb;AACAoG,QAAAA,OAAO,CAACgB,IAAR,CAAa;AACZxL,UAAAA,EAAE,EAAEmN,MADQ;AAEZpN,UAAAA,IAAI,EAAJA,IAFY;AAGZY,UAAAA,KAAK,EAALA;AAHY,SAAb;AAKA8J,QAAAA,cAAc,CAACkD,OAAf,CAAuB;AACtB3N,UAAAA,EAAE,EAAEkN,GADkB;AAEtBnN,UAAAA,IAAI,EAAJA,IAFsB;AAGtBY,UAAAA,KAAK,EAALA;AAHsB,SAAvB;AAKA;;AACDyD,MAAAA,CAAC;AACD,KAfD;AAgBAA,IAAAA,CAAC,GAAG,CAAJ;AACAL,IAAAA,KAAM,CAACxB,OAAP,CAAe,UAAC5B,KAAD;AACd,UAAI,CAACmB,KAAK,CAACqB,GAAN,CAAUxC,KAAV,CAAL,EAAuB;AACtB,YAAMZ,IAAI,GAAGqN,QAAQ,CAACjL,MAAT,CAAgB,CAACiC,CAAD,CAAhB,CAAb;AACAoG,QAAAA,OAAO,CAACgB,IAAR,CAAa;AACZxL,UAAAA,EAAE,EAAEkN,GADQ;AAEZnN,UAAAA,IAAI,EAAJA,IAFY;AAGZY,UAAAA,KAAK,EAALA;AAHY,SAAb;AAKA8J,QAAAA,cAAc,CAACkD,OAAf,CAAuB;AACtB3N,UAAAA,EAAE,EAAEmN,MADkB;AAEtBpN,UAAAA,IAAI,EAAJA,IAFsB;AAGtBY,UAAAA,KAAK,EAALA;AAHsB,SAAvB;AAKA;;AACDyD,MAAAA,CAAC;AACD,KAfD;AAgBA;;AAED,WAASiD,2BAAT,CACCsF,SADD,EAECiB,WAFD,EAGCpD,OAHD,EAICC,cAJD;AAMCD,IAAAA,OAAO,CAACgB,IAAR,CAAa;AACZxL,MAAAA,EAAE,EAAEiN,OADQ;AAEZlN,MAAAA,IAAI,EAAE,EAFM;AAGZY,MAAAA,KAAK,EAAEiN,WAAW,KAAKrO,OAAhB,GAA0BwH,SAA1B,GAAsC6G;AAHjC,KAAb;AAKAnD,IAAAA,cAAc,CAACe,IAAf,CAAoB;AACnBxL,MAAAA,EAAE,EAAEiN,OADe;AAEnBlN,MAAAA,IAAI,EAAE,EAFa;AAGnBY,MAAAA,KAAK,EAAEgM;AAHY,KAApB;AAKA;;AAED,WAASvB,aAAT,CAA0B5E,KAA1B,EAAoCgE,OAApC;AACCA,IAAAA,OAAO,CAACjI,OAAR,CAAgB,UAAA2I,KAAK;UACbnL,OAAYmL,MAAZnL;UAAMC,KAAMkL,MAANlL;AAEb,UAAIiE,IAAI,GAAQuC,KAAhB;;AACA,WAAK,IAAIpC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrE,IAAI,CAACsE,MAAL,GAAc,CAAlC,EAAqCD,CAAC,EAAtC,EAA0C;AACzC,YAAMyJ,UAAU,GAAGhL,WAAW,CAACoB,IAAD,CAA9B;AACA,YAAMoG,CAAC,GAAG,KAAKtK,IAAI,CAACqE,CAAD,CAAnB,CAFyC;;AAIzC,YACC,CAACyJ,UAAU;;AAAV,WAAkCA,UAAU;;AAA7C,cACCxD,CAAC,KAAK,WAAN,IAAqBA,CAAC,KAAK,aAD5B,CADD,EAIClK,GAAG,CAAC,EAAD,CAAH;AACD,YAAI,OAAO8D,IAAP,KAAgB,UAAhB,IAA8BoG,CAAC,KAAK,WAAxC,EAAqDlK,GAAG,CAAC,EAAD,CAAH;AACrD8D,QAAAA,IAAI,GAAGZ,GAAG,CAACY,IAAD,EAAOoG,CAAP,CAAV;AACA,YAAI,OAAOpG,IAAP,KAAgB,QAApB,EAA8B9D,GAAG,CAAC,EAAD,EAAKJ,IAAI,CAAC+N,IAAL,CAAU,GAAV,CAAL,CAAH;AAC9B;;AAED,UAAMC,IAAI,GAAGlL,WAAW,CAACoB,IAAD,CAAxB;AACA,UAAMtD,KAAK,GAAGqN,mBAAmB,CAAC9C,KAAK,CAACvK,KAAP,CAAjC;;AACA,UAAM6B,GAAG,GAAGzC,IAAI,CAACA,IAAI,CAACsE,MAAL,GAAc,CAAf,CAAhB;;AACA,cAAQrE,EAAR;AACC,aAAKiN,OAAL;AACC,kBAAQc,IAAR;AACC;;AAAA;AACC,qBAAO9J,IAAI,CAACX,GAAL,CAASd,GAAT,EAAc7B,KAAd,CAAP;;AACD;;AACA;;AAAA;AACCR,cAAAA,GAAG,CAAC,EAAD,CAAH;;AACD;AACC;AACA;AACA;AACA;AACA,qBAAQ8D,IAAI,CAACzB,GAAD,CAAJ,GAAY7B,KAApB;AAXF;;AAaD,aAAKuM,GAAL;AACC,kBAAQa,IAAR;AACC;;AAAA;AACC,qBAAOvL,GAAG,KAAK,GAAR,GACJyB,IAAI,CAACuH,IAAL,CAAU7K,KAAV,CADI,GAEJsD,IAAI,CAACgK,MAAL,CAAYzL,GAAZ,EAAwB,CAAxB,EAA2B7B,KAA3B,CAFH;;AAGD;;AAAA;AACC,qBAAOsD,IAAI,CAACX,GAAL,CAASd,GAAT,EAAc7B,KAAd,CAAP;;AACD;;AAAA;AACC,qBAAOsD,IAAI,CAACP,GAAL,CAAS/C,KAAT,CAAP;;AACD;AACC,qBAAQsD,IAAI,CAACzB,GAAD,CAAJ,GAAY7B,KAApB;AAVF;;AAYD,aAAKwM,MAAL;AACC,kBAAQY,IAAR;AACC;;AAAA;AACC,qBAAO9J,IAAI,CAACgK,MAAL,CAAYzL,GAAZ,EAAwB,CAAxB,CAAP;;AACD;;AAAA;AACC,qBAAOyB,IAAI,CAACR,MAAL,CAAYjB,GAAZ,CAAP;;AACD;;AAAA;AACC,qBAAOyB,IAAI,CAACR,MAAL,CAAYyH,KAAK,CAACvK,KAAlB,CAAP;;AACD;AACC,qBAAO,OAAOsD,IAAI,CAACzB,GAAD,CAAlB;AARF;;AAUD;AACCrC,UAAAA,GAAG,CAAC,EAAD,EAAKH,EAAL,CAAH;AAxCF;AA0CA,KA/DD;AAiEA,WAAOwG,KAAP;AACA;;AAMD,WAASwH,mBAAT,CAA6B/L,GAA7B;AACC,QAAI,CAACrB,WAAW,CAACqB,GAAD,CAAhB,EAAuB,OAAOA,GAAP;AACvB,QAAInB,KAAK,CAACC,OAAN,CAAckB,GAAd,CAAJ,EAAwB,OAAOA,GAAG,CAACiM,GAAJ,CAAQF,mBAAR,CAAP;AACxB,QAAI/M,KAAK,CAACgB,GAAD,CAAT,EACC,OAAO,IAAIjD,GAAJ,CACN8B,KAAK,CAACgL,IAAN,CAAW7J,GAAG,CAACkM,OAAJ,EAAX,EAA0BD,GAA1B,CAA8B;AAAA,UAAEE,CAAF;AAAA,UAAKC,CAAL;AAAA,aAAY,CAACD,CAAD,EAAIJ,mBAAmB,CAACK,CAAD,CAAvB,CAAZ;AAAA,KAA9B,CADM,CAAP;AAGD,QAAInN,KAAK,CAACe,GAAD,CAAT,EAAgB,OAAO,IAAI/C,GAAJ,CAAQ4B,KAAK,CAACgL,IAAN,CAAW7J,GAAX,EAAgBiM,GAAhB,CAAoBF,mBAApB,CAAR,CAAP;AAChB,QAAMM,MAAM,GAAGlN,MAAM,CAACsD,MAAP,CAActD,MAAM,CAACI,cAAP,CAAsBS,GAAtB,CAAd,CAAf;;AACA,SAAK,IAAMO,GAAX,IAAkBP,GAAlB;AAAuBqM,MAAAA,MAAM,CAAC9L,GAAD,CAAN,GAAcwL,mBAAmB,CAAC/L,GAAG,CAACO,GAAD,CAAJ,CAAjC;AAAvB;;AACA,QAAIW,GAAG,CAAClB,GAAD,EAAMsM,SAAN,CAAP,EAAyBD,MAAM,CAACC,SAAD,CAAN,GAAoBtM,GAAG,CAACsM,SAAD,CAAvB;AACzB,WAAOD,MAAP;AACA;;AAED,WAASd,uBAAT,CAAoCvL,GAApC;AACC,QAAIvB,OAAO,CAACuB,GAAD,CAAX,EAAkB;AACjB,aAAO+L,mBAAmB,CAAC/L,GAAD,CAA1B;AACA,KAFD,MAEO,OAAOA,GAAP;AACP;;AAEDkD,EAAAA,UAAU,CAAC,SAAD,EAAY;AACrBiG,IAAAA,aAAa,EAAbA,aADqB;AAErBxD,IAAAA,gBAAgB,EAAhBA,gBAFqB;AAGrBP,IAAAA,2BAA2B,EAA3BA;AAHqB,GAAZ,CAAV;AAKA;;AC5SD;AACA,SAmBgBmH;AACf;AACA,MAAIC,cAAa,GAAG,uBAASC,CAAT,EAAiBC,CAAjB;AACnBF,IAAAA,cAAa,GACZrN,MAAM,CAACkI,cAAP,IACC;AAACsF,MAAAA,SAAS,EAAE;AAAZ,iBAA2B9N,KAA3B,IACA,UAAS4N,CAAT,EAAYC,CAAZ;AACCD,MAAAA,CAAC,CAACE,SAAF,GAAcD,CAAd;AACA,KAJF,IAKA,UAASD,CAAT,EAAYC,CAAZ;AACC,WAAK,IAAItE,CAAT,IAAcsE,CAAd;AAAiB,YAAIA,CAAC,CAACjN,cAAF,CAAiB2I,CAAjB,CAAJ,EAAyBqE,CAAC,CAACrE,CAAD,CAAD,GAAOsE,CAAC,CAACtE,CAAD,CAAR;AAA1C;AACA,KARF;;AASA,WAAOoE,cAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACA,GAXD;;;AAcA,WAASE,SAAT,CAAmBH,CAAnB,EAA2BC,CAA3B;AACCF,IAAAA,cAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASG,EAAT;AACC,WAAK9N,WAAL,GAAmB0N,CAAnB;AACA;;AACDA,IAAAA,CAAC,CAACrN,SAAF;AAEGyN,IAAAA,EAAE,CAACzN,SAAH,GAAesN,CAAC,CAACtN,SAAlB,EAA8B,IAAIyN,EAAJ,EAFhC;AAGA;;AAED,MAAMC,QAAQ,GAAI,UAASC,MAAT;AACjBH,IAAAA,SAAS,CAACE,QAAD,EAAWC,MAAX,CAAT;;;AAEA,aAASD,QAAT,CAA6B1M,MAA7B,EAA6C8F,MAA7C;AACC,WAAKzI,WAAL,IAAoB;AACnBwD,QAAAA,KAAK;;AADc;AAEnBsC,QAAAA,OAAO,EAAE2C,MAFU;AAGnBV,QAAAA,MAAM,EAAEU,MAAM,GAAGA,MAAM,CAACV,MAAV,GAAmBnC,eAAe,EAH7B;AAInB4B,QAAAA,SAAS,EAAE,KAJQ;AAKnBQ,QAAAA,UAAU,EAAE,KALO;AAMnB3D,QAAAA,KAAK,EAAEgD,SANY;AAOnBiB,QAAAA,SAAS,EAAEjB,SAPQ;AAQnBjF,QAAAA,KAAK,EAAEO,MARY;AASnBsF,QAAAA,MAAM,EAAE,IATW;AAUnBS,QAAAA,SAAS,EAAE,KAVQ;AAWnB1B,QAAAA,QAAQ,EAAE;AAXS,OAApB;AAaA,aAAO,IAAP;AACA;;AACD,QAAM2D,CAAC,GAAG0E,QAAQ,CAAC1N,SAAnB;AAEAD,IAAAA,MAAM,CAACiI,cAAP,CAAsBgB,CAAtB,EAAyB,MAAzB,EAAiC;AAChChH,MAAAA,GAAG,EAAE;AACJ,eAAOS,MAAM,CAAC,KAAKpE,WAAL,CAAD,CAAN,CAA0BuP,IAAjC;AACA,OAH+B;AAKhC;;AALgC,KAAjC;;AAQA5E,IAAAA,CAAC,CAAClH,GAAF,GAAQ,UAASX,GAAT;AACP,aAAOsB,MAAM,CAAC,KAAKpE,WAAL,CAAD,CAAN,CAA0ByD,GAA1B,CAA8BX,GAA9B,CAAP;AACA,KAFD;;AAIA6H,IAAAA,CAAC,CAAC/G,GAAF,GAAQ,UAASd,GAAT,EAAmB7B,KAAnB;AACP,UAAMsC,KAAK,GAAa,KAAKvD,WAAL,CAAxB;AACA0M,MAAAA,eAAe,CAACnJ,KAAD,CAAf;;AACA,UAAI,CAACa,MAAM,CAACb,KAAD,CAAN,CAAcE,GAAd,CAAkBX,GAAlB,CAAD,IAA2BsB,MAAM,CAACb,KAAD,CAAN,CAAcI,GAAd,CAAkBb,GAAlB,MAA2B7B,KAA1D,EAAiE;AAChEuO,QAAAA,cAAc,CAACjM,KAAD,CAAd;AACAiG,QAAAA,WAAW,CAACjG,KAAD,CAAX;AACAA,QAAAA,KAAK,CAAC+E,SAAN,CAAiB1E,GAAjB,CAAqBd,GAArB,EAA0B,IAA1B;AACAS,QAAAA,KAAK,CAACc,KAAN,CAAaT,GAAb,CAAiBd,GAAjB,EAAsB7B,KAAtB;AACAsC,QAAAA,KAAK,CAAC+E,SAAN,CAAiB1E,GAAjB,CAAqBd,GAArB,EAA0B,IAA1B;AACA;;AACD,aAAO,IAAP;AACA,KAXD;;AAaA6H,IAAAA,CAAC,CAAC5G,MAAF,GAAW,UAASjB,GAAT;AACV,UAAI,CAAC,KAAKW,GAAL,CAASX,GAAT,CAAL,EAAoB;AACnB,eAAO,KAAP;AACA;;AAED,UAAMS,KAAK,GAAa,KAAKvD,WAAL,CAAxB;AACA0M,MAAAA,eAAe,CAACnJ,KAAD,CAAf;AACAiM,MAAAA,cAAc,CAACjM,KAAD,CAAd;AACAiG,MAAAA,WAAW,CAACjG,KAAD,CAAX;;AACA,UAAIA,KAAK,CAACnB,KAAN,CAAYqB,GAAZ,CAAgBX,GAAhB,CAAJ,EAA0B;AACzBS,QAAAA,KAAK,CAAC+E,SAAN,CAAiB1E,GAAjB,CAAqBd,GAArB,EAA0B,KAA1B;AACA,OAFD,MAEO;AACNS,QAAAA,KAAK,CAAC+E,SAAN,CAAiBvE,MAAjB,CAAwBjB,GAAxB;AACA;;AACDS,MAAAA,KAAK,CAACc,KAAN,CAAaN,MAAb,CAAoBjB,GAApB;AACA,aAAO,IAAP;AACA,KAhBD;;AAkBA6H,IAAAA,CAAC,CAACvF,KAAF,GAAU;AACT,UAAM7B,KAAK,GAAa,KAAKvD,WAAL,CAAxB;AACA0M,MAAAA,eAAe,CAACnJ,KAAD,CAAf;;AACA,UAAIa,MAAM,CAACb,KAAD,CAAN,CAAcgM,IAAlB,EAAwB;AACvBC,QAAAA,cAAc,CAACjM,KAAD,CAAd;AACAiG,QAAAA,WAAW,CAACjG,KAAD,CAAX;AACAA,QAAAA,KAAK,CAAC+E,SAAN,GAAkB,IAAIhJ,GAAJ,EAAlB;AACA0D,QAAAA,IAAI,CAACO,KAAK,CAACnB,KAAP,EAAc,UAAAU,GAAG;AACpBS,UAAAA,KAAK,CAAC+E,SAAN,CAAiB1E,GAAjB,CAAqBd,GAArB,EAA0B,KAA1B;AACA,SAFG,CAAJ;AAGAS,QAAAA,KAAK,CAACc,KAAN,CAAae,KAAb;AACA;AACD,KAZD;;AAcAuF,IAAAA,CAAC,CAAC9H,OAAF,GAAY,UACX4M,EADW,EAEXC,OAFW;;;AAIX,UAAMnM,KAAK,GAAa,KAAKvD,WAAL,CAAxB;AACAoE,MAAAA,MAAM,CAACb,KAAD,CAAN,CAAcV,OAAd,CAAsB,UAAC8M,MAAD,EAAc7M,GAAd,EAAwB8M,IAAxB;AACrBH,QAAAA,EAAE,CAACxN,IAAH,CAAQyN,OAAR,EAAiB,KAAI,CAAC/L,GAAL,CAASb,GAAT,CAAjB,EAAgCA,GAAhC,EAAqC,KAArC;AACA,OAFD;AAGA,KARD;;AAUA6H,IAAAA,CAAC,CAAChH,GAAF,GAAQ,UAASb,GAAT;AACP,UAAMS,KAAK,GAAa,KAAKvD,WAAL,CAAxB;AACA0M,MAAAA,eAAe,CAACnJ,KAAD,CAAf;AACA,UAAMtC,KAAK,GAAGmD,MAAM,CAACb,KAAD,CAAN,CAAcI,GAAd,CAAkBb,GAAlB,CAAd;;AACA,UAAIS,KAAK,CAACyE,UAAN,IAAoB,CAAC9G,WAAW,CAACD,KAAD,CAApC,EAA6C;AAC5C,eAAOA,KAAP;AACA;;AACD,UAAIA,KAAK,KAAKsC,KAAK,CAACnB,KAAN,CAAYuB,GAAZ,CAAgBb,GAAhB,CAAd,EAAoC;AACnC,eAAO7B,KAAP,CADmC;AAEnC;;;AAED,UAAM6F,KAAK,GAAGsC,WAAW,CAAC7F,KAAK,CAACwE,MAAN,CAAahC,MAAd,EAAsB9E,KAAtB,EAA6BsC,KAA7B,CAAzB;AACAiM,MAAAA,cAAc,CAACjM,KAAD,CAAd;AACAA,MAAAA,KAAK,CAACc,KAAN,CAAaT,GAAb,CAAiBd,GAAjB,EAAsBgE,KAAtB;AACA,aAAOA,KAAP;AACA,KAfD;;AAiBA6D,IAAAA,CAAC,CAACvH,IAAF,GAAS;AACR,aAAOgB,MAAM,CAAC,KAAKpE,WAAL,CAAD,CAAN,CAA0BoD,IAA1B,EAAP;AACA,KAFD;;AAIAuH,IAAAA,CAAC,CAACkF,MAAF,GAAW;;;;AACV,UAAM3P,QAAQ,GAAG,KAAKkD,IAAL,EAAjB;AACA,6BACEnD,cADF,IACmB;AAAA,eAAM,MAAI,CAAC4P,MAAL,EAAN;AAAA,OADnB,OAECC,IAFD,GAEO;AACL,YAAMC,CAAC,GAAG7P,QAAQ,CAAC4P,IAAT,EAAV;AACA;;AACA,YAAIC,CAAC,CAACC,IAAN,EAAY,OAAOD,CAAP;;AACZ,YAAM9O,KAAK,GAAG,MAAI,CAAC0C,GAAL,CAASoM,CAAC,CAAC9O,KAAX,CAAd;;AACA,eAAO;AACN+O,UAAAA,IAAI,EAAE,KADA;AAEN/O,UAAAA,KAAK,EAALA;AAFM,SAAP;AAIA,OAXF;AAaA,KAfD;;AAiBA0J,IAAAA,CAAC,CAAC8D,OAAF,GAAY;;;;AACX,UAAMvO,QAAQ,GAAG,KAAKkD,IAAL,EAAjB;AACA,+BACEnD,cADF,IACmB;AAAA,eAAM,MAAI,CAACwO,OAAL,EAAN;AAAA,OADnB,QAECqB,IAFD,GAEO;AACL,YAAMC,CAAC,GAAG7P,QAAQ,CAAC4P,IAAT,EAAV;AACA;;AACA,YAAIC,CAAC,CAACC,IAAN,EAAY,OAAOD,CAAP;;AACZ,YAAM9O,KAAK,GAAG,MAAI,CAAC0C,GAAL,CAASoM,CAAC,CAAC9O,KAAX,CAAd;;AACA,eAAO;AACN+O,UAAAA,IAAI,EAAE,KADA;AAEN/O,UAAAA,KAAK,EAAE,CAAC8O,CAAC,CAAC9O,KAAH,EAAUA,KAAV;AAFD,SAAP;AAIA,OAXF;AAaA,KAfD;;AAiBA0J,IAAAA,CAAC,CAAC1K,cAAD,CAAD,GAAoB;AACnB,aAAO,KAAKwO,OAAL,EAAP;AACA,KAFD;;AAIA,WAAOY,QAAP;AACA,GApJgB,CAoJd/P,GApJc,CAAjB;;AAsJA,WAASqM,SAAT,CAAqChJ,MAArC,EAAgD8F,MAAhD;AACC;AACA,WAAO,IAAI4G,QAAJ,CAAa1M,MAAb,EAAqB8F,MAArB,CAAP;AACA;;AAED,WAAS+G,cAAT,CAAwBjM,KAAxB;AACC,QAAI,CAACA,KAAK,CAACc,KAAX,EAAkB;AACjBd,MAAAA,KAAK,CAAC+E,SAAN,GAAkB,IAAIhJ,GAAJ,EAAlB;AACAiE,MAAAA,KAAK,CAACc,KAAN,GAAc,IAAI/E,GAAJ,CAAQiE,KAAK,CAACnB,KAAd,CAAd;AACA;AACD;;AAED,MAAM6N,QAAQ,GAAI,UAASX,MAAT;AACjBH,IAAAA,SAAS,CAACc,QAAD,EAAWX,MAAX,CAAT;;;AAEA,aAASW,QAAT,CAA6BtN,MAA7B,EAA6C8F,MAA7C;AACC,WAAKzI,WAAL,IAAoB;AACnBwD,QAAAA,KAAK;;AADc;AAEnBsC,QAAAA,OAAO,EAAE2C,MAFU;AAGnBV,QAAAA,MAAM,EAAEU,MAAM,GAAGA,MAAM,CAACV,MAAV,GAAmBnC,eAAe,EAH7B;AAInB4B,QAAAA,SAAS,EAAE,KAJQ;AAKnBQ,QAAAA,UAAU,EAAE,KALO;AAMnB3D,QAAAA,KAAK,EAAEgD,SANY;AAOnBjF,QAAAA,KAAK,EAAEO,MAPY;AAQnBsF,QAAAA,MAAM,EAAE,IARW;AASnBjC,QAAAA,OAAO,EAAE,IAAI1G,GAAJ,EATU;AAUnB0H,QAAAA,QAAQ,EAAE,KAVS;AAWnB0B,QAAAA,SAAS,EAAE;AAXQ,OAApB;AAaA,aAAO,IAAP;AACA;;AACD,QAAMiC,CAAC,GAAGsF,QAAQ,CAACtO,SAAnB;AAEAD,IAAAA,MAAM,CAACiI,cAAP,CAAsBgB,CAAtB,EAAyB,MAAzB,EAAiC;AAChChH,MAAAA,GAAG,EAAE;AACJ,eAAOS,MAAM,CAAC,KAAKpE,WAAL,CAAD,CAAN,CAA0BuP,IAAjC;AACA,OAH+B;;AAAA,KAAjC;;AAOA5E,IAAAA,CAAC,CAAClH,GAAF,GAAQ,UAASxC,KAAT;AACP,UAAMsC,KAAK,GAAa,KAAKvD,WAAL,CAAxB;AACA0M,MAAAA,eAAe,CAACnJ,KAAD,CAAf;;AAEA,UAAI,CAACA,KAAK,CAACc,KAAX,EAAkB;AACjB,eAAOd,KAAK,CAACnB,KAAN,CAAYqB,GAAZ,CAAgBxC,KAAhB,CAAP;AACA;;AACD,UAAIsC,KAAK,CAACc,KAAN,CAAYZ,GAAZ,CAAgBxC,KAAhB,CAAJ,EAA4B,OAAO,IAAP;AAC5B,UAAIsC,KAAK,CAACyC,OAAN,CAAcvC,GAAd,CAAkBxC,KAAlB,KAA4BsC,KAAK,CAACc,KAAN,CAAYZ,GAAZ,CAAgBF,KAAK,CAACyC,OAAN,CAAcrC,GAAd,CAAkB1C,KAAlB,CAAhB,CAAhC,EACC,OAAO,IAAP;AACD,aAAO,KAAP;AACA,KAXD;;AAaA0J,IAAAA,CAAC,CAAC3G,GAAF,GAAQ,UAAS/C,KAAT;AACP,UAAMsC,KAAK,GAAa,KAAKvD,WAAL,CAAxB;AACA0M,MAAAA,eAAe,CAACnJ,KAAD,CAAf;;AACA,UAAI,CAAC,KAAKE,GAAL,CAASxC,KAAT,CAAL,EAAsB;AACrBiP,QAAAA,cAAc,CAAC3M,KAAD,CAAd;AACAiG,QAAAA,WAAW,CAACjG,KAAD,CAAX;AACAA,QAAAA,KAAK,CAACc,KAAN,CAAaL,GAAb,CAAiB/C,KAAjB;AACA;;AACD,aAAO,IAAP;AACA,KATD;;AAWA0J,IAAAA,CAAC,CAAC5G,MAAF,GAAW,UAAS9C,KAAT;AACV,UAAI,CAAC,KAAKwC,GAAL,CAASxC,KAAT,CAAL,EAAsB;AACrB,eAAO,KAAP;AACA;;AAED,UAAMsC,KAAK,GAAa,KAAKvD,WAAL,CAAxB;AACA0M,MAAAA,eAAe,CAACnJ,KAAD,CAAf;AACA2M,MAAAA,cAAc,CAAC3M,KAAD,CAAd;AACAiG,MAAAA,WAAW,CAACjG,KAAD,CAAX;AACA,aACCA,KAAK,CAACc,KAAN,CAAaN,MAAb,CAAoB9C,KAApB,MACCsC,KAAK,CAACyC,OAAN,CAAcvC,GAAd,CAAkBxC,KAAlB,IACEsC,KAAK,CAACc,KAAN,CAAaN,MAAb,CAAoBR,KAAK,CAACyC,OAAN,CAAcrC,GAAd,CAAkB1C,KAAlB,CAApB,CADF;AAEE;AAA2B,WAH9B,CADD;AAMA,KAfD;;AAiBA0J,IAAAA,CAAC,CAACvF,KAAF,GAAU;AACT,UAAM7B,KAAK,GAAa,KAAKvD,WAAL,CAAxB;AACA0M,MAAAA,eAAe,CAACnJ,KAAD,CAAf;;AACA,UAAIa,MAAM,CAACb,KAAD,CAAN,CAAcgM,IAAlB,EAAwB;AACvBW,QAAAA,cAAc,CAAC3M,KAAD,CAAd;AACAiG,QAAAA,WAAW,CAACjG,KAAD,CAAX;AACAA,QAAAA,KAAK,CAACc,KAAN,CAAae,KAAb;AACA;AACD,KARD;;AAUAuF,IAAAA,CAAC,CAACkF,MAAF,GAAW;AACV,UAAMtM,KAAK,GAAa,KAAKvD,WAAL,CAAxB;AACA0M,MAAAA,eAAe,CAACnJ,KAAD,CAAf;AACA2M,MAAAA,cAAc,CAAC3M,KAAD,CAAd;AACA,aAAOA,KAAK,CAACc,KAAN,CAAawL,MAAb,EAAP;AACA,KALD;;AAOAlF,IAAAA,CAAC,CAAC8D,OAAF,GAAY,SAASA,OAAT;AACX,UAAMlL,KAAK,GAAa,KAAKvD,WAAL,CAAxB;AACA0M,MAAAA,eAAe,CAACnJ,KAAD,CAAf;AACA2M,MAAAA,cAAc,CAAC3M,KAAD,CAAd;AACA,aAAOA,KAAK,CAACc,KAAN,CAAaoK,OAAb,EAAP;AACA,KALD;;AAOA9D,IAAAA,CAAC,CAACvH,IAAF,GAAS;AACR,aAAO,KAAKyM,MAAL,EAAP;AACA,KAFD;;AAIAlF,IAAAA,CAAC,CAAC1K,cAAD,CAAD,GAAoB;AACnB,aAAO,KAAK4P,MAAL,EAAP;AACA,KAFD;;AAIAlF,IAAAA,CAAC,CAAC9H,OAAF,GAAY,SAASA,OAAT,CAAiB4M,EAAjB,EAA0BC,OAA1B;AACX,UAAMxP,QAAQ,GAAG,KAAK2P,MAAL,EAAjB;AACA,UAAI3I,MAAM,GAAGhH,QAAQ,CAAC4P,IAAT,EAAb;;AACA,aAAO,CAAC5I,MAAM,CAAC8I,IAAf,EAAqB;AACpBP,QAAAA,EAAE,CAACxN,IAAH,CAAQyN,OAAR,EAAiBxI,MAAM,CAACjG,KAAxB,EAA+BiG,MAAM,CAACjG,KAAtC,EAA6C,IAA7C;AACAiG,QAAAA,MAAM,GAAGhH,QAAQ,CAAC4P,IAAT,EAAT;AACA;AACD,KAPD;;AASA,WAAOG,QAAP;AACA,GA/GgB,CA+GdzQ,GA/Gc,CAAjB;;AAiHA,WAASoM,SAAT,CAAqCjJ,MAArC,EAAgD8F,MAAhD;AACC;AACA,WAAO,IAAIwH,QAAJ,CAAatN,MAAb,EAAqB8F,MAArB,CAAP;AACA;;AAED,WAASyH,cAAT,CAAwB3M,KAAxB;AACC,QAAI,CAACA,KAAK,CAACc,KAAX,EAAkB;AACjB;AACAd,MAAAA,KAAK,CAACc,KAAN,GAAc,IAAI7E,GAAJ,EAAd;AACA+D,MAAAA,KAAK,CAACnB,KAAN,CAAYS,OAAZ,CAAoB,UAAA5B,KAAK;AACxB,YAAIC,WAAW,CAACD,KAAD,CAAf,EAAwB;AACvB,cAAM6F,KAAK,GAAGsC,WAAW,CAAC7F,KAAK,CAACwE,MAAN,CAAahC,MAAd,EAAsB9E,KAAtB,EAA6BsC,KAA7B,CAAzB;AACAA,UAAAA,KAAK,CAACyC,OAAN,CAAcpC,GAAd,CAAkB3C,KAAlB,EAAyB6F,KAAzB;AACAvD,UAAAA,KAAK,CAACc,KAAN,CAAaL,GAAb,CAAiB8C,KAAjB;AACA,SAJD,MAIO;AACNvD,UAAAA,KAAK,CAACc,KAAN,CAAaL,GAAb,CAAiB/C,KAAjB;AACA;AACD,OARD;AASA;AACD;;AAED,WAASyL,eAAT,CAAyBnJ;AAAW;AAApC;AACC,QAAIA,KAAK,CAACyD,QAAV,EAAoBvG,GAAG,CAAC,CAAD,EAAI2M,IAAI,CAACC,SAAL,CAAejJ,MAAM,CAACb,KAAD,CAArB,CAAJ,CAAH;AACpB;;AAEDkC,EAAAA,UAAU,CAAC,QAAD,EAAW;AAACkG,IAAAA,SAAS,EAATA,SAAD;AAAYC,IAAAA,SAAS,EAATA;AAAZ,GAAX,CAAV;AACA;;SCvVeuE;AACf9D,EAAAA,SAAS;AACTyC,EAAAA,YAAY;AACZxB,EAAAA,aAAa;AACb;;ACcD,IAAMzG,KAAK;AAAA;AAAG,IAAIoD,KAAJ,EAAd;AAEA;;;;;;;;;;;;;;;;;;;;AAmBA,IAAaM,OAAO,GAAa1D,KAAK,CAAC0D,OAAhC;AACP,AAEA;;;;;AAIA,IAAaM,kBAAkB;AAAA;AAAwBhE,KAAK,CAACgE,kBAAN,CAAyBuF,IAAzB,CACtDvJ,KADsD,CAAhD;AAIP;;;;;;AAKA,IAAauE,aAAa;AAAA;AAAGvE,KAAK,CAACuE,aAAN,CAAoBgF,IAApB,CAAyBvJ,KAAzB,CAAtB;AAEP;;;;;;;AAMA,IAAaqE,aAAa;AAAA;AAAGrE,KAAK,CAACqE,aAAN,CAAoBkF,IAApB,CAAyBvJ,KAAzB,CAAtB;AAEP;;;;;;AAKA,IAAa0E,YAAY;AAAA;AAAG1E,KAAK,CAAC0E,YAAN,CAAmB6E,IAAnB,CAAwBvJ,KAAxB,CAArB;AAEP;;;;;AAIA,IAAawE,WAAW;AAAA;AAAGxE,KAAK,CAACwE,WAAN,CAAkB+E,IAAlB,CAAuBvJ,KAAvB,CAApB;AAEP;;;;;;;;;AAQA,IAAayE,WAAW;AAAA;AAAGzE,KAAK,CAACyE,WAAN,CAAkB8E,IAAlB,CAAuBvJ,KAAvB,CAApB;AAEP;;;;;;;AAMA,SAAgBwJ,UAAapP;AAC5B,SAAOA,KAAP;AACA;AAED;;;;;;AAKA,SAAgBqP,cAAiBrP;AAChC,SAAOA,KAAP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;"}
\ No newline at end of file
+{"version":3,"file":"immer.cjs.development.js","sources":["../src/utils/env.ts","../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/mapset.ts","../src/plugins/all.ts","../src/plugins/patches.ts","../src/immer.ts"],"sourcesContent":["// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import { DRAFT_STATE, DRAFTABLE, hasSet, Objectish, Drafted, AnyObject, AnyMap, AnySet, ImmerState, hasMap, Archtype, die } from \"../internal.js\";\r\n\n /** Returns true if the given value is an Immer draft */\r\n/*#__PURE__*/\r\nexport function isDraft(value: any): boolean {\r\n    return !!value && !!value[DRAFT_STATE];\r\n}\r\n\n /** Returns true if the given value can be drafted by Immer */\r\n/*#__PURE__*/\r\nexport function isDraftable(value: any): boolean {\r\n    if (!value)\r\n        return false;\r\n    return (isPlainObject(value) ||\r\n        Array.isArray(value) ||\r\n        !!value[DRAFTABLE] ||\r\n        !!value.constructor?.[DRAFTABLE] ||\r\n        isMap(value) ||\r\n        isSet(value));\r\n}\r\n\n const objectCtorString = Object.prototype.constructor.toString();\r\n/*#__PURE__*/\r\nexport function isPlainObject(value: any): boolean {\r\n    if (!value || typeof value !== \"object\")\r\n        return false;\r\n    const proto = Object.getPrototypeOf(value);\r\n    if (proto === null) {\r\n        return true;\r\n    }\r\n    const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\r\n    \n if (Ctor === Object)\r\n        return true;\r\n    \n return (typeof Ctor == \"function\" &&\r\n        Function.toString.call(Ctor) === objectCtorString);\r\n}\r\n\n /** Get the underlying object that is represented by the given draft */\r\n/*#__PURE__*/\r\nexport function original<T>(value: T): T | undefined;\r\nexport function original(value: Drafted<any>): any {\r\n    if (!isDraft(value))\r\n        die(23, value);\r\n    return value[DRAFT_STATE].base_;\r\n}\r\n\n /*#__PURE__*/\r\nexport const ownKeys: (target: AnyObject) => PropertyKey[] = typeof Reflect !== \"undefined\" && Reflect.ownKeys\r\n    ? Reflect.ownKeys\r\n    : typeof Object.getOwnPropertySymbols !== \"undefined\"\r\n        ? obj => Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj) as any)\r\n        : /* istanbul ignore next */ Object.getOwnPropertyNames;\r\n\n export const getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\r\n    function getOwnPropertyDescriptors(target: any) {\r\n        // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\r\n        const res: any = {};\r\n        ownKeys(target).forEach(key => {\r\n            res[key] = Object.getOwnPropertyDescriptor(target, key);\r\n        });\r\n        return res;\r\n    };\r\n\n export function each<T extends Objectish>(obj: T, iter: (key: string | number, value: any, source: T) => void, enumerableOnly?: boolean): void;\r\nexport function each(obj: any, iter: any, enumerableOnly = false) {\r\n    if (getArchtype(obj) === Archtype.Object) {\r\n        ;\r\n        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\r\n            if (!enumerableOnly || typeof key !== \"symbol\")\r\n                iter(key, obj[key], obj);\r\n        });\r\n    }\r\n    else {\r\n        obj.forEach((entry: any, index: any) => iter(index, entry, obj));\r\n    }\r\n}\r\n\n /*#__PURE__*/\r\nexport function getArchtype(thing: any): Archtype {\r\n    /* istanbul ignore next */\r\n    const state: undefined | ImmerState = thing[DRAFT_STATE];\r\n    return state\r\n        ? state.type_ > 3\r\n            ? state.type_ - 4 // cause Object and Array map back from 4 and 5\r\n            : (state.type_ as any) // others are the same\r\n        : Array.isArray(thing)\r\n            ? Archtype.Array\r\n            : isMap(thing)\r\n                ? Archtype.Map\r\n                : isSet(thing)\r\n                    ? Archtype.Set\r\n                    : Archtype.Object;\r\n}\r\n\n /*#__PURE__*/\r\nexport function has(thing: any, prop: PropertyKey): boolean {\r\n    return getArchtype(thing) === Archtype.Map\r\n        ? thing.has(prop)\r\n        : Object.prototype.hasOwnProperty.call(thing, prop);\r\n}\r\n\n /*#__PURE__*/\r\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\r\n    // @ts-ignore\r\n    return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop];\r\n}\r\n\n /*#__PURE__*/\r\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\r\n    const t = getArchtype(thing);\r\n    if (t === Archtype.Map)\r\n        thing.set(propOrOldValue, value);\r\n    else if (t === Archtype.Set) {\r\n        thing.delete(propOrOldValue);\r\n        thing.add(value);\r\n    }\r\n    else\r\n        thing[propOrOldValue] = value;\r\n}\r\n\n /*#__PURE__*/\r\nexport function is(x: any, y: any): boolean {\r\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\r\n    if (x === y) {\r\n        return x !== 0 || 1 / x === 1 / y;\r\n    }\r\n    else {\r\n        return x !== x && y !== y;\r\n    }\r\n}\r\n\n /*#__PURE__*/\r\nexport function isMap(target: any): target is AnyMap {\r\n    return hasMap && target instanceof Map;\r\n}\r\n\n /*#__PURE__*/\r\nexport function isSet(target: any): target is AnySet {\r\n    return hasSet && target instanceof Set;\r\n}\r\n/*#__PURE__*/\r\nexport function latest(state: ImmerState): any {\r\n    return state.copy_ || state.base_;\r\n}\r\n\n /*#__PURE__*/\r\nexport function shallowCopy(base: any) {\r\n    if (Array.isArray(base))\r\n        return Array.prototype.slice.call(base);\r\n    const descriptors = getOwnPropertyDescriptors(base);\r\n    delete descriptors[DRAFT_STATE as any];\r\n    let keys = ownKeys(descriptors);\r\n    for (let i = 0; i < keys.length; i++) {\r\n        const key: any = keys[i];\r\n        const desc = descriptors[key];\r\n        if (desc.writable === false) {\r\n            desc.writable = true;\r\n            desc.configurable = true;\r\n        }\r\n        // like object.assign, we will read any _own_, get/set accessors. This helps in dealing\r\n        // with libraries that trap values, like mobx or vue\r\n        // unlike object.assign, non-enumerables will be copied as well\r\n        if (desc.get || desc.set)\r\n            descriptors[key] = {\r\n                configurable: true,\r\n                writable: true,\r\n                enumerable: desc.enumerable,\r\n                value: base[key]\r\n            };\r\n    }\r\n    return Object.create(Object.getPrototypeOf(base), descriptors);\r\n}\r\n\n /**\r\n * Freezes draftable objects. Returns the original object.\r\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\r\n *\r\n * @param obj\r\n * @param deep\r\n */\r\nexport function freeze<T>(obj: T, deep?: boolean): T;\r\nexport function freeze<T>(obj: any, deep: boolean = false): T {\r\n    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))\r\n        return obj;\r\n    if (getArchtype(obj) > 1 /* Map or Set */) {\r\n        const desc: PropertyDescriptor = {\r\n            configurable: true,\r\n            writable: true,\r\n            value: dontMutateFrozenCollections\r\n        };\r\n        Object.defineProperties(obj, {\r\n            set: desc,\r\n            add: desc,\r\n            clear: desc,\r\n            delete: desc\r\n        });\r\n    }\r\n    Object.freeze(obj);\r\n    if (deep)\r\n        each(obj, (key, value) => freeze(value, true), true);\r\n    return obj;\r\n}\r\n\n function dontMutateFrozenCollections() {\r\n    die(2);\r\n}\r\n\n export function isFrozen(obj: any): boolean {\r\n    if (obj == null || typeof obj !== \"object\")\r\n        return true;\r\n    // See #600, IE dies on non-objects in Object.isFrozen\r\n    return Object.isFrozen(obj);\r\n}\r\n","import { ImmerState, Patch, ImmerScope, Drafted, AnyObject, ImmerBaseState, AnyMap, AnySet, ProxyType, die } from \"../internal.js\";\r\n\n /** Plugin utilities */\r\nconst plugins: {\r\n    Patches?: {\r\n        generatePatches_(state: ImmerState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]): void;\r\n        generateReplacementPatches_(base: any, replacement: any, patches: Patch[], inversePatches: Patch[]): void;\r\n        applyPatches_<T>(draft: T, patches: Patch[]): T;\r\n    };\r\n    ES5?: {\r\n        willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void;\r\n        createES5Proxy_<T>(base: T, parent?: ImmerState): Drafted<T, ES5ObjectState | ES5ArrayState>;\r\n        hasChanges_(state: ES5ArrayState | ES5ObjectState): boolean;\r\n    };\r\n    MapSet?: {\r\n        proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T;\r\n        proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T;\r\n    };\r\n} = {};\r\n\n type Plugins = typeof plugins;\r\n\n export function getPlugin<K extends keyof Plugins>(pluginKey: K): Exclude<Plugins[K], undefined> {\r\n    const plugin = plugins[pluginKey];\r\n    if (!plugin) {\r\n        die(18, pluginKey);\r\n    }\r\n    // @ts-ignore\r\n    return plugin;\r\n}\r\n\n export function loadPlugin<K extends keyof Plugins>(pluginKey: K, implementation: Plugins[K]): void {\r\n    if (!plugins[pluginKey])\r\n        plugins[pluginKey] = implementation;\r\n}\r\n\n /** ES5 Plugin */\r\n\n interface ES5BaseState extends ImmerBaseState {\r\n    assigned_: {\r\n        [key: string]: any;\r\n    };\r\n    parent_?: ImmerState;\r\n    revoked_: boolean;\r\n}\r\n\n export interface ES5ObjectState extends ES5BaseState {\r\n    type_: ProxyType.ES5Object;\r\n    draft_: Drafted<AnyObject, ES5ObjectState>;\r\n    base_: AnyObject;\r\n    copy_: AnyObject | null;\r\n}\r\n\n export interface ES5ArrayState extends ES5BaseState {\r\n    type_: ProxyType.ES5Array;\r\n    draft_: Drafted<AnyObject, ES5ArrayState>;\r\n    base_: any;\r\n    copy_: any;\r\n}\r\n\n /** Map / Set plugin */\r\n\n export interface MapState extends ImmerBaseState {\r\n    type_: ProxyType.Map;\r\n    copy_: AnyMap | undefined;\r\n    assigned_: Map<any, boolean> | undefined;\r\n    base_: AnyMap;\r\n    revoked_: boolean;\r\n    draft_: Drafted<AnyMap, MapState>;\r\n}\r\n\n export interface SetState extends ImmerBaseState {\r\n    type_: ProxyType.Set;\r\n    copy_: AnySet | undefined;\r\n    base_: AnySet;\r\n    drafts_: Map<any, Drafted>; // maps the original value to the draft value in the new set\r\n    revoked_: boolean;\r\n    draft_: Drafted<AnySet, SetState>;\r\n}\r\n\n /** Patches plugin */\r\n\n export type PatchPath = (string | number)[];\r\n","import { Patch, PatchListener, Drafted, Immer, DRAFT_STATE, ImmerState, ProxyType, getPlugin } from \"../internal.js\";\r\nimport { die } from \"../utils/errors.js\";\r\n\n /** Each scope represents a `produce` call. */\r\n\n export interface ImmerScope {\r\n    patches_?: Patch[];\r\n    inversePatches_?: Patch[];\r\n    canAutoFreeze_: boolean;\r\n    drafts_: any[];\r\n    parent_?: ImmerScope;\r\n    patchListener_?: PatchListener;\r\n    immer_: Immer;\r\n    unfinalizedDrafts_: number;\r\n}\r\n\n let currentScope: ImmerScope | undefined;\r\n\n export function getCurrentScope() {\r\n    if (__DEV__ && !currentScope)\r\n        die(0);\r\n    return currentScope!;\r\n}\r\n\n function createScope(parent_: ImmerScope | undefined, immer_: Immer): ImmerScope {\r\n    return {\r\n        drafts_: [],\r\n        parent_,\r\n        immer_,\r\n        // Whenever the modified draft contains a draft from another scope, we\r\n        // need to prevent auto-freezing so the unowned draft can be finalized.\r\n        canAutoFreeze_: true,\r\n        unfinalizedDrafts_: 0\r\n    };\r\n}\r\n\n export function usePatchesInScope(scope: ImmerScope, patchListener?: PatchListener) {\r\n    if (patchListener) {\r\n        getPlugin(\"Patches\"); // assert we have the plugin\r\n        scope.patches_ = [];\r\n        scope.inversePatches_ = [];\r\n        scope.patchListener_ = patchListener;\r\n    }\r\n}\r\n\n export function revokeScope(scope: ImmerScope) {\r\n    leaveScope(scope);\r\n    scope.drafts_.forEach(revokeDraft);\r\n    // @ts-ignore\r\n    scope.drafts_ = null;\r\n}\r\n\n export function leaveScope(scope: ImmerScope) {\r\n    if (scope === currentScope) {\r\n        currentScope = scope.parent_;\r\n    }\r\n}\r\n\n export function enterScope(immer: Immer) {\r\n    return (currentScope = createScope(currentScope, immer));\r\n}\r\n\n function revokeDraft(draft: Drafted) {\r\n    const state: ImmerState = draft[DRAFT_STATE];\r\n    if (state.type_ === ProxyType.ProxyObject ||\r\n        state.type_ === ProxyType.ProxyArray)\r\n        state.revoke_();\r\n    else\r\n        state.revoked_ = true;\r\n}\r\n","import { ImmerScope, DRAFT_STATE, isDraftable, NOTHING, PatchPath, each, has, freeze, ImmerState, isDraft, SetState, set, ProxyType, getPlugin, die, revokeScope, isFrozen, shallowCopy } from \"../internal.js\";\r\n\n export function processResult(result: any, scope: ImmerScope) {\r\n    scope.unfinalizedDrafts_ = scope.drafts_.length;\r\n    const baseDraft = scope.drafts_![0];\r\n    const isReplaced = result !== undefined && result !== baseDraft;\r\n    if (!scope.immer_.useProxies_)\r\n        getPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced);\r\n    if (isReplaced) {\r\n        if (baseDraft[DRAFT_STATE].modified_) {\r\n            revokeScope(scope);\r\n            die(4);\r\n        }\r\n        if (isDraftable(result)) {\r\n            // Finalize the result in case it contains (or is) a subset of the draft.\r\n            result = finalize(scope, result);\r\n            if (!scope.parent_)\r\n                maybeFreeze(scope, result);\r\n        }\r\n        if (scope.patches_) {\r\n            getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_!);\r\n        }\r\n    }\r\n    else {\r\n        // Finalize the base draft.\r\n        result = finalize(scope, baseDraft, []);\r\n    }\r\n    revokeScope(scope);\r\n    if (scope.patches_) {\r\n        scope.patchListener_!(scope.patches_, scope.inversePatches_!);\r\n    }\r\n    return result !== NOTHING ? result : undefined;\r\n}\r\n\n function finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\r\n    // Don't recurse in tho recursive data structures\r\n    if (isFrozen(value))\r\n        return value;\r\n    \n const state: ImmerState = value[DRAFT_STATE];\r\n    // A plain object, might need freezing, might contain drafts\r\n    if (!state) {\r\n        each(value, (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path), true // See #590, don't recurse into non-enumerable of non drafted objects\r\n        );\r\n        return value;\r\n    }\r\n    // Never finalize drafts owned by another scope.\r\n    if (state.scope_ !== rootScope)\r\n        return value;\r\n    // Unmodified draft, return the (frozen) original\r\n    if (!state.modified_) {\r\n        maybeFreeze(rootScope, state.base_, true);\r\n        return state.base_;\r\n    }\r\n    // Not finalized yet, let's do that now\r\n    if (!state.finalized_) {\r\n        state.finalized_ = true;\r\n        state.scope_.unfinalizedDrafts_--;\r\n        const result = \r\n        // For ES5, create a good copy from the draft first, with added keys and without deleted keys.\r\n        state.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\r\n            ? (state.copy_ = shallowCopy(state.draft_))\r\n            : state.copy_;\r\n        // Finalize all children of the copy\r\n        // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\r\n        // Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\r\n        // back to each(result, ....)\r\n        each(state.type_ === ProxyType.Set ? new Set(result) : result, (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path));\r\n        // everything inside is frozen, we can freeze here\r\n        maybeFreeze(rootScope, result, false);\r\n        // first time finalizing, let's create those patches\r\n        if (path && rootScope.patches_) {\r\n            getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_!);\r\n        }\r\n    }\r\n    return state.copy_;\r\n}\r\n\n function finalizeProperty(rootScope: ImmerScope, parentState: undefined | ImmerState, targetObject: any, prop: string | number, childValue: any, rootPath?: PatchPath) {\r\n    if (__DEV__ && childValue === targetObject)\r\n        die(5);\r\n    if (isDraft(childValue)) {\r\n        const path = rootPath &&\r\n            parentState &&\r\n            parentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\r\n            !has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\r\n            ? rootPath!.concat(prop)\r\n            : undefined;\r\n        // Drafts owned by `scope` are finalized here.\r\n        const res = finalize(rootScope, childValue, path);\r\n        set(targetObject, prop, res);\r\n        // Drafts from another scope must prevented to be frozen\r\n        // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\r\n        if (isDraft(res)) {\r\n            rootScope.canAutoFreeze_ = false;\r\n        }\r\n        else\r\n            return;\r\n    }\r\n    // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\r\n    if (isDraftable(childValue) && !isFrozen(childValue)) {\r\n        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\r\n            // optimization: if an object is not a draft, and we don't have to\r\n            // deepfreeze everything, and we are sure that no drafts are left in the remaining object\r\n            // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\r\n            // This benefits especially adding large data tree's without further processing.\r\n            // See add-data.js perf test\r\n            return;\r\n        }\r\n        finalize(rootScope, childValue);\r\n        // immer deep freezes plain objects, so if there is no parent state, we freeze as well\r\n        if (!parentState || !parentState.scope_.parent_)\r\n            maybeFreeze(rootScope, childValue);\r\n    }\r\n}\r\n\n function maybeFreeze(scope: ImmerScope, value: any, deep = false) {\r\n    if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\r\n        freeze(value, deep);\r\n    }\r\n}\r\n","import { each, has, is, isDraftable, shallowCopy, latest, ImmerBaseState, ImmerState, Drafted, AnyObject, AnyArray, Objectish, getCurrentScope, DRAFT_STATE, die, createProxy, ProxyType } from \"../internal.js\";\r\n\n interface ProxyBaseState extends ImmerBaseState {\r\n    assigned_: {\r\n        [property: string]: boolean;\r\n    };\r\n    parent_?: ImmerState;\r\n    revoke_(): void;\r\n}\r\n\n export interface ProxyObjectState extends ProxyBaseState {\r\n    type_: ProxyType.ProxyObject;\r\n    base_: any;\r\n    copy_: any;\r\n    draft_: Drafted<AnyObject, ProxyObjectState>;\r\n}\r\n\n export interface ProxyArrayState extends ProxyBaseState {\r\n    type_: ProxyType.ProxyArray;\r\n    base_: AnyArray;\r\n    copy_: AnyArray | null;\r\n    draft_: Drafted<AnyArray, ProxyArrayState>;\r\n}\r\n\n type ProxyState = ProxyObjectState | ProxyArrayState;\r\n\n /**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */\r\nexport function createProxyProxy<T extends Objectish>(base: T, parent?: ImmerState): Drafted<T, ProxyState> {\r\n    const isArray = Array.isArray(base);\r\n    const state: ProxyState = {\r\n        type_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\r\n        // Track which produce call this is associated with.\r\n        scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n        // True for both shallow and deep changes.\r\n        modified_: false,\r\n        // Used during finalization.\r\n        finalized_: false,\r\n        // Track which properties have been assigned (true) or deleted (false).\r\n        assigned_: {},\r\n        // The parent draft state.\r\n        parent_: parent,\r\n        // The base state.\r\n        base_: base,\r\n        // The base proxy.\r\n        draft_: null as any,\r\n        // The base copy with any updated values.\r\n        copy_: null,\r\n        // Called by the `produce` function.\r\n        revoke_: null as any,\r\n        isManual_: false\r\n    };\r\n    \n // the traps must target something, a bit like the 'real' base.\r\n    // but also, we need to be able to determine from the target what the relevant state is\r\n    // (to avoid creating traps per instance to capture the state in closure,\r\n    // and to avoid creating weird hidden properties as well)\r\n    // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\r\n    // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\r\n    let target: T = state as any;\r\n    let traps: ProxyHandler<object | Array<any>> = objectTraps;\r\n    if (isArray) {\r\n        target = [state] as any;\r\n        traps = arrayTraps;\r\n    }\r\n    \n const { revoke, proxy } = Proxy.revocable(target, traps);\r\n    state.draft_ = proxy as any;\r\n    state.revoke_ = revoke;\r\n    return proxy as any;\r\n}\r\n\n /**\r\n * Object drafts\r\n */\r\nexport const objectTraps: ProxyHandler<ProxyState> = {\r\n    get(state, prop) {\r\n        if (prop === DRAFT_STATE)\r\n            return state;\r\n        \n const source = latest(state);\r\n        if (!has(source, prop)) {\r\n            // non-existing or non-own property...\r\n            return readPropFromProto(state, source, prop);\r\n        }\r\n        const value = source[prop];\r\n        if (state.finalized_ || !isDraftable(value)) {\r\n            return value;\r\n        }\r\n        // Check for existing draft in modified state.\r\n        // Assigned values are never drafted. This catches any drafts we created, too.\r\n        if (value === peek(state.base_, prop)) {\r\n            prepareCopy(state);\r\n            return (state.copy_![prop as any] = createProxy(state.scope_.immer_, value, state));\r\n        }\r\n        return value;\r\n    },\r\n    has(state, prop) {\r\n        return prop in latest(state);\r\n    },\r\n    ownKeys(state) {\r\n        return Reflect.ownKeys(latest(state));\r\n    },\r\n    set(state: ProxyObjectState, prop: string /* strictly not, but helps TS */, value) {\r\n        const desc = getDescriptorFromProto(latest(state), prop);\r\n        if (desc?.set) {\r\n            // special case: if this write is captured by a setter, we have\r\n            // to trigger it with the correct context\r\n            desc.set.call(state.draft_, value);\r\n            return true;\r\n        }\r\n        if (!state.modified_) {\r\n            // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\r\n            // from setting an existing property with value undefined to undefined (which is not a change)\r\n            const current = peek(latest(state), prop);\r\n            // special case, if we assigning the original value to a draft, we can ignore the assignment\r\n            const currentState: ProxyObjectState = current?.[DRAFT_STATE];\r\n            if (currentState && currentState.base_ === value) {\r\n                state.copy_![prop] = value;\r\n                state.assigned_[prop] = false;\r\n                return true;\r\n            }\r\n            if (is(value, current) && (value !== undefined || has(state.base_, prop)))\r\n                return true;\r\n            prepareCopy(state);\r\n            markChanged(state);\r\n        }\r\n        \n if ((state.copy_![prop] === value &&\r\n            // special case: handle new props with value 'undefined'\r\n            (value !== undefined || prop in state.copy_)) ||\r\n            // special case: NaN\r\n            (Number.isNaN(value) && Number.isNaN(state.copy_![prop])))\r\n            return true;\r\n        \n // @ts-ignore\r\n        state.copy_![prop] = value;\r\n        state.assigned_[prop] = true;\r\n        return true;\r\n    },\r\n    deleteProperty(state, prop: string) {\r\n        // The `undefined` check is a fast path for pre-existing keys.\r\n        if (peek(state.base_, prop) !== undefined || prop in state.base_) {\r\n            state.assigned_[prop] = false;\r\n            prepareCopy(state);\r\n            markChanged(state);\r\n        }\r\n        else {\r\n            // if an originally not assigned property was deleted\r\n            delete state.assigned_[prop];\r\n        }\r\n        // @ts-ignore\r\n        if (state.copy_)\r\n            delete state.copy_[prop];\r\n        return true;\r\n    },\r\n    // Note: We never coerce `desc.value` into an Immer draft, because we can't make\r\n    // the same guarantee in ES5 mode.\r\n    getOwnPropertyDescriptor(state, prop) {\r\n        const owner = latest(state);\r\n        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\r\n        if (!desc)\r\n            return desc;\r\n        return {\r\n            writable: true,\r\n            configurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\r\n            enumerable: desc.enumerable,\r\n            value: owner[prop]\r\n        };\r\n    },\r\n    defineProperty() {\r\n        die(11);\r\n    },\r\n    getPrototypeOf(state) {\r\n        return Object.getPrototypeOf(state.base_);\r\n    },\r\n    setPrototypeOf() {\r\n        die(12);\r\n    }\r\n};\r\n\n /**\r\n * Array drafts\r\n */\r\n\n const arrayTraps: ProxyHandler<[\r\n    ProxyArrayState\r\n]> = {};\r\neach(objectTraps, (key, fn) => {\r\n    // @ts-ignore\r\n    arrayTraps[key] = function () {\r\n        arguments[0] = arguments[0][0];\r\n        return fn.apply(this, arguments);\r\n    };\r\n});\r\narrayTraps.deleteProperty = function (state, prop) {\r\n    if (__DEV__ && isNaN(parseInt(prop as any)))\r\n        die(13);\r\n    // @ts-ignore\r\n    return arrayTraps.set!.call(this, state, prop, undefined);\r\n};\r\narrayTraps.set = function (state, prop, value) {\r\n    if (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any)))\r\n        die(14);\r\n    return objectTraps.set!.call(this, state[0], prop, value, state[0]);\r\n};\r\n\n // Access a property without creating an Immer draft.\r\nfunction peek(draft: Drafted, prop: PropertyKey) {\r\n    const state = draft[DRAFT_STATE];\r\n    const source = state ? latest(state) : draft;\r\n    return source[prop];\r\n}\r\n\n function readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\r\n    const desc = getDescriptorFromProto(source, prop);\r\n    return desc\r\n        ? `value` in desc\r\n            ? desc.value\r\n            : // This is a very special case, if the prop is a getter defined by the\r\n                // prototype, we should invoke it with the draft as context!\r\n                desc.get?.call(state.draft_)\r\n        : undefined;\r\n}\r\n\n function getDescriptorFromProto(source: any, prop: PropertyKey): PropertyDescriptor | undefined {\r\n    // 'in' checks proto!\r\n    if (!(prop in source))\r\n        return undefined;\r\n    let proto = Object.getPrototypeOf(source);\r\n    while (proto) {\r\n        const desc = Object.getOwnPropertyDescriptor(proto, prop);\r\n        if (desc)\r\n            return desc;\r\n        proto = Object.getPrototypeOf(proto);\r\n    }\r\n    return undefined;\r\n}\r\n\n export function markChanged(state: ImmerState) {\r\n    if (!state.modified_) {\r\n        state.modified_ = true;\r\n        if (state.parent_) {\r\n            markChanged(state.parent_);\r\n        }\r\n    }\r\n}\r\n\n export function prepareCopy(state: {\r\n    base_: any;\r\n    copy_: any;\r\n}) {\r\n    if (!state.copy_) {\r\n        state.copy_ = shallowCopy(state.base_);\r\n    }\r\n}\r\n","import { IProduceWithPatches, IProduce, ImmerState, Drafted, isDraftable, processResult, Patch, Objectish, DRAFT_STATE, Draft, PatchListener, isDraft, isMap, isSet, createProxyProxy, getPlugin, die, hasProxies, enterScope, revokeScope, leaveScope, usePatchesInScope, getCurrentScope, NOTHING, freeze, current } from \"../internal.js\";\r\n\n interface ProducersFns {\r\n    produce: IProduce;\r\n    produceWithPatches: IProduceWithPatches;\r\n}\r\n\n export class Immer implements ProducersFns {\r\n    useProxies_: boolean = hasProxies;\r\n    \n autoFreeze_: boolean = true;\r\n    \n constructor(config?: {\r\n        useProxies?: boolean;\r\n        autoFreeze?: boolean;\r\n    }) {\r\n        if (typeof config?.useProxies === \"boolean\")\r\n            this.setUseProxies(config!.useProxies);\r\n        if (typeof config?.autoFreeze === \"boolean\")\r\n            this.setAutoFreeze(config!.autoFreeze);\r\n    }\r\n    \n /**\r\n         * The `produce` function takes a value and a \"recipe function\" (whose\r\n         * return value often depends on the base state). The recipe function is\r\n         * free to mutate its first argument however it wants. All mutations are\r\n         * only ever applied to a __copy__ of the base state.\r\n         *\r\n         * Pass only a function to create a \"curried producer\" which relieves you\r\n         * from passing the recipe function every time.\r\n         *\r\n         * Only plain objects and arrays are made mutable. All other objects are\r\n         * considered uncopyable.\r\n         *\r\n         * Note: This function is __bound__ to its `Immer` instance.\r\n         *\r\n         * @param {any} base - the initial state\r\n         * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n         * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n         * @returns {any} a new state, or the initial state if nothing was modified\r\n         */\r\n    produce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\r\n        // curried invocation\r\n        if (typeof base === \"function\" && typeof recipe !== \"function\") {\r\n            const defaultBase = recipe;\r\n            recipe = base;\r\n            \n const self = this;\r\n            return function curriedProduce(this: any, base = defaultBase, ...args: any[]) {\r\n                return self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)); // prettier-ignore\r\n            };\r\n        }\r\n        \n if (typeof recipe !== \"function\")\r\n            die(6);\r\n        if (patchListener !== undefined && typeof patchListener !== \"function\")\r\n            die(7);\r\n        \n let result;\r\n        \n // Only plain objects, arrays, and \"immerable classes\" are drafted.\r\n        if (isDraftable(base)) {\r\n            const scope = enterScope(this);\r\n            const proxy = createProxy(this, base, undefined);\r\n            let hasError = true;\r\n            try {\r\n                result = recipe(proxy);\r\n                hasError = false;\r\n            }\r\n            finally {\r\n                // finally instead of catch + rethrow better preserves original stack\r\n                if (hasError)\r\n                    revokeScope(scope);\r\n                else\r\n                    leaveScope(scope);\r\n            }\r\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n                return result.then(result => {\r\n                    usePatchesInScope(scope, patchListener);\r\n                    return processResult(result, scope);\r\n                }, error => {\r\n                    revokeScope(scope);\r\n                    throw error;\r\n                });\r\n            }\r\n            usePatchesInScope(scope, patchListener);\r\n            return processResult(result, scope);\r\n        }\r\n        else if (!base || typeof base !== \"object\") {\r\n            result = recipe(base);\r\n            if (result === undefined)\r\n                result = base;\r\n            if (result === NOTHING)\r\n                result = undefined;\r\n            if (this.autoFreeze_)\r\n                freeze(result, true);\r\n            if (patchListener) {\r\n                const p: Patch[] = [];\r\n                const ip: Patch[] = [];\r\n                getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\r\n                patchListener(p, ip);\r\n            }\r\n            return result;\r\n        }\r\n        else\r\n            die(21, base);\r\n    };\r\n    \n produceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\r\n        // curried invocation\r\n        if (typeof base === \"function\") {\r\n            return (state: any, ...args: any[]) => this.produceWithPatches(state, (draft: any) => base(draft, ...args));\r\n        }\r\n        \n let patches: Patch[], inversePatches: Patch[];\r\n        const result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\r\n            patches = p;\r\n            inversePatches = ip;\r\n        });\r\n        \n if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n            return result.then(nextState => [nextState, patches!, inversePatches!]);\r\n        }\r\n        return [result, patches!, inversePatches!];\r\n    };\r\n    \n createDraft<T extends Objectish>(base: T): Draft<T> {\r\n        if (!isDraftable(base))\r\n            die(8);\r\n        if (isDraft(base))\r\n            base = current(base);\r\n        const scope = enterScope(this);\r\n        const proxy = createProxy(this, base, undefined);\r\n        proxy[DRAFT_STATE].isManual_ = true;\r\n        leaveScope(scope);\r\n        return proxy as any;\r\n    }\r\n    \n finishDraft<D extends Draft<any>>(draft: D, patchListener?: PatchListener): D extends Draft<infer T> ? T : never {\r\n        const state: ImmerState = draft && (draft as any)[DRAFT_STATE];\r\n        if (__DEV__) {\r\n            if (!state || !state.isManual_)\r\n                die(9);\r\n            if (state.finalized_)\r\n                die(10);\r\n        }\r\n        const { scope_: scope } = state;\r\n        usePatchesInScope(scope, patchListener);\r\n        return processResult(undefined, scope);\r\n    }\r\n    \n /**\r\n         * Pass true to automatically freeze all copies created by Immer.\r\n         *\r\n         * By default, auto-freezing is enabled.\r\n         */\r\n    setAutoFreeze(value: boolean) {\r\n        this.autoFreeze_ = value;\r\n    }\r\n    \n /**\r\n         * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n         * always faster than using ES5 proxies.\r\n         *\r\n         * By default, feature detection is used, so calling this is rarely necessary.\r\n         */\r\n    setUseProxies(value: boolean) {\r\n        if (value && !hasProxies) {\r\n            die(20);\r\n        }\r\n        this.useProxies_ = value;\r\n    }\r\n    \n applyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\r\n        // If a patch replaces the entire state, take that replacement as base\r\n        // before applying patches\r\n        let i: number;\r\n        for (i = patches.length - 1; i >= 0; i--) {\r\n            const patch = patches[i];\r\n            if (patch.path.length === 0 && patch.op === \"replace\") {\r\n                base = patch.value;\r\n                break;\r\n            }\r\n        }\r\n        // If there was a patch that replaced the entire state, start from the\r\n        // patch after that.\r\n        if (i > -1) {\r\n            patches = patches.slice(i + 1);\r\n        }\r\n        \n const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\r\n        if (isDraft(base)) {\r\n            // N.B: never hits if some patch a replacement, patches are never drafts\r\n            return applyPatchesImpl(base, patches);\r\n        }\r\n        // Otherwise, produce a copy of the base state.\r\n        return this.produce(base, (draft: Drafted) => applyPatchesImpl(draft, patches));\r\n    }\r\n}\r\n\n export function createProxy<T extends Objectish>(immer: Immer, value: T, parent?: ImmerState): Drafted<T, ImmerState> {\r\n    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\r\n    const draft: Drafted = isMap(value)\r\n        ? getPlugin(\"MapSet\").proxyMap_(value, parent)\r\n        : isSet(value)\r\n            ? getPlugin(\"MapSet\").proxySet_(value, parent)\r\n            : immer.useProxies_\r\n                ? createProxyProxy(value, parent)\r\n                : getPlugin(\"ES5\").createES5Proxy_(value, parent);\r\n    \n const scope = parent ? parent.scope_ : getCurrentScope();\r\n    scope.drafts_.push(draft);\r\n    return draft;\r\n}\r\n","import { die, isDraft, shallowCopy, each, DRAFT_STATE, get, set, ImmerState, isDraftable, Archtype, getArchtype, getPlugin } from \"../internal.js\";\r\n\n /** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\r\nexport function current<T>(value: T): T;\r\nexport function current(value: any): any {\r\n    if (!isDraft(value))\r\n        die(22, value);\r\n    return currentImpl(value);\r\n}\r\n\n function currentImpl(value: any): any {\r\n    if (!isDraftable(value))\r\n        return value;\r\n    const state: ImmerState | undefined = value[DRAFT_STATE];\r\n    let copy: any;\r\n    const archType = getArchtype(value);\r\n    if (state) {\r\n        if (!state.modified_ &&\r\n            (state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any)))\r\n            return state.base_;\r\n        // Optimization: avoid generating new drafts during copying\r\n        state.finalized_ = true;\r\n        copy = copyHelper(value, archType);\r\n        state.finalized_ = false;\r\n    }\r\n    else {\r\n        copy = copyHelper(value, archType);\r\n    }\r\n    \n each(copy, (key, childValue) => {\r\n        if (state && get(state.base_, key) === childValue)\r\n            return; // no need to copy or search in something that didn't change\r\n        set(copy, key, currentImpl(childValue));\r\n    });\r\n    // In the future, we might consider freezing here, based on the current settings\r\n    return archType === Archtype.Set ? new Set(copy) : copy;\r\n}\r\n\n function copyHelper(value: any, archType: number): any {\r\n    // creates a shallow copy, even if it is a map or set\r\n    switch (archType) {\r\n        case Archtype.Map:\r\n            return new Map(value);\r\n        case Archtype.Set:\r\n            // Set will be cloned as array temporarily, so that we can replace individual items\r\n            return Array.from(value);\r\n    }\r\n    return shallowCopy(value);\r\n}\r\n","import { ImmerState, Drafted, ES5ArrayState, ES5ObjectState, each, has, isDraft, latest, DRAFT_STATE, is, loadPlugin, ImmerScope, ProxyType, getCurrentScope, die, markChanged, objectTraps, ownKeys, getOwnPropertyDescriptors } from \"../internal.js\";\r\n\n type ES5State = ES5ArrayState | ES5ObjectState;\r\n\n export function enableES5() {\r\n    function willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean) {\r\n        if (!isReplaced) {\r\n            if (scope.patches_) {\r\n                markChangesRecursively(scope.drafts_![0]);\r\n            }\r\n            // This is faster when we don't care about which attributes changed.\r\n            markChangesSweep(scope.drafts_);\r\n        }\r\n        // When a child draft is returned, look for changes.\r\n        else if (isDraft(result) &&\r\n            (result[DRAFT_STATE] as ES5State).scope_ === scope) {\r\n            markChangesSweep(scope.drafts_);\r\n        }\r\n    }\r\n    \n function createES5Draft(isArray: boolean, base: any) {\r\n        if (isArray) {\r\n            const draft = new Array(base.length);\r\n            for (let i = 0; i < base.length; i++)\r\n                Object.defineProperty(draft, \"\" + i, proxyProperty(i, true));\r\n            return draft;\r\n        }\r\n        else {\r\n            const descriptors = getOwnPropertyDescriptors(base);\r\n            delete descriptors[DRAFT_STATE as any];\r\n            const keys = ownKeys(descriptors);\r\n            for (let i = 0; i < keys.length; i++) {\r\n                const key: any = keys[i];\r\n                descriptors[key] = proxyProperty(key, isArray || !!descriptors[key].enumerable);\r\n            }\r\n            return Object.create(Object.getPrototypeOf(base), descriptors);\r\n        }\r\n    }\r\n    \n function createES5Proxy_<T>(base: T, parent?: ImmerState): Drafted<T, ES5ObjectState | ES5ArrayState> {\r\n        const isArray = Array.isArray(base);\r\n        const draft = createES5Draft(isArray, base);\r\n        \n const state: ES5ObjectState | ES5ArrayState = {\r\n            type_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\r\n            scope_: parent ? parent.scope_ : getCurrentScope(),\r\n            modified_: false,\r\n            finalized_: false,\r\n            assigned_: {},\r\n            parent_: parent,\r\n            // base is the object we are drafting\r\n            base_: base,\r\n            // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\r\n            draft_: draft,\r\n            copy_: null,\r\n            revoked_: false,\r\n            isManual_: false\r\n        };\r\n        \n Object.defineProperty(draft, DRAFT_STATE, {\r\n            value: state,\r\n            // enumerable: false <- the default\r\n            writable: true\r\n        });\r\n        return draft;\r\n    }\r\n    \n // property descriptors are recycled to make sure we don't create a get and set closure per property,\r\n    // but share them all instead\r\n    const descriptors: {\r\n        [prop: string]: PropertyDescriptor;\r\n    } = {};\r\n    \n function proxyProperty(prop: string | number, enumerable: boolean): PropertyDescriptor {\r\n        let desc = descriptors[prop];\r\n        if (desc) {\r\n            desc.enumerable = enumerable;\r\n        }\r\n        else {\r\n            descriptors[prop] = desc = {\r\n                configurable: true,\r\n                enumerable,\r\n                get(this: any) {\r\n                    const state = this[DRAFT_STATE];\r\n                    if (__DEV__)\r\n                        assertUnrevoked(state);\r\n                    // @ts-ignore\r\n                    return objectTraps.get(state, prop);\r\n                },\r\n                set(this: any, value) {\r\n                    const state = this[DRAFT_STATE];\r\n                    if (__DEV__)\r\n                        assertUnrevoked(state);\r\n                    // @ts-ignore\r\n                    objectTraps.set(state, prop, value);\r\n                }\r\n            };\r\n        }\r\n        return desc;\r\n    }\r\n    \n // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\r\n    function markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\r\n        // The natural order of drafts in the `scope` array is based on when they\r\n        // were accessed. By processing drafts in reverse natural order, we have a\r\n        // better chance of processing leaf nodes first. When a leaf node is known to\r\n        // have changed, we can avoid any traversal of its ancestor nodes.\r\n        for (let i = drafts.length - 1; i >= 0; i--) {\r\n            const state: ES5State = drafts[i][DRAFT_STATE];\r\n            if (!state.modified_) {\r\n                switch (state.type_) {\r\n                    case ProxyType.ES5Array:\r\n                        if (hasArrayChanges(state))\r\n                            markChanged(state);\r\n                        break;\r\n                    case ProxyType.ES5Object:\r\n                        if (hasObjectChanges(state))\r\n                            markChanged(state);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \n function markChangesRecursively(object: any) {\r\n        if (!object || typeof object !== \"object\")\r\n            return;\r\n        const state: ES5State | undefined = object[DRAFT_STATE];\r\n        if (!state)\r\n            return;\r\n        const { base_, draft_, assigned_, type_ } = state;\r\n        if (type_ === ProxyType.ES5Object) {\r\n            // Look for added keys.\r\n            // probably there is a faster way to detect changes, as sweep + recurse seems to do some\r\n            // unnecessary work.\r\n            // also: probably we can store the information we detect here, to speed up tree finalization!\r\n            each(draft_, key => {\r\n                if ((key as any) === DRAFT_STATE)\r\n                    return;\r\n                // The `undefined` check is a fast path for pre-existing keys.\r\n                if ((base_ as any)[key] === undefined && !has(base_, key)) {\r\n                    assigned_[key] = true;\r\n                    markChanged(state);\r\n                }\r\n                else if (!assigned_[key]) {\r\n                    // Only untouched properties trigger recursion.\r\n                    markChangesRecursively(draft_[key]);\r\n                }\r\n            });\r\n            // Look for removed keys.\r\n            each(base_, key => {\r\n                // The `undefined` check is a fast path for pre-existing keys.\r\n                if (draft_[key] === undefined && !has(draft_, key)) {\r\n                    assigned_[key] = false;\r\n                    markChanged(state);\r\n                }\r\n            });\r\n        }\r\n        else if (type_ === ProxyType.ES5Array) {\r\n            if (hasArrayChanges(state as ES5ArrayState)) {\r\n                markChanged(state);\r\n                assigned_.length = true;\r\n            }\r\n            \n if (draft_.length < base_.length) {\r\n                for (let i = draft_.length; i < base_.length; i++)\r\n                    assigned_[i] = false;\r\n            }\r\n            else {\r\n                for (let i = base_.length; i < draft_.length; i++)\r\n                    assigned_[i] = true;\r\n            }\r\n            \n // Minimum count is enough, the other parts has been processed.\r\n            const min = Math.min(draft_.length, base_.length);\r\n            \n for (let i = 0; i < min; i++) {\r\n                // Only untouched indices trigger recursion.\r\n                if (!draft_.hasOwnProperty(i)) {\r\n                    assigned_[i] = true;\r\n                }\r\n                if (assigned_[i] === undefined)\r\n                    markChangesRecursively(draft_[i]);\r\n            }\r\n        }\r\n    }\r\n    \n function hasObjectChanges(state: ES5ObjectState) {\r\n        const { base_, draft_ } = state;\r\n        \n // Search for added keys and changed keys. Start at the back, because\r\n        // non-numeric keys are ordered by time of definition on the object.\r\n        const keys = ownKeys(draft_);\r\n        for (let i = keys.length - 1; i >= 0; i--) {\r\n            const key: any = keys[i];\r\n            if (key === DRAFT_STATE)\r\n                continue;\r\n            const baseValue = base_[key];\r\n            // The `undefined` check is a fast path for pre-existing keys.\r\n            if (baseValue === undefined && !has(base_, key)) {\r\n                return true;\r\n            }\r\n            // Once a base key is deleted, future changes go undetected, because its\r\n            // descriptor is erased. This branch detects any missed changes.\r\n            else {\r\n                const value = draft_[key];\r\n                const state: ImmerState = value && value[DRAFT_STATE];\r\n                if (state ? state.base_ !== baseValue : !is(value, baseValue)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        \n // At this point, no keys were added or changed.\r\n        // Compare key count to determine if keys were deleted.\r\n        const baseIsDraft = !!base_[DRAFT_STATE as any];\r\n        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE\r\n    }\r\n    \n function hasArrayChanges(state: ES5ArrayState) {\r\n        const { draft_ } = state;\r\n        if (draft_.length !== state.base_.length)\r\n            return true;\r\n        // See #116\r\n        // If we first shorten the length, our array interceptors will be removed.\r\n        // If after that new items are added, result in the same original length,\r\n        // those last items will have no intercepting property.\r\n        // So if there is no own descriptor on the last position, we know that items were removed and added\r\n        // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\r\n        // the last one\r\n        // last descriptor can be not a trap, if the array was extended\r\n        const descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1);\r\n        // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\r\n        if (descriptor && !descriptor.get)\r\n            return true;\r\n        // if we miss a property, it has been deleted, so array probobaly changed\r\n        for (let i = 0; i < draft_.length; i++) {\r\n            if (!draft_.hasOwnProperty(i))\r\n                return true;\r\n        }\r\n        // For all other cases, we don't have to compare, as they would have been picked up by the index setters\r\n        return false;\r\n    }\r\n    \n function hasChanges_(state: ES5State) {\r\n        return state.type_ === ProxyType.ES5Object\r\n            ? hasObjectChanges(state)\r\n            : hasArrayChanges(state);\r\n    }\r\n    \n function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\r\n        if (state.revoked_)\r\n            die(3, JSON.stringify(latest(state)));\r\n    }\r\n    \n loadPlugin(\"ES5\", {\r\n        createES5Proxy_,\r\n        willFinalizeES5_,\r\n        hasChanges_\r\n    });\r\n}\r\n","// types only!\r\nimport { ImmerState, AnyMap, AnySet, MapState, SetState, DRAFT_STATE, getCurrentScope, latest, iteratorSymbol, isDraftable, createProxy, loadPlugin, markChanged, ProxyType, die, each } from \"../internal.js\";\r\n\n export function enableMapSet() {\r\n    /* istanbul ignore next */\r\n    var extendStatics = function (d: any, b: any): any {\r\n        extendStatics =\r\n            Object.setPrototypeOf ||\r\n                ({ __proto__: [] } instanceof Array &&\r\n                    function (d, b) {\r\n                        d.__proto__ = b;\r\n                    }) ||\r\n                function (d, b) {\r\n                    for (var p in b)\r\n                        if (b.hasOwnProperty(p))\r\n                            d[p] = b[p];\r\n                };\r\n        return extendStatics(d, b);\r\n    };\r\n    \n // Ugly hack to resolve #502 and inherit built in Map / Set\r\n    function __extends(d: any, b: any): any {\r\n        extendStatics(d, b);\r\n        function __(this: any): any {\r\n            Object.defineProperty(this, \"constructor\", {\r\n                value: d\r\n            });\r\n        }\r\n        d.prototype =\r\n            // @ts-ignore\r\n            ((__.prototype = b.prototype), new __());\r\n    }\r\n    \n const DraftMap = (function (_super) {\r\n        __extends(DraftMap, _super);\r\n        // Create class manually, cause #502\r\n        function DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\r\n            this[DRAFT_STATE] = {\r\n                type_: ProxyType.Map,\r\n                parent_: parent,\r\n                scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n                modified_: false,\r\n                finalized_: false,\r\n                copy_: undefined,\r\n                assigned_: undefined,\r\n                base_: target,\r\n                draft_: this as any,\r\n                isManual_: false,\r\n                revoked_: false\r\n            } as MapState;\r\n            return this;\r\n        }\r\n        const p = DraftMap.prototype;\r\n        \n Object.defineProperties(p, {\r\n            size: {\r\n                get: function () {\r\n                    return latest(this[DRAFT_STATE]).size;\r\n                },\r\n                configurable: true\r\n            },\r\n            has: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): boolean {\r\n                    return latest(this[DRAFT_STATE]).has(key);\r\n                }\r\n            },\r\n            set: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any, value: any) {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (!latest(state).has(key) || latest(state).get(key) !== value) {\r\n                        prepareMapCopy(state);\r\n                        markChanged(state);\r\n                        state.assigned_!.set(key, true);\r\n                        state.copy_!.set(key, value);\r\n                        state.assigned_!.set(key, true);\r\n                    }\r\n                    return this;\r\n                }\r\n            },\r\n            delete: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): boolean {\r\n                    if (!this.has(key)) {\r\n                        return false;\r\n                    }\r\n                    \n const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareMapCopy(state);\r\n                    markChanged(state);\r\n                    if (state.base_.has(key)) {\r\n                        state.assigned_!.set(key, false);\r\n                    }\r\n                    else {\r\n                        state.assigned_!.delete(key);\r\n                    }\r\n                    state.copy_!.delete(key);\r\n                    return true;\r\n                }\r\n            },\r\n            clear: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (latest(state).size) {\r\n                        prepareMapCopy(state);\r\n                        markChanged(state);\r\n                        state.assigned_ = new Map();\r\n                        each(state.base_, key => {\r\n                            state.assigned_!.set(key, false);\r\n                        });\r\n                        state.copy_!.clear();\r\n                    }\r\n                }\r\n            },\r\n            forEach: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (cb: (value: any, key: any, self: any) => void, thisArg?: any) {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    latest(state).forEach((_value: any, key: any, _map: any) => {\r\n                        cb.call(thisArg, this.get(key), key, this);\r\n                    });\r\n                }\r\n            },\r\n            get: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): any {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    const value = latest(state).get(key);\r\n                    if (state.finalized_ || !isDraftable(value)) {\r\n                        return value;\r\n                    }\r\n                    if (value !== state.base_.get(key)) {\r\n                        return value; // either already drafted or reassigned\r\n                    }\r\n                    // despite what it looks, this creates a draft only once, see above condition\r\n                    const draft = createProxy(state.scope_.immer_, value, state);\r\n                    prepareMapCopy(state);\r\n                    state.copy_!.set(key, draft);\r\n                    return draft;\r\n                }\r\n            },\r\n            keys: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    return latest(this[DRAFT_STATE]).keys();\r\n                }\r\n            },\r\n            values: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    const iterator = this.keys();\r\n                    return {\r\n                        [iteratorSymbol]: () => this.values(),\r\n                        next: () => {\r\n                            const r = iterator.next();\r\n                            /* istanbul ignore next */\r\n                            if (r.done)\r\n                                return r;\r\n                            const value = this.get(r.value);\r\n                            return {\r\n                                done: false,\r\n                                value\r\n                            };\r\n                        }\r\n                    } as any;\r\n                }\r\n            },\r\n            entries: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<[\r\n                    any,\r\n                    any\r\n                ]> {\r\n                    const iterator = this.keys();\r\n                    return {\r\n                        [iteratorSymbol]: () => this.entries(),\r\n                        next: () => {\r\n                            const r = iterator.next();\r\n                            /* istanbul ignore next */\r\n                            if (r.done)\r\n                                return r;\r\n                            const value = this.get(r.value);\r\n                            return {\r\n                                done: false,\r\n                                value: [r.value, value]\r\n                            };\r\n                        }\r\n                    } as any;\r\n                }\r\n            },\r\n            [iteratorSymbol]: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    return this.entries();\r\n                }\r\n            }\r\n        });\r\n        \n return DraftMap;\r\n    })(Map);\r\n    \n function proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\r\n        // @ts-ignore\r\n        return new DraftMap(target, parent);\r\n    }\r\n    \n function prepareMapCopy(state: MapState) {\r\n        if (!state.copy_) {\r\n            state.assigned_ = new Map();\r\n            state.copy_ = new Map(state.base_);\r\n        }\r\n    }\r\n    \n const DraftSet = (function (_super) {\r\n        __extends(DraftSet, _super);\r\n        // Create class manually, cause #502\r\n        function DraftSet(this: any, target: AnySet, parent?: ImmerState) {\r\n            this[DRAFT_STATE] = {\r\n                type_: ProxyType.Set,\r\n                parent_: parent,\r\n                scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n                modified_: false,\r\n                finalized_: false,\r\n                copy_: undefined,\r\n                base_: target,\r\n                draft_: this,\r\n                drafts_: new Map(),\r\n                revoked_: false,\r\n                isManual_: false\r\n            } as SetState;\r\n            return this;\r\n        }\r\n        const p = DraftSet.prototype;\r\n        \n Object.defineProperties(p, {\r\n            size: {\r\n                get: function () {\r\n                    return latest(this[DRAFT_STATE]).size;\r\n                },\r\n                configurable: true\r\n            },\r\n            has: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): boolean {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    // bit of trickery here, to be able to recognize both the value, and the draft of its value\r\n                    if (!state.copy_) {\r\n                        return state.base_.has(value);\r\n                    }\r\n                    if (state.copy_.has(value))\r\n                        return true;\r\n                    if (state.drafts_.has(value) &&\r\n                        state.copy_.has(state.drafts_.get(value)))\r\n                        return true;\r\n                    return false;\r\n                }\r\n            },\r\n            add: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): any {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (!this.has(value)) {\r\n                        prepareSetCopy(state);\r\n                        markChanged(state);\r\n                        state.copy_!.add(value);\r\n                    }\r\n                    return this;\r\n                }\r\n            },\r\n            delete: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): any {\r\n                    if (!this.has(value)) {\r\n                        return false;\r\n                    }\r\n                    \n const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    markChanged(state);\r\n                    return (state.copy_!.delete(value) ||\r\n                        (state.drafts_.has(value)\r\n                            ? state.copy_!.delete(state.drafts_.get(value))\r\n                            : /* istanbul ignore next */ false));\r\n                }\r\n            },\r\n            clear: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (latest(state).size) {\r\n                        prepareSetCopy(state);\r\n                        markChanged(state);\r\n                        state.copy_!.clear();\r\n                    }\r\n                }\r\n            },\r\n            values: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    return state.copy_!.values();\r\n                }\r\n            },\r\n            entries: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function entries(): IterableIterator<[\r\n                    any,\r\n                    any\r\n                ]> {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    return state.copy_!.entries();\r\n                }\r\n            },\r\n            keys: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    return this.values();\r\n                }\r\n            },\r\n            [iteratorSymbol]: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    return this.values();\r\n                }\r\n            },\r\n            forEach: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function forEach(cb: any, thisArg?: any) {\r\n                    const iterator = this.values();\r\n                    let result = iterator.next();\r\n                    while (!result.done) {\r\n                        cb.call(thisArg, result.value, result.value, this);\r\n                        result = iterator.next();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        \n return DraftSet;\r\n    })(Set);\r\n    \n function proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\r\n        // @ts-ignore\r\n        return new DraftSet(target, parent);\r\n    }\r\n    \n function prepareSetCopy(state: SetState) {\r\n        if (!state.copy_) {\r\n            // create drafts for all entries to preserve insertion order\r\n            state.copy_ = new Set();\r\n            state.base_.forEach(value => {\r\n                if (isDraftable(value)) {\r\n                    const draft = createProxy(state.scope_.immer_, value, state);\r\n                    state.drafts_.set(value, draft);\r\n                    state.copy_!.add(draft);\r\n                }\r\n                else {\r\n                    state.copy_!.add(value);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    \n function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\r\n        if (state.revoked_)\r\n            die(3, JSON.stringify(latest(state)));\r\n    }\r\n    \n loadPlugin(\"MapSet\", { proxyMap_, proxySet_ });\r\n}\r\n","import { enableES5 } from \"./es5.js\";\r\nimport { enableMapSet } from \"./mapset.js\";\r\nimport { enablePatches } from \"./patches.js\";\r\n\n export function enableAllPlugins() {\r\n    enableES5();\r\n    enableMapSet();\r\n    enablePatches();\r\n}\r\n","import { immerable } from \"../immer.js\";\r\nimport { ImmerState, Patch, SetState, ES5ArrayState, ProxyArrayState, MapState, ES5ObjectState, ProxyObjectState, PatchPath, get, each, has, getArchtype, isSet, isMap, loadPlugin, ProxyType, Archtype, die, isDraft, isDraftable, NOTHING } from \"../internal.js\";\r\n\n export function enablePatches() {\r\n    const REPLACE = \"replace\";\r\n    const ADD = \"add\";\r\n    const REMOVE = \"remove\";\r\n    \n function generatePatches_(state: ImmerState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]): void {\r\n        switch (state.type_) {\r\n            case ProxyType.ProxyObject:\r\n            case ProxyType.ES5Object:\r\n            case ProxyType.Map:\r\n                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\r\n            case ProxyType.ES5Array:\r\n            case ProxyType.ProxyArray:\r\n                return generateArrayPatches(state, basePath, patches, inversePatches);\r\n            case ProxyType.Set:\r\n                return generateSetPatches((state as any) as SetState, basePath, patches, inversePatches);\r\n        }\r\n    }\r\n    \n function generateArrayPatches(state: ES5ArrayState | ProxyArrayState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        let { base_, assigned_ } = state;\r\n        let copy_ = state.copy_!;\r\n        \n // Reduce complexity by ensuring `base` is never longer.\r\n        if (copy_.length < base_.length) {\r\n            // @ts-ignore\r\n            ;\r\n            [base_, copy_] = [copy_, base_];\r\n            [patches, inversePatches] = [inversePatches, patches];\r\n        }\r\n        \n // Process replaced indices.\r\n        for (let i = 0; i < base_.length; i++) {\r\n            if (assigned_[i] && copy_[i] !== base_[i]) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: REPLACE,\r\n                    path,\r\n                    // Need to maybe clone it, as it can in fact be the original value\r\n                    // due to the base/copy inversion at the start of this function\r\n                    value: clonePatchValueIfNeeded(copy_[i])\r\n                });\r\n                inversePatches.push({\r\n                    op: REPLACE,\r\n                    path,\r\n                    value: clonePatchValueIfNeeded(base_[i])\r\n                });\r\n            }\r\n        }\r\n        \n // Process added indices.\r\n        for (let i = base_.length; i < copy_.length; i++) {\r\n            const path = basePath.concat([i]);\r\n            patches.push({\r\n                op: ADD,\r\n                path,\r\n                // Need to maybe clone it, as it can in fact be the original value\r\n                // due to the base/copy inversion at the start of this function\r\n                value: clonePatchValueIfNeeded(copy_[i])\r\n            });\r\n        }\r\n        if (base_.length < copy_.length) {\r\n            inversePatches.push({\r\n                op: REPLACE,\r\n                path: basePath.concat([\"length\"]),\r\n                value: base_.length\r\n            });\r\n        }\r\n    }\r\n    \n // This is used for both Map objects and normal objects.\r\n    function generatePatchesFromAssigned(state: MapState | ES5ObjectState | ProxyObjectState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        const { base_, copy_ } = state;\r\n        each(state.assigned_!, (key, assignedValue) => {\r\n            const origValue = get(base_, key);\r\n            const value = get(copy_!, key);\r\n            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\r\n            if (origValue === value && op === REPLACE)\r\n                return;\r\n            const path = basePath.concat(key as any);\r\n            patches.push(op === REMOVE ? { op, path } : { op, path, value });\r\n            inversePatches.push(op === ADD\r\n                ? { op: REMOVE, path }\r\n                : op === REMOVE\r\n                    ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) }\r\n                    : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) });\r\n        });\r\n    }\r\n    \n function generateSetPatches(state: SetState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        let { base_, copy_ } = state;\r\n        \n let i = 0;\r\n        base_.forEach((value: any) => {\r\n            if (!copy_!.has(value)) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: REMOVE,\r\n                    path,\r\n                    value\r\n                });\r\n                inversePatches.unshift({\r\n                    op: ADD,\r\n                    path,\r\n                    value\r\n                });\r\n            }\r\n            i++;\r\n        });\r\n        i = 0;\r\n        copy_!.forEach((value: any) => {\r\n            if (!base_.has(value)) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: ADD,\r\n                    path,\r\n                    value\r\n                });\r\n                inversePatches.unshift({\r\n                    op: REMOVE,\r\n                    path,\r\n                    value\r\n                });\r\n            }\r\n            i++;\r\n        });\r\n    }\r\n    \n function generateReplacementPatches_(baseValue: any, replacement: any, patches: Patch[], inversePatches: Patch[]): void {\r\n        patches.push({\r\n            op: REPLACE,\r\n            path: [],\r\n            value: replacement === NOTHING ? undefined : replacement\r\n        });\r\n        inversePatches.push({\r\n            op: REPLACE,\r\n            path: [],\r\n            value: baseValue\r\n        });\r\n    }\r\n    \n function applyPatches_<T>(draft: T, patches: Patch[]): T {\r\n        patches.forEach(patch => {\r\n            const { path, op } = patch;\r\n            \n let base: any = draft;\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                const parentType = getArchtype(base);\r\n                const p = \"\" + path[i];\r\n                // See #738, avoid prototype pollution\r\n                if ((parentType === Archtype.Object || parentType === Archtype.Array) &&\r\n                    (p === \"__proto__\" || p === \"constructor\"))\r\n                    die(24);\r\n                if (typeof base === \"function\" && p === \"prototype\")\r\n                    die(24);\r\n                base = get(base, p);\r\n                if (typeof base !== \"object\")\r\n                    die(15, path.join(\"/\"));\r\n            }\r\n            \n const type = getArchtype(base);\r\n            const value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\r\n            const key = path[path.length - 1];\r\n            switch (op) {\r\n                case REPLACE:\r\n                    switch (type) {\r\n                        case Archtype.Map:\r\n                            return base.set(key, value);\r\n                        /* istanbul ignore next */\r\n                        case Archtype.Set:\r\n                            die(16);\r\n                        default:\r\n                            // if value is an object, then it's assigned by reference\r\n                            // in the following add or remove ops, the value field inside the patch will also be modifyed\r\n                            // so we use value from the cloned patch\r\n                            // @ts-ignore\r\n                            return (base[key] = value);\r\n                    }\r\n                case ADD:\r\n                    switch (type) {\r\n                        case Archtype.Array:\r\n                            return key === \"-\"\r\n                                ? base.push(value)\r\n                                : base.splice(key as any, 0, value);\r\n                        case Archtype.Map:\r\n                            return base.set(key, value);\r\n                        case Archtype.Set:\r\n                            return base.add(value);\r\n                        default:\r\n                            return (base[key] = value);\r\n                    }\r\n                case REMOVE:\r\n                    switch (type) {\r\n                        case Archtype.Array:\r\n                            return base.splice(key as any, 1);\r\n                        case Archtype.Map:\r\n                            return base.delete(key);\r\n                        case Archtype.Set:\r\n                            return base.delete(patch.value);\r\n                        default:\r\n                            return delete base[key];\r\n                    }\r\n                default:\r\n                    die(17, op);\r\n            }\r\n        });\r\n        \n return draft;\r\n    }\r\n    \n // optimize: this is quite a performance hit, can we detect intelligently when it is needed?\r\n    // E.g. auto-draft when new objects from outside are assigned and modified?\r\n    // (See failing test when deepClone just returns obj)\r\n    function deepClonePatchValue<T>(obj: T): T;\r\n    function deepClonePatchValue(obj: any) {\r\n        if (!isDraftable(obj))\r\n            return obj;\r\n        if (Array.isArray(obj))\r\n            return obj.map(deepClonePatchValue);\r\n        if (isMap(obj))\r\n            return new Map(Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)]));\r\n        if (isSet(obj))\r\n            return new Set(Array.from(obj).map(deepClonePatchValue));\r\n        const cloned = Object.create(Object.getPrototypeOf(obj));\r\n        for (const key in obj)\r\n            cloned[key] = deepClonePatchValue(obj[key]);\r\n        if (has(obj, immerable))\r\n            cloned[immerable] = obj[immerable];\r\n        return cloned;\r\n    }\r\n    \n function clonePatchValueIfNeeded<T>(obj: T): T {\r\n        if (isDraft(obj)) {\r\n            return deepClonePatchValue(obj);\r\n        }\r\n        else\r\n            return obj;\r\n    }\r\n    \n loadPlugin(\"Patches\", {\r\n        applyPatches_,\r\n        generatePatches_,\r\n        generateReplacementPatches_\r\n    });\r\n}\r\n","import { IProduce, IProduceWithPatches, Immer, Draft, Immutable } from \"./internal.js\";\r\n\n export { Draft, Immutable, Patch, PatchListener, original, current, isDraft, isDraftable, NOTHING as nothing, DRAFTABLE as immerable, freeze } from \"./internal.js\";\r\n\n const immer = new Immer();\r\n\n /**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */\r\nexport const produce: IProduce = immer.produce;\r\nexport default produce;\r\n\n /**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */\r\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(immer);\r\n\n /**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * Always freeze by default, even in production mode\r\n */\r\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer);\r\n\n /**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */\r\nexport const setUseProxies = immer.setUseProxies.bind(immer);\r\n\n /**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */\r\nexport const applyPatches = immer.applyPatches.bind(immer);\r\n\n /**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */\r\nexport const createDraft = immer.createDraft.bind(immer);\r\n\n /**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */\r\nexport const finishDraft = immer.finishDraft.bind(immer);\r\n\n /**\r\n * This function is actually a no-op, but can be used to cast an immutable type\r\n * to an draft type and make TypeScript happy\r\n *\r\n * @param value\r\n */\r\nexport function castDraft<T>(value: T): Draft<T> {\r\n    return value as any;\r\n}\r\n\n /**\r\n * This function is actually a no-op, but can be used to cast a mutable type\r\n * to an immutable type and make TypeScript happy\r\n * @param value\r\n */\r\nexport function castImmutable<T>(value: T): Immutable<T> {\r\n    return value as any;\r\n}\r\n\n export { Immer };\r\n\n export { enableES5 } from \"./plugins/es5.js\";\r\nexport { enablePatches } from \"./plugins/patches.js\";\r\nexport { enableMapSet } from \"./plugins/mapset.js\";\r\nexport { enableAllPlugins } from \"./plugins/all.js\";\r\n"],"names":["hasSymbol","Symbol","hasMap","Map","hasSet","Set","hasProxies","Proxy","revocable","Reflect","NOTHING","for","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","errors","data","path","op","plugin","thing","die","error","args","e","msg","apply","Error","isDraft","value","isDraftable","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","Object","prototype","toString","proto","getPrototypeOf","Ctor","hasOwnProperty","call","Function","original","base_","ownKeys","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","getOwnPropertyDescriptors","target","res","forEach","key","getOwnPropertyDescriptor","each","iter","enumerableOnly","getArchtype","keys","entry","index","state","type_","has","prop","get","set","propOrOldValue","t","delete","add","is","x","y","latest","copy_","shallowCopy","base","slice","descriptors","i","length","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","dontMutateFrozenCollections","defineProperties","clear","plugins","getPlugin","pluginKey","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","autoFreeze_","createProxyProxy","parent","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","source","readPropFromProto","peek","prepareCopy","createProxy","getDescriptorFromProto","current","currentState","markChanged","Number","isNaN","deleteProperty","owner","defineProperty","setPrototypeOf","fn","arguments","parseInt","Immer","config","recipe","defaultBase","self","curriedProduce","produce","hasError","Promise","then","p","ip","produceWithPatches","patches","inversePatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","createES5Proxy_","push","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","markChangesRecursively","markChangesSweep","createES5Draft","proxyProperty","assertUnrevoked","drafts","hasArrayChanges","hasObjectChanges","object","min","Math","baseValue","baseIsDraft","descriptor","JSON","stringify","enableMapSet","extendStatics","d","b","__proto__","__extends","__","DraftMap","_super","size","prepareMapCopy","cb","thisArg","_value","_map","values","next","r","done","entries","DraftSet","prepareSetCopy","enableAllPlugins","enablePatches","REPLACE","ADD","REMOVE","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","clonePatchValueIfNeeded","assignedValue","origValue","unshift","replacement","parentType","join","type","deepClonePatchValue","splice","map","k","v","cloned","immerable","bind","castDraft","castImmutable"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/immer.cjs.production.min.js b/dist/immer.cjs.production.min.js
index e8717f9957deffe2f50fa9a36f83ecab82535b48..5468c7f60548ae8ad50ff6b802cea6fee67e327d 100644
--- a/dist/immer.cjs.production.min.js
+++ b/dist/immer.cjs.production.min.js
@@ -1,2 +1,2 @@
-function n(n){for(var t=arguments.length,r=Array(t>1?t-1:0),e=1;e<t;e++)r[e-1]=arguments[e];throw Error("[Immer] minified error nr: "+n+(r.length?" "+r.map((function(n){return"'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function t(n){return!!n&&!!n[H]}function r(n){var t;return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var t=Object.getPrototypeOf(n);if(null===t)return!0;var r=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return r===Object||"function"==typeof r&&Function.toString.call(r)===Q}(n)||Array.isArray(n)||!!n[G]||!!(null===(t=n.constructor)||void 0===t?void 0:t[G])||c(n)||v(n))}function e(n,t,r){void 0===r&&(r=!1),0===i(n)?(r?Object.keys:T)(n).forEach((function(e){r&&"symbol"==typeof e||t(e,n[e],n)})):n.forEach((function(r,e){return t(e,r,n)}))}function i(n){var t=n[H];return t?t.t>3?t.t-4:t.t:Array.isArray(n)?1:c(n)?2:v(n)?3:0}function o(n,t){return 2===i(n)?n.has(t):Object.prototype.hasOwnProperty.call(n,t)}function u(n,t){return 2===i(n)?n.get(t):n[t]}function f(n,t,r){var e=i(n);2===e?n.set(t,r):3===e?(n.delete(t),n.add(r)):n[t]=r}function a(n,t){return n===t?0!==n||1/n==1/t:n!=n&&t!=t}function c(n){return W&&n instanceof Map}function v(n){return X&&n instanceof Set}function s(n){return n.i||n.o}function p(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var t=U(n);delete t[H];for(var r=T(t),e=0;e<r.length;e++){var i=r[e],o=t[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(t[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),t)}function l(n,o){return void 0===o&&(o=!1),h(n)||t(n)||!r(n)?n:(i(n)>1&&(n.set=n.add=n.clear=n.delete=d),Object.freeze(n),o&&e(n,(function(n,t){return l(t,!0)}),!0),n)}function d(){n(2)}function h(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function y(t){var r=V[t];return r||n(18,t),r}function _(n,t){V[n]||(V[n]=t)}function b(){return J}function m(n,t){t&&(y("Patches"),n.u=[],n.v=[],n.s=t)}function j(n){O(n),n.p.forEach(w),n.p=null}function O(n){n===J&&(J=n.l)}function x(n){return J={p:[],l:J,h:n,_:!0,m:0}}function w(n){var t=n[H];0===t.t||1===t.t?t.j():t.O=!0}function S(t,e){e.m=e.p.length;var i=e.p[0],o=void 0!==t&&t!==i;return e.h.S||y("ES5").P(e,t,o),o?(i[H].M&&(j(e),n(4)),r(t)&&(t=P(e,t),e.l||g(e,t)),e.u&&y("Patches").g(i[H].o,t,e.u,e.v)):t=P(e,i,[]),j(e),e.u&&e.s(e.u,e.v),t!==B?t:void 0}function P(n,t,r){if(h(t))return t;var i=t[H];if(!i)return e(t,(function(e,o){return M(n,i,t,e,o,r)}),!0),t;if(i.A!==n)return t;if(!i.M)return g(n,i.o,!0),i.o;if(!i.R){i.R=!0,i.A.m--;var o=4===i.t||5===i.t?i.i=p(i.k):i.i;e(3===i.t?new Set(o):o,(function(t,e){return M(n,i,o,t,e,r)})),g(n,o,!1),r&&n.u&&y("Patches").F(i,r,n.u,n.v)}return i.i}function M(n,e,i,u,a,c){if(t(a)){var v=P(n,a,c&&e&&3!==e.t&&!o(e.D,u)?c.concat(u):void 0);if(f(i,u,v),!t(v))return;n._=!1}if(r(a)&&!h(a)){if(!n.h.K&&n.m<1)return;P(n,a),e&&e.A.l||g(n,a)}}function g(n,t,r){void 0===r&&(r=!1),n.h.K&&n._&&l(t,r)}function A(n,t){var r=n[H];return(r?s(r):n)[t]}function z(n,t){if(t in n)for(var r=Object.getPrototypeOf(n);r;){var e=Object.getOwnPropertyDescriptor(r,t);if(e)return e;r=Object.getPrototypeOf(r)}}function E(n){n.M||(n.M=!0,n.l&&E(n.l))}function R(n){n.i||(n.i=p(n.o))}function k(n,t,r){var e=c(t)?y("MapSet").$(t,r):v(t)?y("MapSet").C(t,r):n.S?function(n,t){var r=Array.isArray(n),e={t:r?1:0,A:t?t.A:b(),M:!1,R:!1,D:{},l:t,o:n,k:null,i:null,j:null,I:!1},i=e,o=Y;r&&(i=[e],o=Z);var u=Proxy.revocable(i,o),f=u.revoke,a=u.proxy;return e.k=a,e.j=f,a}(t,r):y("ES5").J(t,r);return(r?r.A:b()).p.push(e),e}function F(o){return t(o)||n(22,o),function n(t){if(!r(t))return t;var o,a=t[H],c=i(t);if(a){if(!a.M&&(a.t<4||!y("ES5").N(a)))return a.o;a.R=!0,o=D(t,c),a.R=!1}else o=D(t,c);return e(o,(function(t,r){a&&u(a.o,t)===r||f(o,t,n(r))})),3===c?new Set(o):o}(o)}function D(n,t){switch(t){case 2:return new Map(n);case 3:return Array.from(n)}return p(n)}function K(){function n(n,t){var r=f[n];return r?r.enumerable=t:f[n]=r={configurable:!0,enumerable:t,get:function(){return Y.get(this[H],n)},set:function(t){Y.set(this[H],n,t)}},r}function r(n){for(var t=n.length-1;t>=0;t--){var r=n[t][H];if(!r.M)switch(r.t){case 5:u(r)&&E(r);break;case 4:i(r)&&E(r)}}}function i(n){for(var t=n.o,r=n.k,e=T(r),i=e.length-1;i>=0;i--){var u=e[i];if(u!==H){var f=t[u];if(void 0===f&&!o(t,u))return!0;var c=r[u],v=c&&c[H];if(v?v.o!==f:!a(c,f))return!0}}var s=!!t[H];return e.length!==T(t).length+(s?0:1)}function u(n){var t=n.k;if(t.length!==n.o.length)return!0;var r=Object.getOwnPropertyDescriptor(t,t.length-1);if(r&&!r.get)return!0;for(var e=0;e<t.length;e++)if(!t.hasOwnProperty(e))return!0;return!1}var f={};_("ES5",{J:function(t,r){var e=Array.isArray(t),i=function(t,r){if(t){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,""+i,n(i,!0));return e}var o=U(r);delete o[H];for(var u=T(o),f=0;f<u.length;f++){var a=u[f];o[a]=n(a,t||!!o[a].enumerable)}return Object.create(Object.getPrototypeOf(r),o)}(e,t),o={t:e?5:4,A:r?r.A:b(),M:!1,R:!1,D:{},l:r,o:t,k:i,i:null,O:!1,I:!1};return Object.defineProperty(i,H,{value:o,writable:!0}),i},P:function(n,i,f){f?t(i)&&i[H].A===n&&r(n.p):(n.u&&function n(t){if(t&&"object"==typeof t){var r=t[H];if(r){var i=r.o,f=r.k,a=r.D,c=r.t;if(4===c)e(f,(function(t){t!==H&&(void 0!==i[t]||o(i,t)?a[t]||n(f[t]):(a[t]=!0,E(r)))})),e(i,(function(n){void 0!==f[n]||o(f,n)||(a[n]=!1,E(r))}));else if(5===c){if(u(r)&&(E(r),a.length=!0),f.length<i.length)for(var v=f.length;v<i.length;v++)a[v]=!1;else for(var s=i.length;s<f.length;s++)a[s]=!0;for(var p=Math.min(f.length,i.length),l=0;l<p;l++)f.hasOwnProperty(l)||(a[l]=!0),void 0===a[l]&&n(f[l])}}}}(n.p[0]),r(n.p))},N:function(n){return 4===n.t?i(n):u(n)}})}function $(){function f(n){if(!r(n))return n;if(Array.isArray(n))return n.map(f);if(c(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],f(n[1])]})));if(v(n))return new Set(Array.from(n).map(f));var t=Object.create(Object.getPrototypeOf(n));for(var e in n)t[e]=f(n[e]);return o(n,G)&&(t[G]=n[G]),t}function a(n){return t(n)?f(n):n}var s="add";_("Patches",{W:function(t,r){return r.forEach((function(r){for(var e=r.path,o=r.op,a=t,c=0;c<e.length-1;c++){var v=i(a),p=""+e[c];0!==v&&1!==v||"__proto__"!==p&&"constructor"!==p||n(24),"function"==typeof a&&"prototype"===p&&n(24),"object"!=typeof(a=u(a,p))&&n(15,e.join("/"))}var l=i(a),d=f(r.value),h=e[e.length-1];switch(o){case"replace":switch(l){case 2:return a.set(h,d);case 3:n(16);default:return a[h]=d}case s:switch(l){case 1:return"-"===h?a.push(d):a.splice(h,0,d);case 2:return a.set(h,d);case 3:return a.add(d);default:return a[h]=d}case"remove":switch(l){case 1:return a.splice(h,1);case 2:return a.delete(h);case 3:return a.delete(r.value);default:return delete a[h]}default:n(17,o)}})),t},F:function(n,t,r,i){switch(n.t){case 0:case 4:case 2:return function(n,t,r,i){var f=n.o,c=n.i;e(n.D,(function(n,e){var v=u(f,n),p=u(c,n),l=e?o(f,n)?"replace":s:"remove";if(v!==p||"replace"!==l){var d=t.concat(n);r.push("remove"===l?{op:l,path:d}:{op:l,path:d,value:p}),i.push(l===s?{op:"remove",path:d}:"remove"===l?{op:s,path:d,value:a(v)}:{op:"replace",path:d,value:a(v)})}}))}(n,t,r,i);case 5:case 1:return function(n,t,r,e){var i=n.o,o=n.D,u=n.i;if(u.length<i.length){var f=[u,i];i=f[0],u=f[1];var c=[e,r];r=c[0],e=c[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=t.concat([v]);r.push({op:"replace",path:p,value:a(u[v])}),e.push({op:"replace",path:p,value:a(i[v])})}for(var l=i.length;l<u.length;l++){var d=t.concat([l]);r.push({op:s,path:d,value:a(u[l])})}i.length<u.length&&e.push({op:"replace",path:t.concat(["length"]),value:i.length})}(n,t,r,i);case 3:return function(n,t,r,e){var i=n.o,o=n.i,u=0;i.forEach((function(n){if(!o.has(n)){var i=t.concat([u]);r.push({op:"remove",path:i,value:n}),e.unshift({op:s,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=t.concat([u]);r.push({op:s,path:o,value:n}),e.unshift({op:"remove",path:o,value:n})}u++}))}(n,t,r,i)}},g:function(n,t,r,e){r.push({op:"replace",path:[],value:t===B?void 0:t}),e.push({op:"replace",path:[],value:n})}})}function C(){function t(n,t){function r(){this.constructor=n}f(n,t),n.prototype=(r.prototype=t.prototype,new r)}function i(n){n.i||(n.D=new Map,n.i=new Map(n.o))}function o(n){n.i||(n.i=new Set,n.o.forEach((function(t){if(r(t)){var e=k(n.A.h,t,n);n.p.set(t,e),n.i.add(e)}else n.i.add(t)})))}function u(t){t.O&&n(3,JSON.stringify(s(t)))}var f=function(n,t){return(f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,t){n.__proto__=t}||function(n,t){for(var r in t)t.hasOwnProperty(r)&&(n[r]=t[r])})(n,t)},a=function(){function n(n,t){return this[H]={t:2,l:t,A:t?t.A:b(),M:!1,R:!1,i:void 0,D:void 0,o:n,k:this,I:!1,O:!1},this}t(n,Map);var o=n.prototype;return Object.defineProperty(o,"size",{get:function(){return s(this[H]).size}}),o.has=function(n){return s(this[H]).has(n)},o.set=function(n,t){var r=this[H];return u(r),s(r).has(n)&&s(r).get(n)===t||(i(r),E(r),r.D.set(n,!0),r.i.set(n,t),r.D.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var t=this[H];return u(t),i(t),E(t),t.o.has(n)?t.D.set(n,!1):t.D.delete(n),t.i.delete(n),!0},o.clear=function(){var n=this[H];u(n),s(n).size&&(i(n),E(n),n.D=new Map,e(n.o,(function(t){n.D.set(t,!1)})),n.i.clear())},o.forEach=function(n,t){var r=this;s(this[H]).forEach((function(e,i){n.call(t,r.get(i),i,r)}))},o.get=function(n){var t=this[H];u(t);var e=s(t).get(n);if(t.R||!r(e))return e;if(e!==t.o.get(n))return e;var o=k(t.A.h,e,t);return i(t),t.i.set(n,o),o},o.keys=function(){return s(this[H]).keys()},o.values=function(){var n,t=this,r=this.keys();return(n={})[L]=function(){return t.values()},n.next=function(){var n=r.next();return n.done?n:{done:!1,value:t.get(n.value)}},n},o.entries=function(){var n,t=this,r=this.keys();return(n={})[L]=function(){return t.entries()},n.next=function(){var n=r.next();if(n.done)return n;var e=t.get(n.value);return{done:!1,value:[n.value,e]}},n},o[L]=function(){return this.entries()},n}(),c=function(){function n(n,t){return this[H]={t:3,l:t,A:t?t.A:b(),M:!1,R:!1,i:void 0,o:n,k:this,p:new Map,O:!1,I:!1},this}t(n,Set);var r=n.prototype;return Object.defineProperty(r,"size",{get:function(){return s(this[H]).size}}),r.has=function(n){var t=this[H];return u(t),t.i?!!t.i.has(n)||!(!t.p.has(n)||!t.i.has(t.p.get(n))):t.o.has(n)},r.add=function(n){var t=this[H];return u(t),this.has(n)||(o(t),E(t),t.i.add(n)),this},r.delete=function(n){if(!this.has(n))return!1;var t=this[H];return u(t),o(t),E(t),t.i.delete(n)||!!t.p.has(n)&&t.i.delete(t.p.get(n))},r.clear=function(){var n=this[H];u(n),s(n).size&&(o(n),E(n),n.i.clear())},r.values=function(){var n=this[H];return u(n),o(n),n.i.values()},r.entries=function(){var n=this[H];return u(n),o(n),n.i.entries()},r.keys=function(){return this.values()},r[L]=function(){return this.values()},r.forEach=function(n,t){for(var r=this.values(),e=r.next();!e.done;)n.call(t,e.value,e.value,this),e=r.next()},n}();_("MapSet",{$:function(n,t){return new a(n,t)},C:function(n,t){return new c(n,t)}})}var I;Object.defineProperty(exports,"__esModule",{value:!0});var J,N="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),W="undefined"!=typeof Map,X="undefined"!=typeof Set,q="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,B=N?Symbol.for("immer-nothing"):((I={})["immer-nothing"]=!0,I),G=N?Symbol.for("immer-draftable"):"__$immer_draftable",H=N?Symbol.for("immer-state"):"__$immer_state",L="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",Q=""+Object.prototype.constructor,T="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,U=Object.getOwnPropertyDescriptors||function(n){var t={};return T(n).forEach((function(r){t[r]=Object.getOwnPropertyDescriptor(n,r)})),t},V={},Y={get:function(n,t){if(t===H)return n;var e=s(n);if(!o(e,t))return function(n,t,r){var e,i=z(t,r);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,t);var i=e[t];return n.R||!r(i)?i:i===A(n.o,t)?(R(n),n.i[t]=k(n.A.h,i,n)):i},has:function(n,t){return t in s(n)},ownKeys:function(n){return Reflect.ownKeys(s(n))},set:function(n,t,r){var e=z(s(n),t);if(null==e?void 0:e.set)return e.set.call(n.k,r),!0;if(!n.M){var i=A(s(n),t),u=null==i?void 0:i[H];if(u&&u.o===r)return n.i[t]=r,n.D[t]=!1,!0;if(a(r,i)&&(void 0!==r||o(n.o,t)))return!0;R(n),E(n)}return n.i[t]===r&&"number"!=typeof r&&(void 0!==r||t in n.i)||(n.i[t]=r,n.D[t]=!0,!0)},deleteProperty:function(n,t){return void 0!==A(n.o,t)||t in n.o?(n.D[t]=!1,R(n),E(n)):delete n.D[t],n.i&&delete n.i[t],!0},getOwnPropertyDescriptor:function(n,t){var r=s(n),e=Reflect.getOwnPropertyDescriptor(r,t);return e?{writable:!0,configurable:1!==n.t||"length"!==t,enumerable:e.enumerable,value:r[t]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.o)},setPrototypeOf:function(){n(12)}},Z={};e(Y,(function(n,t){Z[n]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),Z.deleteProperty=function(n,t){return Z.set.call(this,n,t,void 0)},Z.set=function(n,t,r){return Y.set.call(this,n[0],t,r,n[0])};var nn=function(){function e(t){var e=this;this.S=q,this.K=!0,this.produce=function(t,i,o){if("function"==typeof t&&"function"!=typeof i){var u=i;i=t;var f=e;return function(n){var t=this;void 0===n&&(n=u);for(var r=arguments.length,e=Array(r>1?r-1:0),o=1;o<r;o++)e[o-1]=arguments[o];return f.produce(n,(function(n){var r;return(r=i).call.apply(r,[t,n].concat(e))}))}}var a;if("function"!=typeof i&&n(6),void 0!==o&&"function"!=typeof o&&n(7),r(t)){var c=x(e),v=k(e,t,void 0),s=!0;try{a=i(v),s=!1}finally{s?j(c):O(c)}return"undefined"!=typeof Promise&&a instanceof Promise?a.then((function(n){return m(c,o),S(n,c)}),(function(n){throw j(c),n})):(m(c,o),S(a,c))}if(!t||"object"!=typeof t){if(void 0===(a=i(t))&&(a=t),a===B&&(a=void 0),e.K&&l(a,!0),o){var p=[],d=[];y("Patches").g(t,a,p,d),o(p,d)}return a}n(21,t)},this.produceWithPatches=function(n,t){if("function"==typeof n)return function(t){for(var r=arguments.length,i=Array(r>1?r-1:0),o=1;o<r;o++)i[o-1]=arguments[o];return e.produceWithPatches(t,(function(t){return n.apply(void 0,[t].concat(i))}))};var r,i,o=e.produce(n,t,(function(n,t){r=n,i=t}));return"undefined"!=typeof Promise&&o instanceof Promise?o.then((function(n){return[n,r,i]})):[o,r,i]},"boolean"==typeof(null==t?void 0:t.useProxies)&&this.setUseProxies(t.useProxies),"boolean"==typeof(null==t?void 0:t.autoFreeze)&&this.setAutoFreeze(t.autoFreeze)}var i=e.prototype;return i.createDraft=function(e){r(e)||n(8),t(e)&&(e=F(e));var i=x(this),o=k(this,e,void 0);return o[H].I=!0,O(i),o},i.finishDraft=function(n,t){var r=(n&&n[H]).A;return m(r,t),S(void 0,r)},i.setAutoFreeze=function(n){this.K=n},i.setUseProxies=function(t){t&&!q&&n(20),this.S=t},i.applyPatches=function(n,r){var e;for(e=r.length-1;e>=0;e--){var i=r[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}e>-1&&(r=r.slice(e+1));var o=y("Patches").W;return t(n)?o(n,r):this.produce(n,(function(n){return o(n,r)}))},e}(),tn=new nn,rn=tn.produce,en=tn.produceWithPatches.bind(tn),on=tn.setAutoFreeze.bind(tn),un=tn.setUseProxies.bind(tn),fn=tn.applyPatches.bind(tn),an=tn.createDraft.bind(tn),cn=tn.finishDraft.bind(tn);exports.Immer=nn,exports.applyPatches=fn,exports.castDraft=function(n){return n},exports.castImmutable=function(n){return n},exports.createDraft=an,exports.current=F,exports.default=rn,exports.enableAllPlugins=function(){K(),C(),$()},exports.enableES5=K,exports.enableMapSet=C,exports.enablePatches=$,exports.finishDraft=cn,exports.freeze=l,exports.immerable=G,exports.isDraft=t,exports.isDraftable=r,exports.nothing=B,exports.original=function(r){return t(r)||n(23,r),r[H].o},exports.produce=rn,exports.produceWithPatches=en,exports.setAutoFreeze=on,exports.setUseProxies=un;
+"use strict";var e;Object.defineProperty(exports,"__esModule",{value:!0});var t="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),r="undefined"!=typeof Map,n="undefined"!=typeof Set,a="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,o=t?Symbol.for("immer-nothing"):((e={})["immer-nothing"]=!0,e),i=t?Symbol.for("immer-draftable"):"__$immer_draftable",u=t?Symbol.for("immer-state"):"__$immer_state",c="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator";function s(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];throw new Error("[Immer] minified error nr: "+e+(r.length?" "+r.map((function(e){return"'"+e+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function f(e){return!!e&&!!e[u]}function l(e){var t;return!!e&&(function(e){if(!e||"object"!=typeof e)return!1;var t=Object.getPrototypeOf(e);if(null===t)return!0;var r=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return r===Object||"function"==typeof r&&Function.toString.call(r)===p}(e)||Array.isArray(e)||!!e[i]||!!(null===(t=e.constructor)||void 0===t?void 0:t[i])||P(e)||w(e))}var p=Object.prototype.constructor.toString(),_="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:Object.getOwnPropertyNames,v=Object.getOwnPropertyDescriptors||function(e){var t={};return _(e).forEach((function(r){t[r]=Object.getOwnPropertyDescriptor(e,r)})),t};function h(e,t,r){void 0===r&&(r=!1),0===d(e)?(r?Object.keys:_)(e).forEach((function(n){r&&"symbol"==typeof n||t(n,e[n],e)})):e.forEach((function(r,n){return t(n,r,e)}))}function d(e){var t=e[u];return t?t.type_>3?t.type_-4:t.type_:Array.isArray(e)?1:P(e)?2:w(e)?3:0}function y(e,t){return 2===d(e)?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function b(e,t){return 2===d(e)?e.get(t):e[t]}function g(e,t,r){var n=d(e);2===n?e.set(t,r):3===n?(e.delete(t),e.add(r)):e[t]=r}function m(e,t){return e===t?0!==e||1/e==1/t:e!=e&&t!=t}function P(e){return r&&e instanceof Map}function w(e){return n&&e instanceof Set}function O(e){return e.copy_||e.base_}function x(e){if(Array.isArray(e))return Array.prototype.slice.call(e);var t=v(e);delete t[u];for(var r=_(t),n=0;n<r.length;n++){var a=r[n],o=t[a];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(t[a]={configurable:!0,writable:!0,enumerable:o.enumerable,value:e[a]})}return Object.create(Object.getPrototypeOf(e),t)}function j(e,t){if(void 0===t&&(t=!1),S(e)||f(e)||!l(e))return e;if(d(e)>1){var r={configurable:!0,writable:!0,value:z};Object.defineProperties(e,{set:r,add:r,clear:r,delete:r})}return Object.freeze(e),t&&h(e,(function(e,t){return j(t,!0)}),!0),e}function z(){s(2)}function S(e){return null==e||"object"!=typeof e||Object.isFrozen(e)}var A,E={};function M(e){var t=E[e];return t||s(18,e),t}function D(e,t){E[e]||(E[e]=t)}function F(){return A}function k(e,t){t&&(M("Patches"),e.patches_=[],e.inversePatches_=[],e.patchListener_=t)}function N(e){R(e),e.drafts_.forEach(W),e.drafts_=null}function R(e){e===A&&(A=e.parent_)}function K(e){return A={drafts_:[],parent_:A,immer_:e,canAutoFreeze_:!0,unfinalizedDrafts_:0}}function W(e){var t=e[u];0===t.type_||1===t.type_?t.revoke_():t.revoked_=!0}function U(e,t){t.unfinalizedDrafts_=t.drafts_.length;var r=t.drafts_[0],n=void 0!==e&&e!==r;return t.immer_.useProxies_||M("ES5").willFinalizeES5_(t,e,n),n?(r[u].modified_&&(N(t),s(4)),l(e)&&(e=I(t,e),t.parent_||L(t,e)),t.patches_&&M("Patches").generateReplacementPatches_(r[u].base_,e,t.patches_,t.inversePatches_)):e=I(t,r,[]),N(t),t.patches_&&t.patchListener_(t.patches_,t.inversePatches_),e!==o?e:void 0}function I(e,t,r){if(S(t))return t;var n=t[u];if(!n)return h(t,(function(a,o){return C(e,n,t,a,o,r)}),!0),t;if(n.scope_!==e)return t;if(!n.modified_)return L(e,n.base_,!0),n.base_;if(!n.finalized_){n.finalized_=!0,n.scope_.unfinalizedDrafts_--;var a=4===n.type_||5===n.type_?n.copy_=x(n.draft_):n.copy_;h(3===n.type_?new Set(a):a,(function(t,o){return C(e,n,a,t,o,r)})),L(e,a,!1),r&&e.patches_&&M("Patches").generatePatches_(n,r,e.patches_,e.inversePatches_)}return n.copy_}function C(e,t,r,n,a,o){if(f(a)){var i=I(e,a,o&&t&&3!==t.type_&&!y(t.assigned_,n)?o.concat(n):void 0);if(g(r,n,i),!f(i))return;e.canAutoFreeze_=!1}if(l(a)&&!S(a)){if(!e.immer_.autoFreeze_&&e.unfinalizedDrafts_<1)return;I(e,a),t&&t.scope_.parent_||L(e,a)}}function L(e,t,r){void 0===r&&(r=!1),e.immer_.autoFreeze_&&e.canAutoFreeze_&&j(t,r)}var $={get:function(e,t){if(t===u)return e;var r=O(e);if(!y(r,t))return function(e,t,r){var n,a=q(t,r);return a?"value"in a?a.value:null===(n=a.get)||void 0===n?void 0:n.call(e.draft_):void 0}(e,r,t);var n=r[t];return e.finalized_||!l(n)?n:n===X(e.base_,t)?(G(e),e.copy_[t]=Q(e.scope_.immer_,n,e)):n},has:function(e,t){return t in O(e)},ownKeys:function(e){return Reflect.ownKeys(O(e))},set:function(e,t,r){var n=q(O(e),t);if(null==n?void 0:n.set)return n.set.call(e.draft_,r),!0;if(!e.modified_){var a=X(O(e),t),o=null==a?void 0:a[u];if(o&&o.base_===r)return e.copy_[t]=r,e.assigned_[t]=!1,!0;if(m(r,a)&&(void 0!==r||y(e.base_,t)))return!0;G(e),B(e)}return!!(e.copy_[t]===r&&(void 0!==r||t in e.copy_)||Number.isNaN(r)&&Number.isNaN(e.copy_[t]))||(e.copy_[t]=r,e.assigned_[t]=!0,!0)},deleteProperty:function(e,t){return void 0!==X(e.base_,t)||t in e.base_?(e.assigned_[t]=!1,G(e),B(e)):delete e.assigned_[t],e.copy_&&delete e.copy_[t],!0},getOwnPropertyDescriptor:function(e,t){var r=O(e),n=Reflect.getOwnPropertyDescriptor(r,t);return n?{writable:!0,configurable:1!==e.type_||"length"!==t,enumerable:n.enumerable,value:r[t]}:n},defineProperty:function(){s(11)},getPrototypeOf:function(e){return Object.getPrototypeOf(e.base_)},setPrototypeOf:function(){s(12)}},J={};function X(e,t){var r=e[u];return(r?O(r):e)[t]}function q(e,t){if(t in e)for(var r=Object.getPrototypeOf(e);r;){var n=Object.getOwnPropertyDescriptor(r,t);if(n)return n;r=Object.getPrototypeOf(r)}}function B(e){e.modified_||(e.modified_=!0,e.parent_&&B(e.parent_))}function G(e){e.copy_||(e.copy_=x(e.base_))}h($,(function(e,t){J[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),J.deleteProperty=function(e,t){return J.set.call(this,e,t,void 0)},J.set=function(e,t,r){return $.set.call(this,e[0],t,r,e[0])};var H=function(){function e(e){var t=this;this.useProxies_=a,this.autoFreeze_=!0,this.produce=function(e,r,n){if("function"==typeof e&&"function"!=typeof r){var a=r;r=e;var i=t;return function(e){var t=this;void 0===e&&(e=a);for(var n=arguments.length,o=new Array(n>1?n-1:0),u=1;u<n;u++)o[u-1]=arguments[u];return i.produce(e,(function(e){var n;return(n=r).call.apply(n,[t,e].concat(o))}))}}var u;if("function"!=typeof r&&s(6),void 0!==n&&"function"!=typeof n&&s(7),l(e)){var c=K(t),f=Q(t,e,void 0),p=!0;try{u=r(f),p=!1}finally{p?N(c):R(c)}return"undefined"!=typeof Promise&&u instanceof Promise?u.then((function(e){return k(c,n),U(e,c)}),(function(e){throw N(c),e})):(k(c,n),U(u,c))}if(!e||"object"!=typeof e){if(void 0===(u=r(e))&&(u=e),u===o&&(u=void 0),t.autoFreeze_&&j(u,!0),n){var _=[],v=[];M("Patches").generateReplacementPatches_(e,u,_,v),n(_,v)}return u}s(21,e)},this.produceWithPatches=function(e,r){if("function"==typeof e)return function(r){for(var n=arguments.length,a=new Array(n>1?n-1:0),o=1;o<n;o++)a[o-1]=arguments[o];return t.produceWithPatches(r,(function(t){return e.apply(void 0,[t].concat(a))}))};var n,a,o=t.produce(e,r,(function(e,t){n=e,a=t}));return"undefined"!=typeof Promise&&o instanceof Promise?o.then((function(e){return[e,n,a]})):[o,n,a]},"boolean"==typeof(null==e?void 0:e.useProxies)&&this.setUseProxies(e.useProxies),"boolean"==typeof(null==e?void 0:e.autoFreeze)&&this.setAutoFreeze(e.autoFreeze)}var t=e.prototype;return t.createDraft=function(e){l(e)||s(8),f(e)&&(e=T(e));var t=K(this),r=Q(this,e,void 0);return r[u].isManual_=!0,R(t),r},t.finishDraft=function(e,t){var r=(e&&e[u]).scope_;return k(r,t),U(void 0,r)},t.setAutoFreeze=function(e){this.autoFreeze_=e},t.setUseProxies=function(e){e&&!a&&s(20),this.useProxies_=e},t.applyPatches=function(e,t){var r;for(r=t.length-1;r>=0;r--){var n=t[r];if(0===n.path.length&&"replace"===n.op){e=n.value;break}}r>-1&&(t=t.slice(r+1));var a=M("Patches").applyPatches_;return f(e)?a(e,t):this.produce(e,(function(e){return a(e,t)}))},e}();function Q(e,t,r){var n=P(t)?M("MapSet").proxyMap_(t,r):w(t)?M("MapSet").proxySet_(t,r):e.useProxies_?function(e,t){var r=Array.isArray(e),n={type_:r?1:0,scope_:t?t.scope_:F(),modified_:!1,finalized_:!1,assigned_:{},parent_:t,base_:e,draft_:null,copy_:null,revoke_:null,isManual_:!1},a=n,o=$;r&&(a=[n],o=J);var i=Proxy.revocable(a,o),u=i.revoke,c=i.proxy;return n.draft_=c,n.revoke_=u,c}(t,r):M("ES5").createES5Proxy_(t,r);return(r?r.scope_:F()).drafts_.push(n),n}function T(e){return f(e)||s(22,e),function e(t){if(!l(t))return t;var r,n=t[u],a=d(t);if(n){if(!n.modified_&&(n.type_<4||!M("ES5").hasChanges_(n)))return n.base_;n.finalized_=!0,r=V(t,a),n.finalized_=!1}else r=V(t,a);return h(r,(function(t,a){n&&b(n.base_,t)===a||g(r,t,e(a))})),3===a?new Set(r):r}(e)}function V(e,t){switch(t){case 2:return new Map(e);case 3:return Array.from(e)}return x(e)}function Y(){var e={};function t(t,r){var n=e[t];return n?n.enumerable=r:e[t]=n={configurable:!0,enumerable:r,get:function(){return $.get(this[u],t)},set:function(e){$.set(this[u],t,e)}},n}function r(e){for(var t=e.length-1;t>=0;t--){var r=e[t][u];if(!r.modified_)switch(r.type_){case 5:a(r)&&B(r);break;case 4:n(r)&&B(r)}}}function n(e){for(var t=e.base_,r=e.draft_,n=_(r),a=n.length-1;a>=0;a--){var o=n[a];if(o!==u){var i=t[o];if(void 0===i&&!y(t,o))return!0;var c=r[o],s=c&&c[u];if(s?s.base_!==i:!m(c,i))return!0}}var f=!!t[u];return n.length!==_(t).length+(f?0:1)}function a(e){var t=e.draft_;if(t.length!==e.base_.length)return!0;var r=Object.getOwnPropertyDescriptor(t,t.length-1);if(r&&!r.get)return!0;for(var n=0;n<t.length;n++)if(!t.hasOwnProperty(n))return!0;return!1}D("ES5",{createES5Proxy_:function(e,r){var n=Array.isArray(e),a=function(e,r){if(e){for(var n=new Array(r.length),a=0;a<r.length;a++)Object.defineProperty(n,""+a,t(a,!0));return n}var o=v(r);delete o[u];for(var i=_(o),c=0;c<i.length;c++){var s=i[c];o[s]=t(s,e||!!o[s].enumerable)}return Object.create(Object.getPrototypeOf(r),o)}(n,e),o={type_:n?5:4,scope_:r?r.scope_:F(),modified_:!1,finalized_:!1,assigned_:{},parent_:r,base_:e,draft_:a,copy_:null,revoked_:!1,isManual_:!1};return Object.defineProperty(a,u,{value:o,writable:!0}),a},willFinalizeES5_:function(e,t,n){n?f(t)&&t[u].scope_===e&&r(e.drafts_):(e.patches_&&function e(t){if(t&&"object"==typeof t){var r=t[u];if(r){var n=r.base_,o=r.draft_,i=r.assigned_,c=r.type_;if(4===c)h(o,(function(t){t!==u&&(void 0!==n[t]||y(n,t)?i[t]||e(o[t]):(i[t]=!0,B(r)))})),h(n,(function(e){void 0!==o[e]||y(o,e)||(i[e]=!1,B(r))}));else if(5===c){if(a(r)&&(B(r),i.length=!0),o.length<n.length)for(var s=o.length;s<n.length;s++)i[s]=!1;else for(var f=n.length;f<o.length;f++)i[f]=!0;for(var l=Math.min(o.length,n.length),p=0;p<l;p++)o.hasOwnProperty(p)||(i[p]=!0),void 0===i[p]&&e(o[p])}}}}(e.drafts_[0]),r(e.drafts_))},hasChanges_:function(e){return 4===e.type_?n(e):a(e)}})}function Z(){var e=function(t,r){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(t,r)};function t(t,r){function n(){Object.defineProperty(this,"constructor",{value:t})}e(t,r),t.prototype=(n.prototype=r.prototype,new n)}var r=function(e){var r;function a(e,t){return this[u]={type_:2,parent_:t,scope_:t?t.scope_:F(),modified_:!1,finalized_:!1,copy_:void 0,assigned_:void 0,base_:e,draft_:this,isManual_:!1,revoked_:!1},this}return t(a,Map),Object.defineProperties(a.prototype,((r={size:{get:function(){return O(this[u]).size},configurable:!0},has:{configurable:!0,writable:!0,value:function(e){return O(this[u]).has(e)}},set:{configurable:!0,writable:!0,value:function(e,t){var r=this[u];return i(r),O(r).has(e)&&O(r).get(e)===t||(n(r),B(r),r.assigned_.set(e,!0),r.copy_.set(e,t),r.assigned_.set(e,!0)),this}},delete:{configurable:!0,writable:!0,value:function(e){if(!this.has(e))return!1;var t=this[u];return i(t),n(t),B(t),t.base_.has(e)?t.assigned_.set(e,!1):t.assigned_.delete(e),t.copy_.delete(e),!0}},clear:{configurable:!0,writable:!0,value:function(){var e=this[u];i(e),O(e).size&&(n(e),B(e),e.assigned_=new Map,h(e.base_,(function(t){e.assigned_.set(t,!1)})),e.copy_.clear())}},forEach:{configurable:!0,writable:!0,value:function(e,t){var r=this;O(this[u]).forEach((function(n,a,o){e.call(t,r.get(a),a,r)}))}},get:{configurable:!0,writable:!0,value:function(e){var t=this[u];i(t);var r=O(t).get(e);if(t.finalized_||!l(r))return r;if(r!==t.base_.get(e))return r;var a=Q(t.scope_.immer_,r,t);return n(t),t.copy_.set(e,a),a}},keys:{configurable:!0,writable:!0,value:function(){return O(this[u]).keys()}},values:{configurable:!0,writable:!0,value:function(){var e,t=this,r=this.keys();return(e={})[c]=function(){return t.values()},e.next=function(){var e=r.next();return e.done?e:{done:!1,value:t.get(e.value)}},e}},entries:{configurable:!0,writable:!0,value:function(){var e,t=this,r=this.keys();return(e={})[c]=function(){return t.entries()},e.next=function(){var e=r.next();if(e.done)return e;var n=t.get(e.value);return{done:!1,value:[e.value,n]}},e}}})[c]={configurable:!0,writable:!0,value:function(){return this.entries()}},r)),a}();function n(e){e.copy_||(e.assigned_=new Map,e.copy_=new Map(e.base_))}var a=function(e){var r;function n(e,t){return this[u]={type_:3,parent_:t,scope_:t?t.scope_:F(),modified_:!1,finalized_:!1,copy_:void 0,base_:e,draft_:this,drafts_:new Map,revoked_:!1,isManual_:!1},this}return t(n,Set),Object.defineProperties(n.prototype,((r={size:{get:function(){return O(this[u]).size},configurable:!0},has:{configurable:!0,writable:!0,value:function(e){var t=this[u];return i(t),t.copy_?!!t.copy_.has(e)||!(!t.drafts_.has(e)||!t.copy_.has(t.drafts_.get(e))):t.base_.has(e)}},add:{configurable:!0,writable:!0,value:function(e){var t=this[u];return i(t),this.has(e)||(o(t),B(t),t.copy_.add(e)),this}},delete:{configurable:!0,writable:!0,value:function(e){if(!this.has(e))return!1;var t=this[u];return i(t),o(t),B(t),t.copy_.delete(e)||!!t.drafts_.has(e)&&t.copy_.delete(t.drafts_.get(e))}},clear:{configurable:!0,writable:!0,value:function(){var e=this[u];i(e),O(e).size&&(o(e),B(e),e.copy_.clear())}},values:{configurable:!0,writable:!0,value:function(){var e=this[u];return i(e),o(e),e.copy_.values()}},entries:{configurable:!0,writable:!0,value:function(){var e=this[u];return i(e),o(e),e.copy_.entries()}},keys:{configurable:!0,writable:!0,value:function(){return this.values()}}})[c]={configurable:!0,writable:!0,value:function(){return this.values()}},r.forEach={configurable:!0,writable:!0,value:function(e,t){for(var r=this.values(),n=r.next();!n.done;)e.call(t,n.value,n.value,this),n=r.next()}},r)),n}();function o(e){e.copy_||(e.copy_=new Set,e.base_.forEach((function(t){if(l(t)){var r=Q(e.scope_.immer_,t,e);e.drafts_.set(t,r),e.copy_.add(r)}else e.copy_.add(t)})))}function i(e){e.revoked_&&s(3,JSON.stringify(O(e)))}D("MapSet",{proxyMap_:function(e,t){return new r(e,t)},proxySet_:function(e,t){return new a(e,t)}})}function ee(){var e="add";function t(e){if(!l(e))return e;if(Array.isArray(e))return e.map(t);if(P(e))return new Map(Array.from(e.entries()).map((function(e){return[e[0],t(e[1])]})));if(w(e))return new Set(Array.from(e).map(t));var r=Object.create(Object.getPrototypeOf(e));for(var n in e)r[n]=t(e[n]);return y(e,i)&&(r[i]=e[i]),r}function r(e){return f(e)?t(e):e}D("Patches",{applyPatches_:function(r,n){return n.forEach((function(n){for(var a=n.path,o=n.op,i=r,u=0;u<a.length-1;u++){var c=d(i),f=""+a[u];0!==c&&1!==c||"__proto__"!==f&&"constructor"!==f||s(24),"function"==typeof i&&"prototype"===f&&s(24),"object"!=typeof(i=b(i,f))&&s(15,a.join("/"))}var l=d(i),p=t(n.value),_=a[a.length-1];switch(o){case"replace":switch(l){case 2:return i.set(_,p);case 3:s(16);default:return i[_]=p}case e:switch(l){case 1:return"-"===_?i.push(p):i.splice(_,0,p);case 2:return i.set(_,p);case 3:return i.add(p);default:return i[_]=p}case"remove":switch(l){case 1:return i.splice(_,1);case 2:return i.delete(_);case 3:return i.delete(n.value);default:return delete i[_]}default:s(17,o)}})),r},generatePatches_:function(t,n,a,o){switch(t.type_){case 0:case 4:case 2:return function(t,n,a,o){var i=t.base_,u=t.copy_;h(t.assigned_,(function(t,c){var s=b(i,t),f=b(u,t),l=c?y(i,t)?"replace":e:"remove";if(s!==f||"replace"!==l){var p=n.concat(t);a.push("remove"===l?{op:l,path:p}:{op:l,path:p,value:f}),o.push(l===e?{op:"remove",path:p}:"remove"===l?{op:e,path:p,value:r(s)}:{op:"replace",path:p,value:r(s)})}}))}(t,n,a,o);case 5:case 1:return function(t,n,a,o){var i=t.base_,u=t.assigned_,c=t.copy_;if(c.length<i.length){var s=[c,i];i=s[0],c=s[1];var f=[o,a];a=f[0],o=f[1]}for(var l=0;l<i.length;l++)if(u[l]&&c[l]!==i[l]){var p=n.concat([l]);a.push({op:"replace",path:p,value:r(c[l])}),o.push({op:"replace",path:p,value:r(i[l])})}for(var _=i.length;_<c.length;_++){var v=n.concat([_]);a.push({op:e,path:v,value:r(c[_])})}i.length<c.length&&o.push({op:"replace",path:n.concat(["length"]),value:i.length})}(t,n,a,o);case 3:return function(t,r,n,a){var o=t.base_,i=t.copy_,u=0;o.forEach((function(t){if(!i.has(t)){var o=r.concat([u]);n.push({op:"remove",path:o,value:t}),a.unshift({op:e,path:o,value:t})}u++})),u=0,i.forEach((function(t){if(!o.has(t)){var i=r.concat([u]);n.push({op:e,path:i,value:t}),a.unshift({op:"remove",path:i,value:t})}u++}))}(t,n,a,o)}},generateReplacementPatches_:function(e,t,r,n){r.push({op:"replace",path:[],value:t===o?void 0:t}),n.push({op:"replace",path:[],value:e})}})}var te=new H,re=te.produce,ne=te.produceWithPatches.bind(te),ae=te.setAutoFreeze.bind(te),oe=te.setUseProxies.bind(te),ie=te.applyPatches.bind(te),ue=te.createDraft.bind(te),ce=te.finishDraft.bind(te);exports.Immer=H,exports.applyPatches=ie,exports.castDraft=function(e){return e},exports.castImmutable=function(e){return e},exports.createDraft=ue,exports.current=T,exports.default=re,exports.enableAllPlugins=function(){Y(),Z(),ee()},exports.enableES5=Y,exports.enableMapSet=Z,exports.enablePatches=ee,exports.finishDraft=ce,exports.freeze=j,exports.immerable=i,exports.isDraft=f,exports.isDraftable=l,exports.nothing=o,exports.original=function(e){return f(e)||s(23,e),e[u].base_},exports.produce=re,exports.produceWithPatches=ne,exports.setAutoFreeze=ae,exports.setUseProxies=oe;
 //# sourceMappingURL=immer.cjs.production.min.js.map
diff --git a/dist/immer.cjs.production.min.js.map b/dist/immer.cjs.production.min.js.map
index 07125d59799eb075e88b393c0a9f9e74f65d93d7..68b3a079db90209fbc103ac1ce0ad15aae91b3d9 100644
--- a/dist/immer.cjs.production.min.js.map
+++ b/dist/immer.cjs.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"immer.cjs.production.min.js","sources":["../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/patches.ts","../src/plugins/mapset.ts","../src/utils/env.ts","../src/immer.ts","../src/plugins/all.ts"],"sourcesContent":["const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\tbase: any,\n\t\trecipe?: any,\n\t): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tthis.constructor = d\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: false,\n\t\t\t// configurable: true\n\t\t})\n\n\t\tp.has = function(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tp.set = function(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.forEach = function(\n\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\tthisArg?: any\n\t\t) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tp.get = function(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp.entries = function(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.entries()\n\t\t}\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: true,\n\t\t})\n\n\t\tp.has = function(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tp.add = function(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tp.entries = function entries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp.forEach = function forEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n"],"names":["die","error","args","Error","length","map","s","join","isDraft","value","DRAFT_STATE","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","toString","objectCtorString","Array","isArray","DRAFTABLE","_value$constructor","isMap","isSet","each","obj","iter","enumerableOnly","getArchtype","keys","ownKeys","forEach","key","entry","index","thing","state","type_","has","prop","prototype","get","set","propOrOldValue","t","delete","add","is","x","y","target","hasMap","Map","hasSet","Set","latest","copy_","base_","shallowCopy","base","slice","descriptors","getOwnPropertyDescriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","loadPlugin","implementation","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","push","current","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","proxyProperty","this","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","defineProperty","markChangesRecursively","object","min","Math","enablePatches","deepClonePatchValue","entries","cloned","immerable","clonePatchValueIfNeeded","ADD","applyPatches_","patches","patch","op","parentType","p","type","splice","basePath","inversePatches","assignedValue","origValue","unshift","replacement","enableMapSet","__extends","d","b","__","extendStatics","prepareMapCopy","prepareSetCopy","assertUnrevoked","JSON","stringify","setPrototypeOf","__proto__","DraftMap","size","cb","thisArg","_value","_this","values","iterator","iteratorSymbol","_this2","next","r","done","_this3","DraftSet","hasSymbol","Symbol","hasProxies","Reflect","for","getOwnPropertySymbols","getOwnPropertyNames","_desc$get","currentState","deleteProperty","owner","fn","arguments","apply","Immer","config","recipe","defaultBase","self","produce","hasError","Promise","then","ip","produceWithPatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","applyPatchesImpl","bind"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"immer.cjs.production.min.js","sources":["../src/utils/env.ts","../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/mapset.ts","../src/plugins/patches.ts","../src/immer.ts","../src/plugins/all.ts"],"sourcesContent":["// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import { DRAFT_STATE, DRAFTABLE, hasSet, Objectish, Drafted, AnyObject, AnyMap, AnySet, ImmerState, hasMap, Archtype, die } from \"../internal.js\";\r\n\n /** Returns true if the given value is an Immer draft */\r\n/*#__PURE__*/\r\nexport function isDraft(value: any): boolean {\r\n    return !!value && !!value[DRAFT_STATE];\r\n}\r\n\n /** Returns true if the given value can be drafted by Immer */\r\n/*#__PURE__*/\r\nexport function isDraftable(value: any): boolean {\r\n    if (!value)\r\n        return false;\r\n    return (isPlainObject(value) ||\r\n        Array.isArray(value) ||\r\n        !!value[DRAFTABLE] ||\r\n        !!value.constructor?.[DRAFTABLE] ||\r\n        isMap(value) ||\r\n        isSet(value));\r\n}\r\n\n const objectCtorString = Object.prototype.constructor.toString();\r\n/*#__PURE__*/\r\nexport function isPlainObject(value: any): boolean {\r\n    if (!value || typeof value !== \"object\")\r\n        return false;\r\n    const proto = Object.getPrototypeOf(value);\r\n    if (proto === null) {\r\n        return true;\r\n    }\r\n    const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\r\n    \n if (Ctor === Object)\r\n        return true;\r\n    \n return (typeof Ctor == \"function\" &&\r\n        Function.toString.call(Ctor) === objectCtorString);\r\n}\r\n\n /** Get the underlying object that is represented by the given draft */\r\n/*#__PURE__*/\r\nexport function original<T>(value: T): T | undefined;\r\nexport function original(value: Drafted<any>): any {\r\n    if (!isDraft(value))\r\n        die(23, value);\r\n    return value[DRAFT_STATE].base_;\r\n}\r\n\n /*#__PURE__*/\r\nexport const ownKeys: (target: AnyObject) => PropertyKey[] = typeof Reflect !== \"undefined\" && Reflect.ownKeys\r\n    ? Reflect.ownKeys\r\n    : typeof Object.getOwnPropertySymbols !== \"undefined\"\r\n        ? obj => Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj) as any)\r\n        : /* istanbul ignore next */ Object.getOwnPropertyNames;\r\n\n export const getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\r\n    function getOwnPropertyDescriptors(target: any) {\r\n        // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\r\n        const res: any = {};\r\n        ownKeys(target).forEach(key => {\r\n            res[key] = Object.getOwnPropertyDescriptor(target, key);\r\n        });\r\n        return res;\r\n    };\r\n\n export function each<T extends Objectish>(obj: T, iter: (key: string | number, value: any, source: T) => void, enumerableOnly?: boolean): void;\r\nexport function each(obj: any, iter: any, enumerableOnly = false) {\r\n    if (getArchtype(obj) === Archtype.Object) {\r\n        ;\r\n        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\r\n            if (!enumerableOnly || typeof key !== \"symbol\")\r\n                iter(key, obj[key], obj);\r\n        });\r\n    }\r\n    else {\r\n        obj.forEach((entry: any, index: any) => iter(index, entry, obj));\r\n    }\r\n}\r\n\n /*#__PURE__*/\r\nexport function getArchtype(thing: any): Archtype {\r\n    /* istanbul ignore next */\r\n    const state: undefined | ImmerState = thing[DRAFT_STATE];\r\n    return state\r\n        ? state.type_ > 3\r\n            ? state.type_ - 4 // cause Object and Array map back from 4 and 5\r\n            : (state.type_ as any) // others are the same\r\n        : Array.isArray(thing)\r\n            ? Archtype.Array\r\n            : isMap(thing)\r\n                ? Archtype.Map\r\n                : isSet(thing)\r\n                    ? Archtype.Set\r\n                    : Archtype.Object;\r\n}\r\n\n /*#__PURE__*/\r\nexport function has(thing: any, prop: PropertyKey): boolean {\r\n    return getArchtype(thing) === Archtype.Map\r\n        ? thing.has(prop)\r\n        : Object.prototype.hasOwnProperty.call(thing, prop);\r\n}\r\n\n /*#__PURE__*/\r\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\r\n    // @ts-ignore\r\n    return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop];\r\n}\r\n\n /*#__PURE__*/\r\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\r\n    const t = getArchtype(thing);\r\n    if (t === Archtype.Map)\r\n        thing.set(propOrOldValue, value);\r\n    else if (t === Archtype.Set) {\r\n        thing.delete(propOrOldValue);\r\n        thing.add(value);\r\n    }\r\n    else\r\n        thing[propOrOldValue] = value;\r\n}\r\n\n /*#__PURE__*/\r\nexport function is(x: any, y: any): boolean {\r\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\r\n    if (x === y) {\r\n        return x !== 0 || 1 / x === 1 / y;\r\n    }\r\n    else {\r\n        return x !== x && y !== y;\r\n    }\r\n}\r\n\n /*#__PURE__*/\r\nexport function isMap(target: any): target is AnyMap {\r\n    return hasMap && target instanceof Map;\r\n}\r\n\n /*#__PURE__*/\r\nexport function isSet(target: any): target is AnySet {\r\n    return hasSet && target instanceof Set;\r\n}\r\n/*#__PURE__*/\r\nexport function latest(state: ImmerState): any {\r\n    return state.copy_ || state.base_;\r\n}\r\n\n /*#__PURE__*/\r\nexport function shallowCopy(base: any) {\r\n    if (Array.isArray(base))\r\n        return Array.prototype.slice.call(base);\r\n    const descriptors = getOwnPropertyDescriptors(base);\r\n    delete descriptors[DRAFT_STATE as any];\r\n    let keys = ownKeys(descriptors);\r\n    for (let i = 0; i < keys.length; i++) {\r\n        const key: any = keys[i];\r\n        const desc = descriptors[key];\r\n        if (desc.writable === false) {\r\n            desc.writable = true;\r\n            desc.configurable = true;\r\n        }\r\n        // like object.assign, we will read any _own_, get/set accessors. This helps in dealing\r\n        // with libraries that trap values, like mobx or vue\r\n        // unlike object.assign, non-enumerables will be copied as well\r\n        if (desc.get || desc.set)\r\n            descriptors[key] = {\r\n                configurable: true,\r\n                writable: true,\r\n                enumerable: desc.enumerable,\r\n                value: base[key]\r\n            };\r\n    }\r\n    return Object.create(Object.getPrototypeOf(base), descriptors);\r\n}\r\n\n /**\r\n * Freezes draftable objects. Returns the original object.\r\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\r\n *\r\n * @param obj\r\n * @param deep\r\n */\r\nexport function freeze<T>(obj: T, deep?: boolean): T;\r\nexport function freeze<T>(obj: any, deep: boolean = false): T {\r\n    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))\r\n        return obj;\r\n    if (getArchtype(obj) > 1 /* Map or Set */) {\r\n        const desc: PropertyDescriptor = {\r\n            configurable: true,\r\n            writable: true,\r\n            value: dontMutateFrozenCollections\r\n        };\r\n        Object.defineProperties(obj, {\r\n            set: desc,\r\n            add: desc,\r\n            clear: desc,\r\n            delete: desc\r\n        });\r\n    }\r\n    Object.freeze(obj);\r\n    if (deep)\r\n        each(obj, (key, value) => freeze(value, true), true);\r\n    return obj;\r\n}\r\n\n function dontMutateFrozenCollections() {\r\n    die(2);\r\n}\r\n\n export function isFrozen(obj: any): boolean {\r\n    if (obj == null || typeof obj !== \"object\")\r\n        return true;\r\n    // See #600, IE dies on non-objects in Object.isFrozen\r\n    return Object.isFrozen(obj);\r\n}\r\n","import { ImmerState, Patch, ImmerScope, Drafted, AnyObject, ImmerBaseState, AnyMap, AnySet, ProxyType, die } from \"../internal.js\";\r\n\n /** Plugin utilities */\r\nconst plugins: {\r\n    Patches?: {\r\n        generatePatches_(state: ImmerState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]): void;\r\n        generateReplacementPatches_(base: any, replacement: any, patches: Patch[], inversePatches: Patch[]): void;\r\n        applyPatches_<T>(draft: T, patches: Patch[]): T;\r\n    };\r\n    ES5?: {\r\n        willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void;\r\n        createES5Proxy_<T>(base: T, parent?: ImmerState): Drafted<T, ES5ObjectState | ES5ArrayState>;\r\n        hasChanges_(state: ES5ArrayState | ES5ObjectState): boolean;\r\n    };\r\n    MapSet?: {\r\n        proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T;\r\n        proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T;\r\n    };\r\n} = {};\r\n\n type Plugins = typeof plugins;\r\n\n export function getPlugin<K extends keyof Plugins>(pluginKey: K): Exclude<Plugins[K], undefined> {\r\n    const plugin = plugins[pluginKey];\r\n    if (!plugin) {\r\n        die(18, pluginKey);\r\n    }\r\n    // @ts-ignore\r\n    return plugin;\r\n}\r\n\n export function loadPlugin<K extends keyof Plugins>(pluginKey: K, implementation: Plugins[K]): void {\r\n    if (!plugins[pluginKey])\r\n        plugins[pluginKey] = implementation;\r\n}\r\n\n /** ES5 Plugin */\r\n\n interface ES5BaseState extends ImmerBaseState {\r\n    assigned_: {\r\n        [key: string]: any;\r\n    };\r\n    parent_?: ImmerState;\r\n    revoked_: boolean;\r\n}\r\n\n export interface ES5ObjectState extends ES5BaseState {\r\n    type_: ProxyType.ES5Object;\r\n    draft_: Drafted<AnyObject, ES5ObjectState>;\r\n    base_: AnyObject;\r\n    copy_: AnyObject | null;\r\n}\r\n\n export interface ES5ArrayState extends ES5BaseState {\r\n    type_: ProxyType.ES5Array;\r\n    draft_: Drafted<AnyObject, ES5ArrayState>;\r\n    base_: any;\r\n    copy_: any;\r\n}\r\n\n /** Map / Set plugin */\r\n\n export interface MapState extends ImmerBaseState {\r\n    type_: ProxyType.Map;\r\n    copy_: AnyMap | undefined;\r\n    assigned_: Map<any, boolean> | undefined;\r\n    base_: AnyMap;\r\n    revoked_: boolean;\r\n    draft_: Drafted<AnyMap, MapState>;\r\n}\r\n\n export interface SetState extends ImmerBaseState {\r\n    type_: ProxyType.Set;\r\n    copy_: AnySet | undefined;\r\n    base_: AnySet;\r\n    drafts_: Map<any, Drafted>; // maps the original value to the draft value in the new set\r\n    revoked_: boolean;\r\n    draft_: Drafted<AnySet, SetState>;\r\n}\r\n\n /** Patches plugin */\r\n\n export type PatchPath = (string | number)[];\r\n","import { Patch, PatchListener, Drafted, Immer, DRAFT_STATE, ImmerState, ProxyType, getPlugin } from \"../internal.js\";\r\nimport { die } from \"../utils/errors.js\";\r\n\n /** Each scope represents a `produce` call. */\r\n\n export interface ImmerScope {\r\n    patches_?: Patch[];\r\n    inversePatches_?: Patch[];\r\n    canAutoFreeze_: boolean;\r\n    drafts_: any[];\r\n    parent_?: ImmerScope;\r\n    patchListener_?: PatchListener;\r\n    immer_: Immer;\r\n    unfinalizedDrafts_: number;\r\n}\r\n\n let currentScope: ImmerScope | undefined;\r\n\n export function getCurrentScope() {\r\n    if (__DEV__ && !currentScope)\r\n        die(0);\r\n    return currentScope!;\r\n}\r\n\n function createScope(parent_: ImmerScope | undefined, immer_: Immer): ImmerScope {\r\n    return {\r\n        drafts_: [],\r\n        parent_,\r\n        immer_,\r\n        // Whenever the modified draft contains a draft from another scope, we\r\n        // need to prevent auto-freezing so the unowned draft can be finalized.\r\n        canAutoFreeze_: true,\r\n        unfinalizedDrafts_: 0\r\n    };\r\n}\r\n\n export function usePatchesInScope(scope: ImmerScope, patchListener?: PatchListener) {\r\n    if (patchListener) {\r\n        getPlugin(\"Patches\"); // assert we have the plugin\r\n        scope.patches_ = [];\r\n        scope.inversePatches_ = [];\r\n        scope.patchListener_ = patchListener;\r\n    }\r\n}\r\n\n export function revokeScope(scope: ImmerScope) {\r\n    leaveScope(scope);\r\n    scope.drafts_.forEach(revokeDraft);\r\n    // @ts-ignore\r\n    scope.drafts_ = null;\r\n}\r\n\n export function leaveScope(scope: ImmerScope) {\r\n    if (scope === currentScope) {\r\n        currentScope = scope.parent_;\r\n    }\r\n}\r\n\n export function enterScope(immer: Immer) {\r\n    return (currentScope = createScope(currentScope, immer));\r\n}\r\n\n function revokeDraft(draft: Drafted) {\r\n    const state: ImmerState = draft[DRAFT_STATE];\r\n    if (state.type_ === ProxyType.ProxyObject ||\r\n        state.type_ === ProxyType.ProxyArray)\r\n        state.revoke_();\r\n    else\r\n        state.revoked_ = true;\r\n}\r\n","import { ImmerScope, DRAFT_STATE, isDraftable, NOTHING, PatchPath, each, has, freeze, ImmerState, isDraft, SetState, set, ProxyType, getPlugin, die, revokeScope, isFrozen, shallowCopy } from \"../internal.js\";\r\n\n export function processResult(result: any, scope: ImmerScope) {\r\n    scope.unfinalizedDrafts_ = scope.drafts_.length;\r\n    const baseDraft = scope.drafts_![0];\r\n    const isReplaced = result !== undefined && result !== baseDraft;\r\n    if (!scope.immer_.useProxies_)\r\n        getPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced);\r\n    if (isReplaced) {\r\n        if (baseDraft[DRAFT_STATE].modified_) {\r\n            revokeScope(scope);\r\n            die(4);\r\n        }\r\n        if (isDraftable(result)) {\r\n            // Finalize the result in case it contains (or is) a subset of the draft.\r\n            result = finalize(scope, result);\r\n            if (!scope.parent_)\r\n                maybeFreeze(scope, result);\r\n        }\r\n        if (scope.patches_) {\r\n            getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_!);\r\n        }\r\n    }\r\n    else {\r\n        // Finalize the base draft.\r\n        result = finalize(scope, baseDraft, []);\r\n    }\r\n    revokeScope(scope);\r\n    if (scope.patches_) {\r\n        scope.patchListener_!(scope.patches_, scope.inversePatches_!);\r\n    }\r\n    return result !== NOTHING ? result : undefined;\r\n}\r\n\n function finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\r\n    // Don't recurse in tho recursive data structures\r\n    if (isFrozen(value))\r\n        return value;\r\n    \n const state: ImmerState = value[DRAFT_STATE];\r\n    // A plain object, might need freezing, might contain drafts\r\n    if (!state) {\r\n        each(value, (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path), true // See #590, don't recurse into non-enumerable of non drafted objects\r\n        );\r\n        return value;\r\n    }\r\n    // Never finalize drafts owned by another scope.\r\n    if (state.scope_ !== rootScope)\r\n        return value;\r\n    // Unmodified draft, return the (frozen) original\r\n    if (!state.modified_) {\r\n        maybeFreeze(rootScope, state.base_, true);\r\n        return state.base_;\r\n    }\r\n    // Not finalized yet, let's do that now\r\n    if (!state.finalized_) {\r\n        state.finalized_ = true;\r\n        state.scope_.unfinalizedDrafts_--;\r\n        const result = \r\n        // For ES5, create a good copy from the draft first, with added keys and without deleted keys.\r\n        state.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\r\n            ? (state.copy_ = shallowCopy(state.draft_))\r\n            : state.copy_;\r\n        // Finalize all children of the copy\r\n        // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\r\n        // Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\r\n        // back to each(result, ....)\r\n        each(state.type_ === ProxyType.Set ? new Set(result) : result, (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path));\r\n        // everything inside is frozen, we can freeze here\r\n        maybeFreeze(rootScope, result, false);\r\n        // first time finalizing, let's create those patches\r\n        if (path && rootScope.patches_) {\r\n            getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_!);\r\n        }\r\n    }\r\n    return state.copy_;\r\n}\r\n\n function finalizeProperty(rootScope: ImmerScope, parentState: undefined | ImmerState, targetObject: any, prop: string | number, childValue: any, rootPath?: PatchPath) {\r\n    if (__DEV__ && childValue === targetObject)\r\n        die(5);\r\n    if (isDraft(childValue)) {\r\n        const path = rootPath &&\r\n            parentState &&\r\n            parentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\r\n            !has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\r\n            ? rootPath!.concat(prop)\r\n            : undefined;\r\n        // Drafts owned by `scope` are finalized here.\r\n        const res = finalize(rootScope, childValue, path);\r\n        set(targetObject, prop, res);\r\n        // Drafts from another scope must prevented to be frozen\r\n        // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\r\n        if (isDraft(res)) {\r\n            rootScope.canAutoFreeze_ = false;\r\n        }\r\n        else\r\n            return;\r\n    }\r\n    // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\r\n    if (isDraftable(childValue) && !isFrozen(childValue)) {\r\n        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\r\n            // optimization: if an object is not a draft, and we don't have to\r\n            // deepfreeze everything, and we are sure that no drafts are left in the remaining object\r\n            // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\r\n            // This benefits especially adding large data tree's without further processing.\r\n            // See add-data.js perf test\r\n            return;\r\n        }\r\n        finalize(rootScope, childValue);\r\n        // immer deep freezes plain objects, so if there is no parent state, we freeze as well\r\n        if (!parentState || !parentState.scope_.parent_)\r\n            maybeFreeze(rootScope, childValue);\r\n    }\r\n}\r\n\n function maybeFreeze(scope: ImmerScope, value: any, deep = false) {\r\n    if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\r\n        freeze(value, deep);\r\n    }\r\n}\r\n","import { each, has, is, isDraftable, shallowCopy, latest, ImmerBaseState, ImmerState, Drafted, AnyObject, AnyArray, Objectish, getCurrentScope, DRAFT_STATE, die, createProxy, ProxyType } from \"../internal.js\";\r\n\n interface ProxyBaseState extends ImmerBaseState {\r\n    assigned_: {\r\n        [property: string]: boolean;\r\n    };\r\n    parent_?: ImmerState;\r\n    revoke_(): void;\r\n}\r\n\n export interface ProxyObjectState extends ProxyBaseState {\r\n    type_: ProxyType.ProxyObject;\r\n    base_: any;\r\n    copy_: any;\r\n    draft_: Drafted<AnyObject, ProxyObjectState>;\r\n}\r\n\n export interface ProxyArrayState extends ProxyBaseState {\r\n    type_: ProxyType.ProxyArray;\r\n    base_: AnyArray;\r\n    copy_: AnyArray | null;\r\n    draft_: Drafted<AnyArray, ProxyArrayState>;\r\n}\r\n\n type ProxyState = ProxyObjectState | ProxyArrayState;\r\n\n /**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */\r\nexport function createProxyProxy<T extends Objectish>(base: T, parent?: ImmerState): Drafted<T, ProxyState> {\r\n    const isArray = Array.isArray(base);\r\n    const state: ProxyState = {\r\n        type_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\r\n        // Track which produce call this is associated with.\r\n        scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n        // True for both shallow and deep changes.\r\n        modified_: false,\r\n        // Used during finalization.\r\n        finalized_: false,\r\n        // Track which properties have been assigned (true) or deleted (false).\r\n        assigned_: {},\r\n        // The parent draft state.\r\n        parent_: parent,\r\n        // The base state.\r\n        base_: base,\r\n        // The base proxy.\r\n        draft_: null as any,\r\n        // The base copy with any updated values.\r\n        copy_: null,\r\n        // Called by the `produce` function.\r\n        revoke_: null as any,\r\n        isManual_: false\r\n    };\r\n    \n // the traps must target something, a bit like the 'real' base.\r\n    // but also, we need to be able to determine from the target what the relevant state is\r\n    // (to avoid creating traps per instance to capture the state in closure,\r\n    // and to avoid creating weird hidden properties as well)\r\n    // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\r\n    // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\r\n    let target: T = state as any;\r\n    let traps: ProxyHandler<object | Array<any>> = objectTraps;\r\n    if (isArray) {\r\n        target = [state] as any;\r\n        traps = arrayTraps;\r\n    }\r\n    \n const { revoke, proxy } = Proxy.revocable(target, traps);\r\n    state.draft_ = proxy as any;\r\n    state.revoke_ = revoke;\r\n    return proxy as any;\r\n}\r\n\n /**\r\n * Object drafts\r\n */\r\nexport const objectTraps: ProxyHandler<ProxyState> = {\r\n    get(state, prop) {\r\n        if (prop === DRAFT_STATE)\r\n            return state;\r\n        \n const source = latest(state);\r\n        if (!has(source, prop)) {\r\n            // non-existing or non-own property...\r\n            return readPropFromProto(state, source, prop);\r\n        }\r\n        const value = source[prop];\r\n        if (state.finalized_ || !isDraftable(value)) {\r\n            return value;\r\n        }\r\n        // Check for existing draft in modified state.\r\n        // Assigned values are never drafted. This catches any drafts we created, too.\r\n        if (value === peek(state.base_, prop)) {\r\n            prepareCopy(state);\r\n            return (state.copy_![prop as any] = createProxy(state.scope_.immer_, value, state));\r\n        }\r\n        return value;\r\n    },\r\n    has(state, prop) {\r\n        return prop in latest(state);\r\n    },\r\n    ownKeys(state) {\r\n        return Reflect.ownKeys(latest(state));\r\n    },\r\n    set(state: ProxyObjectState, prop: string /* strictly not, but helps TS */, value) {\r\n        const desc = getDescriptorFromProto(latest(state), prop);\r\n        if (desc?.set) {\r\n            // special case: if this write is captured by a setter, we have\r\n            // to trigger it with the correct context\r\n            desc.set.call(state.draft_, value);\r\n            return true;\r\n        }\r\n        if (!state.modified_) {\r\n            // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\r\n            // from setting an existing property with value undefined to undefined (which is not a change)\r\n            const current = peek(latest(state), prop);\r\n            // special case, if we assigning the original value to a draft, we can ignore the assignment\r\n            const currentState: ProxyObjectState = current?.[DRAFT_STATE];\r\n            if (currentState && currentState.base_ === value) {\r\n                state.copy_![prop] = value;\r\n                state.assigned_[prop] = false;\r\n                return true;\r\n            }\r\n            if (is(value, current) && (value !== undefined || has(state.base_, prop)))\r\n                return true;\r\n            prepareCopy(state);\r\n            markChanged(state);\r\n        }\r\n        \n if ((state.copy_![prop] === value &&\r\n            // special case: handle new props with value 'undefined'\r\n            (value !== undefined || prop in state.copy_)) ||\r\n            // special case: NaN\r\n            (Number.isNaN(value) && Number.isNaN(state.copy_![prop])))\r\n            return true;\r\n        \n // @ts-ignore\r\n        state.copy_![prop] = value;\r\n        state.assigned_[prop] = true;\r\n        return true;\r\n    },\r\n    deleteProperty(state, prop: string) {\r\n        // The `undefined` check is a fast path for pre-existing keys.\r\n        if (peek(state.base_, prop) !== undefined || prop in state.base_) {\r\n            state.assigned_[prop] = false;\r\n            prepareCopy(state);\r\n            markChanged(state);\r\n        }\r\n        else {\r\n            // if an originally not assigned property was deleted\r\n            delete state.assigned_[prop];\r\n        }\r\n        // @ts-ignore\r\n        if (state.copy_)\r\n            delete state.copy_[prop];\r\n        return true;\r\n    },\r\n    // Note: We never coerce `desc.value` into an Immer draft, because we can't make\r\n    // the same guarantee in ES5 mode.\r\n    getOwnPropertyDescriptor(state, prop) {\r\n        const owner = latest(state);\r\n        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\r\n        if (!desc)\r\n            return desc;\r\n        return {\r\n            writable: true,\r\n            configurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\r\n            enumerable: desc.enumerable,\r\n            value: owner[prop]\r\n        };\r\n    },\r\n    defineProperty() {\r\n        die(11);\r\n    },\r\n    getPrototypeOf(state) {\r\n        return Object.getPrototypeOf(state.base_);\r\n    },\r\n    setPrototypeOf() {\r\n        die(12);\r\n    }\r\n};\r\n\n /**\r\n * Array drafts\r\n */\r\n\n const arrayTraps: ProxyHandler<[\r\n    ProxyArrayState\r\n]> = {};\r\neach(objectTraps, (key, fn) => {\r\n    // @ts-ignore\r\n    arrayTraps[key] = function () {\r\n        arguments[0] = arguments[0][0];\r\n        return fn.apply(this, arguments);\r\n    };\r\n});\r\narrayTraps.deleteProperty = function (state, prop) {\r\n    if (__DEV__ && isNaN(parseInt(prop as any)))\r\n        die(13);\r\n    // @ts-ignore\r\n    return arrayTraps.set!.call(this, state, prop, undefined);\r\n};\r\narrayTraps.set = function (state, prop, value) {\r\n    if (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any)))\r\n        die(14);\r\n    return objectTraps.set!.call(this, state[0], prop, value, state[0]);\r\n};\r\n\n // Access a property without creating an Immer draft.\r\nfunction peek(draft: Drafted, prop: PropertyKey) {\r\n    const state = draft[DRAFT_STATE];\r\n    const source = state ? latest(state) : draft;\r\n    return source[prop];\r\n}\r\n\n function readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\r\n    const desc = getDescriptorFromProto(source, prop);\r\n    return desc\r\n        ? `value` in desc\r\n            ? desc.value\r\n            : // This is a very special case, if the prop is a getter defined by the\r\n                // prototype, we should invoke it with the draft as context!\r\n                desc.get?.call(state.draft_)\r\n        : undefined;\r\n}\r\n\n function getDescriptorFromProto(source: any, prop: PropertyKey): PropertyDescriptor | undefined {\r\n    // 'in' checks proto!\r\n    if (!(prop in source))\r\n        return undefined;\r\n    let proto = Object.getPrototypeOf(source);\r\n    while (proto) {\r\n        const desc = Object.getOwnPropertyDescriptor(proto, prop);\r\n        if (desc)\r\n            return desc;\r\n        proto = Object.getPrototypeOf(proto);\r\n    }\r\n    return undefined;\r\n}\r\n\n export function markChanged(state: ImmerState) {\r\n    if (!state.modified_) {\r\n        state.modified_ = true;\r\n        if (state.parent_) {\r\n            markChanged(state.parent_);\r\n        }\r\n    }\r\n}\r\n\n export function prepareCopy(state: {\r\n    base_: any;\r\n    copy_: any;\r\n}) {\r\n    if (!state.copy_) {\r\n        state.copy_ = shallowCopy(state.base_);\r\n    }\r\n}\r\n","import { IProduceWithPatches, IProduce, ImmerState, Drafted, isDraftable, processResult, Patch, Objectish, DRAFT_STATE, Draft, PatchListener, isDraft, isMap, isSet, createProxyProxy, getPlugin, die, hasProxies, enterScope, revokeScope, leaveScope, usePatchesInScope, getCurrentScope, NOTHING, freeze, current } from \"../internal.js\";\r\n\n interface ProducersFns {\r\n    produce: IProduce;\r\n    produceWithPatches: IProduceWithPatches;\r\n}\r\n\n export class Immer implements ProducersFns {\r\n    useProxies_: boolean = hasProxies;\r\n    \n autoFreeze_: boolean = true;\r\n    \n constructor(config?: {\r\n        useProxies?: boolean;\r\n        autoFreeze?: boolean;\r\n    }) {\r\n        if (typeof config?.useProxies === \"boolean\")\r\n            this.setUseProxies(config!.useProxies);\r\n        if (typeof config?.autoFreeze === \"boolean\")\r\n            this.setAutoFreeze(config!.autoFreeze);\r\n    }\r\n    \n /**\r\n         * The `produce` function takes a value and a \"recipe function\" (whose\r\n         * return value often depends on the base state). The recipe function is\r\n         * free to mutate its first argument however it wants. All mutations are\r\n         * only ever applied to a __copy__ of the base state.\r\n         *\r\n         * Pass only a function to create a \"curried producer\" which relieves you\r\n         * from passing the recipe function every time.\r\n         *\r\n         * Only plain objects and arrays are made mutable. All other objects are\r\n         * considered uncopyable.\r\n         *\r\n         * Note: This function is __bound__ to its `Immer` instance.\r\n         *\r\n         * @param {any} base - the initial state\r\n         * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n         * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n         * @returns {any} a new state, or the initial state if nothing was modified\r\n         */\r\n    produce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\r\n        // curried invocation\r\n        if (typeof base === \"function\" && typeof recipe !== \"function\") {\r\n            const defaultBase = recipe;\r\n            recipe = base;\r\n            \n const self = this;\r\n            return function curriedProduce(this: any, base = defaultBase, ...args: any[]) {\r\n                return self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)); // prettier-ignore\r\n            };\r\n        }\r\n        \n if (typeof recipe !== \"function\")\r\n            die(6);\r\n        if (patchListener !== undefined && typeof patchListener !== \"function\")\r\n            die(7);\r\n        \n let result;\r\n        \n // Only plain objects, arrays, and \"immerable classes\" are drafted.\r\n        if (isDraftable(base)) {\r\n            const scope = enterScope(this);\r\n            const proxy = createProxy(this, base, undefined);\r\n            let hasError = true;\r\n            try {\r\n                result = recipe(proxy);\r\n                hasError = false;\r\n            }\r\n            finally {\r\n                // finally instead of catch + rethrow better preserves original stack\r\n                if (hasError)\r\n                    revokeScope(scope);\r\n                else\r\n                    leaveScope(scope);\r\n            }\r\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n                return result.then(result => {\r\n                    usePatchesInScope(scope, patchListener);\r\n                    return processResult(result, scope);\r\n                }, error => {\r\n                    revokeScope(scope);\r\n                    throw error;\r\n                });\r\n            }\r\n            usePatchesInScope(scope, patchListener);\r\n            return processResult(result, scope);\r\n        }\r\n        else if (!base || typeof base !== \"object\") {\r\n            result = recipe(base);\r\n            if (result === undefined)\r\n                result = base;\r\n            if (result === NOTHING)\r\n                result = undefined;\r\n            if (this.autoFreeze_)\r\n                freeze(result, true);\r\n            if (patchListener) {\r\n                const p: Patch[] = [];\r\n                const ip: Patch[] = [];\r\n                getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\r\n                patchListener(p, ip);\r\n            }\r\n            return result;\r\n        }\r\n        else\r\n            die(21, base);\r\n    };\r\n    \n produceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\r\n        // curried invocation\r\n        if (typeof base === \"function\") {\r\n            return (state: any, ...args: any[]) => this.produceWithPatches(state, (draft: any) => base(draft, ...args));\r\n        }\r\n        \n let patches: Patch[], inversePatches: Patch[];\r\n        const result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\r\n            patches = p;\r\n            inversePatches = ip;\r\n        });\r\n        \n if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n            return result.then(nextState => [nextState, patches!, inversePatches!]);\r\n        }\r\n        return [result, patches!, inversePatches!];\r\n    };\r\n    \n createDraft<T extends Objectish>(base: T): Draft<T> {\r\n        if (!isDraftable(base))\r\n            die(8);\r\n        if (isDraft(base))\r\n            base = current(base);\r\n        const scope = enterScope(this);\r\n        const proxy = createProxy(this, base, undefined);\r\n        proxy[DRAFT_STATE].isManual_ = true;\r\n        leaveScope(scope);\r\n        return proxy as any;\r\n    }\r\n    \n finishDraft<D extends Draft<any>>(draft: D, patchListener?: PatchListener): D extends Draft<infer T> ? T : never {\r\n        const state: ImmerState = draft && (draft as any)[DRAFT_STATE];\r\n        if (__DEV__) {\r\n            if (!state || !state.isManual_)\r\n                die(9);\r\n            if (state.finalized_)\r\n                die(10);\r\n        }\r\n        const { scope_: scope } = state;\r\n        usePatchesInScope(scope, patchListener);\r\n        return processResult(undefined, scope);\r\n    }\r\n    \n /**\r\n         * Pass true to automatically freeze all copies created by Immer.\r\n         *\r\n         * By default, auto-freezing is enabled.\r\n         */\r\n    setAutoFreeze(value: boolean) {\r\n        this.autoFreeze_ = value;\r\n    }\r\n    \n /**\r\n         * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n         * always faster than using ES5 proxies.\r\n         *\r\n         * By default, feature detection is used, so calling this is rarely necessary.\r\n         */\r\n    setUseProxies(value: boolean) {\r\n        if (value && !hasProxies) {\r\n            die(20);\r\n        }\r\n        this.useProxies_ = value;\r\n    }\r\n    \n applyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\r\n        // If a patch replaces the entire state, take that replacement as base\r\n        // before applying patches\r\n        let i: number;\r\n        for (i = patches.length - 1; i >= 0; i--) {\r\n            const patch = patches[i];\r\n            if (patch.path.length === 0 && patch.op === \"replace\") {\r\n                base = patch.value;\r\n                break;\r\n            }\r\n        }\r\n        // If there was a patch that replaced the entire state, start from the\r\n        // patch after that.\r\n        if (i > -1) {\r\n            patches = patches.slice(i + 1);\r\n        }\r\n        \n const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\r\n        if (isDraft(base)) {\r\n            // N.B: never hits if some patch a replacement, patches are never drafts\r\n            return applyPatchesImpl(base, patches);\r\n        }\r\n        // Otherwise, produce a copy of the base state.\r\n        return this.produce(base, (draft: Drafted) => applyPatchesImpl(draft, patches));\r\n    }\r\n}\r\n\n export function createProxy<T extends Objectish>(immer: Immer, value: T, parent?: ImmerState): Drafted<T, ImmerState> {\r\n    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\r\n    const draft: Drafted = isMap(value)\r\n        ? getPlugin(\"MapSet\").proxyMap_(value, parent)\r\n        : isSet(value)\r\n            ? getPlugin(\"MapSet\").proxySet_(value, parent)\r\n            : immer.useProxies_\r\n                ? createProxyProxy(value, parent)\r\n                : getPlugin(\"ES5\").createES5Proxy_(value, parent);\r\n    \n const scope = parent ? parent.scope_ : getCurrentScope();\r\n    scope.drafts_.push(draft);\r\n    return draft;\r\n}\r\n","import { die, isDraft, shallowCopy, each, DRAFT_STATE, get, set, ImmerState, isDraftable, Archtype, getArchtype, getPlugin } from \"../internal.js\";\r\n\n /** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\r\nexport function current<T>(value: T): T;\r\nexport function current(value: any): any {\r\n    if (!isDraft(value))\r\n        die(22, value);\r\n    return currentImpl(value);\r\n}\r\n\n function currentImpl(value: any): any {\r\n    if (!isDraftable(value))\r\n        return value;\r\n    const state: ImmerState | undefined = value[DRAFT_STATE];\r\n    let copy: any;\r\n    const archType = getArchtype(value);\r\n    if (state) {\r\n        if (!state.modified_ &&\r\n            (state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any)))\r\n            return state.base_;\r\n        // Optimization: avoid generating new drafts during copying\r\n        state.finalized_ = true;\r\n        copy = copyHelper(value, archType);\r\n        state.finalized_ = false;\r\n    }\r\n    else {\r\n        copy = copyHelper(value, archType);\r\n    }\r\n    \n each(copy, (key, childValue) => {\r\n        if (state && get(state.base_, key) === childValue)\r\n            return; // no need to copy or search in something that didn't change\r\n        set(copy, key, currentImpl(childValue));\r\n    });\r\n    // In the future, we might consider freezing here, based on the current settings\r\n    return archType === Archtype.Set ? new Set(copy) : copy;\r\n}\r\n\n function copyHelper(value: any, archType: number): any {\r\n    // creates a shallow copy, even if it is a map or set\r\n    switch (archType) {\r\n        case Archtype.Map:\r\n            return new Map(value);\r\n        case Archtype.Set:\r\n            // Set will be cloned as array temporarily, so that we can replace individual items\r\n            return Array.from(value);\r\n    }\r\n    return shallowCopy(value);\r\n}\r\n","import { ImmerState, Drafted, ES5ArrayState, ES5ObjectState, each, has, isDraft, latest, DRAFT_STATE, is, loadPlugin, ImmerScope, ProxyType, getCurrentScope, die, markChanged, objectTraps, ownKeys, getOwnPropertyDescriptors } from \"../internal.js\";\r\n\n type ES5State = ES5ArrayState | ES5ObjectState;\r\n\n export function enableES5() {\r\n    function willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean) {\r\n        if (!isReplaced) {\r\n            if (scope.patches_) {\r\n                markChangesRecursively(scope.drafts_![0]);\r\n            }\r\n            // This is faster when we don't care about which attributes changed.\r\n            markChangesSweep(scope.drafts_);\r\n        }\r\n        // When a child draft is returned, look for changes.\r\n        else if (isDraft(result) &&\r\n            (result[DRAFT_STATE] as ES5State).scope_ === scope) {\r\n            markChangesSweep(scope.drafts_);\r\n        }\r\n    }\r\n    \n function createES5Draft(isArray: boolean, base: any) {\r\n        if (isArray) {\r\n            const draft = new Array(base.length);\r\n            for (let i = 0; i < base.length; i++)\r\n                Object.defineProperty(draft, \"\" + i, proxyProperty(i, true));\r\n            return draft;\r\n        }\r\n        else {\r\n            const descriptors = getOwnPropertyDescriptors(base);\r\n            delete descriptors[DRAFT_STATE as any];\r\n            const keys = ownKeys(descriptors);\r\n            for (let i = 0; i < keys.length; i++) {\r\n                const key: any = keys[i];\r\n                descriptors[key] = proxyProperty(key, isArray || !!descriptors[key].enumerable);\r\n            }\r\n            return Object.create(Object.getPrototypeOf(base), descriptors);\r\n        }\r\n    }\r\n    \n function createES5Proxy_<T>(base: T, parent?: ImmerState): Drafted<T, ES5ObjectState | ES5ArrayState> {\r\n        const isArray = Array.isArray(base);\r\n        const draft = createES5Draft(isArray, base);\r\n        \n const state: ES5ObjectState | ES5ArrayState = {\r\n            type_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\r\n            scope_: parent ? parent.scope_ : getCurrentScope(),\r\n            modified_: false,\r\n            finalized_: false,\r\n            assigned_: {},\r\n            parent_: parent,\r\n            // base is the object we are drafting\r\n            base_: base,\r\n            // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\r\n            draft_: draft,\r\n            copy_: null,\r\n            revoked_: false,\r\n            isManual_: false\r\n        };\r\n        \n Object.defineProperty(draft, DRAFT_STATE, {\r\n            value: state,\r\n            // enumerable: false <- the default\r\n            writable: true\r\n        });\r\n        return draft;\r\n    }\r\n    \n // property descriptors are recycled to make sure we don't create a get and set closure per property,\r\n    // but share them all instead\r\n    const descriptors: {\r\n        [prop: string]: PropertyDescriptor;\r\n    } = {};\r\n    \n function proxyProperty(prop: string | number, enumerable: boolean): PropertyDescriptor {\r\n        let desc = descriptors[prop];\r\n        if (desc) {\r\n            desc.enumerable = enumerable;\r\n        }\r\n        else {\r\n            descriptors[prop] = desc = {\r\n                configurable: true,\r\n                enumerable,\r\n                get(this: any) {\r\n                    const state = this[DRAFT_STATE];\r\n                    if (__DEV__)\r\n                        assertUnrevoked(state);\r\n                    // @ts-ignore\r\n                    return objectTraps.get(state, prop);\r\n                },\r\n                set(this: any, value) {\r\n                    const state = this[DRAFT_STATE];\r\n                    if (__DEV__)\r\n                        assertUnrevoked(state);\r\n                    // @ts-ignore\r\n                    objectTraps.set(state, prop, value);\r\n                }\r\n            };\r\n        }\r\n        return desc;\r\n    }\r\n    \n // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\r\n    function markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\r\n        // The natural order of drafts in the `scope` array is based on when they\r\n        // were accessed. By processing drafts in reverse natural order, we have a\r\n        // better chance of processing leaf nodes first. When a leaf node is known to\r\n        // have changed, we can avoid any traversal of its ancestor nodes.\r\n        for (let i = drafts.length - 1; i >= 0; i--) {\r\n            const state: ES5State = drafts[i][DRAFT_STATE];\r\n            if (!state.modified_) {\r\n                switch (state.type_) {\r\n                    case ProxyType.ES5Array:\r\n                        if (hasArrayChanges(state))\r\n                            markChanged(state);\r\n                        break;\r\n                    case ProxyType.ES5Object:\r\n                        if (hasObjectChanges(state))\r\n                            markChanged(state);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \n function markChangesRecursively(object: any) {\r\n        if (!object || typeof object !== \"object\")\r\n            return;\r\n        const state: ES5State | undefined = object[DRAFT_STATE];\r\n        if (!state)\r\n            return;\r\n        const { base_, draft_, assigned_, type_ } = state;\r\n        if (type_ === ProxyType.ES5Object) {\r\n            // Look for added keys.\r\n            // probably there is a faster way to detect changes, as sweep + recurse seems to do some\r\n            // unnecessary work.\r\n            // also: probably we can store the information we detect here, to speed up tree finalization!\r\n            each(draft_, key => {\r\n                if ((key as any) === DRAFT_STATE)\r\n                    return;\r\n                // The `undefined` check is a fast path for pre-existing keys.\r\n                if ((base_ as any)[key] === undefined && !has(base_, key)) {\r\n                    assigned_[key] = true;\r\n                    markChanged(state);\r\n                }\r\n                else if (!assigned_[key]) {\r\n                    // Only untouched properties trigger recursion.\r\n                    markChangesRecursively(draft_[key]);\r\n                }\r\n            });\r\n            // Look for removed keys.\r\n            each(base_, key => {\r\n                // The `undefined` check is a fast path for pre-existing keys.\r\n                if (draft_[key] === undefined && !has(draft_, key)) {\r\n                    assigned_[key] = false;\r\n                    markChanged(state);\r\n                }\r\n            });\r\n        }\r\n        else if (type_ === ProxyType.ES5Array) {\r\n            if (hasArrayChanges(state as ES5ArrayState)) {\r\n                markChanged(state);\r\n                assigned_.length = true;\r\n            }\r\n            \n if (draft_.length < base_.length) {\r\n                for (let i = draft_.length; i < base_.length; i++)\r\n                    assigned_[i] = false;\r\n            }\r\n            else {\r\n                for (let i = base_.length; i < draft_.length; i++)\r\n                    assigned_[i] = true;\r\n            }\r\n            \n // Minimum count is enough, the other parts has been processed.\r\n            const min = Math.min(draft_.length, base_.length);\r\n            \n for (let i = 0; i < min; i++) {\r\n                // Only untouched indices trigger recursion.\r\n                if (!draft_.hasOwnProperty(i)) {\r\n                    assigned_[i] = true;\r\n                }\r\n                if (assigned_[i] === undefined)\r\n                    markChangesRecursively(draft_[i]);\r\n            }\r\n        }\r\n    }\r\n    \n function hasObjectChanges(state: ES5ObjectState) {\r\n        const { base_, draft_ } = state;\r\n        \n // Search for added keys and changed keys. Start at the back, because\r\n        // non-numeric keys are ordered by time of definition on the object.\r\n        const keys = ownKeys(draft_);\r\n        for (let i = keys.length - 1; i >= 0; i--) {\r\n            const key: any = keys[i];\r\n            if (key === DRAFT_STATE)\r\n                continue;\r\n            const baseValue = base_[key];\r\n            // The `undefined` check is a fast path for pre-existing keys.\r\n            if (baseValue === undefined && !has(base_, key)) {\r\n                return true;\r\n            }\r\n            // Once a base key is deleted, future changes go undetected, because its\r\n            // descriptor is erased. This branch detects any missed changes.\r\n            else {\r\n                const value = draft_[key];\r\n                const state: ImmerState = value && value[DRAFT_STATE];\r\n                if (state ? state.base_ !== baseValue : !is(value, baseValue)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        \n // At this point, no keys were added or changed.\r\n        // Compare key count to determine if keys were deleted.\r\n        const baseIsDraft = !!base_[DRAFT_STATE as any];\r\n        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE\r\n    }\r\n    \n function hasArrayChanges(state: ES5ArrayState) {\r\n        const { draft_ } = state;\r\n        if (draft_.length !== state.base_.length)\r\n            return true;\r\n        // See #116\r\n        // If we first shorten the length, our array interceptors will be removed.\r\n        // If after that new items are added, result in the same original length,\r\n        // those last items will have no intercepting property.\r\n        // So if there is no own descriptor on the last position, we know that items were removed and added\r\n        // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\r\n        // the last one\r\n        // last descriptor can be not a trap, if the array was extended\r\n        const descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1);\r\n        // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\r\n        if (descriptor && !descriptor.get)\r\n            return true;\r\n        // if we miss a property, it has been deleted, so array probobaly changed\r\n        for (let i = 0; i < draft_.length; i++) {\r\n            if (!draft_.hasOwnProperty(i))\r\n                return true;\r\n        }\r\n        // For all other cases, we don't have to compare, as they would have been picked up by the index setters\r\n        return false;\r\n    }\r\n    \n function hasChanges_(state: ES5State) {\r\n        return state.type_ === ProxyType.ES5Object\r\n            ? hasObjectChanges(state)\r\n            : hasArrayChanges(state);\r\n    }\r\n    \n function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\r\n        if (state.revoked_)\r\n            die(3, JSON.stringify(latest(state)));\r\n    }\r\n    \n loadPlugin(\"ES5\", {\r\n        createES5Proxy_,\r\n        willFinalizeES5_,\r\n        hasChanges_\r\n    });\r\n}\r\n","// types only!\r\nimport { ImmerState, AnyMap, AnySet, MapState, SetState, DRAFT_STATE, getCurrentScope, latest, iteratorSymbol, isDraftable, createProxy, loadPlugin, markChanged, ProxyType, die, each } from \"../internal.js\";\r\n\n export function enableMapSet() {\r\n    /* istanbul ignore next */\r\n    var extendStatics = function (d: any, b: any): any {\r\n        extendStatics =\r\n            Object.setPrototypeOf ||\r\n                ({ __proto__: [] } instanceof Array &&\r\n                    function (d, b) {\r\n                        d.__proto__ = b;\r\n                    }) ||\r\n                function (d, b) {\r\n                    for (var p in b)\r\n                        if (b.hasOwnProperty(p))\r\n                            d[p] = b[p];\r\n                };\r\n        return extendStatics(d, b);\r\n    };\r\n    \n // Ugly hack to resolve #502 and inherit built in Map / Set\r\n    function __extends(d: any, b: any): any {\r\n        extendStatics(d, b);\r\n        function __(this: any): any {\r\n            Object.defineProperty(this, \"constructor\", {\r\n                value: d\r\n            });\r\n        }\r\n        d.prototype =\r\n            // @ts-ignore\r\n            ((__.prototype = b.prototype), new __());\r\n    }\r\n    \n const DraftMap = (function (_super) {\r\n        __extends(DraftMap, _super);\r\n        // Create class manually, cause #502\r\n        function DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\r\n            this[DRAFT_STATE] = {\r\n                type_: ProxyType.Map,\r\n                parent_: parent,\r\n                scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n                modified_: false,\r\n                finalized_: false,\r\n                copy_: undefined,\r\n                assigned_: undefined,\r\n                base_: target,\r\n                draft_: this as any,\r\n                isManual_: false,\r\n                revoked_: false\r\n            } as MapState;\r\n            return this;\r\n        }\r\n        const p = DraftMap.prototype;\r\n        \n Object.defineProperties(p, {\r\n            size: {\r\n                get: function () {\r\n                    return latest(this[DRAFT_STATE]).size;\r\n                },\r\n                configurable: true\r\n            },\r\n            has: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): boolean {\r\n                    return latest(this[DRAFT_STATE]).has(key);\r\n                }\r\n            },\r\n            set: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any, value: any) {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (!latest(state).has(key) || latest(state).get(key) !== value) {\r\n                        prepareMapCopy(state);\r\n                        markChanged(state);\r\n                        state.assigned_!.set(key, true);\r\n                        state.copy_!.set(key, value);\r\n                        state.assigned_!.set(key, true);\r\n                    }\r\n                    return this;\r\n                }\r\n            },\r\n            delete: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): boolean {\r\n                    if (!this.has(key)) {\r\n                        return false;\r\n                    }\r\n                    \n const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareMapCopy(state);\r\n                    markChanged(state);\r\n                    if (state.base_.has(key)) {\r\n                        state.assigned_!.set(key, false);\r\n                    }\r\n                    else {\r\n                        state.assigned_!.delete(key);\r\n                    }\r\n                    state.copy_!.delete(key);\r\n                    return true;\r\n                }\r\n            },\r\n            clear: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (latest(state).size) {\r\n                        prepareMapCopy(state);\r\n                        markChanged(state);\r\n                        state.assigned_ = new Map();\r\n                        each(state.base_, key => {\r\n                            state.assigned_!.set(key, false);\r\n                        });\r\n                        state.copy_!.clear();\r\n                    }\r\n                }\r\n            },\r\n            forEach: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (cb: (value: any, key: any, self: any) => void, thisArg?: any) {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    latest(state).forEach((_value: any, key: any, _map: any) => {\r\n                        cb.call(thisArg, this.get(key), key, this);\r\n                    });\r\n                }\r\n            },\r\n            get: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): any {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    const value = latest(state).get(key);\r\n                    if (state.finalized_ || !isDraftable(value)) {\r\n                        return value;\r\n                    }\r\n                    if (value !== state.base_.get(key)) {\r\n                        return value; // either already drafted or reassigned\r\n                    }\r\n                    // despite what it looks, this creates a draft only once, see above condition\r\n                    const draft = createProxy(state.scope_.immer_, value, state);\r\n                    prepareMapCopy(state);\r\n                    state.copy_!.set(key, draft);\r\n                    return draft;\r\n                }\r\n            },\r\n            keys: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    return latest(this[DRAFT_STATE]).keys();\r\n                }\r\n            },\r\n            values: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    const iterator = this.keys();\r\n                    return {\r\n                        [iteratorSymbol]: () => this.values(),\r\n                        next: () => {\r\n                            const r = iterator.next();\r\n                            /* istanbul ignore next */\r\n                            if (r.done)\r\n                                return r;\r\n                            const value = this.get(r.value);\r\n                            return {\r\n                                done: false,\r\n                                value\r\n                            };\r\n                        }\r\n                    } as any;\r\n                }\r\n            },\r\n            entries: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<[\r\n                    any,\r\n                    any\r\n                ]> {\r\n                    const iterator = this.keys();\r\n                    return {\r\n                        [iteratorSymbol]: () => this.entries(),\r\n                        next: () => {\r\n                            const r = iterator.next();\r\n                            /* istanbul ignore next */\r\n                            if (r.done)\r\n                                return r;\r\n                            const value = this.get(r.value);\r\n                            return {\r\n                                done: false,\r\n                                value: [r.value, value]\r\n                            };\r\n                        }\r\n                    } as any;\r\n                }\r\n            },\r\n            [iteratorSymbol]: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    return this.entries();\r\n                }\r\n            }\r\n        });\r\n        \n return DraftMap;\r\n    })(Map);\r\n    \n function proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\r\n        // @ts-ignore\r\n        return new DraftMap(target, parent);\r\n    }\r\n    \n function prepareMapCopy(state: MapState) {\r\n        if (!state.copy_) {\r\n            state.assigned_ = new Map();\r\n            state.copy_ = new Map(state.base_);\r\n        }\r\n    }\r\n    \n const DraftSet = (function (_super) {\r\n        __extends(DraftSet, _super);\r\n        // Create class manually, cause #502\r\n        function DraftSet(this: any, target: AnySet, parent?: ImmerState) {\r\n            this[DRAFT_STATE] = {\r\n                type_: ProxyType.Set,\r\n                parent_: parent,\r\n                scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n                modified_: false,\r\n                finalized_: false,\r\n                copy_: undefined,\r\n                base_: target,\r\n                draft_: this,\r\n                drafts_: new Map(),\r\n                revoked_: false,\r\n                isManual_: false\r\n            } as SetState;\r\n            return this;\r\n        }\r\n        const p = DraftSet.prototype;\r\n        \n Object.defineProperties(p, {\r\n            size: {\r\n                get: function () {\r\n                    return latest(this[DRAFT_STATE]).size;\r\n                },\r\n                configurable: true\r\n            },\r\n            has: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): boolean {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    // bit of trickery here, to be able to recognize both the value, and the draft of its value\r\n                    if (!state.copy_) {\r\n                        return state.base_.has(value);\r\n                    }\r\n                    if (state.copy_.has(value))\r\n                        return true;\r\n                    if (state.drafts_.has(value) &&\r\n                        state.copy_.has(state.drafts_.get(value)))\r\n                        return true;\r\n                    return false;\r\n                }\r\n            },\r\n            add: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): any {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (!this.has(value)) {\r\n                        prepareSetCopy(state);\r\n                        markChanged(state);\r\n                        state.copy_!.add(value);\r\n                    }\r\n                    return this;\r\n                }\r\n            },\r\n            delete: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): any {\r\n                    if (!this.has(value)) {\r\n                        return false;\r\n                    }\r\n                    \n const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    markChanged(state);\r\n                    return (state.copy_!.delete(value) ||\r\n                        (state.drafts_.has(value)\r\n                            ? state.copy_!.delete(state.drafts_.get(value))\r\n                            : /* istanbul ignore next */ false));\r\n                }\r\n            },\r\n            clear: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (latest(state).size) {\r\n                        prepareSetCopy(state);\r\n                        markChanged(state);\r\n                        state.copy_!.clear();\r\n                    }\r\n                }\r\n            },\r\n            values: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    return state.copy_!.values();\r\n                }\r\n            },\r\n            entries: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function entries(): IterableIterator<[\r\n                    any,\r\n                    any\r\n                ]> {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    return state.copy_!.entries();\r\n                }\r\n            },\r\n            keys: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    return this.values();\r\n                }\r\n            },\r\n            [iteratorSymbol]: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    return this.values();\r\n                }\r\n            },\r\n            forEach: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function forEach(cb: any, thisArg?: any) {\r\n                    const iterator = this.values();\r\n                    let result = iterator.next();\r\n                    while (!result.done) {\r\n                        cb.call(thisArg, result.value, result.value, this);\r\n                        result = iterator.next();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        \n return DraftSet;\r\n    })(Set);\r\n    \n function proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\r\n        // @ts-ignore\r\n        return new DraftSet(target, parent);\r\n    }\r\n    \n function prepareSetCopy(state: SetState) {\r\n        if (!state.copy_) {\r\n            // create drafts for all entries to preserve insertion order\r\n            state.copy_ = new Set();\r\n            state.base_.forEach(value => {\r\n                if (isDraftable(value)) {\r\n                    const draft = createProxy(state.scope_.immer_, value, state);\r\n                    state.drafts_.set(value, draft);\r\n                    state.copy_!.add(draft);\r\n                }\r\n                else {\r\n                    state.copy_!.add(value);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    \n function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\r\n        if (state.revoked_)\r\n            die(3, JSON.stringify(latest(state)));\r\n    }\r\n    \n loadPlugin(\"MapSet\", { proxyMap_, proxySet_ });\r\n}\r\n","import { immerable } from \"../immer.js\";\r\nimport { ImmerState, Patch, SetState, ES5ArrayState, ProxyArrayState, MapState, ES5ObjectState, ProxyObjectState, PatchPath, get, each, has, getArchtype, isSet, isMap, loadPlugin, ProxyType, Archtype, die, isDraft, isDraftable, NOTHING } from \"../internal.js\";\r\n\n export function enablePatches() {\r\n    const REPLACE = \"replace\";\r\n    const ADD = \"add\";\r\n    const REMOVE = \"remove\";\r\n    \n function generatePatches_(state: ImmerState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]): void {\r\n        switch (state.type_) {\r\n            case ProxyType.ProxyObject:\r\n            case ProxyType.ES5Object:\r\n            case ProxyType.Map:\r\n                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\r\n            case ProxyType.ES5Array:\r\n            case ProxyType.ProxyArray:\r\n                return generateArrayPatches(state, basePath, patches, inversePatches);\r\n            case ProxyType.Set:\r\n                return generateSetPatches((state as any) as SetState, basePath, patches, inversePatches);\r\n        }\r\n    }\r\n    \n function generateArrayPatches(state: ES5ArrayState | ProxyArrayState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        let { base_, assigned_ } = state;\r\n        let copy_ = state.copy_!;\r\n        \n // Reduce complexity by ensuring `base` is never longer.\r\n        if (copy_.length < base_.length) {\r\n            // @ts-ignore\r\n            ;\r\n            [base_, copy_] = [copy_, base_];\r\n            [patches, inversePatches] = [inversePatches, patches];\r\n        }\r\n        \n // Process replaced indices.\r\n        for (let i = 0; i < base_.length; i++) {\r\n            if (assigned_[i] && copy_[i] !== base_[i]) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: REPLACE,\r\n                    path,\r\n                    // Need to maybe clone it, as it can in fact be the original value\r\n                    // due to the base/copy inversion at the start of this function\r\n                    value: clonePatchValueIfNeeded(copy_[i])\r\n                });\r\n                inversePatches.push({\r\n                    op: REPLACE,\r\n                    path,\r\n                    value: clonePatchValueIfNeeded(base_[i])\r\n                });\r\n            }\r\n        }\r\n        \n // Process added indices.\r\n        for (let i = base_.length; i < copy_.length; i++) {\r\n            const path = basePath.concat([i]);\r\n            patches.push({\r\n                op: ADD,\r\n                path,\r\n                // Need to maybe clone it, as it can in fact be the original value\r\n                // due to the base/copy inversion at the start of this function\r\n                value: clonePatchValueIfNeeded(copy_[i])\r\n            });\r\n        }\r\n        if (base_.length < copy_.length) {\r\n            inversePatches.push({\r\n                op: REPLACE,\r\n                path: basePath.concat([\"length\"]),\r\n                value: base_.length\r\n            });\r\n        }\r\n    }\r\n    \n // This is used for both Map objects and normal objects.\r\n    function generatePatchesFromAssigned(state: MapState | ES5ObjectState | ProxyObjectState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        const { base_, copy_ } = state;\r\n        each(state.assigned_!, (key, assignedValue) => {\r\n            const origValue = get(base_, key);\r\n            const value = get(copy_!, key);\r\n            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\r\n            if (origValue === value && op === REPLACE)\r\n                return;\r\n            const path = basePath.concat(key as any);\r\n            patches.push(op === REMOVE ? { op, path } : { op, path, value });\r\n            inversePatches.push(op === ADD\r\n                ? { op: REMOVE, path }\r\n                : op === REMOVE\r\n                    ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) }\r\n                    : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) });\r\n        });\r\n    }\r\n    \n function generateSetPatches(state: SetState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        let { base_, copy_ } = state;\r\n        \n let i = 0;\r\n        base_.forEach((value: any) => {\r\n            if (!copy_!.has(value)) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: REMOVE,\r\n                    path,\r\n                    value\r\n                });\r\n                inversePatches.unshift({\r\n                    op: ADD,\r\n                    path,\r\n                    value\r\n                });\r\n            }\r\n            i++;\r\n        });\r\n        i = 0;\r\n        copy_!.forEach((value: any) => {\r\n            if (!base_.has(value)) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: ADD,\r\n                    path,\r\n                    value\r\n                });\r\n                inversePatches.unshift({\r\n                    op: REMOVE,\r\n                    path,\r\n                    value\r\n                });\r\n            }\r\n            i++;\r\n        });\r\n    }\r\n    \n function generateReplacementPatches_(baseValue: any, replacement: any, patches: Patch[], inversePatches: Patch[]): void {\r\n        patches.push({\r\n            op: REPLACE,\r\n            path: [],\r\n            value: replacement === NOTHING ? undefined : replacement\r\n        });\r\n        inversePatches.push({\r\n            op: REPLACE,\r\n            path: [],\r\n            value: baseValue\r\n        });\r\n    }\r\n    \n function applyPatches_<T>(draft: T, patches: Patch[]): T {\r\n        patches.forEach(patch => {\r\n            const { path, op } = patch;\r\n            \n let base: any = draft;\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                const parentType = getArchtype(base);\r\n                const p = \"\" + path[i];\r\n                // See #738, avoid prototype pollution\r\n                if ((parentType === Archtype.Object || parentType === Archtype.Array) &&\r\n                    (p === \"__proto__\" || p === \"constructor\"))\r\n                    die(24);\r\n                if (typeof base === \"function\" && p === \"prototype\")\r\n                    die(24);\r\n                base = get(base, p);\r\n                if (typeof base !== \"object\")\r\n                    die(15, path.join(\"/\"));\r\n            }\r\n            \n const type = getArchtype(base);\r\n            const value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\r\n            const key = path[path.length - 1];\r\n            switch (op) {\r\n                case REPLACE:\r\n                    switch (type) {\r\n                        case Archtype.Map:\r\n                            return base.set(key, value);\r\n                        /* istanbul ignore next */\r\n                        case Archtype.Set:\r\n                            die(16);\r\n                        default:\r\n                            // if value is an object, then it's assigned by reference\r\n                            // in the following add or remove ops, the value field inside the patch will also be modifyed\r\n                            // so we use value from the cloned patch\r\n                            // @ts-ignore\r\n                            return (base[key] = value);\r\n                    }\r\n                case ADD:\r\n                    switch (type) {\r\n                        case Archtype.Array:\r\n                            return key === \"-\"\r\n                                ? base.push(value)\r\n                                : base.splice(key as any, 0, value);\r\n                        case Archtype.Map:\r\n                            return base.set(key, value);\r\n                        case Archtype.Set:\r\n                            return base.add(value);\r\n                        default:\r\n                            return (base[key] = value);\r\n                    }\r\n                case REMOVE:\r\n                    switch (type) {\r\n                        case Archtype.Array:\r\n                            return base.splice(key as any, 1);\r\n                        case Archtype.Map:\r\n                            return base.delete(key);\r\n                        case Archtype.Set:\r\n                            return base.delete(patch.value);\r\n                        default:\r\n                            return delete base[key];\r\n                    }\r\n                default:\r\n                    die(17, op);\r\n            }\r\n        });\r\n        \n return draft;\r\n    }\r\n    \n // optimize: this is quite a performance hit, can we detect intelligently when it is needed?\r\n    // E.g. auto-draft when new objects from outside are assigned and modified?\r\n    // (See failing test when deepClone just returns obj)\r\n    function deepClonePatchValue<T>(obj: T): T;\r\n    function deepClonePatchValue(obj: any) {\r\n        if (!isDraftable(obj))\r\n            return obj;\r\n        if (Array.isArray(obj))\r\n            return obj.map(deepClonePatchValue);\r\n        if (isMap(obj))\r\n            return new Map(Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)]));\r\n        if (isSet(obj))\r\n            return new Set(Array.from(obj).map(deepClonePatchValue));\r\n        const cloned = Object.create(Object.getPrototypeOf(obj));\r\n        for (const key in obj)\r\n            cloned[key] = deepClonePatchValue(obj[key]);\r\n        if (has(obj, immerable))\r\n            cloned[immerable] = obj[immerable];\r\n        return cloned;\r\n    }\r\n    \n function clonePatchValueIfNeeded<T>(obj: T): T {\r\n        if (isDraft(obj)) {\r\n            return deepClonePatchValue(obj);\r\n        }\r\n        else\r\n            return obj;\r\n    }\r\n    \n loadPlugin(\"Patches\", {\r\n        applyPatches_,\r\n        generatePatches_,\r\n        generateReplacementPatches_\r\n    });\r\n}\r\n","import { IProduce, IProduceWithPatches, Immer, Draft, Immutable } from \"./internal.js\";\r\n\n export { Draft, Immutable, Patch, PatchListener, original, current, isDraft, isDraftable, NOTHING as nothing, DRAFTABLE as immerable, freeze } from \"./internal.js\";\r\n\n const immer = new Immer();\r\n\n /**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */\r\nexport const produce: IProduce = immer.produce;\r\nexport default produce;\r\n\n /**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */\r\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(immer);\r\n\n /**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * Always freeze by default, even in production mode\r\n */\r\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer);\r\n\n /**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */\r\nexport const setUseProxies = immer.setUseProxies.bind(immer);\r\n\n /**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */\r\nexport const applyPatches = immer.applyPatches.bind(immer);\r\n\n /**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */\r\nexport const createDraft = immer.createDraft.bind(immer);\r\n\n /**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */\r\nexport const finishDraft = immer.finishDraft.bind(immer);\r\n\n /**\r\n * This function is actually a no-op, but can be used to cast an immutable type\r\n * to an draft type and make TypeScript happy\r\n *\r\n * @param value\r\n */\r\nexport function castDraft<T>(value: T): Draft<T> {\r\n    return value as any;\r\n}\r\n\n /**\r\n * This function is actually a no-op, but can be used to cast a mutable type\r\n * to an immutable type and make TypeScript happy\r\n * @param value\r\n */\r\nexport function castImmutable<T>(value: T): Immutable<T> {\r\n    return value as any;\r\n}\r\n\n export { Immer };\r\n\n export { enableES5 } from \"./plugins/es5.js\";\r\nexport { enablePatches } from \"./plugins/patches.js\";\r\nexport { enableMapSet } from \"./plugins/mapset.js\";\r\nexport { enableAllPlugins } from \"./plugins/all.js\";\r\n","import { enableES5 } from \"./es5.js\";\r\nimport { enableMapSet } from \"./mapset.js\";\r\nimport { enablePatches } from \"./patches.js\";\r\n\n export function enableAllPlugins() {\r\n    enableES5();\r\n    enableMapSet();\r\n    enablePatches();\r\n}\r\n"],"names":["hasSymbol","Symbol","hasMap","Map","hasSet","Set","hasProxies","Proxy","revocable","Reflect","NOTHING","for","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","die","error","args","Error","length","map","s","join","isDraft","value","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","toString","objectCtorString","isPlainObject","Array","isArray","_value$constructor","isMap","isSet","prototype","ownKeys","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","getOwnPropertyDescriptors","target","res","forEach","key","getOwnPropertyDescriptor","each","iter","enumerableOnly","getArchtype","keys","entry","index","thing","state","type_","has","prop","get","set","propOrOldValue","t","delete","add","is","x","y","latest","copy_","base_","shallowCopy","base","slice","descriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","dontMutateFrozenCollections","defineProperties","clear","currentScope","plugins","getPlugin","pluginKey","plugin","loadPlugin","implementation","getCurrentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","autoFreeze_","objectTraps","source","getDescriptorFromProto","_desc$get","readPropFromProto","peek","prepareCopy","createProxy","current","currentState","markChanged","Number","isNaN","deleteProperty","owner","defineProperty","setPrototypeOf","arrayTraps","fn","arguments","apply","this","Immer","config","recipe","defaultBase","self","_this","produce","_this2","proxy","hasError","Promise","then","p","ip","produceWithPatches","patches","inversePatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","isManual_","finishDraft","applyPatches","patch","op","applyPatchesImpl","applyPatches_","parent","proxyMap_","proxySet_","traps","revoke","createProxyProxy","createES5Proxy_","push","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","proxyProperty","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","createES5Draft","markChangesRecursively","object","min","Math","enableMapSet","extendStatics","d","b","__proto__","__extends","__","DraftMap","_super","size","assertUnrevoked","prepareMapCopy","cb","thisArg","_value","_map","values","next","r","done","entries","_this3","DraftSet","prepareSetCopy","JSON","stringify","enablePatches","ADD","deepClonePatchValue","cloned","immerable","clonePatchValueIfNeeded","parentType","type","splice","basePath","assignedValue","origValue","generatePatchesFromAssigned","generateArrayPatches","unshift","generateSetPatches","replacement","bind"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/immer.d.ts b/dist/immer.d.ts
index c248d89764dc0760a16fc4e0c13cea354cf68473..9da4578dd0bbbef494a7d7967e27d63365db9339 100644
--- a/dist/immer.d.ts
+++ b/dist/immer.d.ts
@@ -1,80 +1,80 @@
-import { IProduce, IProduceWithPatches, Immer, Draft, Immutable } from "./internal";
-export { Draft, Immutable, Patch, PatchListener, original, current, isDraft, isDraftable, NOTHING as nothing, DRAFTABLE as immerable, freeze } from "./internal";
+import { IProduce, IProduceWithPatches, Immer, Draft, Immutable } from "./internal.js";
+export { Draft, Immutable, Patch, PatchListener, original, current, isDraft, isDraftable, NOTHING as nothing, DRAFTABLE as immerable, freeze } from "./internal.js";
 /**
- * The `produce` function takes a value and a "recipe function" (whose
- * return value often depends on the base state). The recipe function is
- * free to mutate its first argument however it wants. All mutations are
- * only ever applied to a __copy__ of the base state.
- *
- * Pass only a function to create a "curried producer" which relieves you
- * from passing the recipe function every time.
- *
- * Only plain objects and arrays are made mutable. All other objects are
- * considered uncopyable.
- *
- * Note: This function is __bound__ to its `Immer` instance.
- *
- * @param {any} base - the initial state
- * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
- * @param {Function} patchListener - optional function that will be called with all the patches produced here
- * @returns {any} a new state, or the initial state if nothing was modified
- */
+* The `produce` function takes a value and a "recipe function" (whose
+* return value often depends on the base state). The recipe function is
+* free to mutate its first argument however it wants. All mutations are
+* only ever applied to a __copy__ of the base state.
+*
+* Pass only a function to create a "curried producer" which relieves you
+* from passing the recipe function every time.
+*
+* Only plain objects and arrays are made mutable. All other objects are
+* considered uncopyable.
+*
+* Note: This function is __bound__ to its `Immer` instance.
+*
+* @param {any} base - the initial state
+* @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+* @param {Function} patchListener - optional function that will be called with all the patches produced here
+* @returns {any} a new state, or the initial state if nothing was modified
+*/
 export declare const produce: IProduce;
 export default produce;
 /**
- * Like `produce`, but `produceWithPatches` always returns a tuple
- * [nextState, patches, inversePatches] (instead of just the next state)
- */
+* Like `produce`, but `produceWithPatches` always returns a tuple
+* [nextState, patches, inversePatches] (instead of just the next state)
+*/
 export declare const produceWithPatches: IProduceWithPatches;
 /**
- * Pass true to automatically freeze all copies created by Immer.
- *
- * Always freeze by default, even in production mode
- */
+* Pass true to automatically freeze all copies created by Immer.
+*
+* Always freeze by default, even in production mode
+*/
 export declare const setAutoFreeze: (value: boolean) => void;
 /**
- * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
- * always faster than using ES5 proxies.
- *
- * By default, feature detection is used, so calling this is rarely necessary.
- */
+* Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+* always faster than using ES5 proxies.
+*
+* By default, feature detection is used, so calling this is rarely necessary.
+*/
 export declare const setUseProxies: (value: boolean) => void;
 /**
- * Apply an array of Immer patches to the first argument.
- *
- * This function is a producer, which means copy-on-write is in effect.
- */
-export declare const applyPatches: <T extends import("./internal").Objectish>(base: T, patches: import("./internal").Patch[]) => T;
+* Apply an array of Immer patches to the first argument.
+*
+* This function is a producer, which means copy-on-write is in effect.
+*/
+export declare const applyPatches: <T extends import("./internal.js").Objectish>(base: T, patches: import("./internal.js").Patch[]) => T;
 /**
- * Create an Immer draft from the given base state, which may be a draft itself.
- * The draft can be modified until you finalize it with the `finishDraft` function.
- */
-export declare const createDraft: <T extends import("./internal").Objectish>(base: T) => Draft<T>;
+* Create an Immer draft from the given base state, which may be a draft itself.
+* The draft can be modified until you finalize it with the `finishDraft` function.
+*/
+export declare const createDraft: <T extends import("./internal.js").Objectish>(base: T) => Draft<T>;
 /**
- * Finalize an Immer draft from a `createDraft` call, returning the base state
- * (if no changes were made) or a modified copy. The draft must *not* be
- * mutated afterwards.
- *
- * Pass a function as the 2nd argument to generate Immer patches based on the
- * changes that were made.
- */
-export declare const finishDraft: <D extends any>(draft: D, patchListener?: import("./internal").PatchListener | undefined) => D extends Draft<infer T> ? T : never;
+* Finalize an Immer draft from a `createDraft` call, returning the base state
+* (if no changes were made) or a modified copy. The draft must *not* be
+* mutated afterwards.
+*
+* Pass a function as the 2nd argument to generate Immer patches based on the
+* changes that were made.
+*/
+export declare const finishDraft: <D extends any>(draft: D, patchListener?: import("./internal.js").PatchListener | undefined) => D extends Draft<infer T> ? T : never;
 /**
- * This function is actually a no-op, but can be used to cast an immutable type
- * to an draft type and make TypeScript happy
- *
- * @param value
- */
+* This function is actually a no-op, but can be used to cast an immutable type
+* to an draft type and make TypeScript happy
+*
+* @param value
+*/
 export declare function castDraft<T>(value: T): Draft<T>;
 /**
- * This function is actually a no-op, but can be used to cast a mutable type
- * to an immutable type and make TypeScript happy
- * @param value
- */
+* This function is actually a no-op, but can be used to cast a mutable type
+* to an immutable type and make TypeScript happy
+* @param value
+*/
 export declare function castImmutable<T>(value: T): Immutable<T>;
 export { Immer };
-export { enableES5 } from "./plugins/es5";
-export { enablePatches } from "./plugins/patches";
-export { enableMapSet } from "./plugins/mapset";
-export { enableAllPlugins } from "./plugins/all";
+export { enableES5 } from "./plugins/es5.js";
+export { enablePatches } from "./plugins/patches.js";
+export { enableMapSet } from "./plugins/mapset.js";
+export { enableAllPlugins } from "./plugins/all.js";
 //# sourceMappingURL=immer.d.ts.map
\ No newline at end of file
diff --git a/dist/immer.d.ts.map b/dist/immer.d.ts.map
index d288dc7b55b69ddf166f176831ff73afb7c1489f..181c3acbeefc0090844f8fe92b09754f683cb19f 100644
--- a/dist/immer.d.ts.map
+++ b/dist/immer.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"immer.d.ts","sourceRoot":"","sources":["src/immer.ts"],"names":[],"mappings":"AAAA,OAAO,EACN,QAAQ,EACR,mBAAmB,EACnB,KAAK,EACL,KAAK,EACL,SAAS,EACT,MAAM,YAAY,CAAA;AAEnB,OAAO,EACN,KAAK,EACL,SAAS,EACT,KAAK,EACL,aAAa,EACb,QAAQ,EACR,OAAO,EACP,OAAO,EACP,WAAW,EACX,OAAO,IAAI,OAAO,EAClB,SAAS,IAAI,SAAS,EACtB,MAAM,EACN,MAAM,YAAY,CAAA;AAInB;;;;;;;;;;;;;;;;;;GAkBG;AACH,eAAO,MAAM,OAAO,EAAE,QAAwB,CAAA;AAC9C,eAAe,OAAO,CAAA;AAEtB;;;GAGG;AACH,eAAO,MAAM,kBAAkB,EAAE,mBAEhC,CAAA;AAED;;;;GAIG;AACH,eAAO,MAAM,aAAa,0BAAkC,CAAA;AAE5D;;;;;GAKG;AACH,eAAO,MAAM,aAAa,0BAAkC,CAAA;AAE5D;;;;GAIG;AACH,eAAO,MAAM,YAAY,iGAAiC,CAAA;AAE1D;;;GAGG;AACH,eAAO,MAAM,WAAW,iEAAgC,CAAA;AAExD;;;;;;;GAOG;AACH,eAAO,MAAM,WAAW,mIAAgC,CAAA;AAExD;;;;;GAKG;AACH,wBAAgB,SAAS,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAE/C;AAED;;;;GAIG;AACH,wBAAgB,aAAa,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAEvD;AAED,OAAO,EAAC,KAAK,EAAC,CAAA;AAEd,OAAO,EAAC,SAAS,EAAC,MAAM,eAAe,CAAA;AACvC,OAAO,EAAC,aAAa,EAAC,MAAM,mBAAmB,CAAA;AAC/C,OAAO,EAAC,YAAY,EAAC,MAAM,kBAAkB,CAAA;AAC7C,OAAO,EAAC,gBAAgB,EAAC,MAAM,eAAe,CAAA"}
\ No newline at end of file
+{"version":3,"file":"immer.d.ts","sourceRoot":"","sources":["src/immer.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,mBAAmB,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAEtF,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,aAAa,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,OAAO,IAAI,OAAO,EAAE,SAAS,IAAI,SAAS,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AAIpK;;;;;;;;;;;;;;;;;;EAkBE;AACH,eAAO,MAAM,OAAO,EAAE,QAAwB,CAAC;AAC/C,eAAe,OAAO,CAAC;AAEtB;;;EAGE;AACH,eAAO,MAAM,kBAAkB,EAAE,mBAA0D,CAAC;AAE3F;;;;EAIE;AACH,eAAO,MAAM,aAAa,0BAAkC,CAAC;AAE5D;;;;;EAKE;AACH,eAAO,MAAM,aAAa,0BAAkC,CAAC;AAE5D;;;;EAIE;AACH,eAAO,MAAM,YAAY,uGAAiC,CAAC;AAE1D;;;EAGE;AACH,eAAO,MAAM,WAAW,oEAAgC,CAAC;AAExD;;;;;;;EAOE;AACH,eAAO,MAAM,WAAW,sIAAgC,CAAC;AAExD;;;;;EAKE;AACH,wBAAgB,SAAS,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAE/C;AAEA;;;;EAIE;AACH,wBAAgB,aAAa,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAEvD;AAEA,OAAO,EAAE,KAAK,EAAE,CAAC;AAEjB,OAAO,EAAE,SAAS,EAAE,MAAM,kBAAkB,CAAC;AAC9C,OAAO,EAAE,aAAa,EAAE,MAAM,sBAAsB,CAAC;AACrD,OAAO,EAAE,YAAY,EAAE,MAAM,qBAAqB,CAAC;AACnD,OAAO,EAAE,gBAAgB,EAAE,MAAM,kBAAkB,CAAC"}
\ No newline at end of file
diff --git a/dist/immer.esm.js b/dist/immer.esm.js
index 4ad55ff106409efdb53189e24445eceedb5bacfe..ef5bc2eaa123e6a9d552d8a62f19dc8c4a587807 100644
--- a/dist/immer.esm.js
+++ b/dist/immer.esm.js
@@ -1,2 +1,2120 @@
-function n(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];if("production"!==process.env.NODE_ENV){var i=Y[n],o=i?"function"==typeof i?i.apply(null,t):i:"unknown error nr: "+n;throw Error("[Immer] "+o)}throw Error("[Immer] minified error nr: "+n+(t.length?" "+t.map((function(n){return"'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r(n){return!!n&&!!n[Q]}function t(n){var r;return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var r=Object.getPrototypeOf(n);if(null===r)return!0;var t=Object.hasOwnProperty.call(r,"constructor")&&r.constructor;return t===Object||"function"==typeof t&&Function.toString.call(t)===Z}(n)||Array.isArray(n)||!!n[L]||!!(null===(r=n.constructor)||void 0===r?void 0:r[L])||s(n)||v(n))}function e(t){return r(t)||n(23,t),t[Q].t}function i(n,r,t){void 0===t&&(t=!1),0===o(n)?(t?Object.keys:nn)(n).forEach((function(e){t&&"symbol"==typeof e||r(e,n[e],n)})):n.forEach((function(t,e){return r(e,t,n)}))}function o(n){var r=n[Q];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:s(n)?2:v(n)?3:0}function u(n,r){return 2===o(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a(n,r){return 2===o(n)?n.get(r):n[r]}function f(n,r,t){var e=o(n);2===e?n.set(r,t):3===e?(n.delete(r),n.add(t)):n[r]=t}function c(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function s(n){return X&&n instanceof Map}function v(n){return q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=rn(n);delete r[Q];for(var t=nn(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),r)}function d(n,e){return void 0===e&&(e=!1),y(n)||r(n)||!t(n)?n:(o(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&i(n,(function(n,r){return d(r,!0)}),!0),n)}function h(){n(2)}function y(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function b(r){var t=tn[r];return t||n(18,r),t}function m(n,r){tn[n]||(tn[n]=r)}function _(){return"production"===process.env.NODE_ENV||U||n(0),U}function j(n,r){r&&(b("Patches"),n.u=[],n.s=[],n.v=r)}function O(n){g(n),n.p.forEach(S),n.p=null}function g(n){n===U&&(U=n.l)}function w(n){return U={p:[],l:U,h:n,m:!0,_:0}}function S(n){var r=n[Q];0===r.i||1===r.i?r.j():r.O=!0}function P(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.g||b("ES5").S(e,r,o),o?(i[Q].P&&(O(e),n(4)),t(r)&&(r=M(e,r),e.l||x(e,r)),e.u&&b("Patches").M(i[Q].t,r,e.u,e.s)):r=M(e,i,[]),O(e),e.u&&e.v(e.u,e.s),r!==H?r:void 0}function M(n,r,t){if(y(r))return r;var e=r[Q];if(!e)return i(r,(function(i,o){return A(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o;i(3===e.i?new Set(o):o,(function(r,i){return A(n,e,o,r,i,t)})),x(n,o,!1),t&&n.u&&b("Patches").R(e,t,n.u,n.s)}return e.o}function A(e,i,o,a,c,s){if("production"!==process.env.NODE_ENV&&c===o&&n(5),r(c)){var v=M(e,c,s&&i&&3!==i.i&&!u(i.D,a)?s.concat(a):void 0);if(f(o,a,v),!r(v))return;e.m=!1}if(t(c)&&!y(c)){if(!e.h.F&&e._<1)return;M(e,c),i&&i.A.l||x(e,c)}}function x(n,r,t){void 0===t&&(t=!1),n.h.F&&n.m&&d(r,t)}function z(n,r){var t=n[Q];return(t?p(t):n)[r]}function I(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t)}}function k(n){n.P||(n.P=!0,n.l&&k(n.l))}function E(n){n.o||(n.o=l(n.t))}function R(n,r,t){var e=s(r)?b("MapSet").N(r,t):v(r)?b("MapSet").T(r,t):n.g?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=en;t&&(i=[e],o=on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):b("ES5").J(r,t);return(t?t.A:_()).p.push(e),e}function D(e){return r(e)||n(22,e),function n(r){if(!t(r))return r;var e,u=r[Q],c=o(r);if(u){if(!u.P&&(u.i<4||!b("ES5").K(u)))return u.t;u.I=!0,e=F(r,c),u.I=!1}else e=F(r,c);return i(e,(function(r,t){u&&a(u.t,r)===t||f(e,r,n(t))})),3===c?new Set(e):e}(e)}function F(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}function N(){function t(n,r){var t=s[n];return t?t.enumerable=r:s[n]=t={configurable:!0,enumerable:r,get:function(){var r=this[Q];return"production"!==process.env.NODE_ENV&&f(r),en.get(r,n)},set:function(r){var t=this[Q];"production"!==process.env.NODE_ENV&&f(t),en.set(t,n,r)}},t}function e(n){for(var r=n.length-1;r>=0;r--){var t=n[r][Q];if(!t.P)switch(t.i){case 5:a(t)&&k(t);break;case 4:o(t)&&k(t)}}}function o(n){for(var r=n.t,t=n.k,e=nn(t),i=e.length-1;i>=0;i--){var o=e[i];if(o!==Q){var a=r[o];if(void 0===a&&!u(r,o))return!0;var f=t[o],s=f&&f[Q];if(s?s.t!==a:!c(f,a))return!0}}var v=!!r[Q];return e.length!==nn(r).length+(v?0:1)}function a(n){var r=n.k;if(r.length!==n.t.length)return!0;var t=Object.getOwnPropertyDescriptor(r,r.length-1);if(t&&!t.get)return!0;for(var e=0;e<r.length;e++)if(!r.hasOwnProperty(e))return!0;return!1}function f(r){r.O&&n(3,JSON.stringify(p(r)))}var s={};m("ES5",{J:function(n,r){var e=Array.isArray(n),i=function(n,r){if(n){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,""+i,t(i,!0));return e}var o=rn(r);delete o[Q];for(var u=nn(o),a=0;a<u.length;a++){var f=u[a];o[f]=t(f,n||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(r),o)}(e,n),o={i:e?5:4,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:i,o:null,O:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(n,t,o){o?r(t)&&t[Q].A===n&&e(n.p):(n.u&&function n(r){if(r&&"object"==typeof r){var t=r[Q];if(t){var e=t.t,o=t.k,f=t.D,c=t.i;if(4===c)i(o,(function(r){r!==Q&&(void 0!==e[r]||u(e,r)?f[r]||n(o[r]):(f[r]=!0,k(t)))})),i(e,(function(n){void 0!==o[n]||u(o,n)||(f[n]=!1,k(t))}));else if(5===c){if(a(t)&&(k(t),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)o.hasOwnProperty(l)||(f[l]=!0),void 0===f[l]&&n(o[l])}}}}(n.p[0]),e(n.p))},K:function(n){return 4===n.i?o(n):a(n)}})}function T(){function e(n){if(!t(n))return n;if(Array.isArray(n))return n.map(e);if(s(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(v(n))return new Set(Array.from(n).map(e));var r=Object.create(Object.getPrototypeOf(n));for(var i in n)r[i]=e(n[i]);return u(n,L)&&(r[L]=n[L]),r}function f(n){return r(n)?e(n):n}var c="add";m("Patches",{$:function(r,t){return t.forEach((function(t){for(var i=t.path,u=t.op,f=r,s=0;s<i.length-1;s++){var v=o(f),p=""+i[s];0!==v&&1!==v||"__proto__"!==p&&"constructor"!==p||n(24),"function"==typeof f&&"prototype"===p&&n(24),"object"!=typeof(f=a(f,p))&&n(15,i.join("/"))}var l=o(f),d=e(t.value),h=i[i.length-1];switch(u){case"replace":switch(l){case 2:return f.set(h,d);case 3:n(16);default:return f[h]=d}case c:switch(l){case 1:return"-"===h?f.push(d):f.splice(h,0,d);case 2:return f.set(h,d);case 3:return f.add(d);default:return f[h]=d}case"remove":switch(l){case 1:return f.splice(h,1);case 2:return f.delete(h);case 3:return f.delete(t.value);default:return delete f[h]}default:n(17,u)}})),r},R:function(n,r,t,e){switch(n.i){case 0:case 4:case 2:return function(n,r,t,e){var o=n.t,s=n.o;i(n.D,(function(n,i){var v=a(o,n),p=a(s,n),l=i?u(o,n)?"replace":c:"remove";if(v!==p||"replace"!==l){var d=r.concat(n);t.push("remove"===l?{op:l,path:d}:{op:l,path:d,value:p}),e.push(l===c?{op:"remove",path:d}:"remove"===l?{op:c,path:d,value:f(v)}:{op:"replace",path:d,value:f(v)})}}))}(n,r,t,e);case 5:case 1:return function(n,r,t,e){var i=n.t,o=n.D,u=n.o;if(u.length<i.length){var a=[u,i];i=a[0],u=a[1];var s=[e,t];t=s[0],e=s[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=r.concat([v]);t.push({op:"replace",path:p,value:f(u[v])}),e.push({op:"replace",path:p,value:f(i[v])})}for(var l=i.length;l<u.length;l++){var d=r.concat([l]);t.push({op:c,path:d,value:f(u[l])})}i.length<u.length&&e.push({op:"replace",path:r.concat(["length"]),value:i.length})}(n,r,t,e);case 3:return function(n,r,t,e){var i=n.t,o=n.o,u=0;i.forEach((function(n){if(!o.has(n)){var i=r.concat([u]);t.push({op:"remove",path:i,value:n}),e.unshift({op:c,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=r.concat([u]);t.push({op:c,path:o,value:n}),e.unshift({op:"remove",path:o,value:n})}u++}))}(n,r,t,e)}},M:function(n,r,t,e){t.push({op:"replace",path:[],value:r===H?void 0:r}),e.push({op:"replace",path:[],value:n})}})}function C(){function r(n,r){function t(){this.constructor=n}a(n,r),n.prototype=(t.prototype=r.prototype,new t)}function e(n){n.o||(n.D=new Map,n.o=new Map(n.t))}function o(n){n.o||(n.o=new Set,n.t.forEach((function(r){if(t(r)){var e=R(n.A.h,r,n);n.p.set(r,e),n.o.add(e)}else n.o.add(r)})))}function u(r){r.O&&n(3,JSON.stringify(p(r)))}var a=function(n,r){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t])})(n,r)},f=function(){function n(n,r){return this[Q]={i:2,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,D:void 0,t:n,k:this,C:!1,O:!1},this}r(n,Map);var o=n.prototype;return Object.defineProperty(o,"size",{get:function(){return p(this[Q]).size}}),o.has=function(n){return p(this[Q]).has(n)},o.set=function(n,r){var t=this[Q];return u(t),p(t).has(n)&&p(t).get(n)===r||(e(t),k(t),t.D.set(n,!0),t.o.set(n,r),t.D.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),e(r),k(r),r.t.has(n)?r.D.set(n,!1):r.D.delete(n),r.o.delete(n),!0},o.clear=function(){var n=this[Q];u(n),p(n).size&&(e(n),k(n),n.D=new Map,i(n.t,(function(r){n.D.set(r,!1)})),n.o.clear())},o.forEach=function(n,r){var t=this;p(this[Q]).forEach((function(e,i){n.call(r,t.get(i),i,t)}))},o.get=function(n){var r=this[Q];u(r);var i=p(r).get(n);if(r.I||!t(i))return i;if(i!==r.t.get(n))return i;var o=R(r.A.h,i,r);return e(r),r.o.set(n,o),o},o.keys=function(){return p(this[Q]).keys()},o.values=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.values()},n.next=function(){var n=t.next();return n.done?n:{done:!1,value:r.get(n.value)}},n},o.entries=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.entries()},n.next=function(){var n=t.next();if(n.done)return n;var e=r.get(n.value);return{done:!1,value:[n.value,e]}},n},o[V]=function(){return this.entries()},n}(),c=function(){function n(n,r){return this[Q]={i:3,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,t:n,k:this,p:new Map,O:!1,C:!1},this}r(n,Set);var t=n.prototype;return Object.defineProperty(t,"size",{get:function(){return p(this[Q]).size}}),t.has=function(n){var r=this[Q];return u(r),r.o?!!r.o.has(n)||!(!r.p.has(n)||!r.o.has(r.p.get(n))):r.t.has(n)},t.add=function(n){var r=this[Q];return u(r),this.has(n)||(o(r),k(r),r.o.add(n)),this},t.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),o(r),k(r),r.o.delete(n)||!!r.p.has(n)&&r.o.delete(r.p.get(n))},t.clear=function(){var n=this[Q];u(n),p(n).size&&(o(n),k(n),n.o.clear())},t.values=function(){var n=this[Q];return u(n),o(n),n.o.values()},t.entries=function(){var n=this[Q];return u(n),o(n),n.o.entries()},t.keys=function(){return this.values()},t[V]=function(){return this.values()},t.forEach=function(n,r){for(var t=this.values(),e=t.next();!e.done;)n.call(r,e.value,e.value,this),e=t.next()},n}();m("MapSet",{N:function(n,r){return new f(n,r)},T:function(n,r){return new c(n,r)}})}function J(){N(),C(),T()}function K(n){return n}function $(n){return n}var G,U,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H=W?Symbol.for("immer-nothing"):((G={})["immer-nothing"]=!0,G),L=W?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W?Symbol.for("immer-state"):"__$immer_state",V="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",Y={0:"Illegal state",1:"Immer drafts cannot have computed properties",2:"This object has been frozen and should not be mutated",3:function(n){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+n},4:"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",5:"Immer forbids circular references",6:"The first or second argument to `produce` must be a function",7:"The third argument to `produce` must be a function or undefined",8:"First argument to `createDraft` must be a plain object, an array, or an immerable object",9:"First argument to `finishDraft` must be a draft returned by `createDraft`",10:"The given draft is already finalized",11:"Object.defineProperty() cannot be used on an Immer draft",12:"Object.setPrototypeOf() cannot be used on an Immer draft",13:"Immer only supports deleting array indices",14:"Immer only supports setting array indices and the 'length' property",15:function(n){return"Cannot apply patch, path doesn't resolve: "+n},16:'Sets cannot have "replace" patches.',17:function(n){return"Unsupported patch operation: "+n},18:function(n){return"The plugin for '"+n+"' has not been loaded into Immer. To enable the plugin, import and call `enable"+n+"()` when initializing your application."},20:"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",21:function(n){return"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '"+n+"'"},22:function(n){return"'current' expects a draft, got: "+n},23:function(n){return"'original' expects a draft, got: "+n},24:"Patching reserved attributes like __proto__, prototype and constructor is not allowed"},Z=""+Object.prototype.constructor,nn="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,rn=Object.getOwnPropertyDescriptors||function(n){var r={};return nn(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t)})),r},tn={},en={get:function(n,r){if(r===Q)return n;var e=p(n);if(!u(e,r))return function(n,r,t){var e,i=I(r,t);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!t(i)?i:i===z(n.t,r)?(E(n),n.o[r]=R(n.A.h,i,n)):i},has:function(n,r){return r in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,r,t){var e=I(p(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=z(p(n),r),o=null==i?void 0:i[Q];if(o&&o.t===t)return n.o[r]=t,n.D[r]=!1,!0;if(c(t,i)&&(void 0!==t||u(n.t,r)))return!0;E(n),k(n)}return n.o[r]===t&&"number"!=typeof t&&(void 0!==t||r in n.o)||(n.o[r]=t,n.D[r]=!0,!0)},deleteProperty:function(n,r){return void 0!==z(n.t,r)||r in n.t?(n.D[r]=!1,E(n),k(n)):delete n.D[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=p(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||"length"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n(12)}},on={};i(en,(function(n,r){on[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)}})),on.deleteProperty=function(r,t){return"production"!==process.env.NODE_ENV&&isNaN(parseInt(t))&&n(13),on.set.call(this,r,t,void 0)},on.set=function(r,t,e){return"production"!==process.env.NODE_ENV&&"length"!==t&&isNaN(parseInt(t))&&n(14),en.set.call(this,r[0],t,e,r[0])};var un=function(){function e(r){var e=this;this.g=B,this.F=!0,this.produce=function(r,i,o){if("function"==typeof r&&"function"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return(t=i).call.apply(t,[r,n].concat(e))}))}}var f;if("function"!=typeof i&&n(6),void 0!==o&&"function"!=typeof o&&n(7),t(r)){var c=w(e),s=R(e,r,void 0),v=!0;try{f=i(s),v=!1}finally{v?O(c):g(c)}return"undefined"!=typeof Promise&&f instanceof Promise?f.then((function(n){return j(c,o),P(n,c)}),(function(n){throw O(c),n})):(j(c,o),P(f,c))}if(!r||"object"!=typeof r){if(void 0===(f=i(r))&&(f=r),f===H&&(f=void 0),e.F&&d(f,!0),o){var p=[],l=[];b("Patches").M(r,f,p,l),o(p,l)}return f}n(21,r)},this.produceWithPatches=function(n,r){if("function"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,o=e.produce(n,r,(function(n,r){t=n,i=r}));return"undefined"!=typeof Promise&&o instanceof Promise?o.then((function(n){return[n,t,i]})):[o,t,i]},"boolean"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),"boolean"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze)}var i=e.prototype;return i.createDraft=function(e){t(e)||n(8),r(e)&&(e=D(e));var i=w(this),o=R(this,e,void 0);return o[Q].C=!0,g(i),o},i.finishDraft=function(r,t){var e=r&&r[Q];"production"!==process.env.NODE_ENV&&(e&&e.C||n(9),e.I&&n(10));var i=e.A;return j(i,t),P(void 0,i)},i.setAutoFreeze=function(n){this.F=n},i.setUseProxies=function(r){r&&!B&&n(20),this.g=r},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var o=b("Patches").$;return r(n)?o(n,t):this.produce(n,(function(n){return o(n,t)}))},e}(),an=new un,fn=an.produce,cn=an.produceWithPatches.bind(an),sn=an.setAutoFreeze.bind(an),vn=an.setUseProxies.bind(an),pn=an.applyPatches.bind(an),ln=an.createDraft.bind(an),dn=an.finishDraft.bind(an);export default fn;export{un as Immer,pn as applyPatches,K as castDraft,$ as castImmutable,ln as createDraft,D as current,J as enableAllPlugins,N as enableES5,C as enableMapSet,T as enablePatches,dn as finishDraft,d as freeze,L as immerable,r as isDraft,t as isDraftable,H as nothing,e as original,fn as produce,cn as produceWithPatches,sn as setAutoFreeze,vn as setUseProxies};
+var _ref;
+
+// Should be no imports here!
+// Some things that should be evaluated before all else...
+// We only want to know if non-polyfilled symbols are available
+var hasSymbol = typeof Symbol !== "undefined" && typeof
+/*#__PURE__*/
+Symbol("x") === "symbol";
+var hasMap = typeof Map !== "undefined";
+var hasSet = typeof Set !== "undefined";
+var hasProxies = typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined";
+/**
+ * The sentinel value returned by producers to replace the draft with undefined.
+ */
+
+var NOTHING = hasSymbol ?
+/*#__PURE__*/
+Symbol.for("immer-nothing") : (_ref = {}, _ref["immer-nothing"] = true, _ref);
+/**
+ * To let Immer treat your class instances as plain immutable objects
+ * (albeit with a custom prototype), you must define either an instance property
+ * or a static property on each of your custom classes.
+ *
+ * Otherwise, your class instance will never be drafted, which means it won't be
+ * safe to mutate in a produce callback.
+ */
+
+var DRAFTABLE = hasSymbol ?
+/*#__PURE__*/
+Symbol.for("immer-draftable") : "__$immer_draftable";
+var DRAFT_STATE = hasSymbol ?
+/*#__PURE__*/
+Symbol.for("immer-state") : "__$immer_state"; // Even a polyfilled Symbol might provide Symbol.iterator
+
+var iteratorSymbol = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";
+
+var errors = {
+  0: "Illegal state",
+  1: "Immer drafts cannot have computed properties",
+  2: "This object has been frozen and should not be mutated",
+  3: function _(data) {
+    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
+  },
+  4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
+  5: "Immer forbids circular references",
+  6: "The first or second argument to `produce` must be a function",
+  7: "The third argument to `produce` must be a function or undefined",
+  8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
+  9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
+  10: "The given draft is already finalized",
+  11: "Object.defineProperty() cannot be used on an Immer draft",
+  12: "Object.setPrototypeOf() cannot be used on an Immer draft",
+  13: "Immer only supports deleting array indices",
+  14: "Immer only supports setting array indices and the 'length' property",
+  15: function _(path) {
+    return "Cannot apply patch, path doesn't resolve: " + path;
+  },
+  16: 'Sets cannot have "replace" patches.',
+  17: function _(op) {
+    return "Unsupported patch operation: " + op;
+  },
+  18: function _(plugin) {
+    return "The plugin for '" + plugin + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + plugin + "()` when initializing your application.";
+  },
+  20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
+  21: function _(thing) {
+    return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + thing + "'";
+  },
+  22: function _(thing) {
+    return "'current' expects a draft, got: " + thing;
+  },
+  23: function _(thing) {
+    return "'original' expects a draft, got: " + thing;
+  },
+  24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
+};
+function die(error) {
+  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
+    args[_key - 1] = arguments[_key];
+  }
+
+  if (process.env.NODE_ENV !== "production") {
+    var e = errors[error];
+    var msg = !e ? "unknown error nr: " + error : typeof e === "function" ? e.apply(null, args) : e;
+    throw new Error("[Immer] " + msg);
+  }
+
+  throw new Error("[Immer] minified error nr: " + error + (args.length ? " " + args.map(function (s) {
+    return "'" + s + "'";
+  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
+}
+
+/** Returns true if the given value is an Immer draft */
+
+/*#__PURE__*/
+
+function isDraft(value) {
+  return !!value && !!value[DRAFT_STATE];
+}
+/** Returns true if the given value can be drafted by Immer */
+
+/*#__PURE__*/
+
+function isDraftable(value) {
+  var _value$constructor;
+
+  if (!value) return false;
+  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);
+}
+var objectCtorString =
+/*#__PURE__*/
+Object.prototype.constructor.toString();
+/*#__PURE__*/
+
+function isPlainObject(value) {
+  if (!value || typeof value !== "object") return false;
+  var proto = Object.getPrototypeOf(value);
+
+  if (proto === null) {
+    return true;
+  }
+
+  var Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
+  if (Ctor === Object) return true;
+  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
+}
+function original(value) {
+  if (!isDraft(value)) die(23, value);
+  return value[DRAFT_STATE].base_;
+}
+/*#__PURE__*/
+
+var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function (obj) {
+  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
+} :
+/* istanbul ignore next */
+Object.getOwnPropertyNames;
+var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
+  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
+  var res = {};
+  ownKeys(target).forEach(function (key) {
+    res[key] = Object.getOwnPropertyDescriptor(target, key);
+  });
+  return res;
+};
+function each(obj, iter, enumerableOnly) {
+  if (enumerableOnly === void 0) {
+    enumerableOnly = false;
+  }
+
+  if (getArchtype(obj) === 0
+  /* Object */
+  ) {
+      (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function (key) {
+        if (!enumerableOnly || typeof key !== "symbol") iter(key, obj[key], obj);
+      });
+    } else {
+    obj.forEach(function (entry, index) {
+      return iter(index, entry, obj);
+    });
+  }
+}
+/*#__PURE__*/
+
+function getArchtype(thing) {
+  /* istanbul ignore next */
+  var state = thing[DRAFT_STATE];
+  return state ? state.type_ > 3 ? state.type_ - 4 // cause Object and Array map back from 4 and 5
+  : state.type_ // others are the same
+  : Array.isArray(thing) ? 1
+  /* Array */
+  : isMap(thing) ? 2
+  /* Map */
+  : isSet(thing) ? 3
+  /* Set */
+  : 0
+  /* Object */
+  ;
+}
+/*#__PURE__*/
+
+function has(thing, prop) {
+  return getArchtype(thing) === 2
+  /* Map */
+  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
+}
+/*#__PURE__*/
+
+function get(thing, prop) {
+  // @ts-ignore
+  return getArchtype(thing) === 2
+  /* Map */
+  ? thing.get(prop) : thing[prop];
+}
+/*#__PURE__*/
+
+function set(thing, propOrOldValue, value) {
+  var t = getArchtype(thing);
+  if (t === 2
+  /* Map */
+  ) thing.set(propOrOldValue, value);else if (t === 3
+  /* Set */
+  ) {
+      thing.delete(propOrOldValue);
+      thing.add(value);
+    } else thing[propOrOldValue] = value;
+}
+/*#__PURE__*/
+
+function is(x, y) {
+  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
+  if (x === y) {
+    return x !== 0 || 1 / x === 1 / y;
+  } else {
+    return x !== x && y !== y;
+  }
+}
+/*#__PURE__*/
+
+function isMap(target) {
+  return hasMap && target instanceof Map;
+}
+/*#__PURE__*/
+
+function isSet(target) {
+  return hasSet && target instanceof Set;
+}
+/*#__PURE__*/
+
+function latest(state) {
+  return state.copy_ || state.base_;
+}
+/*#__PURE__*/
+
+function shallowCopy(base) {
+  if (Array.isArray(base)) return Array.prototype.slice.call(base);
+  var descriptors = getOwnPropertyDescriptors(base);
+  delete descriptors[DRAFT_STATE];
+  var keys = ownKeys(descriptors);
+
+  for (var i = 0; i < keys.length; i++) {
+    var key = keys[i];
+    var desc = descriptors[key];
+
+    if (desc.writable === false) {
+      desc.writable = true;
+      desc.configurable = true;
+    } // like object.assign, we will read any _own_, get/set accessors. This helps in dealing
+    // with libraries that trap values, like mobx or vue
+    // unlike object.assign, non-enumerables will be copied as well
+
+
+    if (desc.get || desc.set) descriptors[key] = {
+      configurable: true,
+      writable: true,
+      enumerable: desc.enumerable,
+      value: base[key]
+    };
+  }
+
+  return Object.create(Object.getPrototypeOf(base), descriptors);
+}
+function freeze(obj, deep) {
+  if (deep === void 0) {
+    deep = false;
+  }
+
+  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
+
+  if (getArchtype(obj) > 1
+  /* Map or Set */
+  ) {
+      var desc = {
+        configurable: true,
+        writable: true,
+        value: dontMutateFrozenCollections
+      };
+      Object.defineProperties(obj, {
+        set: desc,
+        add: desc,
+        clear: desc,
+        delete: desc
+      });
+    }
+
+  Object.freeze(obj);
+  if (deep) each(obj, function (key, value) {
+    return freeze(value, true);
+  }, true);
+  return obj;
+}
+
+function dontMutateFrozenCollections() {
+  die(2);
+}
+
+function isFrozen(obj) {
+  if (obj == null || typeof obj !== "object") return true; // See #600, IE dies on non-objects in Object.isFrozen
+
+  return Object.isFrozen(obj);
+}
+
+/** Plugin utilities */
+
+var plugins = {};
+function getPlugin(pluginKey) {
+  var plugin = plugins[pluginKey];
+
+  if (!plugin) {
+    die(18, pluginKey);
+  } // @ts-ignore
+
+
+  return plugin;
+}
+function loadPlugin(pluginKey, implementation) {
+  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
+}
+
+var currentScope;
+function getCurrentScope() {
+  if (process.env.NODE_ENV !== "production" && !currentScope) die(0);
+  return currentScope;
+}
+
+function createScope(parent_, immer_) {
+  return {
+    drafts_: [],
+    parent_: parent_,
+    immer_: immer_,
+    // Whenever the modified draft contains a draft from another scope, we
+    // need to prevent auto-freezing so the unowned draft can be finalized.
+    canAutoFreeze_: true,
+    unfinalizedDrafts_: 0
+  };
+}
+
+function usePatchesInScope(scope, patchListener) {
+  if (patchListener) {
+    getPlugin("Patches"); // assert we have the plugin
+
+    scope.patches_ = [];
+    scope.inversePatches_ = [];
+    scope.patchListener_ = patchListener;
+  }
+}
+function revokeScope(scope) {
+  leaveScope(scope);
+  scope.drafts_.forEach(revokeDraft); // @ts-ignore
+
+  scope.drafts_ = null;
+}
+function leaveScope(scope) {
+  if (scope === currentScope) {
+    currentScope = scope.parent_;
+  }
+}
+function enterScope(immer) {
+  return currentScope = createScope(currentScope, immer);
+}
+
+function revokeDraft(draft) {
+  var state = draft[DRAFT_STATE];
+  if (state.type_ === 0
+  /* ProxyObject */
+  || state.type_ === 1
+  /* ProxyArray */
+  ) state.revoke_();else state.revoked_ = true;
+}
+
+function processResult(result, scope) {
+  scope.unfinalizedDrafts_ = scope.drafts_.length;
+  var baseDraft = scope.drafts_[0];
+  var isReplaced = result !== undefined && result !== baseDraft;
+  if (!scope.immer_.useProxies_) getPlugin("ES5").willFinalizeES5_(scope, result, isReplaced);
+
+  if (isReplaced) {
+    if (baseDraft[DRAFT_STATE].modified_) {
+      revokeScope(scope);
+      die(4);
+    }
+
+    if (isDraftable(result)) {
+      // Finalize the result in case it contains (or is) a subset of the draft.
+      result = finalize(scope, result);
+      if (!scope.parent_) maybeFreeze(scope, result);
+    }
+
+    if (scope.patches_) {
+      getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
+    }
+  } else {
+    // Finalize the base draft.
+    result = finalize(scope, baseDraft, []);
+  }
+
+  revokeScope(scope);
+
+  if (scope.patches_) {
+    scope.patchListener_(scope.patches_, scope.inversePatches_);
+  }
+
+  return result !== NOTHING ? result : undefined;
+}
+
+function finalize(rootScope, value, path) {
+  // Don't recurse in tho recursive data structures
+  if (isFrozen(value)) return value;
+  var state = value[DRAFT_STATE]; // A plain object, might need freezing, might contain drafts
+
+  if (!state) {
+    each(value, function (key, childValue) {
+      return finalizeProperty(rootScope, state, value, key, childValue, path);
+    }, true // See #590, don't recurse into non-enumerable of non drafted objects
+    );
+    return value;
+  } // Never finalize drafts owned by another scope.
+
+
+  if (state.scope_ !== rootScope) return value; // Unmodified draft, return the (frozen) original
+
+  if (!state.modified_) {
+    maybeFreeze(rootScope, state.base_, true);
+    return state.base_;
+  } // Not finalized yet, let's do that now
+
+
+  if (!state.finalized_) {
+    state.finalized_ = true;
+    state.scope_.unfinalizedDrafts_--;
+    var result = // For ES5, create a good copy from the draft first, with added keys and without deleted keys.
+    state.type_ === 4
+    /* ES5Object */
+    || state.type_ === 5
+    /* ES5Array */
+    ? state.copy_ = shallowCopy(state.draft_) : state.copy_; // Finalize all children of the copy
+    // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628
+    // Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line
+    // back to each(result, ....)
+
+    each(state.type_ === 3
+    /* Set */
+    ? new Set(result) : result, function (key, childValue) {
+      return finalizeProperty(rootScope, state, result, key, childValue, path);
+    }); // everything inside is frozen, we can freeze here
+
+    maybeFreeze(rootScope, result, false); // first time finalizing, let's create those patches
+
+    if (path && rootScope.patches_) {
+      getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
+    }
+  }
+
+  return state.copy_;
+}
+
+function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath) {
+  if (process.env.NODE_ENV !== "production" && childValue === targetObject) die(5);
+
+  if (isDraft(childValue)) {
+    var path = rootPath && parentState && parentState.type_ !== 3
+    /* Set */
+    && // Set objects are atomic since they have no keys.
+    !has(parentState.assigned_, prop) // Skip deep patches for assigned keys.
+    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.
+
+    var res = finalize(rootScope, childValue, path);
+    set(targetObject, prop, res); // Drafts from another scope must prevented to be frozen
+    // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze
+
+    if (isDraft(res)) {
+      rootScope.canAutoFreeze_ = false;
+    } else return;
+  } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.
+
+
+  if (isDraftable(childValue) && !isFrozen(childValue)) {
+    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
+      // optimization: if an object is not a draft, and we don't have to
+      // deepfreeze everything, and we are sure that no drafts are left in the remaining object
+      // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.
+      // This benefits especially adding large data tree's without further processing.
+      // See add-data.js perf test
+      return;
+    }
+
+    finalize(rootScope, childValue); // immer deep freezes plain objects, so if there is no parent state, we freeze as well
+
+    if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);
+  }
+}
+
+function maybeFreeze(scope, value, deep) {
+  if (deep === void 0) {
+    deep = false;
+  }
+
+  if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
+    freeze(value, deep);
+  }
+}
+
+/**
+* Returns a new draft of the `base` object.
+*
+* The second argument is the parent draft-state (used internally).
+*/
+
+function createProxyProxy(base, parent) {
+  var isArray = Array.isArray(base);
+  var state = {
+    type_: isArray ? 1
+    /* ProxyArray */
+    : 0
+    /* ProxyObject */
+    ,
+    // Track which produce call this is associated with.
+    scope_: parent ? parent.scope_ : getCurrentScope(),
+    // True for both shallow and deep changes.
+    modified_: false,
+    // Used during finalization.
+    finalized_: false,
+    // Track which properties have been assigned (true) or deleted (false).
+    assigned_: {},
+    // The parent draft state.
+    parent_: parent,
+    // The base state.
+    base_: base,
+    // The base proxy.
+    draft_: null,
+    // The base copy with any updated values.
+    copy_: null,
+    // Called by the `produce` function.
+    revoke_: null,
+    isManual_: false
+  }; // the traps must target something, a bit like the 'real' base.
+  // but also, we need to be able to determine from the target what the relevant state is
+  // (to avoid creating traps per instance to capture the state in closure,
+  // and to avoid creating weird hidden properties as well)
+  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)
+  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb
+
+  var target = state;
+  var traps = objectTraps;
+
+  if (isArray) {
+    target = [state];
+    traps = arrayTraps;
+  }
+
+  var _Proxy$revocable = Proxy.revocable(target, traps),
+      revoke = _Proxy$revocable.revoke,
+      proxy = _Proxy$revocable.proxy;
+
+  state.draft_ = proxy;
+  state.revoke_ = revoke;
+  return proxy;
+}
+/**
+* Object drafts
+*/
+
+var objectTraps = {
+  get: function get(state, prop) {
+    if (prop === DRAFT_STATE) return state;
+    var source = latest(state);
+
+    if (!has(source, prop)) {
+      // non-existing or non-own property...
+      return readPropFromProto(state, source, prop);
+    }
+
+    var value = source[prop];
+
+    if (state.finalized_ || !isDraftable(value)) {
+      return value;
+    } // Check for existing draft in modified state.
+    // Assigned values are never drafted. This catches any drafts we created, too.
+
+
+    if (value === peek(state.base_, prop)) {
+      prepareCopy(state);
+      return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);
+    }
+
+    return value;
+  },
+  has: function has(state, prop) {
+    return prop in latest(state);
+  },
+  ownKeys: function ownKeys(state) {
+    return Reflect.ownKeys(latest(state));
+  },
+  set: function set(state, prop
+  /* strictly not, but helps TS */
+  , value) {
+    var desc = getDescriptorFromProto(latest(state), prop);
+
+    if (desc === null || desc === void 0 ? void 0 : desc.set) {
+      // special case: if this write is captured by a setter, we have
+      // to trigger it with the correct context
+      desc.set.call(state.draft_, value);
+      return true;
+    }
+
+    if (!state.modified_) {
+      // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)
+      // from setting an existing property with value undefined to undefined (which is not a change)
+      var current = peek(latest(state), prop); // special case, if we assigning the original value to a draft, we can ignore the assignment
+
+      var currentState = current === null || current === void 0 ? void 0 : current[DRAFT_STATE];
+
+      if (currentState && currentState.base_ === value) {
+        state.copy_[prop] = value;
+        state.assigned_[prop] = false;
+        return true;
+      }
+
+      if (is(value, current) && (value !== undefined || has(state.base_, prop))) return true;
+      prepareCopy(state);
+      markChanged(state);
+    }
+
+    if (state.copy_[prop] === value && ( // special case: handle new props with value 'undefined'
+    value !== undefined || prop in state.copy_) || // special case: NaN
+    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true; // @ts-ignore
+
+    state.copy_[prop] = value;
+    state.assigned_[prop] = true;
+    return true;
+  },
+  deleteProperty: function deleteProperty(state, prop) {
+    // The `undefined` check is a fast path for pre-existing keys.
+    if (peek(state.base_, prop) !== undefined || prop in state.base_) {
+      state.assigned_[prop] = false;
+      prepareCopy(state);
+      markChanged(state);
+    } else {
+      // if an originally not assigned property was deleted
+      delete state.assigned_[prop];
+    } // @ts-ignore
+
+
+    if (state.copy_) delete state.copy_[prop];
+    return true;
+  },
+  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
+  // the same guarantee in ES5 mode.
+  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
+    var owner = latest(state);
+    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
+    if (!desc) return desc;
+    return {
+      writable: true,
+      configurable: state.type_ !== 1
+      /* ProxyArray */
+      || prop !== "length",
+      enumerable: desc.enumerable,
+      value: owner[prop]
+    };
+  },
+  defineProperty: function defineProperty() {
+    die(11);
+  },
+  getPrototypeOf: function getPrototypeOf(state) {
+    return Object.getPrototypeOf(state.base_);
+  },
+  setPrototypeOf: function setPrototypeOf() {
+    die(12);
+  }
+};
+/**
+* Array drafts
+*/
+
+var arrayTraps = {};
+each(objectTraps, function (key, fn) {
+  // @ts-ignore
+  arrayTraps[key] = function () {
+    arguments[0] = arguments[0][0];
+    return fn.apply(this, arguments);
+  };
+});
+
+arrayTraps.deleteProperty = function (state, prop) {
+  if (process.env.NODE_ENV !== "production" && isNaN(parseInt(prop))) die(13); // @ts-ignore
+
+  return arrayTraps.set.call(this, state, prop, undefined);
+};
+
+arrayTraps.set = function (state, prop, value) {
+  if (process.env.NODE_ENV !== "production" && prop !== "length" && isNaN(parseInt(prop))) die(14);
+  return objectTraps.set.call(this, state[0], prop, value, state[0]);
+}; // Access a property without creating an Immer draft.
+
+
+function peek(draft, prop) {
+  var state = draft[DRAFT_STATE];
+  var source = state ? latest(state) : draft;
+  return source[prop];
+}
+
+function readPropFromProto(state, source, prop) {
+  var _desc$get;
+
+  var desc = getDescriptorFromProto(source, prop);
+  return desc ? "value" in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the
+  // prototype, we should invoke it with the draft as context!
+  (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : undefined;
+}
+
+function getDescriptorFromProto(source, prop) {
+  // 'in' checks proto!
+  if (!(prop in source)) return undefined;
+  var proto = Object.getPrototypeOf(source);
+
+  while (proto) {
+    var desc = Object.getOwnPropertyDescriptor(proto, prop);
+    if (desc) return desc;
+    proto = Object.getPrototypeOf(proto);
+  }
+
+  return undefined;
+}
+
+function markChanged(state) {
+  if (!state.modified_) {
+    state.modified_ = true;
+
+    if (state.parent_) {
+      markChanged(state.parent_);
+    }
+  }
+}
+function prepareCopy(state) {
+  if (!state.copy_) {
+    state.copy_ = shallowCopy(state.base_);
+  }
+}
+
+var Immer =
+/*#__PURE__*/
+function () {
+  function Immer(config) {
+    var _this = this;
+
+    this.useProxies_ = hasProxies;
+    this.autoFreeze_ = true;
+    /**
+            * The `produce` function takes a value and a "recipe function" (whose
+            * return value often depends on the base state). The recipe function is
+            * free to mutate its first argument however it wants. All mutations are
+            * only ever applied to a __copy__ of the base state.
+            *
+            * Pass only a function to create a "curried producer" which relieves you
+            * from passing the recipe function every time.
+            *
+            * Only plain objects and arrays are made mutable. All other objects are
+            * considered uncopyable.
+            *
+            * Note: This function is __bound__ to its `Immer` instance.
+            *
+            * @param {any} base - the initial state
+            * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+            * @param {Function} patchListener - optional function that will be called with all the patches produced here
+            * @returns {any} a new state, or the initial state if nothing was modified
+            */
+
+    this.produce = function (base, recipe, patchListener) {
+      // curried invocation
+      if (typeof base === "function" && typeof recipe !== "function") {
+        var defaultBase = recipe;
+        recipe = base;
+        var self = _this;
+        return function curriedProduce(base) {
+          var _this2 = this;
+
+          if (base === void 0) {
+            base = defaultBase;
+          }
+
+          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
+            args[_key - 1] = arguments[_key];
+          }
+
+          return self.produce(base, function (draft) {
+            var _recipe;
+
+            return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));
+          }); // prettier-ignore
+        };
+      }
+
+      if (typeof recipe !== "function") die(6);
+      if (patchListener !== undefined && typeof patchListener !== "function") die(7);
+      var result; // Only plain objects, arrays, and "immerable classes" are drafted.
+
+      if (isDraftable(base)) {
+        var scope = enterScope(_this);
+        var proxy = createProxy(_this, base, undefined);
+        var hasError = true;
+
+        try {
+          result = recipe(proxy);
+          hasError = false;
+        } finally {
+          // finally instead of catch + rethrow better preserves original stack
+          if (hasError) revokeScope(scope);else leaveScope(scope);
+        }
+
+        if (typeof Promise !== "undefined" && result instanceof Promise) {
+          return result.then(function (result) {
+            usePatchesInScope(scope, patchListener);
+            return processResult(result, scope);
+          }, function (error) {
+            revokeScope(scope);
+            throw error;
+          });
+        }
+
+        usePatchesInScope(scope, patchListener);
+        return processResult(result, scope);
+      } else if (!base || typeof base !== "object") {
+        result = recipe(base);
+        if (result === undefined) result = base;
+        if (result === NOTHING) result = undefined;
+        if (_this.autoFreeze_) freeze(result, true);
+
+        if (patchListener) {
+          var p = [];
+          var ip = [];
+          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
+          patchListener(p, ip);
+        }
+
+        return result;
+      } else die(21, base);
+    };
+
+    this.produceWithPatches = function (base, recipe) {
+      // curried invocation
+      if (typeof base === "function") {
+        return function (state) {
+          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
+            args[_key2 - 1] = arguments[_key2];
+          }
+
+          return _this.produceWithPatches(state, function (draft) {
+            return base.apply(void 0, [draft].concat(args));
+          });
+        };
+      }
+
+      var patches, inversePatches;
+
+      var result = _this.produce(base, recipe, function (p, ip) {
+        patches = p;
+        inversePatches = ip;
+      });
+
+      if (typeof Promise !== "undefined" && result instanceof Promise) {
+        return result.then(function (nextState) {
+          return [nextState, patches, inversePatches];
+        });
+      }
+
+      return [result, patches, inversePatches];
+    };
+
+    if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === "boolean") this.setUseProxies(config.useProxies);
+    if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean") this.setAutoFreeze(config.autoFreeze);
+  }
+
+  var _proto = Immer.prototype;
+
+  _proto.createDraft = function createDraft(base) {
+    if (!isDraftable(base)) die(8);
+    if (isDraft(base)) base = current(base);
+    var scope = enterScope(this);
+    var proxy = createProxy(this, base, undefined);
+    proxy[DRAFT_STATE].isManual_ = true;
+    leaveScope(scope);
+    return proxy;
+  };
+
+  _proto.finishDraft = function finishDraft(draft, patchListener) {
+    var state = draft && draft[DRAFT_STATE];
+
+    if (process.env.NODE_ENV !== "production") {
+      if (!state || !state.isManual_) die(9);
+      if (state.finalized_) die(10);
+    }
+
+    var scope = state.scope_;
+    usePatchesInScope(scope, patchListener);
+    return processResult(undefined, scope);
+  }
+  /**
+          * Pass true to automatically freeze all copies created by Immer.
+          *
+          * By default, auto-freezing is enabled.
+          */
+  ;
+
+  _proto.setAutoFreeze = function setAutoFreeze(value) {
+    this.autoFreeze_ = value;
+  }
+  /**
+          * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+          * always faster than using ES5 proxies.
+          *
+          * By default, feature detection is used, so calling this is rarely necessary.
+          */
+  ;
+
+  _proto.setUseProxies = function setUseProxies(value) {
+    if (value && !hasProxies) {
+      die(20);
+    }
+
+    this.useProxies_ = value;
+  };
+
+  _proto.applyPatches = function applyPatches(base, patches) {
+    // If a patch replaces the entire state, take that replacement as base
+    // before applying patches
+    var i;
+
+    for (i = patches.length - 1; i >= 0; i--) {
+      var patch = patches[i];
+
+      if (patch.path.length === 0 && patch.op === "replace") {
+        base = patch.value;
+        break;
+      }
+    } // If there was a patch that replaced the entire state, start from the
+    // patch after that.
+
+
+    if (i > -1) {
+      patches = patches.slice(i + 1);
+    }
+
+    var applyPatchesImpl = getPlugin("Patches").applyPatches_;
+
+    if (isDraft(base)) {
+      // N.B: never hits if some patch a replacement, patches are never drafts
+      return applyPatchesImpl(base, patches);
+    } // Otherwise, produce a copy of the base state.
+
+
+    return this.produce(base, function (draft) {
+      return applyPatchesImpl(draft, patches);
+    });
+  };
+
+  return Immer;
+}();
+function createProxy(immer, value, parent) {
+  // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft
+  var draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : immer.useProxies_ ? createProxyProxy(value, parent) : getPlugin("ES5").createES5Proxy_(value, parent);
+  var scope = parent ? parent.scope_ : getCurrentScope();
+  scope.drafts_.push(draft);
+  return draft;
+}
+
+function current(value) {
+  if (!isDraft(value)) die(22, value);
+  return currentImpl(value);
+}
+
+function currentImpl(value) {
+  if (!isDraftable(value)) return value;
+  var state = value[DRAFT_STATE];
+  var copy;
+  var archType = getArchtype(value);
+
+  if (state) {
+    if (!state.modified_ && (state.type_ < 4 || !getPlugin("ES5").hasChanges_(state))) return state.base_; // Optimization: avoid generating new drafts during copying
+
+    state.finalized_ = true;
+    copy = copyHelper(value, archType);
+    state.finalized_ = false;
+  } else {
+    copy = copyHelper(value, archType);
+  }
+
+  each(copy, function (key, childValue) {
+    if (state && get(state.base_, key) === childValue) return; // no need to copy or search in something that didn't change
+
+    set(copy, key, currentImpl(childValue));
+  }); // In the future, we might consider freezing here, based on the current settings
+
+  return archType === 3
+  /* Set */
+  ? new Set(copy) : copy;
+}
+
+function copyHelper(value, archType) {
+  // creates a shallow copy, even if it is a map or set
+  switch (archType) {
+    case 2
+    /* Map */
+    :
+      return new Map(value);
+
+    case 3
+    /* Set */
+    :
+      // Set will be cloned as array temporarily, so that we can replace individual items
+      return Array.from(value);
+  }
+
+  return shallowCopy(value);
+}
+
+function enableES5() {
+  function willFinalizeES5_(scope, result, isReplaced) {
+    if (!isReplaced) {
+      if (scope.patches_) {
+        markChangesRecursively(scope.drafts_[0]);
+      } // This is faster when we don't care about which attributes changed.
+
+
+      markChangesSweep(scope.drafts_);
+    } // When a child draft is returned, look for changes.
+    else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {
+        markChangesSweep(scope.drafts_);
+      }
+  }
+
+  function createES5Draft(isArray, base) {
+    if (isArray) {
+      var draft = new Array(base.length);
+
+      for (var i = 0; i < base.length; i++) {
+        Object.defineProperty(draft, "" + i, proxyProperty(i, true));
+      }
+
+      return draft;
+    } else {
+      var _descriptors = getOwnPropertyDescriptors(base);
+
+      delete _descriptors[DRAFT_STATE];
+      var keys = ownKeys(_descriptors);
+
+      for (var _i = 0; _i < keys.length; _i++) {
+        var key = keys[_i];
+        _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);
+      }
+
+      return Object.create(Object.getPrototypeOf(base), _descriptors);
+    }
+  }
+
+  function createES5Proxy_(base, parent) {
+    var isArray = Array.isArray(base);
+    var draft = createES5Draft(isArray, base);
+    var state = {
+      type_: isArray ? 5
+      /* ES5Array */
+      : 4
+      /* ES5Object */
+      ,
+      scope_: parent ? parent.scope_ : getCurrentScope(),
+      modified_: false,
+      finalized_: false,
+      assigned_: {},
+      parent_: parent,
+      // base is the object we are drafting
+      base_: base,
+      // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)
+      draft_: draft,
+      copy_: null,
+      revoked_: false,
+      isManual_: false
+    };
+    Object.defineProperty(draft, DRAFT_STATE, {
+      value: state,
+      // enumerable: false <- the default
+      writable: true
+    });
+    return draft;
+  } // property descriptors are recycled to make sure we don't create a get and set closure per property,
+  // but share them all instead
+
+
+  var descriptors = {};
+
+  function proxyProperty(prop, enumerable) {
+    var desc = descriptors[prop];
+
+    if (desc) {
+      desc.enumerable = enumerable;
+    } else {
+      descriptors[prop] = desc = {
+        configurable: true,
+        enumerable: enumerable,
+        get: function get() {
+          var state = this[DRAFT_STATE];
+          if (process.env.NODE_ENV !== "production") assertUnrevoked(state); // @ts-ignore
+
+          return objectTraps.get(state, prop);
+        },
+        set: function set(value) {
+          var state = this[DRAFT_STATE];
+          if (process.env.NODE_ENV !== "production") assertUnrevoked(state); // @ts-ignore
+
+          objectTraps.set(state, prop, value);
+        }
+      };
+    }
+
+    return desc;
+  } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.
+
+
+  function markChangesSweep(drafts) {
+    // The natural order of drafts in the `scope` array is based on when they
+    // were accessed. By processing drafts in reverse natural order, we have a
+    // better chance of processing leaf nodes first. When a leaf node is known to
+    // have changed, we can avoid any traversal of its ancestor nodes.
+    for (var i = drafts.length - 1; i >= 0; i--) {
+      var state = drafts[i][DRAFT_STATE];
+
+      if (!state.modified_) {
+        switch (state.type_) {
+          case 5
+          /* ES5Array */
+          :
+            if (hasArrayChanges(state)) markChanged(state);
+            break;
+
+          case 4
+          /* ES5Object */
+          :
+            if (hasObjectChanges(state)) markChanged(state);
+            break;
+        }
+      }
+    }
+  }
+
+  function markChangesRecursively(object) {
+    if (!object || typeof object !== "object") return;
+    var state = object[DRAFT_STATE];
+    if (!state) return;
+    var base_ = state.base_,
+        draft_ = state.draft_,
+        assigned_ = state.assigned_,
+        type_ = state.type_;
+
+    if (type_ === 4
+    /* ES5Object */
+    ) {
+        // Look for added keys.
+        // probably there is a faster way to detect changes, as sweep + recurse seems to do some
+        // unnecessary work.
+        // also: probably we can store the information we detect here, to speed up tree finalization!
+        each(draft_, function (key) {
+          if (key === DRAFT_STATE) return; // The `undefined` check is a fast path for pre-existing keys.
+
+          if (base_[key] === undefined && !has(base_, key)) {
+            assigned_[key] = true;
+            markChanged(state);
+          } else if (!assigned_[key]) {
+            // Only untouched properties trigger recursion.
+            markChangesRecursively(draft_[key]);
+          }
+        }); // Look for removed keys.
+
+        each(base_, function (key) {
+          // The `undefined` check is a fast path for pre-existing keys.
+          if (draft_[key] === undefined && !has(draft_, key)) {
+            assigned_[key] = false;
+            markChanged(state);
+          }
+        });
+      } else if (type_ === 5
+    /* ES5Array */
+    ) {
+        if (hasArrayChanges(state)) {
+          markChanged(state);
+          assigned_.length = true;
+        }
+
+        if (draft_.length < base_.length) {
+          for (var i = draft_.length; i < base_.length; i++) {
+            assigned_[i] = false;
+          }
+        } else {
+          for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {
+            assigned_[_i2] = true;
+          }
+        } // Minimum count is enough, the other parts has been processed.
+
+
+        var min = Math.min(draft_.length, base_.length);
+
+        for (var _i3 = 0; _i3 < min; _i3++) {
+          // Only untouched indices trigger recursion.
+          if (!draft_.hasOwnProperty(_i3)) {
+            assigned_[_i3] = true;
+          }
+
+          if (assigned_[_i3] === undefined) markChangesRecursively(draft_[_i3]);
+        }
+      }
+  }
+
+  function hasObjectChanges(state) {
+    var base_ = state.base_,
+        draft_ = state.draft_; // Search for added keys and changed keys. Start at the back, because
+    // non-numeric keys are ordered by time of definition on the object.
+
+    var keys = ownKeys(draft_);
+
+    for (var i = keys.length - 1; i >= 0; i--) {
+      var key = keys[i];
+      if (key === DRAFT_STATE) continue;
+      var baseValue = base_[key]; // The `undefined` check is a fast path for pre-existing keys.
+
+      if (baseValue === undefined && !has(base_, key)) {
+        return true;
+      } // Once a base key is deleted, future changes go undetected, because its
+      // descriptor is erased. This branch detects any missed changes.
+      else {
+          var value = draft_[key];
+
+          var _state = value && value[DRAFT_STATE];
+
+          if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {
+            return true;
+          }
+        }
+    } // At this point, no keys were added or changed.
+    // Compare key count to determine if keys were deleted.
+
+
+    var baseIsDraft = !!base_[DRAFT_STATE];
+    return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE
+  }
+
+  function hasArrayChanges(state) {
+    var draft_ = state.draft_;
+    if (draft_.length !== state.base_.length) return true; // See #116
+    // If we first shorten the length, our array interceptors will be removed.
+    // If after that new items are added, result in the same original length,
+    // those last items will have no intercepting property.
+    // So if there is no own descriptor on the last position, we know that items were removed and added
+    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
+    // the last one
+    // last descriptor can be not a trap, if the array was extended
+
+    var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)
+
+    if (descriptor && !descriptor.get) return true; // if we miss a property, it has been deleted, so array probobaly changed
+
+    for (var i = 0; i < draft_.length; i++) {
+      if (!draft_.hasOwnProperty(i)) return true;
+    } // For all other cases, we don't have to compare, as they would have been picked up by the index setters
+
+
+    return false;
+  }
+
+  function hasChanges_(state) {
+    return state.type_ === 4
+    /* ES5Object */
+    ? hasObjectChanges(state) : hasArrayChanges(state);
+  }
+
+  function assertUnrevoked(state
+  /*ES5State | MapState | SetState*/
+  ) {
+    if (state.revoked_) die(3, JSON.stringify(latest(state)));
+  }
+
+  loadPlugin("ES5", {
+    createES5Proxy_: createES5Proxy_,
+    willFinalizeES5_: willFinalizeES5_,
+    hasChanges_: hasChanges_
+  });
+}
+
+// types only!
+function enableMapSet() {
+  /* istanbul ignore next */
+  var _extendStatics = function extendStatics(d, b) {
+    _extendStatics = Object.setPrototypeOf || {
+      __proto__: []
+    } instanceof Array && function (d, b) {
+      d.__proto__ = b;
+    } || function (d, b) {
+      for (var p in b) {
+        if (b.hasOwnProperty(p)) d[p] = b[p];
+      }
+    };
+
+    return _extendStatics(d, b);
+  }; // Ugly hack to resolve #502 and inherit built in Map / Set
+
+
+  function __extends(d, b) {
+    _extendStatics(d, b);
+
+    function __() {
+      Object.defineProperty(this, "constructor", {
+        value: d
+      });
+    }
+
+    d.prototype = ( // @ts-ignore
+    __.prototype = b.prototype, new __());
+  }
+
+  var DraftMap = function (_super) {
+    var _Object$definePropert;
+
+    __extends(DraftMap, _super); // Create class manually, cause #502
+
+
+    function DraftMap(target, parent) {
+      this[DRAFT_STATE] = {
+        type_: 2
+        /* Map */
+        ,
+        parent_: parent,
+        scope_: parent ? parent.scope_ : getCurrentScope(),
+        modified_: false,
+        finalized_: false,
+        copy_: undefined,
+        assigned_: undefined,
+        base_: target,
+        draft_: this,
+        isManual_: false,
+        revoked_: false
+      };
+      return this;
+    }
+
+    var p = DraftMap.prototype;
+    Object.defineProperties(p, (_Object$definePropert = {
+      size: {
+        get: function get() {
+          return latest(this[DRAFT_STATE]).size;
+        },
+        configurable: true
+      },
+      has: {
+        configurable: true,
+        writable: true,
+        value: function value(key) {
+          return latest(this[DRAFT_STATE]).has(key);
+        }
+      },
+      set: {
+        configurable: true,
+        writable: true,
+        value: function value(key, _value2) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (!latest(state).has(key) || latest(state).get(key) !== _value2) {
+            prepareMapCopy(state);
+            markChanged(state);
+            state.assigned_.set(key, true);
+            state.copy_.set(key, _value2);
+            state.assigned_.set(key, true);
+          }
+
+          return this;
+        }
+      },
+      delete: {
+        configurable: true,
+        writable: true,
+        value: function value(key) {
+          if (!this.has(key)) {
+            return false;
+          }
+
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareMapCopy(state);
+          markChanged(state);
+
+          if (state.base_.has(key)) {
+            state.assigned_.set(key, false);
+          } else {
+            state.assigned_.delete(key);
+          }
+
+          state.copy_.delete(key);
+          return true;
+        }
+      },
+      clear: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (latest(state).size) {
+            prepareMapCopy(state);
+            markChanged(state);
+            state.assigned_ = new Map();
+            each(state.base_, function (key) {
+              state.assigned_.set(key, false);
+            });
+            state.copy_.clear();
+          }
+        }
+      },
+      forEach: {
+        configurable: true,
+        writable: true,
+        value: function value(cb, thisArg) {
+          var _this = this;
+
+          var state = this[DRAFT_STATE];
+          latest(state).forEach(function (_value, key, _map) {
+            cb.call(thisArg, _this.get(key), key, _this);
+          });
+        }
+      },
+      get: {
+        configurable: true,
+        writable: true,
+        value: function value(key) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          var value = latest(state).get(key);
+
+          if (state.finalized_ || !isDraftable(value)) {
+            return value;
+          }
+
+          if (value !== state.base_.get(key)) {
+            return value; // either already drafted or reassigned
+          } // despite what it looks, this creates a draft only once, see above condition
+
+
+          var draft = createProxy(state.scope_.immer_, value, state);
+          prepareMapCopy(state);
+          state.copy_.set(key, draft);
+          return draft;
+        }
+      },
+      keys: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          return latest(this[DRAFT_STATE]).keys();
+        }
+      },
+      values: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var _this2 = this,
+              _ref;
+
+          var iterator = this.keys();
+          return _ref = {}, _ref[iteratorSymbol] = function () {
+            return _this2.values();
+          }, _ref.next = function next() {
+            var r = iterator.next();
+            /* istanbul ignore next */
+
+            if (r.done) return r;
+
+            var value = _this2.get(r.value);
+
+            return {
+              done: false,
+              value: value
+            };
+          }, _ref;
+        }
+      },
+      entries: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var _this3 = this,
+              _ref2;
+
+          var iterator = this.keys();
+          return _ref2 = {}, _ref2[iteratorSymbol] = function () {
+            return _this3.entries();
+          }, _ref2.next = function next() {
+            var r = iterator.next();
+            /* istanbul ignore next */
+
+            if (r.done) return r;
+
+            var value = _this3.get(r.value);
+
+            return {
+              done: false,
+              value: [r.value, value]
+            };
+          }, _ref2;
+        }
+      }
+    }, _Object$definePropert[iteratorSymbol] = {
+      configurable: true,
+      writable: true,
+      value: function value() {
+        return this.entries();
+      }
+    }, _Object$definePropert));
+    return DraftMap;
+  }(Map);
+
+  function proxyMap_(target, parent) {
+    // @ts-ignore
+    return new DraftMap(target, parent);
+  }
+
+  function prepareMapCopy(state) {
+    if (!state.copy_) {
+      state.assigned_ = new Map();
+      state.copy_ = new Map(state.base_);
+    }
+  }
+
+  var DraftSet = function (_super) {
+    var _Object$definePropert2;
+
+    __extends(DraftSet, _super); // Create class manually, cause #502
+
+
+    function DraftSet(target, parent) {
+      this[DRAFT_STATE] = {
+        type_: 3
+        /* Set */
+        ,
+        parent_: parent,
+        scope_: parent ? parent.scope_ : getCurrentScope(),
+        modified_: false,
+        finalized_: false,
+        copy_: undefined,
+        base_: target,
+        draft_: this,
+        drafts_: new Map(),
+        revoked_: false,
+        isManual_: false
+      };
+      return this;
+    }
+
+    var p = DraftSet.prototype;
+    Object.defineProperties(p, (_Object$definePropert2 = {
+      size: {
+        get: function get() {
+          return latest(this[DRAFT_STATE]).size;
+        },
+        configurable: true
+      },
+      has: {
+        configurable: true,
+        writable: true,
+        value: function value(_value3) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value
+
+          if (!state.copy_) {
+            return state.base_.has(_value3);
+          }
+
+          if (state.copy_.has(_value3)) return true;
+          if (state.drafts_.has(_value3) && state.copy_.has(state.drafts_.get(_value3))) return true;
+          return false;
+        }
+      },
+      add: {
+        configurable: true,
+        writable: true,
+        value: function value(_value4) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (!this.has(_value4)) {
+            prepareSetCopy(state);
+            markChanged(state);
+            state.copy_.add(_value4);
+          }
+
+          return this;
+        }
+      },
+      delete: {
+        configurable: true,
+        writable: true,
+        value: function value(_value5) {
+          if (!this.has(_value5)) {
+            return false;
+          }
+
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareSetCopy(state);
+          markChanged(state);
+          return state.copy_.delete(_value5) || (state.drafts_.has(_value5) ? state.copy_.delete(state.drafts_.get(_value5)) :
+          /* istanbul ignore next */
+          false);
+        }
+      },
+      clear: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (latest(state).size) {
+            prepareSetCopy(state);
+            markChanged(state);
+            state.copy_.clear();
+          }
+        }
+      },
+      values: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareSetCopy(state);
+          return state.copy_.values();
+        }
+      },
+      entries: {
+        configurable: true,
+        writable: true,
+        value: function entries() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareSetCopy(state);
+          return state.copy_.entries();
+        }
+      },
+      keys: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          return this.values();
+        }
+      }
+    }, _Object$definePropert2[iteratorSymbol] = {
+      configurable: true,
+      writable: true,
+      value: function value() {
+        return this.values();
+      }
+    }, _Object$definePropert2.forEach = {
+      configurable: true,
+      writable: true,
+      value: function forEach(cb, thisArg) {
+        var iterator = this.values();
+        var result = iterator.next();
+
+        while (!result.done) {
+          cb.call(thisArg, result.value, result.value, this);
+          result = iterator.next();
+        }
+      }
+    }, _Object$definePropert2));
+    return DraftSet;
+  }(Set);
+
+  function proxySet_(target, parent) {
+    // @ts-ignore
+    return new DraftSet(target, parent);
+  }
+
+  function prepareSetCopy(state) {
+    if (!state.copy_) {
+      // create drafts for all entries to preserve insertion order
+      state.copy_ = new Set();
+      state.base_.forEach(function (value) {
+        if (isDraftable(value)) {
+          var draft = createProxy(state.scope_.immer_, value, state);
+          state.drafts_.set(value, draft);
+          state.copy_.add(draft);
+        } else {
+          state.copy_.add(value);
+        }
+      });
+    }
+  }
+
+  function assertUnrevoked(state
+  /*ES5State | MapState | SetState*/
+  ) {
+    if (state.revoked_) die(3, JSON.stringify(latest(state)));
+  }
+
+  loadPlugin("MapSet", {
+    proxyMap_: proxyMap_,
+    proxySet_: proxySet_
+  });
+}
+
+function enableAllPlugins() {
+  enableES5();
+  enableMapSet();
+  enablePatches();
+}
+
+function enablePatches() {
+  var REPLACE = "replace";
+  var ADD = "add";
+  var REMOVE = "remove";
+
+  function generatePatches_(state, basePath, patches, inversePatches) {
+    switch (state.type_) {
+      case 0
+      /* ProxyObject */
+      :
+      case 4
+      /* ES5Object */
+      :
+      case 2
+      /* Map */
+      :
+        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
+
+      case 5
+      /* ES5Array */
+      :
+      case 1
+      /* ProxyArray */
+      :
+        return generateArrayPatches(state, basePath, patches, inversePatches);
+
+      case 3
+      /* Set */
+      :
+        return generateSetPatches(state, basePath, patches, inversePatches);
+    }
+  }
+
+  function generateArrayPatches(state, basePath, patches, inversePatches) {
+    var base_ = state.base_,
+        assigned_ = state.assigned_;
+    var copy_ = state.copy_; // Reduce complexity by ensuring `base` is never longer.
+
+    if (copy_.length < base_.length) {
+      var _ref = [copy_, base_];
+      base_ = _ref[0];
+      copy_ = _ref[1];
+      var _ref2 = [inversePatches, patches];
+      patches = _ref2[0];
+      inversePatches = _ref2[1];
+    } // Process replaced indices.
+
+
+    for (var i = 0; i < base_.length; i++) {
+      if (assigned_[i] && copy_[i] !== base_[i]) {
+        var path = basePath.concat([i]);
+        patches.push({
+          op: REPLACE,
+          path: path,
+          // Need to maybe clone it, as it can in fact be the original value
+          // due to the base/copy inversion at the start of this function
+          value: clonePatchValueIfNeeded(copy_[i])
+        });
+        inversePatches.push({
+          op: REPLACE,
+          path: path,
+          value: clonePatchValueIfNeeded(base_[i])
+        });
+      }
+    } // Process added indices.
+
+
+    for (var _i = base_.length; _i < copy_.length; _i++) {
+      var _path = basePath.concat([_i]);
+
+      patches.push({
+        op: ADD,
+        path: _path,
+        // Need to maybe clone it, as it can in fact be the original value
+        // due to the base/copy inversion at the start of this function
+        value: clonePatchValueIfNeeded(copy_[_i])
+      });
+    }
+
+    if (base_.length < copy_.length) {
+      inversePatches.push({
+        op: REPLACE,
+        path: basePath.concat(["length"]),
+        value: base_.length
+      });
+    }
+  } // This is used for both Map objects and normal objects.
+
+
+  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
+    var base_ = state.base_,
+        copy_ = state.copy_;
+    each(state.assigned_, function (key, assignedValue) {
+      var origValue = get(base_, key);
+      var value = get(copy_, key);
+      var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
+      if (origValue === value && op === REPLACE) return;
+      var path = basePath.concat(key);
+      patches.push(op === REMOVE ? {
+        op: op,
+        path: path
+      } : {
+        op: op,
+        path: path,
+        value: value
+      });
+      inversePatches.push(op === ADD ? {
+        op: REMOVE,
+        path: path
+      } : op === REMOVE ? {
+        op: ADD,
+        path: path,
+        value: clonePatchValueIfNeeded(origValue)
+      } : {
+        op: REPLACE,
+        path: path,
+        value: clonePatchValueIfNeeded(origValue)
+      });
+    });
+  }
+
+  function generateSetPatches(state, basePath, patches, inversePatches) {
+    var base_ = state.base_,
+        copy_ = state.copy_;
+    var i = 0;
+    base_.forEach(function (value) {
+      if (!copy_.has(value)) {
+        var path = basePath.concat([i]);
+        patches.push({
+          op: REMOVE,
+          path: path,
+          value: value
+        });
+        inversePatches.unshift({
+          op: ADD,
+          path: path,
+          value: value
+        });
+      }
+
+      i++;
+    });
+    i = 0;
+    copy_.forEach(function (value) {
+      if (!base_.has(value)) {
+        var path = basePath.concat([i]);
+        patches.push({
+          op: ADD,
+          path: path,
+          value: value
+        });
+        inversePatches.unshift({
+          op: REMOVE,
+          path: path,
+          value: value
+        });
+      }
+
+      i++;
+    });
+  }
+
+  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
+    patches.push({
+      op: REPLACE,
+      path: [],
+      value: replacement === NOTHING ? undefined : replacement
+    });
+    inversePatches.push({
+      op: REPLACE,
+      path: [],
+      value: baseValue
+    });
+  }
+
+  function applyPatches_(draft, patches) {
+    patches.forEach(function (patch) {
+      var path = patch.path,
+          op = patch.op;
+      var base = draft;
+
+      for (var i = 0; i < path.length - 1; i++) {
+        var parentType = getArchtype(base);
+        var p = "" + path[i]; // See #738, avoid prototype pollution
+
+        if ((parentType === 0
+        /* Object */
+        || parentType === 1
+        /* Array */
+        ) && (p === "__proto__" || p === "constructor")) die(24);
+        if (typeof base === "function" && p === "prototype") die(24);
+        base = get(base, p);
+        if (typeof base !== "object") die(15, path.join("/"));
+      }
+
+      var type = getArchtype(base);
+      var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411
+
+      var key = path[path.length - 1];
+
+      switch (op) {
+        case REPLACE:
+          switch (type) {
+            case 2
+            /* Map */
+            :
+              return base.set(key, value);
+
+            /* istanbul ignore next */
+
+            case 3
+            /* Set */
+            :
+              die(16);
+
+            default:
+              // if value is an object, then it's assigned by reference
+              // in the following add or remove ops, the value field inside the patch will also be modifyed
+              // so we use value from the cloned patch
+              // @ts-ignore
+              return base[key] = value;
+          }
+
+        case ADD:
+          switch (type) {
+            case 1
+            /* Array */
+            :
+              return key === "-" ? base.push(value) : base.splice(key, 0, value);
+
+            case 2
+            /* Map */
+            :
+              return base.set(key, value);
+
+            case 3
+            /* Set */
+            :
+              return base.add(value);
+
+            default:
+              return base[key] = value;
+          }
+
+        case REMOVE:
+          switch (type) {
+            case 1
+            /* Array */
+            :
+              return base.splice(key, 1);
+
+            case 2
+            /* Map */
+            :
+              return base.delete(key);
+
+            case 3
+            /* Set */
+            :
+              return base.delete(patch.value);
+
+            default:
+              return delete base[key];
+          }
+
+        default:
+          die(17, op);
+      }
+    });
+    return draft;
+  }
+
+  function deepClonePatchValue(obj) {
+    if (!isDraftable(obj)) return obj;
+    if (Array.isArray(obj)) return obj.map(deepClonePatchValue);
+    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function (_ref3) {
+      var k = _ref3[0],
+          v = _ref3[1];
+      return [k, deepClonePatchValue(v)];
+    }));
+    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
+    var cloned = Object.create(Object.getPrototypeOf(obj));
+
+    for (var key in obj) {
+      cloned[key] = deepClonePatchValue(obj[key]);
+    }
+
+    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
+    return cloned;
+  }
+
+  function clonePatchValueIfNeeded(obj) {
+    if (isDraft(obj)) {
+      return deepClonePatchValue(obj);
+    } else return obj;
+  }
+
+  loadPlugin("Patches", {
+    applyPatches_: applyPatches_,
+    generatePatches_: generatePatches_,
+    generateReplacementPatches_: generateReplacementPatches_
+  });
+}
+
+var immer =
+/*#__PURE__*/
+new Immer();
+/**
+* The `produce` function takes a value and a "recipe function" (whose
+* return value often depends on the base state). The recipe function is
+* free to mutate its first argument however it wants. All mutations are
+* only ever applied to a __copy__ of the base state.
+*
+* Pass only a function to create a "curried producer" which relieves you
+* from passing the recipe function every time.
+*
+* Only plain objects and arrays are made mutable. All other objects are
+* considered uncopyable.
+*
+* Note: This function is __bound__ to its `Immer` instance.
+*
+* @param {any} base - the initial state
+* @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+* @param {Function} patchListener - optional function that will be called with all the patches produced here
+* @returns {any} a new state, or the initial state if nothing was modified
+*/
+
+var produce = immer.produce;
+/**
+* Like `produce`, but `produceWithPatches` always returns a tuple
+* [nextState, patches, inversePatches] (instead of just the next state)
+*/
+
+var produceWithPatches =
+/*#__PURE__*/
+immer.produceWithPatches.bind(immer);
+/**
+* Pass true to automatically freeze all copies created by Immer.
+*
+* Always freeze by default, even in production mode
+*/
+
+var setAutoFreeze =
+/*#__PURE__*/
+immer.setAutoFreeze.bind(immer);
+/**
+* Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+* always faster than using ES5 proxies.
+*
+* By default, feature detection is used, so calling this is rarely necessary.
+*/
+
+var setUseProxies =
+/*#__PURE__*/
+immer.setUseProxies.bind(immer);
+/**
+* Apply an array of Immer patches to the first argument.
+*
+* This function is a producer, which means copy-on-write is in effect.
+*/
+
+var applyPatches =
+/*#__PURE__*/
+immer.applyPatches.bind(immer);
+/**
+* Create an Immer draft from the given base state, which may be a draft itself.
+* The draft can be modified until you finalize it with the `finishDraft` function.
+*/
+
+var createDraft =
+/*#__PURE__*/
+immer.createDraft.bind(immer);
+/**
+* Finalize an Immer draft from a `createDraft` call, returning the base state
+* (if no changes were made) or a modified copy. The draft must *not* be
+* mutated afterwards.
+*
+* Pass a function as the 2nd argument to generate Immer patches based on the
+* changes that were made.
+*/
+
+var finishDraft =
+/*#__PURE__*/
+immer.finishDraft.bind(immer);
+/**
+* This function is actually a no-op, but can be used to cast an immutable type
+* to an draft type and make TypeScript happy
+*
+* @param value
+*/
+
+function castDraft(value) {
+  return value;
+}
+/**
+* This function is actually a no-op, but can be used to cast a mutable type
+* to an immutable type and make TypeScript happy
+* @param value
+*/
+
+function castImmutable(value) {
+  return value;
+}
+
+export default produce;
+export { Immer, applyPatches, castDraft, castImmutable, createDraft, current, enableAllPlugins, enableES5, enableMapSet, enablePatches, finishDraft, freeze, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };
 //# sourceMappingURL=immer.esm.js.map
diff --git a/dist/immer.esm.js.map b/dist/immer.esm.js.map
index 1a55c22a4d54c6a0072e7e19308431ecabce7d0c..2bcda4f34328f420a45b62a02aa42c5b5cd68f24 100644
--- a/dist/immer.esm.js.map
+++ b/dist/immer.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"immer.esm.js","sources":["../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/patches.ts","../src/plugins/mapset.ts","../src/plugins/all.ts","../src/immer.ts","../src/utils/env.ts"],"sourcesContent":["const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\tbase: any,\n\t\trecipe?: any,\n\t): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tthis.constructor = d\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: false,\n\t\t\t// configurable: true\n\t\t})\n\n\t\tp.has = function(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tp.set = function(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.forEach = function(\n\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\tthisArg?: any\n\t\t) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tp.get = function(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp.entries = function(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.entries()\n\t\t}\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: true,\n\t\t})\n\n\t\tp.has = function(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tp.add = function(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tp.entries = function entries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp.forEach = function forEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n"],"names":["die","error","args","e","errors","msg","apply","Error","length","map","s","join","isDraft","value","DRAFT_STATE","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","toString","objectCtorString","isPlainObject","Array","isArray","DRAFTABLE","_value$constructor","isMap","isSet","original","base_","each","obj","iter","enumerableOnly","getArchtype","keys","ownKeys","forEach","key","entry","index","thing","state","type_","has","prop","prototype","get","set","propOrOldValue","t","delete","add","is","x","y","target","hasMap","Map","hasSet","Set","latest","copy_","shallowCopy","base","slice","descriptors","getOwnPropertyDescriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","loadPlugin","implementation","getCurrentScope","process","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createProxyProxy","createES5Proxy_","push","current","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","proxyProperty","this","assertUnrevoked","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","JSON","stringify","defineProperty","createES5Draft","markChangesRecursively","object","min","Math","enablePatches","deepClonePatchValue","entries","cloned","immerable","clonePatchValueIfNeeded","ADD","applyPatches_","patches","patch","op","parentType","p","type","splice","basePath","inversePatches","assignedValue","origValue","generatePatchesFromAssigned","generateArrayPatches","unshift","generateSetPatches","replacement","enableMapSet","__extends","d","b","__","extendStatics","prepareMapCopy","prepareSetCopy","setPrototypeOf","__proto__","DraftMap","size","cb","thisArg","_value","_this","values","iterator","iteratorSymbol","_this2","next","r","done","_this3","DraftSet","enableAllPlugins","castDraft","castImmutable","hasSymbol","Symbol","hasProxies","Reflect","for","data","getOwnPropertySymbols","getOwnPropertyNames","_desc$get","readPropFromProto","currentState","deleteProperty","owner","fn","arguments","isNaN","parseInt","Immer","config","recipe","defaultBase","self","produce","hasError","Promise","then","ip","produceWithPatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","applyPatchesImpl","bind"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"immer.esm.js","sources":["../src/utils/env.ts","../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/mapset.ts","../src/plugins/all.ts","../src/plugins/patches.ts","../src/immer.ts"],"sourcesContent":["// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import { DRAFT_STATE, DRAFTABLE, hasSet, Objectish, Drafted, AnyObject, AnyMap, AnySet, ImmerState, hasMap, Archtype, die } from \"../internal.js\";\r\n\n /** Returns true if the given value is an Immer draft */\r\n/*#__PURE__*/\r\nexport function isDraft(value: any): boolean {\r\n    return !!value && !!value[DRAFT_STATE];\r\n}\r\n\n /** Returns true if the given value can be drafted by Immer */\r\n/*#__PURE__*/\r\nexport function isDraftable(value: any): boolean {\r\n    if (!value)\r\n        return false;\r\n    return (isPlainObject(value) ||\r\n        Array.isArray(value) ||\r\n        !!value[DRAFTABLE] ||\r\n        !!value.constructor?.[DRAFTABLE] ||\r\n        isMap(value) ||\r\n        isSet(value));\r\n}\r\n\n const objectCtorString = Object.prototype.constructor.toString();\r\n/*#__PURE__*/\r\nexport function isPlainObject(value: any): boolean {\r\n    if (!value || typeof value !== \"object\")\r\n        return false;\r\n    const proto = Object.getPrototypeOf(value);\r\n    if (proto === null) {\r\n        return true;\r\n    }\r\n    const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\r\n    \n if (Ctor === Object)\r\n        return true;\r\n    \n return (typeof Ctor == \"function\" &&\r\n        Function.toString.call(Ctor) === objectCtorString);\r\n}\r\n\n /** Get the underlying object that is represented by the given draft */\r\n/*#__PURE__*/\r\nexport function original<T>(value: T): T | undefined;\r\nexport function original(value: Drafted<any>): any {\r\n    if (!isDraft(value))\r\n        die(23, value);\r\n    return value[DRAFT_STATE].base_;\r\n}\r\n\n /*#__PURE__*/\r\nexport const ownKeys: (target: AnyObject) => PropertyKey[] = typeof Reflect !== \"undefined\" && Reflect.ownKeys\r\n    ? Reflect.ownKeys\r\n    : typeof Object.getOwnPropertySymbols !== \"undefined\"\r\n        ? obj => Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj) as any)\r\n        : /* istanbul ignore next */ Object.getOwnPropertyNames;\r\n\n export const getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\r\n    function getOwnPropertyDescriptors(target: any) {\r\n        // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\r\n        const res: any = {};\r\n        ownKeys(target).forEach(key => {\r\n            res[key] = Object.getOwnPropertyDescriptor(target, key);\r\n        });\r\n        return res;\r\n    };\r\n\n export function each<T extends Objectish>(obj: T, iter: (key: string | number, value: any, source: T) => void, enumerableOnly?: boolean): void;\r\nexport function each(obj: any, iter: any, enumerableOnly = false) {\r\n    if (getArchtype(obj) === Archtype.Object) {\r\n        ;\r\n        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\r\n            if (!enumerableOnly || typeof key !== \"symbol\")\r\n                iter(key, obj[key], obj);\r\n        });\r\n    }\r\n    else {\r\n        obj.forEach((entry: any, index: any) => iter(index, entry, obj));\r\n    }\r\n}\r\n\n /*#__PURE__*/\r\nexport function getArchtype(thing: any): Archtype {\r\n    /* istanbul ignore next */\r\n    const state: undefined | ImmerState = thing[DRAFT_STATE];\r\n    return state\r\n        ? state.type_ > 3\r\n            ? state.type_ - 4 // cause Object and Array map back from 4 and 5\r\n            : (state.type_ as any) // others are the same\r\n        : Array.isArray(thing)\r\n            ? Archtype.Array\r\n            : isMap(thing)\r\n                ? Archtype.Map\r\n                : isSet(thing)\r\n                    ? Archtype.Set\r\n                    : Archtype.Object;\r\n}\r\n\n /*#__PURE__*/\r\nexport function has(thing: any, prop: PropertyKey): boolean {\r\n    return getArchtype(thing) === Archtype.Map\r\n        ? thing.has(prop)\r\n        : Object.prototype.hasOwnProperty.call(thing, prop);\r\n}\r\n\n /*#__PURE__*/\r\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\r\n    // @ts-ignore\r\n    return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop];\r\n}\r\n\n /*#__PURE__*/\r\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\r\n    const t = getArchtype(thing);\r\n    if (t === Archtype.Map)\r\n        thing.set(propOrOldValue, value);\r\n    else if (t === Archtype.Set) {\r\n        thing.delete(propOrOldValue);\r\n        thing.add(value);\r\n    }\r\n    else\r\n        thing[propOrOldValue] = value;\r\n}\r\n\n /*#__PURE__*/\r\nexport function is(x: any, y: any): boolean {\r\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\r\n    if (x === y) {\r\n        return x !== 0 || 1 / x === 1 / y;\r\n    }\r\n    else {\r\n        return x !== x && y !== y;\r\n    }\r\n}\r\n\n /*#__PURE__*/\r\nexport function isMap(target: any): target is AnyMap {\r\n    return hasMap && target instanceof Map;\r\n}\r\n\n /*#__PURE__*/\r\nexport function isSet(target: any): target is AnySet {\r\n    return hasSet && target instanceof Set;\r\n}\r\n/*#__PURE__*/\r\nexport function latest(state: ImmerState): any {\r\n    return state.copy_ || state.base_;\r\n}\r\n\n /*#__PURE__*/\r\nexport function shallowCopy(base: any) {\r\n    if (Array.isArray(base))\r\n        return Array.prototype.slice.call(base);\r\n    const descriptors = getOwnPropertyDescriptors(base);\r\n    delete descriptors[DRAFT_STATE as any];\r\n    let keys = ownKeys(descriptors);\r\n    for (let i = 0; i < keys.length; i++) {\r\n        const key: any = keys[i];\r\n        const desc = descriptors[key];\r\n        if (desc.writable === false) {\r\n            desc.writable = true;\r\n            desc.configurable = true;\r\n        }\r\n        // like object.assign, we will read any _own_, get/set accessors. This helps in dealing\r\n        // with libraries that trap values, like mobx or vue\r\n        // unlike object.assign, non-enumerables will be copied as well\r\n        if (desc.get || desc.set)\r\n            descriptors[key] = {\r\n                configurable: true,\r\n                writable: true,\r\n                enumerable: desc.enumerable,\r\n                value: base[key]\r\n            };\r\n    }\r\n    return Object.create(Object.getPrototypeOf(base), descriptors);\r\n}\r\n\n /**\r\n * Freezes draftable objects. Returns the original object.\r\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\r\n *\r\n * @param obj\r\n * @param deep\r\n */\r\nexport function freeze<T>(obj: T, deep?: boolean): T;\r\nexport function freeze<T>(obj: any, deep: boolean = false): T {\r\n    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))\r\n        return obj;\r\n    if (getArchtype(obj) > 1 /* Map or Set */) {\r\n        const desc: PropertyDescriptor = {\r\n            configurable: true,\r\n            writable: true,\r\n            value: dontMutateFrozenCollections\r\n        };\r\n        Object.defineProperties(obj, {\r\n            set: desc,\r\n            add: desc,\r\n            clear: desc,\r\n            delete: desc\r\n        });\r\n    }\r\n    Object.freeze(obj);\r\n    if (deep)\r\n        each(obj, (key, value) => freeze(value, true), true);\r\n    return obj;\r\n}\r\n\n function dontMutateFrozenCollections() {\r\n    die(2);\r\n}\r\n\n export function isFrozen(obj: any): boolean {\r\n    if (obj == null || typeof obj !== \"object\")\r\n        return true;\r\n    // See #600, IE dies on non-objects in Object.isFrozen\r\n    return Object.isFrozen(obj);\r\n}\r\n","import { ImmerState, Patch, ImmerScope, Drafted, AnyObject, ImmerBaseState, AnyMap, AnySet, ProxyType, die } from \"../internal.js\";\r\n\n /** Plugin utilities */\r\nconst plugins: {\r\n    Patches?: {\r\n        generatePatches_(state: ImmerState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]): void;\r\n        generateReplacementPatches_(base: any, replacement: any, patches: Patch[], inversePatches: Patch[]): void;\r\n        applyPatches_<T>(draft: T, patches: Patch[]): T;\r\n    };\r\n    ES5?: {\r\n        willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void;\r\n        createES5Proxy_<T>(base: T, parent?: ImmerState): Drafted<T, ES5ObjectState | ES5ArrayState>;\r\n        hasChanges_(state: ES5ArrayState | ES5ObjectState): boolean;\r\n    };\r\n    MapSet?: {\r\n        proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T;\r\n        proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T;\r\n    };\r\n} = {};\r\n\n type Plugins = typeof plugins;\r\n\n export function getPlugin<K extends keyof Plugins>(pluginKey: K): Exclude<Plugins[K], undefined> {\r\n    const plugin = plugins[pluginKey];\r\n    if (!plugin) {\r\n        die(18, pluginKey);\r\n    }\r\n    // @ts-ignore\r\n    return plugin;\r\n}\r\n\n export function loadPlugin<K extends keyof Plugins>(pluginKey: K, implementation: Plugins[K]): void {\r\n    if (!plugins[pluginKey])\r\n        plugins[pluginKey] = implementation;\r\n}\r\n\n /** ES5 Plugin */\r\n\n interface ES5BaseState extends ImmerBaseState {\r\n    assigned_: {\r\n        [key: string]: any;\r\n    };\r\n    parent_?: ImmerState;\r\n    revoked_: boolean;\r\n}\r\n\n export interface ES5ObjectState extends ES5BaseState {\r\n    type_: ProxyType.ES5Object;\r\n    draft_: Drafted<AnyObject, ES5ObjectState>;\r\n    base_: AnyObject;\r\n    copy_: AnyObject | null;\r\n}\r\n\n export interface ES5ArrayState extends ES5BaseState {\r\n    type_: ProxyType.ES5Array;\r\n    draft_: Drafted<AnyObject, ES5ArrayState>;\r\n    base_: any;\r\n    copy_: any;\r\n}\r\n\n /** Map / Set plugin */\r\n\n export interface MapState extends ImmerBaseState {\r\n    type_: ProxyType.Map;\r\n    copy_: AnyMap | undefined;\r\n    assigned_: Map<any, boolean> | undefined;\r\n    base_: AnyMap;\r\n    revoked_: boolean;\r\n    draft_: Drafted<AnyMap, MapState>;\r\n}\r\n\n export interface SetState extends ImmerBaseState {\r\n    type_: ProxyType.Set;\r\n    copy_: AnySet | undefined;\r\n    base_: AnySet;\r\n    drafts_: Map<any, Drafted>; // maps the original value to the draft value in the new set\r\n    revoked_: boolean;\r\n    draft_: Drafted<AnySet, SetState>;\r\n}\r\n\n /** Patches plugin */\r\n\n export type PatchPath = (string | number)[];\r\n","import { Patch, PatchListener, Drafted, Immer, DRAFT_STATE, ImmerState, ProxyType, getPlugin } from \"../internal.js\";\r\nimport { die } from \"../utils/errors.js\";\r\n\n /** Each scope represents a `produce` call. */\r\n\n export interface ImmerScope {\r\n    patches_?: Patch[];\r\n    inversePatches_?: Patch[];\r\n    canAutoFreeze_: boolean;\r\n    drafts_: any[];\r\n    parent_?: ImmerScope;\r\n    patchListener_?: PatchListener;\r\n    immer_: Immer;\r\n    unfinalizedDrafts_: number;\r\n}\r\n\n let currentScope: ImmerScope | undefined;\r\n\n export function getCurrentScope() {\r\n    if (__DEV__ && !currentScope)\r\n        die(0);\r\n    return currentScope!;\r\n}\r\n\n function createScope(parent_: ImmerScope | undefined, immer_: Immer): ImmerScope {\r\n    return {\r\n        drafts_: [],\r\n        parent_,\r\n        immer_,\r\n        // Whenever the modified draft contains a draft from another scope, we\r\n        // need to prevent auto-freezing so the unowned draft can be finalized.\r\n        canAutoFreeze_: true,\r\n        unfinalizedDrafts_: 0\r\n    };\r\n}\r\n\n export function usePatchesInScope(scope: ImmerScope, patchListener?: PatchListener) {\r\n    if (patchListener) {\r\n        getPlugin(\"Patches\"); // assert we have the plugin\r\n        scope.patches_ = [];\r\n        scope.inversePatches_ = [];\r\n        scope.patchListener_ = patchListener;\r\n    }\r\n}\r\n\n export function revokeScope(scope: ImmerScope) {\r\n    leaveScope(scope);\r\n    scope.drafts_.forEach(revokeDraft);\r\n    // @ts-ignore\r\n    scope.drafts_ = null;\r\n}\r\n\n export function leaveScope(scope: ImmerScope) {\r\n    if (scope === currentScope) {\r\n        currentScope = scope.parent_;\r\n    }\r\n}\r\n\n export function enterScope(immer: Immer) {\r\n    return (currentScope = createScope(currentScope, immer));\r\n}\r\n\n function revokeDraft(draft: Drafted) {\r\n    const state: ImmerState = draft[DRAFT_STATE];\r\n    if (state.type_ === ProxyType.ProxyObject ||\r\n        state.type_ === ProxyType.ProxyArray)\r\n        state.revoke_();\r\n    else\r\n        state.revoked_ = true;\r\n}\r\n","import { ImmerScope, DRAFT_STATE, isDraftable, NOTHING, PatchPath, each, has, freeze, ImmerState, isDraft, SetState, set, ProxyType, getPlugin, die, revokeScope, isFrozen, shallowCopy } from \"../internal.js\";\r\n\n export function processResult(result: any, scope: ImmerScope) {\r\n    scope.unfinalizedDrafts_ = scope.drafts_.length;\r\n    const baseDraft = scope.drafts_![0];\r\n    const isReplaced = result !== undefined && result !== baseDraft;\r\n    if (!scope.immer_.useProxies_)\r\n        getPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced);\r\n    if (isReplaced) {\r\n        if (baseDraft[DRAFT_STATE].modified_) {\r\n            revokeScope(scope);\r\n            die(4);\r\n        }\r\n        if (isDraftable(result)) {\r\n            // Finalize the result in case it contains (or is) a subset of the draft.\r\n            result = finalize(scope, result);\r\n            if (!scope.parent_)\r\n                maybeFreeze(scope, result);\r\n        }\r\n        if (scope.patches_) {\r\n            getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_!);\r\n        }\r\n    }\r\n    else {\r\n        // Finalize the base draft.\r\n        result = finalize(scope, baseDraft, []);\r\n    }\r\n    revokeScope(scope);\r\n    if (scope.patches_) {\r\n        scope.patchListener_!(scope.patches_, scope.inversePatches_!);\r\n    }\r\n    return result !== NOTHING ? result : undefined;\r\n}\r\n\n function finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\r\n    // Don't recurse in tho recursive data structures\r\n    if (isFrozen(value))\r\n        return value;\r\n    \n const state: ImmerState = value[DRAFT_STATE];\r\n    // A plain object, might need freezing, might contain drafts\r\n    if (!state) {\r\n        each(value, (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path), true // See #590, don't recurse into non-enumerable of non drafted objects\r\n        );\r\n        return value;\r\n    }\r\n    // Never finalize drafts owned by another scope.\r\n    if (state.scope_ !== rootScope)\r\n        return value;\r\n    // Unmodified draft, return the (frozen) original\r\n    if (!state.modified_) {\r\n        maybeFreeze(rootScope, state.base_, true);\r\n        return state.base_;\r\n    }\r\n    // Not finalized yet, let's do that now\r\n    if (!state.finalized_) {\r\n        state.finalized_ = true;\r\n        state.scope_.unfinalizedDrafts_--;\r\n        const result = \r\n        // For ES5, create a good copy from the draft first, with added keys and without deleted keys.\r\n        state.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\r\n            ? (state.copy_ = shallowCopy(state.draft_))\r\n            : state.copy_;\r\n        // Finalize all children of the copy\r\n        // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\r\n        // Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\r\n        // back to each(result, ....)\r\n        each(state.type_ === ProxyType.Set ? new Set(result) : result, (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path));\r\n        // everything inside is frozen, we can freeze here\r\n        maybeFreeze(rootScope, result, false);\r\n        // first time finalizing, let's create those patches\r\n        if (path && rootScope.patches_) {\r\n            getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_!);\r\n        }\r\n    }\r\n    return state.copy_;\r\n}\r\n\n function finalizeProperty(rootScope: ImmerScope, parentState: undefined | ImmerState, targetObject: any, prop: string | number, childValue: any, rootPath?: PatchPath) {\r\n    if (__DEV__ && childValue === targetObject)\r\n        die(5);\r\n    if (isDraft(childValue)) {\r\n        const path = rootPath &&\r\n            parentState &&\r\n            parentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\r\n            !has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\r\n            ? rootPath!.concat(prop)\r\n            : undefined;\r\n        // Drafts owned by `scope` are finalized here.\r\n        const res = finalize(rootScope, childValue, path);\r\n        set(targetObject, prop, res);\r\n        // Drafts from another scope must prevented to be frozen\r\n        // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\r\n        if (isDraft(res)) {\r\n            rootScope.canAutoFreeze_ = false;\r\n        }\r\n        else\r\n            return;\r\n    }\r\n    // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\r\n    if (isDraftable(childValue) && !isFrozen(childValue)) {\r\n        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\r\n            // optimization: if an object is not a draft, and we don't have to\r\n            // deepfreeze everything, and we are sure that no drafts are left in the remaining object\r\n            // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\r\n            // This benefits especially adding large data tree's without further processing.\r\n            // See add-data.js perf test\r\n            return;\r\n        }\r\n        finalize(rootScope, childValue);\r\n        // immer deep freezes plain objects, so if there is no parent state, we freeze as well\r\n        if (!parentState || !parentState.scope_.parent_)\r\n            maybeFreeze(rootScope, childValue);\r\n    }\r\n}\r\n\n function maybeFreeze(scope: ImmerScope, value: any, deep = false) {\r\n    if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\r\n        freeze(value, deep);\r\n    }\r\n}\r\n","import { each, has, is, isDraftable, shallowCopy, latest, ImmerBaseState, ImmerState, Drafted, AnyObject, AnyArray, Objectish, getCurrentScope, DRAFT_STATE, die, createProxy, ProxyType } from \"../internal.js\";\r\n\n interface ProxyBaseState extends ImmerBaseState {\r\n    assigned_: {\r\n        [property: string]: boolean;\r\n    };\r\n    parent_?: ImmerState;\r\n    revoke_(): void;\r\n}\r\n\n export interface ProxyObjectState extends ProxyBaseState {\r\n    type_: ProxyType.ProxyObject;\r\n    base_: any;\r\n    copy_: any;\r\n    draft_: Drafted<AnyObject, ProxyObjectState>;\r\n}\r\n\n export interface ProxyArrayState extends ProxyBaseState {\r\n    type_: ProxyType.ProxyArray;\r\n    base_: AnyArray;\r\n    copy_: AnyArray | null;\r\n    draft_: Drafted<AnyArray, ProxyArrayState>;\r\n}\r\n\n type ProxyState = ProxyObjectState | ProxyArrayState;\r\n\n /**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */\r\nexport function createProxyProxy<T extends Objectish>(base: T, parent?: ImmerState): Drafted<T, ProxyState> {\r\n    const isArray = Array.isArray(base);\r\n    const state: ProxyState = {\r\n        type_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\r\n        // Track which produce call this is associated with.\r\n        scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n        // True for both shallow and deep changes.\r\n        modified_: false,\r\n        // Used during finalization.\r\n        finalized_: false,\r\n        // Track which properties have been assigned (true) or deleted (false).\r\n        assigned_: {},\r\n        // The parent draft state.\r\n        parent_: parent,\r\n        // The base state.\r\n        base_: base,\r\n        // The base proxy.\r\n        draft_: null as any,\r\n        // The base copy with any updated values.\r\n        copy_: null,\r\n        // Called by the `produce` function.\r\n        revoke_: null as any,\r\n        isManual_: false\r\n    };\r\n    \n // the traps must target something, a bit like the 'real' base.\r\n    // but also, we need to be able to determine from the target what the relevant state is\r\n    // (to avoid creating traps per instance to capture the state in closure,\r\n    // and to avoid creating weird hidden properties as well)\r\n    // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\r\n    // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\r\n    let target: T = state as any;\r\n    let traps: ProxyHandler<object | Array<any>> = objectTraps;\r\n    if (isArray) {\r\n        target = [state] as any;\r\n        traps = arrayTraps;\r\n    }\r\n    \n const { revoke, proxy } = Proxy.revocable(target, traps);\r\n    state.draft_ = proxy as any;\r\n    state.revoke_ = revoke;\r\n    return proxy as any;\r\n}\r\n\n /**\r\n * Object drafts\r\n */\r\nexport const objectTraps: ProxyHandler<ProxyState> = {\r\n    get(state, prop) {\r\n        if (prop === DRAFT_STATE)\r\n            return state;\r\n        \n const source = latest(state);\r\n        if (!has(source, prop)) {\r\n            // non-existing or non-own property...\r\n            return readPropFromProto(state, source, prop);\r\n        }\r\n        const value = source[prop];\r\n        if (state.finalized_ || !isDraftable(value)) {\r\n            return value;\r\n        }\r\n        // Check for existing draft in modified state.\r\n        // Assigned values are never drafted. This catches any drafts we created, too.\r\n        if (value === peek(state.base_, prop)) {\r\n            prepareCopy(state);\r\n            return (state.copy_![prop as any] = createProxy(state.scope_.immer_, value, state));\r\n        }\r\n        return value;\r\n    },\r\n    has(state, prop) {\r\n        return prop in latest(state);\r\n    },\r\n    ownKeys(state) {\r\n        return Reflect.ownKeys(latest(state));\r\n    },\r\n    set(state: ProxyObjectState, prop: string /* strictly not, but helps TS */, value) {\r\n        const desc = getDescriptorFromProto(latest(state), prop);\r\n        if (desc?.set) {\r\n            // special case: if this write is captured by a setter, we have\r\n            // to trigger it with the correct context\r\n            desc.set.call(state.draft_, value);\r\n            return true;\r\n        }\r\n        if (!state.modified_) {\r\n            // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\r\n            // from setting an existing property with value undefined to undefined (which is not a change)\r\n            const current = peek(latest(state), prop);\r\n            // special case, if we assigning the original value to a draft, we can ignore the assignment\r\n            const currentState: ProxyObjectState = current?.[DRAFT_STATE];\r\n            if (currentState && currentState.base_ === value) {\r\n                state.copy_![prop] = value;\r\n                state.assigned_[prop] = false;\r\n                return true;\r\n            }\r\n            if (is(value, current) && (value !== undefined || has(state.base_, prop)))\r\n                return true;\r\n            prepareCopy(state);\r\n            markChanged(state);\r\n        }\r\n        \n if ((state.copy_![prop] === value &&\r\n            // special case: handle new props with value 'undefined'\r\n            (value !== undefined || prop in state.copy_)) ||\r\n            // special case: NaN\r\n            (Number.isNaN(value) && Number.isNaN(state.copy_![prop])))\r\n            return true;\r\n        \n // @ts-ignore\r\n        state.copy_![prop] = value;\r\n        state.assigned_[prop] = true;\r\n        return true;\r\n    },\r\n    deleteProperty(state, prop: string) {\r\n        // The `undefined` check is a fast path for pre-existing keys.\r\n        if (peek(state.base_, prop) !== undefined || prop in state.base_) {\r\n            state.assigned_[prop] = false;\r\n            prepareCopy(state);\r\n            markChanged(state);\r\n        }\r\n        else {\r\n            // if an originally not assigned property was deleted\r\n            delete state.assigned_[prop];\r\n        }\r\n        // @ts-ignore\r\n        if (state.copy_)\r\n            delete state.copy_[prop];\r\n        return true;\r\n    },\r\n    // Note: We never coerce `desc.value` into an Immer draft, because we can't make\r\n    // the same guarantee in ES5 mode.\r\n    getOwnPropertyDescriptor(state, prop) {\r\n        const owner = latest(state);\r\n        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\r\n        if (!desc)\r\n            return desc;\r\n        return {\r\n            writable: true,\r\n            configurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\r\n            enumerable: desc.enumerable,\r\n            value: owner[prop]\r\n        };\r\n    },\r\n    defineProperty() {\r\n        die(11);\r\n    },\r\n    getPrototypeOf(state) {\r\n        return Object.getPrototypeOf(state.base_);\r\n    },\r\n    setPrototypeOf() {\r\n        die(12);\r\n    }\r\n};\r\n\n /**\r\n * Array drafts\r\n */\r\n\n const arrayTraps: ProxyHandler<[\r\n    ProxyArrayState\r\n]> = {};\r\neach(objectTraps, (key, fn) => {\r\n    // @ts-ignore\r\n    arrayTraps[key] = function () {\r\n        arguments[0] = arguments[0][0];\r\n        return fn.apply(this, arguments);\r\n    };\r\n});\r\narrayTraps.deleteProperty = function (state, prop) {\r\n    if (__DEV__ && isNaN(parseInt(prop as any)))\r\n        die(13);\r\n    // @ts-ignore\r\n    return arrayTraps.set!.call(this, state, prop, undefined);\r\n};\r\narrayTraps.set = function (state, prop, value) {\r\n    if (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any)))\r\n        die(14);\r\n    return objectTraps.set!.call(this, state[0], prop, value, state[0]);\r\n};\r\n\n // Access a property without creating an Immer draft.\r\nfunction peek(draft: Drafted, prop: PropertyKey) {\r\n    const state = draft[DRAFT_STATE];\r\n    const source = state ? latest(state) : draft;\r\n    return source[prop];\r\n}\r\n\n function readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\r\n    const desc = getDescriptorFromProto(source, prop);\r\n    return desc\r\n        ? `value` in desc\r\n            ? desc.value\r\n            : // This is a very special case, if the prop is a getter defined by the\r\n                // prototype, we should invoke it with the draft as context!\r\n                desc.get?.call(state.draft_)\r\n        : undefined;\r\n}\r\n\n function getDescriptorFromProto(source: any, prop: PropertyKey): PropertyDescriptor | undefined {\r\n    // 'in' checks proto!\r\n    if (!(prop in source))\r\n        return undefined;\r\n    let proto = Object.getPrototypeOf(source);\r\n    while (proto) {\r\n        const desc = Object.getOwnPropertyDescriptor(proto, prop);\r\n        if (desc)\r\n            return desc;\r\n        proto = Object.getPrototypeOf(proto);\r\n    }\r\n    return undefined;\r\n}\r\n\n export function markChanged(state: ImmerState) {\r\n    if (!state.modified_) {\r\n        state.modified_ = true;\r\n        if (state.parent_) {\r\n            markChanged(state.parent_);\r\n        }\r\n    }\r\n}\r\n\n export function prepareCopy(state: {\r\n    base_: any;\r\n    copy_: any;\r\n}) {\r\n    if (!state.copy_) {\r\n        state.copy_ = shallowCopy(state.base_);\r\n    }\r\n}\r\n","import { IProduceWithPatches, IProduce, ImmerState, Drafted, isDraftable, processResult, Patch, Objectish, DRAFT_STATE, Draft, PatchListener, isDraft, isMap, isSet, createProxyProxy, getPlugin, die, hasProxies, enterScope, revokeScope, leaveScope, usePatchesInScope, getCurrentScope, NOTHING, freeze, current } from \"../internal.js\";\r\n\n interface ProducersFns {\r\n    produce: IProduce;\r\n    produceWithPatches: IProduceWithPatches;\r\n}\r\n\n export class Immer implements ProducersFns {\r\n    useProxies_: boolean = hasProxies;\r\n    \n autoFreeze_: boolean = true;\r\n    \n constructor(config?: {\r\n        useProxies?: boolean;\r\n        autoFreeze?: boolean;\r\n    }) {\r\n        if (typeof config?.useProxies === \"boolean\")\r\n            this.setUseProxies(config!.useProxies);\r\n        if (typeof config?.autoFreeze === \"boolean\")\r\n            this.setAutoFreeze(config!.autoFreeze);\r\n    }\r\n    \n /**\r\n         * The `produce` function takes a value and a \"recipe function\" (whose\r\n         * return value often depends on the base state). The recipe function is\r\n         * free to mutate its first argument however it wants. All mutations are\r\n         * only ever applied to a __copy__ of the base state.\r\n         *\r\n         * Pass only a function to create a \"curried producer\" which relieves you\r\n         * from passing the recipe function every time.\r\n         *\r\n         * Only plain objects and arrays are made mutable. All other objects are\r\n         * considered uncopyable.\r\n         *\r\n         * Note: This function is __bound__ to its `Immer` instance.\r\n         *\r\n         * @param {any} base - the initial state\r\n         * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n         * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n         * @returns {any} a new state, or the initial state if nothing was modified\r\n         */\r\n    produce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\r\n        // curried invocation\r\n        if (typeof base === \"function\" && typeof recipe !== \"function\") {\r\n            const defaultBase = recipe;\r\n            recipe = base;\r\n            \n const self = this;\r\n            return function curriedProduce(this: any, base = defaultBase, ...args: any[]) {\r\n                return self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)); // prettier-ignore\r\n            };\r\n        }\r\n        \n if (typeof recipe !== \"function\")\r\n            die(6);\r\n        if (patchListener !== undefined && typeof patchListener !== \"function\")\r\n            die(7);\r\n        \n let result;\r\n        \n // Only plain objects, arrays, and \"immerable classes\" are drafted.\r\n        if (isDraftable(base)) {\r\n            const scope = enterScope(this);\r\n            const proxy = createProxy(this, base, undefined);\r\n            let hasError = true;\r\n            try {\r\n                result = recipe(proxy);\r\n                hasError = false;\r\n            }\r\n            finally {\r\n                // finally instead of catch + rethrow better preserves original stack\r\n                if (hasError)\r\n                    revokeScope(scope);\r\n                else\r\n                    leaveScope(scope);\r\n            }\r\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n                return result.then(result => {\r\n                    usePatchesInScope(scope, patchListener);\r\n                    return processResult(result, scope);\r\n                }, error => {\r\n                    revokeScope(scope);\r\n                    throw error;\r\n                });\r\n            }\r\n            usePatchesInScope(scope, patchListener);\r\n            return processResult(result, scope);\r\n        }\r\n        else if (!base || typeof base !== \"object\") {\r\n            result = recipe(base);\r\n            if (result === undefined)\r\n                result = base;\r\n            if (result === NOTHING)\r\n                result = undefined;\r\n            if (this.autoFreeze_)\r\n                freeze(result, true);\r\n            if (patchListener) {\r\n                const p: Patch[] = [];\r\n                const ip: Patch[] = [];\r\n                getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\r\n                patchListener(p, ip);\r\n            }\r\n            return result;\r\n        }\r\n        else\r\n            die(21, base);\r\n    };\r\n    \n produceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\r\n        // curried invocation\r\n        if (typeof base === \"function\") {\r\n            return (state: any, ...args: any[]) => this.produceWithPatches(state, (draft: any) => base(draft, ...args));\r\n        }\r\n        \n let patches: Patch[], inversePatches: Patch[];\r\n        const result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\r\n            patches = p;\r\n            inversePatches = ip;\r\n        });\r\n        \n if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n            return result.then(nextState => [nextState, patches!, inversePatches!]);\r\n        }\r\n        return [result, patches!, inversePatches!];\r\n    };\r\n    \n createDraft<T extends Objectish>(base: T): Draft<T> {\r\n        if (!isDraftable(base))\r\n            die(8);\r\n        if (isDraft(base))\r\n            base = current(base);\r\n        const scope = enterScope(this);\r\n        const proxy = createProxy(this, base, undefined);\r\n        proxy[DRAFT_STATE].isManual_ = true;\r\n        leaveScope(scope);\r\n        return proxy as any;\r\n    }\r\n    \n finishDraft<D extends Draft<any>>(draft: D, patchListener?: PatchListener): D extends Draft<infer T> ? T : never {\r\n        const state: ImmerState = draft && (draft as any)[DRAFT_STATE];\r\n        if (__DEV__) {\r\n            if (!state || !state.isManual_)\r\n                die(9);\r\n            if (state.finalized_)\r\n                die(10);\r\n        }\r\n        const { scope_: scope } = state;\r\n        usePatchesInScope(scope, patchListener);\r\n        return processResult(undefined, scope);\r\n    }\r\n    \n /**\r\n         * Pass true to automatically freeze all copies created by Immer.\r\n         *\r\n         * By default, auto-freezing is enabled.\r\n         */\r\n    setAutoFreeze(value: boolean) {\r\n        this.autoFreeze_ = value;\r\n    }\r\n    \n /**\r\n         * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n         * always faster than using ES5 proxies.\r\n         *\r\n         * By default, feature detection is used, so calling this is rarely necessary.\r\n         */\r\n    setUseProxies(value: boolean) {\r\n        if (value && !hasProxies) {\r\n            die(20);\r\n        }\r\n        this.useProxies_ = value;\r\n    }\r\n    \n applyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\r\n        // If a patch replaces the entire state, take that replacement as base\r\n        // before applying patches\r\n        let i: number;\r\n        for (i = patches.length - 1; i >= 0; i--) {\r\n            const patch = patches[i];\r\n            if (patch.path.length === 0 && patch.op === \"replace\") {\r\n                base = patch.value;\r\n                break;\r\n            }\r\n        }\r\n        // If there was a patch that replaced the entire state, start from the\r\n        // patch after that.\r\n        if (i > -1) {\r\n            patches = patches.slice(i + 1);\r\n        }\r\n        \n const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\r\n        if (isDraft(base)) {\r\n            // N.B: never hits if some patch a replacement, patches are never drafts\r\n            return applyPatchesImpl(base, patches);\r\n        }\r\n        // Otherwise, produce a copy of the base state.\r\n        return this.produce(base, (draft: Drafted) => applyPatchesImpl(draft, patches));\r\n    }\r\n}\r\n\n export function createProxy<T extends Objectish>(immer: Immer, value: T, parent?: ImmerState): Drafted<T, ImmerState> {\r\n    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\r\n    const draft: Drafted = isMap(value)\r\n        ? getPlugin(\"MapSet\").proxyMap_(value, parent)\r\n        : isSet(value)\r\n            ? getPlugin(\"MapSet\").proxySet_(value, parent)\r\n            : immer.useProxies_\r\n                ? createProxyProxy(value, parent)\r\n                : getPlugin(\"ES5\").createES5Proxy_(value, parent);\r\n    \n const scope = parent ? parent.scope_ : getCurrentScope();\r\n    scope.drafts_.push(draft);\r\n    return draft;\r\n}\r\n","import { die, isDraft, shallowCopy, each, DRAFT_STATE, get, set, ImmerState, isDraftable, Archtype, getArchtype, getPlugin } from \"../internal.js\";\r\n\n /** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\r\nexport function current<T>(value: T): T;\r\nexport function current(value: any): any {\r\n    if (!isDraft(value))\r\n        die(22, value);\r\n    return currentImpl(value);\r\n}\r\n\n function currentImpl(value: any): any {\r\n    if (!isDraftable(value))\r\n        return value;\r\n    const state: ImmerState | undefined = value[DRAFT_STATE];\r\n    let copy: any;\r\n    const archType = getArchtype(value);\r\n    if (state) {\r\n        if (!state.modified_ &&\r\n            (state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any)))\r\n            return state.base_;\r\n        // Optimization: avoid generating new drafts during copying\r\n        state.finalized_ = true;\r\n        copy = copyHelper(value, archType);\r\n        state.finalized_ = false;\r\n    }\r\n    else {\r\n        copy = copyHelper(value, archType);\r\n    }\r\n    \n each(copy, (key, childValue) => {\r\n        if (state && get(state.base_, key) === childValue)\r\n            return; // no need to copy or search in something that didn't change\r\n        set(copy, key, currentImpl(childValue));\r\n    });\r\n    // In the future, we might consider freezing here, based on the current settings\r\n    return archType === Archtype.Set ? new Set(copy) : copy;\r\n}\r\n\n function copyHelper(value: any, archType: number): any {\r\n    // creates a shallow copy, even if it is a map or set\r\n    switch (archType) {\r\n        case Archtype.Map:\r\n            return new Map(value);\r\n        case Archtype.Set:\r\n            // Set will be cloned as array temporarily, so that we can replace individual items\r\n            return Array.from(value);\r\n    }\r\n    return shallowCopy(value);\r\n}\r\n","import { ImmerState, Drafted, ES5ArrayState, ES5ObjectState, each, has, isDraft, latest, DRAFT_STATE, is, loadPlugin, ImmerScope, ProxyType, getCurrentScope, die, markChanged, objectTraps, ownKeys, getOwnPropertyDescriptors } from \"../internal.js\";\r\n\n type ES5State = ES5ArrayState | ES5ObjectState;\r\n\n export function enableES5() {\r\n    function willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean) {\r\n        if (!isReplaced) {\r\n            if (scope.patches_) {\r\n                markChangesRecursively(scope.drafts_![0]);\r\n            }\r\n            // This is faster when we don't care about which attributes changed.\r\n            markChangesSweep(scope.drafts_);\r\n        }\r\n        // When a child draft is returned, look for changes.\r\n        else if (isDraft(result) &&\r\n            (result[DRAFT_STATE] as ES5State).scope_ === scope) {\r\n            markChangesSweep(scope.drafts_);\r\n        }\r\n    }\r\n    \n function createES5Draft(isArray: boolean, base: any) {\r\n        if (isArray) {\r\n            const draft = new Array(base.length);\r\n            for (let i = 0; i < base.length; i++)\r\n                Object.defineProperty(draft, \"\" + i, proxyProperty(i, true));\r\n            return draft;\r\n        }\r\n        else {\r\n            const descriptors = getOwnPropertyDescriptors(base);\r\n            delete descriptors[DRAFT_STATE as any];\r\n            const keys = ownKeys(descriptors);\r\n            for (let i = 0; i < keys.length; i++) {\r\n                const key: any = keys[i];\r\n                descriptors[key] = proxyProperty(key, isArray || !!descriptors[key].enumerable);\r\n            }\r\n            return Object.create(Object.getPrototypeOf(base), descriptors);\r\n        }\r\n    }\r\n    \n function createES5Proxy_<T>(base: T, parent?: ImmerState): Drafted<T, ES5ObjectState | ES5ArrayState> {\r\n        const isArray = Array.isArray(base);\r\n        const draft = createES5Draft(isArray, base);\r\n        \n const state: ES5ObjectState | ES5ArrayState = {\r\n            type_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\r\n            scope_: parent ? parent.scope_ : getCurrentScope(),\r\n            modified_: false,\r\n            finalized_: false,\r\n            assigned_: {},\r\n            parent_: parent,\r\n            // base is the object we are drafting\r\n            base_: base,\r\n            // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\r\n            draft_: draft,\r\n            copy_: null,\r\n            revoked_: false,\r\n            isManual_: false\r\n        };\r\n        \n Object.defineProperty(draft, DRAFT_STATE, {\r\n            value: state,\r\n            // enumerable: false <- the default\r\n            writable: true\r\n        });\r\n        return draft;\r\n    }\r\n    \n // property descriptors are recycled to make sure we don't create a get and set closure per property,\r\n    // but share them all instead\r\n    const descriptors: {\r\n        [prop: string]: PropertyDescriptor;\r\n    } = {};\r\n    \n function proxyProperty(prop: string | number, enumerable: boolean): PropertyDescriptor {\r\n        let desc = descriptors[prop];\r\n        if (desc) {\r\n            desc.enumerable = enumerable;\r\n        }\r\n        else {\r\n            descriptors[prop] = desc = {\r\n                configurable: true,\r\n                enumerable,\r\n                get(this: any) {\r\n                    const state = this[DRAFT_STATE];\r\n                    if (__DEV__)\r\n                        assertUnrevoked(state);\r\n                    // @ts-ignore\r\n                    return objectTraps.get(state, prop);\r\n                },\r\n                set(this: any, value) {\r\n                    const state = this[DRAFT_STATE];\r\n                    if (__DEV__)\r\n                        assertUnrevoked(state);\r\n                    // @ts-ignore\r\n                    objectTraps.set(state, prop, value);\r\n                }\r\n            };\r\n        }\r\n        return desc;\r\n    }\r\n    \n // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\r\n    function markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\r\n        // The natural order of drafts in the `scope` array is based on when they\r\n        // were accessed. By processing drafts in reverse natural order, we have a\r\n        // better chance of processing leaf nodes first. When a leaf node is known to\r\n        // have changed, we can avoid any traversal of its ancestor nodes.\r\n        for (let i = drafts.length - 1; i >= 0; i--) {\r\n            const state: ES5State = drafts[i][DRAFT_STATE];\r\n            if (!state.modified_) {\r\n                switch (state.type_) {\r\n                    case ProxyType.ES5Array:\r\n                        if (hasArrayChanges(state))\r\n                            markChanged(state);\r\n                        break;\r\n                    case ProxyType.ES5Object:\r\n                        if (hasObjectChanges(state))\r\n                            markChanged(state);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \n function markChangesRecursively(object: any) {\r\n        if (!object || typeof object !== \"object\")\r\n            return;\r\n        const state: ES5State | undefined = object[DRAFT_STATE];\r\n        if (!state)\r\n            return;\r\n        const { base_, draft_, assigned_, type_ } = state;\r\n        if (type_ === ProxyType.ES5Object) {\r\n            // Look for added keys.\r\n            // probably there is a faster way to detect changes, as sweep + recurse seems to do some\r\n            // unnecessary work.\r\n            // also: probably we can store the information we detect here, to speed up tree finalization!\r\n            each(draft_, key => {\r\n                if ((key as any) === DRAFT_STATE)\r\n                    return;\r\n                // The `undefined` check is a fast path for pre-existing keys.\r\n                if ((base_ as any)[key] === undefined && !has(base_, key)) {\r\n                    assigned_[key] = true;\r\n                    markChanged(state);\r\n                }\r\n                else if (!assigned_[key]) {\r\n                    // Only untouched properties trigger recursion.\r\n                    markChangesRecursively(draft_[key]);\r\n                }\r\n            });\r\n            // Look for removed keys.\r\n            each(base_, key => {\r\n                // The `undefined` check is a fast path for pre-existing keys.\r\n                if (draft_[key] === undefined && !has(draft_, key)) {\r\n                    assigned_[key] = false;\r\n                    markChanged(state);\r\n                }\r\n            });\r\n        }\r\n        else if (type_ === ProxyType.ES5Array) {\r\n            if (hasArrayChanges(state as ES5ArrayState)) {\r\n                markChanged(state);\r\n                assigned_.length = true;\r\n            }\r\n            \n if (draft_.length < base_.length) {\r\n                for (let i = draft_.length; i < base_.length; i++)\r\n                    assigned_[i] = false;\r\n            }\r\n            else {\r\n                for (let i = base_.length; i < draft_.length; i++)\r\n                    assigned_[i] = true;\r\n            }\r\n            \n // Minimum count is enough, the other parts has been processed.\r\n            const min = Math.min(draft_.length, base_.length);\r\n            \n for (let i = 0; i < min; i++) {\r\n                // Only untouched indices trigger recursion.\r\n                if (!draft_.hasOwnProperty(i)) {\r\n                    assigned_[i] = true;\r\n                }\r\n                if (assigned_[i] === undefined)\r\n                    markChangesRecursively(draft_[i]);\r\n            }\r\n        }\r\n    }\r\n    \n function hasObjectChanges(state: ES5ObjectState) {\r\n        const { base_, draft_ } = state;\r\n        \n // Search for added keys and changed keys. Start at the back, because\r\n        // non-numeric keys are ordered by time of definition on the object.\r\n        const keys = ownKeys(draft_);\r\n        for (let i = keys.length - 1; i >= 0; i--) {\r\n            const key: any = keys[i];\r\n            if (key === DRAFT_STATE)\r\n                continue;\r\n            const baseValue = base_[key];\r\n            // The `undefined` check is a fast path for pre-existing keys.\r\n            if (baseValue === undefined && !has(base_, key)) {\r\n                return true;\r\n            }\r\n            // Once a base key is deleted, future changes go undetected, because its\r\n            // descriptor is erased. This branch detects any missed changes.\r\n            else {\r\n                const value = draft_[key];\r\n                const state: ImmerState = value && value[DRAFT_STATE];\r\n                if (state ? state.base_ !== baseValue : !is(value, baseValue)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        \n // At this point, no keys were added or changed.\r\n        // Compare key count to determine if keys were deleted.\r\n        const baseIsDraft = !!base_[DRAFT_STATE as any];\r\n        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE\r\n    }\r\n    \n function hasArrayChanges(state: ES5ArrayState) {\r\n        const { draft_ } = state;\r\n        if (draft_.length !== state.base_.length)\r\n            return true;\r\n        // See #116\r\n        // If we first shorten the length, our array interceptors will be removed.\r\n        // If after that new items are added, result in the same original length,\r\n        // those last items will have no intercepting property.\r\n        // So if there is no own descriptor on the last position, we know that items were removed and added\r\n        // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\r\n        // the last one\r\n        // last descriptor can be not a trap, if the array was extended\r\n        const descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1);\r\n        // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\r\n        if (descriptor && !descriptor.get)\r\n            return true;\r\n        // if we miss a property, it has been deleted, so array probobaly changed\r\n        for (let i = 0; i < draft_.length; i++) {\r\n            if (!draft_.hasOwnProperty(i))\r\n                return true;\r\n        }\r\n        // For all other cases, we don't have to compare, as they would have been picked up by the index setters\r\n        return false;\r\n    }\r\n    \n function hasChanges_(state: ES5State) {\r\n        return state.type_ === ProxyType.ES5Object\r\n            ? hasObjectChanges(state)\r\n            : hasArrayChanges(state);\r\n    }\r\n    \n function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\r\n        if (state.revoked_)\r\n            die(3, JSON.stringify(latest(state)));\r\n    }\r\n    \n loadPlugin(\"ES5\", {\r\n        createES5Proxy_,\r\n        willFinalizeES5_,\r\n        hasChanges_\r\n    });\r\n}\r\n","// types only!\r\nimport { ImmerState, AnyMap, AnySet, MapState, SetState, DRAFT_STATE, getCurrentScope, latest, iteratorSymbol, isDraftable, createProxy, loadPlugin, markChanged, ProxyType, die, each } from \"../internal.js\";\r\n\n export function enableMapSet() {\r\n    /* istanbul ignore next */\r\n    var extendStatics = function (d: any, b: any): any {\r\n        extendStatics =\r\n            Object.setPrototypeOf ||\r\n                ({ __proto__: [] } instanceof Array &&\r\n                    function (d, b) {\r\n                        d.__proto__ = b;\r\n                    }) ||\r\n                function (d, b) {\r\n                    for (var p in b)\r\n                        if (b.hasOwnProperty(p))\r\n                            d[p] = b[p];\r\n                };\r\n        return extendStatics(d, b);\r\n    };\r\n    \n // Ugly hack to resolve #502 and inherit built in Map / Set\r\n    function __extends(d: any, b: any): any {\r\n        extendStatics(d, b);\r\n        function __(this: any): any {\r\n            Object.defineProperty(this, \"constructor\", {\r\n                value: d\r\n            });\r\n        }\r\n        d.prototype =\r\n            // @ts-ignore\r\n            ((__.prototype = b.prototype), new __());\r\n    }\r\n    \n const DraftMap = (function (_super) {\r\n        __extends(DraftMap, _super);\r\n        // Create class manually, cause #502\r\n        function DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\r\n            this[DRAFT_STATE] = {\r\n                type_: ProxyType.Map,\r\n                parent_: parent,\r\n                scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n                modified_: false,\r\n                finalized_: false,\r\n                copy_: undefined,\r\n                assigned_: undefined,\r\n                base_: target,\r\n                draft_: this as any,\r\n                isManual_: false,\r\n                revoked_: false\r\n            } as MapState;\r\n            return this;\r\n        }\r\n        const p = DraftMap.prototype;\r\n        \n Object.defineProperties(p, {\r\n            size: {\r\n                get: function () {\r\n                    return latest(this[DRAFT_STATE]).size;\r\n                },\r\n                configurable: true\r\n            },\r\n            has: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): boolean {\r\n                    return latest(this[DRAFT_STATE]).has(key);\r\n                }\r\n            },\r\n            set: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any, value: any) {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (!latest(state).has(key) || latest(state).get(key) !== value) {\r\n                        prepareMapCopy(state);\r\n                        markChanged(state);\r\n                        state.assigned_!.set(key, true);\r\n                        state.copy_!.set(key, value);\r\n                        state.assigned_!.set(key, true);\r\n                    }\r\n                    return this;\r\n                }\r\n            },\r\n            delete: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): boolean {\r\n                    if (!this.has(key)) {\r\n                        return false;\r\n                    }\r\n                    \n const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareMapCopy(state);\r\n                    markChanged(state);\r\n                    if (state.base_.has(key)) {\r\n                        state.assigned_!.set(key, false);\r\n                    }\r\n                    else {\r\n                        state.assigned_!.delete(key);\r\n                    }\r\n                    state.copy_!.delete(key);\r\n                    return true;\r\n                }\r\n            },\r\n            clear: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (latest(state).size) {\r\n                        prepareMapCopy(state);\r\n                        markChanged(state);\r\n                        state.assigned_ = new Map();\r\n                        each(state.base_, key => {\r\n                            state.assigned_!.set(key, false);\r\n                        });\r\n                        state.copy_!.clear();\r\n                    }\r\n                }\r\n            },\r\n            forEach: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (cb: (value: any, key: any, self: any) => void, thisArg?: any) {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    latest(state).forEach((_value: any, key: any, _map: any) => {\r\n                        cb.call(thisArg, this.get(key), key, this);\r\n                    });\r\n                }\r\n            },\r\n            get: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): any {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    const value = latest(state).get(key);\r\n                    if (state.finalized_ || !isDraftable(value)) {\r\n                        return value;\r\n                    }\r\n                    if (value !== state.base_.get(key)) {\r\n                        return value; // either already drafted or reassigned\r\n                    }\r\n                    // despite what it looks, this creates a draft only once, see above condition\r\n                    const draft = createProxy(state.scope_.immer_, value, state);\r\n                    prepareMapCopy(state);\r\n                    state.copy_!.set(key, draft);\r\n                    return draft;\r\n                }\r\n            },\r\n            keys: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    return latest(this[DRAFT_STATE]).keys();\r\n                }\r\n            },\r\n            values: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    const iterator = this.keys();\r\n                    return {\r\n                        [iteratorSymbol]: () => this.values(),\r\n                        next: () => {\r\n                            const r = iterator.next();\r\n                            /* istanbul ignore next */\r\n                            if (r.done)\r\n                                return r;\r\n                            const value = this.get(r.value);\r\n                            return {\r\n                                done: false,\r\n                                value\r\n                            };\r\n                        }\r\n                    } as any;\r\n                }\r\n            },\r\n            entries: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<[\r\n                    any,\r\n                    any\r\n                ]> {\r\n                    const iterator = this.keys();\r\n                    return {\r\n                        [iteratorSymbol]: () => this.entries(),\r\n                        next: () => {\r\n                            const r = iterator.next();\r\n                            /* istanbul ignore next */\r\n                            if (r.done)\r\n                                return r;\r\n                            const value = this.get(r.value);\r\n                            return {\r\n                                done: false,\r\n                                value: [r.value, value]\r\n                            };\r\n                        }\r\n                    } as any;\r\n                }\r\n            },\r\n            [iteratorSymbol]: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    return this.entries();\r\n                }\r\n            }\r\n        });\r\n        \n return DraftMap;\r\n    })(Map);\r\n    \n function proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\r\n        // @ts-ignore\r\n        return new DraftMap(target, parent);\r\n    }\r\n    \n function prepareMapCopy(state: MapState) {\r\n        if (!state.copy_) {\r\n            state.assigned_ = new Map();\r\n            state.copy_ = new Map(state.base_);\r\n        }\r\n    }\r\n    \n const DraftSet = (function (_super) {\r\n        __extends(DraftSet, _super);\r\n        // Create class manually, cause #502\r\n        function DraftSet(this: any, target: AnySet, parent?: ImmerState) {\r\n            this[DRAFT_STATE] = {\r\n                type_: ProxyType.Set,\r\n                parent_: parent,\r\n                scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n                modified_: false,\r\n                finalized_: false,\r\n                copy_: undefined,\r\n                base_: target,\r\n                draft_: this,\r\n                drafts_: new Map(),\r\n                revoked_: false,\r\n                isManual_: false\r\n            } as SetState;\r\n            return this;\r\n        }\r\n        const p = DraftSet.prototype;\r\n        \n Object.defineProperties(p, {\r\n            size: {\r\n                get: function () {\r\n                    return latest(this[DRAFT_STATE]).size;\r\n                },\r\n                configurable: true\r\n            },\r\n            has: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): boolean {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    // bit of trickery here, to be able to recognize both the value, and the draft of its value\r\n                    if (!state.copy_) {\r\n                        return state.base_.has(value);\r\n                    }\r\n                    if (state.copy_.has(value))\r\n                        return true;\r\n                    if (state.drafts_.has(value) &&\r\n                        state.copy_.has(state.drafts_.get(value)))\r\n                        return true;\r\n                    return false;\r\n                }\r\n            },\r\n            add: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): any {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (!this.has(value)) {\r\n                        prepareSetCopy(state);\r\n                        markChanged(state);\r\n                        state.copy_!.add(value);\r\n                    }\r\n                    return this;\r\n                }\r\n            },\r\n            delete: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): any {\r\n                    if (!this.has(value)) {\r\n                        return false;\r\n                    }\r\n                    \n const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    markChanged(state);\r\n                    return (state.copy_!.delete(value) ||\r\n                        (state.drafts_.has(value)\r\n                            ? state.copy_!.delete(state.drafts_.get(value))\r\n                            : /* istanbul ignore next */ false));\r\n                }\r\n            },\r\n            clear: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (latest(state).size) {\r\n                        prepareSetCopy(state);\r\n                        markChanged(state);\r\n                        state.copy_!.clear();\r\n                    }\r\n                }\r\n            },\r\n            values: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    return state.copy_!.values();\r\n                }\r\n            },\r\n            entries: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function entries(): IterableIterator<[\r\n                    any,\r\n                    any\r\n                ]> {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    return state.copy_!.entries();\r\n                }\r\n            },\r\n            keys: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    return this.values();\r\n                }\r\n            },\r\n            [iteratorSymbol]: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    return this.values();\r\n                }\r\n            },\r\n            forEach: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function forEach(cb: any, thisArg?: any) {\r\n                    const iterator = this.values();\r\n                    let result = iterator.next();\r\n                    while (!result.done) {\r\n                        cb.call(thisArg, result.value, result.value, this);\r\n                        result = iterator.next();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        \n return DraftSet;\r\n    })(Set);\r\n    \n function proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\r\n        // @ts-ignore\r\n        return new DraftSet(target, parent);\r\n    }\r\n    \n function prepareSetCopy(state: SetState) {\r\n        if (!state.copy_) {\r\n            // create drafts for all entries to preserve insertion order\r\n            state.copy_ = new Set();\r\n            state.base_.forEach(value => {\r\n                if (isDraftable(value)) {\r\n                    const draft = createProxy(state.scope_.immer_, value, state);\r\n                    state.drafts_.set(value, draft);\r\n                    state.copy_!.add(draft);\r\n                }\r\n                else {\r\n                    state.copy_!.add(value);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    \n function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\r\n        if (state.revoked_)\r\n            die(3, JSON.stringify(latest(state)));\r\n    }\r\n    \n loadPlugin(\"MapSet\", { proxyMap_, proxySet_ });\r\n}\r\n","import { enableES5 } from \"./es5.js\";\r\nimport { enableMapSet } from \"./mapset.js\";\r\nimport { enablePatches } from \"./patches.js\";\r\n\n export function enableAllPlugins() {\r\n    enableES5();\r\n    enableMapSet();\r\n    enablePatches();\r\n}\r\n","import { immerable } from \"../immer.js\";\r\nimport { ImmerState, Patch, SetState, ES5ArrayState, ProxyArrayState, MapState, ES5ObjectState, ProxyObjectState, PatchPath, get, each, has, getArchtype, isSet, isMap, loadPlugin, ProxyType, Archtype, die, isDraft, isDraftable, NOTHING } from \"../internal.js\";\r\n\n export function enablePatches() {\r\n    const REPLACE = \"replace\";\r\n    const ADD = \"add\";\r\n    const REMOVE = \"remove\";\r\n    \n function generatePatches_(state: ImmerState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]): void {\r\n        switch (state.type_) {\r\n            case ProxyType.ProxyObject:\r\n            case ProxyType.ES5Object:\r\n            case ProxyType.Map:\r\n                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\r\n            case ProxyType.ES5Array:\r\n            case ProxyType.ProxyArray:\r\n                return generateArrayPatches(state, basePath, patches, inversePatches);\r\n            case ProxyType.Set:\r\n                return generateSetPatches((state as any) as SetState, basePath, patches, inversePatches);\r\n        }\r\n    }\r\n    \n function generateArrayPatches(state: ES5ArrayState | ProxyArrayState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        let { base_, assigned_ } = state;\r\n        let copy_ = state.copy_!;\r\n        \n // Reduce complexity by ensuring `base` is never longer.\r\n        if (copy_.length < base_.length) {\r\n            // @ts-ignore\r\n            ;\r\n            [base_, copy_] = [copy_, base_];\r\n            [patches, inversePatches] = [inversePatches, patches];\r\n        }\r\n        \n // Process replaced indices.\r\n        for (let i = 0; i < base_.length; i++) {\r\n            if (assigned_[i] && copy_[i] !== base_[i]) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: REPLACE,\r\n                    path,\r\n                    // Need to maybe clone it, as it can in fact be the original value\r\n                    // due to the base/copy inversion at the start of this function\r\n                    value: clonePatchValueIfNeeded(copy_[i])\r\n                });\r\n                inversePatches.push({\r\n                    op: REPLACE,\r\n                    path,\r\n                    value: clonePatchValueIfNeeded(base_[i])\r\n                });\r\n            }\r\n        }\r\n        \n // Process added indices.\r\n        for (let i = base_.length; i < copy_.length; i++) {\r\n            const path = basePath.concat([i]);\r\n            patches.push({\r\n                op: ADD,\r\n                path,\r\n                // Need to maybe clone it, as it can in fact be the original value\r\n                // due to the base/copy inversion at the start of this function\r\n                value: clonePatchValueIfNeeded(copy_[i])\r\n            });\r\n        }\r\n        if (base_.length < copy_.length) {\r\n            inversePatches.push({\r\n                op: REPLACE,\r\n                path: basePath.concat([\"length\"]),\r\n                value: base_.length\r\n            });\r\n        }\r\n    }\r\n    \n // This is used for both Map objects and normal objects.\r\n    function generatePatchesFromAssigned(state: MapState | ES5ObjectState | ProxyObjectState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        const { base_, copy_ } = state;\r\n        each(state.assigned_!, (key, assignedValue) => {\r\n            const origValue = get(base_, key);\r\n            const value = get(copy_!, key);\r\n            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\r\n            if (origValue === value && op === REPLACE)\r\n                return;\r\n            const path = basePath.concat(key as any);\r\n            patches.push(op === REMOVE ? { op, path } : { op, path, value });\r\n            inversePatches.push(op === ADD\r\n                ? { op: REMOVE, path }\r\n                : op === REMOVE\r\n                    ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) }\r\n                    : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) });\r\n        });\r\n    }\r\n    \n function generateSetPatches(state: SetState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        let { base_, copy_ } = state;\r\n        \n let i = 0;\r\n        base_.forEach((value: any) => {\r\n            if (!copy_!.has(value)) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: REMOVE,\r\n                    path,\r\n                    value\r\n                });\r\n                inversePatches.unshift({\r\n                    op: ADD,\r\n                    path,\r\n                    value\r\n                });\r\n            }\r\n            i++;\r\n        });\r\n        i = 0;\r\n        copy_!.forEach((value: any) => {\r\n            if (!base_.has(value)) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: ADD,\r\n                    path,\r\n                    value\r\n                });\r\n                inversePatches.unshift({\r\n                    op: REMOVE,\r\n                    path,\r\n                    value\r\n                });\r\n            }\r\n            i++;\r\n        });\r\n    }\r\n    \n function generateReplacementPatches_(baseValue: any, replacement: any, patches: Patch[], inversePatches: Patch[]): void {\r\n        patches.push({\r\n            op: REPLACE,\r\n            path: [],\r\n            value: replacement === NOTHING ? undefined : replacement\r\n        });\r\n        inversePatches.push({\r\n            op: REPLACE,\r\n            path: [],\r\n            value: baseValue\r\n        });\r\n    }\r\n    \n function applyPatches_<T>(draft: T, patches: Patch[]): T {\r\n        patches.forEach(patch => {\r\n            const { path, op } = patch;\r\n            \n let base: any = draft;\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                const parentType = getArchtype(base);\r\n                const p = \"\" + path[i];\r\n                // See #738, avoid prototype pollution\r\n                if ((parentType === Archtype.Object || parentType === Archtype.Array) &&\r\n                    (p === \"__proto__\" || p === \"constructor\"))\r\n                    die(24);\r\n                if (typeof base === \"function\" && p === \"prototype\")\r\n                    die(24);\r\n                base = get(base, p);\r\n                if (typeof base !== \"object\")\r\n                    die(15, path.join(\"/\"));\r\n            }\r\n            \n const type = getArchtype(base);\r\n            const value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\r\n            const key = path[path.length - 1];\r\n            switch (op) {\r\n                case REPLACE:\r\n                    switch (type) {\r\n                        case Archtype.Map:\r\n                            return base.set(key, value);\r\n                        /* istanbul ignore next */\r\n                        case Archtype.Set:\r\n                            die(16);\r\n                        default:\r\n                            // if value is an object, then it's assigned by reference\r\n                            // in the following add or remove ops, the value field inside the patch will also be modifyed\r\n                            // so we use value from the cloned patch\r\n                            // @ts-ignore\r\n                            return (base[key] = value);\r\n                    }\r\n                case ADD:\r\n                    switch (type) {\r\n                        case Archtype.Array:\r\n                            return key === \"-\"\r\n                                ? base.push(value)\r\n                                : base.splice(key as any, 0, value);\r\n                        case Archtype.Map:\r\n                            return base.set(key, value);\r\n                        case Archtype.Set:\r\n                            return base.add(value);\r\n                        default:\r\n                            return (base[key] = value);\r\n                    }\r\n                case REMOVE:\r\n                    switch (type) {\r\n                        case Archtype.Array:\r\n                            return base.splice(key as any, 1);\r\n                        case Archtype.Map:\r\n                            return base.delete(key);\r\n                        case Archtype.Set:\r\n                            return base.delete(patch.value);\r\n                        default:\r\n                            return delete base[key];\r\n                    }\r\n                default:\r\n                    die(17, op);\r\n            }\r\n        });\r\n        \n return draft;\r\n    }\r\n    \n // optimize: this is quite a performance hit, can we detect intelligently when it is needed?\r\n    // E.g. auto-draft when new objects from outside are assigned and modified?\r\n    // (See failing test when deepClone just returns obj)\r\n    function deepClonePatchValue<T>(obj: T): T;\r\n    function deepClonePatchValue(obj: any) {\r\n        if (!isDraftable(obj))\r\n            return obj;\r\n        if (Array.isArray(obj))\r\n            return obj.map(deepClonePatchValue);\r\n        if (isMap(obj))\r\n            return new Map(Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)]));\r\n        if (isSet(obj))\r\n            return new Set(Array.from(obj).map(deepClonePatchValue));\r\n        const cloned = Object.create(Object.getPrototypeOf(obj));\r\n        for (const key in obj)\r\n            cloned[key] = deepClonePatchValue(obj[key]);\r\n        if (has(obj, immerable))\r\n            cloned[immerable] = obj[immerable];\r\n        return cloned;\r\n    }\r\n    \n function clonePatchValueIfNeeded<T>(obj: T): T {\r\n        if (isDraft(obj)) {\r\n            return deepClonePatchValue(obj);\r\n        }\r\n        else\r\n            return obj;\r\n    }\r\n    \n loadPlugin(\"Patches\", {\r\n        applyPatches_,\r\n        generatePatches_,\r\n        generateReplacementPatches_\r\n    });\r\n}\r\n","import { IProduce, IProduceWithPatches, Immer, Draft, Immutable } from \"./internal.js\";\r\n\n export { Draft, Immutable, Patch, PatchListener, original, current, isDraft, isDraftable, NOTHING as nothing, DRAFTABLE as immerable, freeze } from \"./internal.js\";\r\n\n const immer = new Immer();\r\n\n /**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */\r\nexport const produce: IProduce = immer.produce;\r\nexport default produce;\r\n\n /**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */\r\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(immer);\r\n\n /**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * Always freeze by default, even in production mode\r\n */\r\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer);\r\n\n /**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */\r\nexport const setUseProxies = immer.setUseProxies.bind(immer);\r\n\n /**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */\r\nexport const applyPatches = immer.applyPatches.bind(immer);\r\n\n /**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */\r\nexport const createDraft = immer.createDraft.bind(immer);\r\n\n /**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */\r\nexport const finishDraft = immer.finishDraft.bind(immer);\r\n\n /**\r\n * This function is actually a no-op, but can be used to cast an immutable type\r\n * to an draft type and make TypeScript happy\r\n *\r\n * @param value\r\n */\r\nexport function castDraft<T>(value: T): Draft<T> {\r\n    return value as any;\r\n}\r\n\n /**\r\n * This function is actually a no-op, but can be used to cast a mutable type\r\n * to an immutable type and make TypeScript happy\r\n * @param value\r\n */\r\nexport function castImmutable<T>(value: T): Immutable<T> {\r\n    return value as any;\r\n}\r\n\n export { Immer };\r\n\n export { enableES5 } from \"./plugins/es5.js\";\r\nexport { enablePatches } from \"./plugins/patches.js\";\r\nexport { enableMapSet } from \"./plugins/mapset.js\";\r\nexport { enableAllPlugins } from \"./plugins/all.js\";\r\n"],"names":["hasSymbol","Symbol","hasMap","Map","hasSet","Set","hasProxies","Proxy","revocable","Reflect","NOTHING","for","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","errors","data","path","op","plugin","thing","die","error","args","e","msg","apply","Error","length","map","s","join","isDraft","value","isDraftable","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","Object","prototype","toString","proto","getPrototypeOf","Ctor","hasOwnProperty","call","Function","original","base_","ownKeys","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","getOwnPropertyDescriptors","target","res","forEach","key","getOwnPropertyDescriptor","each","iter","enumerableOnly","getArchtype","keys","entry","index","state","type_","has","prop","get","set","propOrOldValue","t","delete","add","is","x","y","latest","copy_","shallowCopy","base","slice","descriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","dontMutateFrozenCollections","defineProperties","clear","plugins","getPlugin","pluginKey","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","autoFreeze_","createProxyProxy","parent","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","source","readPropFromProto","peek","prepareCopy","createProxy","getDescriptorFromProto","current","currentState","markChanged","Number","isNaN","deleteProperty","owner","defineProperty","setPrototypeOf","fn","arguments","parseInt","Immer","config","recipe","defaultBase","self","curriedProduce","produce","hasError","Promise","then","p","ip","produceWithPatches","patches","inversePatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","createES5Proxy_","push","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","markChangesRecursively","markChangesSweep","createES5Draft","proxyProperty","assertUnrevoked","drafts","hasArrayChanges","hasObjectChanges","object","min","Math","baseValue","baseIsDraft","descriptor","JSON","stringify","enableMapSet","extendStatics","d","b","__proto__","__extends","__","DraftMap","_super","size","prepareMapCopy","cb","thisArg","_value","_map","values","next","r","done","entries","DraftSet","prepareSetCopy","enableAllPlugins","enablePatches","REPLACE","ADD","REMOVE","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","clonePatchValueIfNeeded","assignedValue","origValue","unshift","replacement","parentType","type","deepClonePatchValue","splice","k","v","cloned","immerable","bind","castDraft","castImmutable"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/immer.esm.mjs b/dist/immer.esm.mjs
index 4ad55ff106409efdb53189e24445eceedb5bacfe..ef5bc2eaa123e6a9d552d8a62f19dc8c4a587807 100644
--- a/dist/immer.esm.mjs
+++ b/dist/immer.esm.mjs
@@ -1,2 +1,2120 @@
-function n(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];if("production"!==process.env.NODE_ENV){var i=Y[n],o=i?"function"==typeof i?i.apply(null,t):i:"unknown error nr: "+n;throw Error("[Immer] "+o)}throw Error("[Immer] minified error nr: "+n+(t.length?" "+t.map((function(n){return"'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r(n){return!!n&&!!n[Q]}function t(n){var r;return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var r=Object.getPrototypeOf(n);if(null===r)return!0;var t=Object.hasOwnProperty.call(r,"constructor")&&r.constructor;return t===Object||"function"==typeof t&&Function.toString.call(t)===Z}(n)||Array.isArray(n)||!!n[L]||!!(null===(r=n.constructor)||void 0===r?void 0:r[L])||s(n)||v(n))}function e(t){return r(t)||n(23,t),t[Q].t}function i(n,r,t){void 0===t&&(t=!1),0===o(n)?(t?Object.keys:nn)(n).forEach((function(e){t&&"symbol"==typeof e||r(e,n[e],n)})):n.forEach((function(t,e){return r(e,t,n)}))}function o(n){var r=n[Q];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:s(n)?2:v(n)?3:0}function u(n,r){return 2===o(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a(n,r){return 2===o(n)?n.get(r):n[r]}function f(n,r,t){var e=o(n);2===e?n.set(r,t):3===e?(n.delete(r),n.add(t)):n[r]=t}function c(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function s(n){return X&&n instanceof Map}function v(n){return q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=rn(n);delete r[Q];for(var t=nn(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),r)}function d(n,e){return void 0===e&&(e=!1),y(n)||r(n)||!t(n)?n:(o(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&i(n,(function(n,r){return d(r,!0)}),!0),n)}function h(){n(2)}function y(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function b(r){var t=tn[r];return t||n(18,r),t}function m(n,r){tn[n]||(tn[n]=r)}function _(){return"production"===process.env.NODE_ENV||U||n(0),U}function j(n,r){r&&(b("Patches"),n.u=[],n.s=[],n.v=r)}function O(n){g(n),n.p.forEach(S),n.p=null}function g(n){n===U&&(U=n.l)}function w(n){return U={p:[],l:U,h:n,m:!0,_:0}}function S(n){var r=n[Q];0===r.i||1===r.i?r.j():r.O=!0}function P(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.g||b("ES5").S(e,r,o),o?(i[Q].P&&(O(e),n(4)),t(r)&&(r=M(e,r),e.l||x(e,r)),e.u&&b("Patches").M(i[Q].t,r,e.u,e.s)):r=M(e,i,[]),O(e),e.u&&e.v(e.u,e.s),r!==H?r:void 0}function M(n,r,t){if(y(r))return r;var e=r[Q];if(!e)return i(r,(function(i,o){return A(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o;i(3===e.i?new Set(o):o,(function(r,i){return A(n,e,o,r,i,t)})),x(n,o,!1),t&&n.u&&b("Patches").R(e,t,n.u,n.s)}return e.o}function A(e,i,o,a,c,s){if("production"!==process.env.NODE_ENV&&c===o&&n(5),r(c)){var v=M(e,c,s&&i&&3!==i.i&&!u(i.D,a)?s.concat(a):void 0);if(f(o,a,v),!r(v))return;e.m=!1}if(t(c)&&!y(c)){if(!e.h.F&&e._<1)return;M(e,c),i&&i.A.l||x(e,c)}}function x(n,r,t){void 0===t&&(t=!1),n.h.F&&n.m&&d(r,t)}function z(n,r){var t=n[Q];return(t?p(t):n)[r]}function I(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t)}}function k(n){n.P||(n.P=!0,n.l&&k(n.l))}function E(n){n.o||(n.o=l(n.t))}function R(n,r,t){var e=s(r)?b("MapSet").N(r,t):v(r)?b("MapSet").T(r,t):n.g?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=en;t&&(i=[e],o=on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):b("ES5").J(r,t);return(t?t.A:_()).p.push(e),e}function D(e){return r(e)||n(22,e),function n(r){if(!t(r))return r;var e,u=r[Q],c=o(r);if(u){if(!u.P&&(u.i<4||!b("ES5").K(u)))return u.t;u.I=!0,e=F(r,c),u.I=!1}else e=F(r,c);return i(e,(function(r,t){u&&a(u.t,r)===t||f(e,r,n(t))})),3===c?new Set(e):e}(e)}function F(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}function N(){function t(n,r){var t=s[n];return t?t.enumerable=r:s[n]=t={configurable:!0,enumerable:r,get:function(){var r=this[Q];return"production"!==process.env.NODE_ENV&&f(r),en.get(r,n)},set:function(r){var t=this[Q];"production"!==process.env.NODE_ENV&&f(t),en.set(t,n,r)}},t}function e(n){for(var r=n.length-1;r>=0;r--){var t=n[r][Q];if(!t.P)switch(t.i){case 5:a(t)&&k(t);break;case 4:o(t)&&k(t)}}}function o(n){for(var r=n.t,t=n.k,e=nn(t),i=e.length-1;i>=0;i--){var o=e[i];if(o!==Q){var a=r[o];if(void 0===a&&!u(r,o))return!0;var f=t[o],s=f&&f[Q];if(s?s.t!==a:!c(f,a))return!0}}var v=!!r[Q];return e.length!==nn(r).length+(v?0:1)}function a(n){var r=n.k;if(r.length!==n.t.length)return!0;var t=Object.getOwnPropertyDescriptor(r,r.length-1);if(t&&!t.get)return!0;for(var e=0;e<r.length;e++)if(!r.hasOwnProperty(e))return!0;return!1}function f(r){r.O&&n(3,JSON.stringify(p(r)))}var s={};m("ES5",{J:function(n,r){var e=Array.isArray(n),i=function(n,r){if(n){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,""+i,t(i,!0));return e}var o=rn(r);delete o[Q];for(var u=nn(o),a=0;a<u.length;a++){var f=u[a];o[f]=t(f,n||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(r),o)}(e,n),o={i:e?5:4,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:i,o:null,O:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(n,t,o){o?r(t)&&t[Q].A===n&&e(n.p):(n.u&&function n(r){if(r&&"object"==typeof r){var t=r[Q];if(t){var e=t.t,o=t.k,f=t.D,c=t.i;if(4===c)i(o,(function(r){r!==Q&&(void 0!==e[r]||u(e,r)?f[r]||n(o[r]):(f[r]=!0,k(t)))})),i(e,(function(n){void 0!==o[n]||u(o,n)||(f[n]=!1,k(t))}));else if(5===c){if(a(t)&&(k(t),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)o.hasOwnProperty(l)||(f[l]=!0),void 0===f[l]&&n(o[l])}}}}(n.p[0]),e(n.p))},K:function(n){return 4===n.i?o(n):a(n)}})}function T(){function e(n){if(!t(n))return n;if(Array.isArray(n))return n.map(e);if(s(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(v(n))return new Set(Array.from(n).map(e));var r=Object.create(Object.getPrototypeOf(n));for(var i in n)r[i]=e(n[i]);return u(n,L)&&(r[L]=n[L]),r}function f(n){return r(n)?e(n):n}var c="add";m("Patches",{$:function(r,t){return t.forEach((function(t){for(var i=t.path,u=t.op,f=r,s=0;s<i.length-1;s++){var v=o(f),p=""+i[s];0!==v&&1!==v||"__proto__"!==p&&"constructor"!==p||n(24),"function"==typeof f&&"prototype"===p&&n(24),"object"!=typeof(f=a(f,p))&&n(15,i.join("/"))}var l=o(f),d=e(t.value),h=i[i.length-1];switch(u){case"replace":switch(l){case 2:return f.set(h,d);case 3:n(16);default:return f[h]=d}case c:switch(l){case 1:return"-"===h?f.push(d):f.splice(h,0,d);case 2:return f.set(h,d);case 3:return f.add(d);default:return f[h]=d}case"remove":switch(l){case 1:return f.splice(h,1);case 2:return f.delete(h);case 3:return f.delete(t.value);default:return delete f[h]}default:n(17,u)}})),r},R:function(n,r,t,e){switch(n.i){case 0:case 4:case 2:return function(n,r,t,e){var o=n.t,s=n.o;i(n.D,(function(n,i){var v=a(o,n),p=a(s,n),l=i?u(o,n)?"replace":c:"remove";if(v!==p||"replace"!==l){var d=r.concat(n);t.push("remove"===l?{op:l,path:d}:{op:l,path:d,value:p}),e.push(l===c?{op:"remove",path:d}:"remove"===l?{op:c,path:d,value:f(v)}:{op:"replace",path:d,value:f(v)})}}))}(n,r,t,e);case 5:case 1:return function(n,r,t,e){var i=n.t,o=n.D,u=n.o;if(u.length<i.length){var a=[u,i];i=a[0],u=a[1];var s=[e,t];t=s[0],e=s[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=r.concat([v]);t.push({op:"replace",path:p,value:f(u[v])}),e.push({op:"replace",path:p,value:f(i[v])})}for(var l=i.length;l<u.length;l++){var d=r.concat([l]);t.push({op:c,path:d,value:f(u[l])})}i.length<u.length&&e.push({op:"replace",path:r.concat(["length"]),value:i.length})}(n,r,t,e);case 3:return function(n,r,t,e){var i=n.t,o=n.o,u=0;i.forEach((function(n){if(!o.has(n)){var i=r.concat([u]);t.push({op:"remove",path:i,value:n}),e.unshift({op:c,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=r.concat([u]);t.push({op:c,path:o,value:n}),e.unshift({op:"remove",path:o,value:n})}u++}))}(n,r,t,e)}},M:function(n,r,t,e){t.push({op:"replace",path:[],value:r===H?void 0:r}),e.push({op:"replace",path:[],value:n})}})}function C(){function r(n,r){function t(){this.constructor=n}a(n,r),n.prototype=(t.prototype=r.prototype,new t)}function e(n){n.o||(n.D=new Map,n.o=new Map(n.t))}function o(n){n.o||(n.o=new Set,n.t.forEach((function(r){if(t(r)){var e=R(n.A.h,r,n);n.p.set(r,e),n.o.add(e)}else n.o.add(r)})))}function u(r){r.O&&n(3,JSON.stringify(p(r)))}var a=function(n,r){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t])})(n,r)},f=function(){function n(n,r){return this[Q]={i:2,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,D:void 0,t:n,k:this,C:!1,O:!1},this}r(n,Map);var o=n.prototype;return Object.defineProperty(o,"size",{get:function(){return p(this[Q]).size}}),o.has=function(n){return p(this[Q]).has(n)},o.set=function(n,r){var t=this[Q];return u(t),p(t).has(n)&&p(t).get(n)===r||(e(t),k(t),t.D.set(n,!0),t.o.set(n,r),t.D.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),e(r),k(r),r.t.has(n)?r.D.set(n,!1):r.D.delete(n),r.o.delete(n),!0},o.clear=function(){var n=this[Q];u(n),p(n).size&&(e(n),k(n),n.D=new Map,i(n.t,(function(r){n.D.set(r,!1)})),n.o.clear())},o.forEach=function(n,r){var t=this;p(this[Q]).forEach((function(e,i){n.call(r,t.get(i),i,t)}))},o.get=function(n){var r=this[Q];u(r);var i=p(r).get(n);if(r.I||!t(i))return i;if(i!==r.t.get(n))return i;var o=R(r.A.h,i,r);return e(r),r.o.set(n,o),o},o.keys=function(){return p(this[Q]).keys()},o.values=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.values()},n.next=function(){var n=t.next();return n.done?n:{done:!1,value:r.get(n.value)}},n},o.entries=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.entries()},n.next=function(){var n=t.next();if(n.done)return n;var e=r.get(n.value);return{done:!1,value:[n.value,e]}},n},o[V]=function(){return this.entries()},n}(),c=function(){function n(n,r){return this[Q]={i:3,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,t:n,k:this,p:new Map,O:!1,C:!1},this}r(n,Set);var t=n.prototype;return Object.defineProperty(t,"size",{get:function(){return p(this[Q]).size}}),t.has=function(n){var r=this[Q];return u(r),r.o?!!r.o.has(n)||!(!r.p.has(n)||!r.o.has(r.p.get(n))):r.t.has(n)},t.add=function(n){var r=this[Q];return u(r),this.has(n)||(o(r),k(r),r.o.add(n)),this},t.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),o(r),k(r),r.o.delete(n)||!!r.p.has(n)&&r.o.delete(r.p.get(n))},t.clear=function(){var n=this[Q];u(n),p(n).size&&(o(n),k(n),n.o.clear())},t.values=function(){var n=this[Q];return u(n),o(n),n.o.values()},t.entries=function(){var n=this[Q];return u(n),o(n),n.o.entries()},t.keys=function(){return this.values()},t[V]=function(){return this.values()},t.forEach=function(n,r){for(var t=this.values(),e=t.next();!e.done;)n.call(r,e.value,e.value,this),e=t.next()},n}();m("MapSet",{N:function(n,r){return new f(n,r)},T:function(n,r){return new c(n,r)}})}function J(){N(),C(),T()}function K(n){return n}function $(n){return n}var G,U,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H=W?Symbol.for("immer-nothing"):((G={})["immer-nothing"]=!0,G),L=W?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W?Symbol.for("immer-state"):"__$immer_state",V="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",Y={0:"Illegal state",1:"Immer drafts cannot have computed properties",2:"This object has been frozen and should not be mutated",3:function(n){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+n},4:"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",5:"Immer forbids circular references",6:"The first or second argument to `produce` must be a function",7:"The third argument to `produce` must be a function or undefined",8:"First argument to `createDraft` must be a plain object, an array, or an immerable object",9:"First argument to `finishDraft` must be a draft returned by `createDraft`",10:"The given draft is already finalized",11:"Object.defineProperty() cannot be used on an Immer draft",12:"Object.setPrototypeOf() cannot be used on an Immer draft",13:"Immer only supports deleting array indices",14:"Immer only supports setting array indices and the 'length' property",15:function(n){return"Cannot apply patch, path doesn't resolve: "+n},16:'Sets cannot have "replace" patches.',17:function(n){return"Unsupported patch operation: "+n},18:function(n){return"The plugin for '"+n+"' has not been loaded into Immer. To enable the plugin, import and call `enable"+n+"()` when initializing your application."},20:"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",21:function(n){return"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '"+n+"'"},22:function(n){return"'current' expects a draft, got: "+n},23:function(n){return"'original' expects a draft, got: "+n},24:"Patching reserved attributes like __proto__, prototype and constructor is not allowed"},Z=""+Object.prototype.constructor,nn="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,rn=Object.getOwnPropertyDescriptors||function(n){var r={};return nn(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t)})),r},tn={},en={get:function(n,r){if(r===Q)return n;var e=p(n);if(!u(e,r))return function(n,r,t){var e,i=I(r,t);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!t(i)?i:i===z(n.t,r)?(E(n),n.o[r]=R(n.A.h,i,n)):i},has:function(n,r){return r in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,r,t){var e=I(p(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=z(p(n),r),o=null==i?void 0:i[Q];if(o&&o.t===t)return n.o[r]=t,n.D[r]=!1,!0;if(c(t,i)&&(void 0!==t||u(n.t,r)))return!0;E(n),k(n)}return n.o[r]===t&&"number"!=typeof t&&(void 0!==t||r in n.o)||(n.o[r]=t,n.D[r]=!0,!0)},deleteProperty:function(n,r){return void 0!==z(n.t,r)||r in n.t?(n.D[r]=!1,E(n),k(n)):delete n.D[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=p(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||"length"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n(12)}},on={};i(en,(function(n,r){on[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)}})),on.deleteProperty=function(r,t){return"production"!==process.env.NODE_ENV&&isNaN(parseInt(t))&&n(13),on.set.call(this,r,t,void 0)},on.set=function(r,t,e){return"production"!==process.env.NODE_ENV&&"length"!==t&&isNaN(parseInt(t))&&n(14),en.set.call(this,r[0],t,e,r[0])};var un=function(){function e(r){var e=this;this.g=B,this.F=!0,this.produce=function(r,i,o){if("function"==typeof r&&"function"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return(t=i).call.apply(t,[r,n].concat(e))}))}}var f;if("function"!=typeof i&&n(6),void 0!==o&&"function"!=typeof o&&n(7),t(r)){var c=w(e),s=R(e,r,void 0),v=!0;try{f=i(s),v=!1}finally{v?O(c):g(c)}return"undefined"!=typeof Promise&&f instanceof Promise?f.then((function(n){return j(c,o),P(n,c)}),(function(n){throw O(c),n})):(j(c,o),P(f,c))}if(!r||"object"!=typeof r){if(void 0===(f=i(r))&&(f=r),f===H&&(f=void 0),e.F&&d(f,!0),o){var p=[],l=[];b("Patches").M(r,f,p,l),o(p,l)}return f}n(21,r)},this.produceWithPatches=function(n,r){if("function"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,o=e.produce(n,r,(function(n,r){t=n,i=r}));return"undefined"!=typeof Promise&&o instanceof Promise?o.then((function(n){return[n,t,i]})):[o,t,i]},"boolean"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),"boolean"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze)}var i=e.prototype;return i.createDraft=function(e){t(e)||n(8),r(e)&&(e=D(e));var i=w(this),o=R(this,e,void 0);return o[Q].C=!0,g(i),o},i.finishDraft=function(r,t){var e=r&&r[Q];"production"!==process.env.NODE_ENV&&(e&&e.C||n(9),e.I&&n(10));var i=e.A;return j(i,t),P(void 0,i)},i.setAutoFreeze=function(n){this.F=n},i.setUseProxies=function(r){r&&!B&&n(20),this.g=r},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var o=b("Patches").$;return r(n)?o(n,t):this.produce(n,(function(n){return o(n,t)}))},e}(),an=new un,fn=an.produce,cn=an.produceWithPatches.bind(an),sn=an.setAutoFreeze.bind(an),vn=an.setUseProxies.bind(an),pn=an.applyPatches.bind(an),ln=an.createDraft.bind(an),dn=an.finishDraft.bind(an);export default fn;export{un as Immer,pn as applyPatches,K as castDraft,$ as castImmutable,ln as createDraft,D as current,J as enableAllPlugins,N as enableES5,C as enableMapSet,T as enablePatches,dn as finishDraft,d as freeze,L as immerable,r as isDraft,t as isDraftable,H as nothing,e as original,fn as produce,cn as produceWithPatches,sn as setAutoFreeze,vn as setUseProxies};
+var _ref;
+
+// Should be no imports here!
+// Some things that should be evaluated before all else...
+// We only want to know if non-polyfilled symbols are available
+var hasSymbol = typeof Symbol !== "undefined" && typeof
+/*#__PURE__*/
+Symbol("x") === "symbol";
+var hasMap = typeof Map !== "undefined";
+var hasSet = typeof Set !== "undefined";
+var hasProxies = typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined";
+/**
+ * The sentinel value returned by producers to replace the draft with undefined.
+ */
+
+var NOTHING = hasSymbol ?
+/*#__PURE__*/
+Symbol.for("immer-nothing") : (_ref = {}, _ref["immer-nothing"] = true, _ref);
+/**
+ * To let Immer treat your class instances as plain immutable objects
+ * (albeit with a custom prototype), you must define either an instance property
+ * or a static property on each of your custom classes.
+ *
+ * Otherwise, your class instance will never be drafted, which means it won't be
+ * safe to mutate in a produce callback.
+ */
+
+var DRAFTABLE = hasSymbol ?
+/*#__PURE__*/
+Symbol.for("immer-draftable") : "__$immer_draftable";
+var DRAFT_STATE = hasSymbol ?
+/*#__PURE__*/
+Symbol.for("immer-state") : "__$immer_state"; // Even a polyfilled Symbol might provide Symbol.iterator
+
+var iteratorSymbol = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";
+
+var errors = {
+  0: "Illegal state",
+  1: "Immer drafts cannot have computed properties",
+  2: "This object has been frozen and should not be mutated",
+  3: function _(data) {
+    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
+  },
+  4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
+  5: "Immer forbids circular references",
+  6: "The first or second argument to `produce` must be a function",
+  7: "The third argument to `produce` must be a function or undefined",
+  8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
+  9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
+  10: "The given draft is already finalized",
+  11: "Object.defineProperty() cannot be used on an Immer draft",
+  12: "Object.setPrototypeOf() cannot be used on an Immer draft",
+  13: "Immer only supports deleting array indices",
+  14: "Immer only supports setting array indices and the 'length' property",
+  15: function _(path) {
+    return "Cannot apply patch, path doesn't resolve: " + path;
+  },
+  16: 'Sets cannot have "replace" patches.',
+  17: function _(op) {
+    return "Unsupported patch operation: " + op;
+  },
+  18: function _(plugin) {
+    return "The plugin for '" + plugin + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + plugin + "()` when initializing your application.";
+  },
+  20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
+  21: function _(thing) {
+    return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + thing + "'";
+  },
+  22: function _(thing) {
+    return "'current' expects a draft, got: " + thing;
+  },
+  23: function _(thing) {
+    return "'original' expects a draft, got: " + thing;
+  },
+  24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
+};
+function die(error) {
+  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
+    args[_key - 1] = arguments[_key];
+  }
+
+  if (process.env.NODE_ENV !== "production") {
+    var e = errors[error];
+    var msg = !e ? "unknown error nr: " + error : typeof e === "function" ? e.apply(null, args) : e;
+    throw new Error("[Immer] " + msg);
+  }
+
+  throw new Error("[Immer] minified error nr: " + error + (args.length ? " " + args.map(function (s) {
+    return "'" + s + "'";
+  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
+}
+
+/** Returns true if the given value is an Immer draft */
+
+/*#__PURE__*/
+
+function isDraft(value) {
+  return !!value && !!value[DRAFT_STATE];
+}
+/** Returns true if the given value can be drafted by Immer */
+
+/*#__PURE__*/
+
+function isDraftable(value) {
+  var _value$constructor;
+
+  if (!value) return false;
+  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);
+}
+var objectCtorString =
+/*#__PURE__*/
+Object.prototype.constructor.toString();
+/*#__PURE__*/
+
+function isPlainObject(value) {
+  if (!value || typeof value !== "object") return false;
+  var proto = Object.getPrototypeOf(value);
+
+  if (proto === null) {
+    return true;
+  }
+
+  var Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
+  if (Ctor === Object) return true;
+  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
+}
+function original(value) {
+  if (!isDraft(value)) die(23, value);
+  return value[DRAFT_STATE].base_;
+}
+/*#__PURE__*/
+
+var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function (obj) {
+  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
+} :
+/* istanbul ignore next */
+Object.getOwnPropertyNames;
+var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
+  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
+  var res = {};
+  ownKeys(target).forEach(function (key) {
+    res[key] = Object.getOwnPropertyDescriptor(target, key);
+  });
+  return res;
+};
+function each(obj, iter, enumerableOnly) {
+  if (enumerableOnly === void 0) {
+    enumerableOnly = false;
+  }
+
+  if (getArchtype(obj) === 0
+  /* Object */
+  ) {
+      (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function (key) {
+        if (!enumerableOnly || typeof key !== "symbol") iter(key, obj[key], obj);
+      });
+    } else {
+    obj.forEach(function (entry, index) {
+      return iter(index, entry, obj);
+    });
+  }
+}
+/*#__PURE__*/
+
+function getArchtype(thing) {
+  /* istanbul ignore next */
+  var state = thing[DRAFT_STATE];
+  return state ? state.type_ > 3 ? state.type_ - 4 // cause Object and Array map back from 4 and 5
+  : state.type_ // others are the same
+  : Array.isArray(thing) ? 1
+  /* Array */
+  : isMap(thing) ? 2
+  /* Map */
+  : isSet(thing) ? 3
+  /* Set */
+  : 0
+  /* Object */
+  ;
+}
+/*#__PURE__*/
+
+function has(thing, prop) {
+  return getArchtype(thing) === 2
+  /* Map */
+  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
+}
+/*#__PURE__*/
+
+function get(thing, prop) {
+  // @ts-ignore
+  return getArchtype(thing) === 2
+  /* Map */
+  ? thing.get(prop) : thing[prop];
+}
+/*#__PURE__*/
+
+function set(thing, propOrOldValue, value) {
+  var t = getArchtype(thing);
+  if (t === 2
+  /* Map */
+  ) thing.set(propOrOldValue, value);else if (t === 3
+  /* Set */
+  ) {
+      thing.delete(propOrOldValue);
+      thing.add(value);
+    } else thing[propOrOldValue] = value;
+}
+/*#__PURE__*/
+
+function is(x, y) {
+  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
+  if (x === y) {
+    return x !== 0 || 1 / x === 1 / y;
+  } else {
+    return x !== x && y !== y;
+  }
+}
+/*#__PURE__*/
+
+function isMap(target) {
+  return hasMap && target instanceof Map;
+}
+/*#__PURE__*/
+
+function isSet(target) {
+  return hasSet && target instanceof Set;
+}
+/*#__PURE__*/
+
+function latest(state) {
+  return state.copy_ || state.base_;
+}
+/*#__PURE__*/
+
+function shallowCopy(base) {
+  if (Array.isArray(base)) return Array.prototype.slice.call(base);
+  var descriptors = getOwnPropertyDescriptors(base);
+  delete descriptors[DRAFT_STATE];
+  var keys = ownKeys(descriptors);
+
+  for (var i = 0; i < keys.length; i++) {
+    var key = keys[i];
+    var desc = descriptors[key];
+
+    if (desc.writable === false) {
+      desc.writable = true;
+      desc.configurable = true;
+    } // like object.assign, we will read any _own_, get/set accessors. This helps in dealing
+    // with libraries that trap values, like mobx or vue
+    // unlike object.assign, non-enumerables will be copied as well
+
+
+    if (desc.get || desc.set) descriptors[key] = {
+      configurable: true,
+      writable: true,
+      enumerable: desc.enumerable,
+      value: base[key]
+    };
+  }
+
+  return Object.create(Object.getPrototypeOf(base), descriptors);
+}
+function freeze(obj, deep) {
+  if (deep === void 0) {
+    deep = false;
+  }
+
+  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
+
+  if (getArchtype(obj) > 1
+  /* Map or Set */
+  ) {
+      var desc = {
+        configurable: true,
+        writable: true,
+        value: dontMutateFrozenCollections
+      };
+      Object.defineProperties(obj, {
+        set: desc,
+        add: desc,
+        clear: desc,
+        delete: desc
+      });
+    }
+
+  Object.freeze(obj);
+  if (deep) each(obj, function (key, value) {
+    return freeze(value, true);
+  }, true);
+  return obj;
+}
+
+function dontMutateFrozenCollections() {
+  die(2);
+}
+
+function isFrozen(obj) {
+  if (obj == null || typeof obj !== "object") return true; // See #600, IE dies on non-objects in Object.isFrozen
+
+  return Object.isFrozen(obj);
+}
+
+/** Plugin utilities */
+
+var plugins = {};
+function getPlugin(pluginKey) {
+  var plugin = plugins[pluginKey];
+
+  if (!plugin) {
+    die(18, pluginKey);
+  } // @ts-ignore
+
+
+  return plugin;
+}
+function loadPlugin(pluginKey, implementation) {
+  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
+}
+
+var currentScope;
+function getCurrentScope() {
+  if (process.env.NODE_ENV !== "production" && !currentScope) die(0);
+  return currentScope;
+}
+
+function createScope(parent_, immer_) {
+  return {
+    drafts_: [],
+    parent_: parent_,
+    immer_: immer_,
+    // Whenever the modified draft contains a draft from another scope, we
+    // need to prevent auto-freezing so the unowned draft can be finalized.
+    canAutoFreeze_: true,
+    unfinalizedDrafts_: 0
+  };
+}
+
+function usePatchesInScope(scope, patchListener) {
+  if (patchListener) {
+    getPlugin("Patches"); // assert we have the plugin
+
+    scope.patches_ = [];
+    scope.inversePatches_ = [];
+    scope.patchListener_ = patchListener;
+  }
+}
+function revokeScope(scope) {
+  leaveScope(scope);
+  scope.drafts_.forEach(revokeDraft); // @ts-ignore
+
+  scope.drafts_ = null;
+}
+function leaveScope(scope) {
+  if (scope === currentScope) {
+    currentScope = scope.parent_;
+  }
+}
+function enterScope(immer) {
+  return currentScope = createScope(currentScope, immer);
+}
+
+function revokeDraft(draft) {
+  var state = draft[DRAFT_STATE];
+  if (state.type_ === 0
+  /* ProxyObject */
+  || state.type_ === 1
+  /* ProxyArray */
+  ) state.revoke_();else state.revoked_ = true;
+}
+
+function processResult(result, scope) {
+  scope.unfinalizedDrafts_ = scope.drafts_.length;
+  var baseDraft = scope.drafts_[0];
+  var isReplaced = result !== undefined && result !== baseDraft;
+  if (!scope.immer_.useProxies_) getPlugin("ES5").willFinalizeES5_(scope, result, isReplaced);
+
+  if (isReplaced) {
+    if (baseDraft[DRAFT_STATE].modified_) {
+      revokeScope(scope);
+      die(4);
+    }
+
+    if (isDraftable(result)) {
+      // Finalize the result in case it contains (or is) a subset of the draft.
+      result = finalize(scope, result);
+      if (!scope.parent_) maybeFreeze(scope, result);
+    }
+
+    if (scope.patches_) {
+      getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
+    }
+  } else {
+    // Finalize the base draft.
+    result = finalize(scope, baseDraft, []);
+  }
+
+  revokeScope(scope);
+
+  if (scope.patches_) {
+    scope.patchListener_(scope.patches_, scope.inversePatches_);
+  }
+
+  return result !== NOTHING ? result : undefined;
+}
+
+function finalize(rootScope, value, path) {
+  // Don't recurse in tho recursive data structures
+  if (isFrozen(value)) return value;
+  var state = value[DRAFT_STATE]; // A plain object, might need freezing, might contain drafts
+
+  if (!state) {
+    each(value, function (key, childValue) {
+      return finalizeProperty(rootScope, state, value, key, childValue, path);
+    }, true // See #590, don't recurse into non-enumerable of non drafted objects
+    );
+    return value;
+  } // Never finalize drafts owned by another scope.
+
+
+  if (state.scope_ !== rootScope) return value; // Unmodified draft, return the (frozen) original
+
+  if (!state.modified_) {
+    maybeFreeze(rootScope, state.base_, true);
+    return state.base_;
+  } // Not finalized yet, let's do that now
+
+
+  if (!state.finalized_) {
+    state.finalized_ = true;
+    state.scope_.unfinalizedDrafts_--;
+    var result = // For ES5, create a good copy from the draft first, with added keys and without deleted keys.
+    state.type_ === 4
+    /* ES5Object */
+    || state.type_ === 5
+    /* ES5Array */
+    ? state.copy_ = shallowCopy(state.draft_) : state.copy_; // Finalize all children of the copy
+    // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628
+    // Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line
+    // back to each(result, ....)
+
+    each(state.type_ === 3
+    /* Set */
+    ? new Set(result) : result, function (key, childValue) {
+      return finalizeProperty(rootScope, state, result, key, childValue, path);
+    }); // everything inside is frozen, we can freeze here
+
+    maybeFreeze(rootScope, result, false); // first time finalizing, let's create those patches
+
+    if (path && rootScope.patches_) {
+      getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
+    }
+  }
+
+  return state.copy_;
+}
+
+function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath) {
+  if (process.env.NODE_ENV !== "production" && childValue === targetObject) die(5);
+
+  if (isDraft(childValue)) {
+    var path = rootPath && parentState && parentState.type_ !== 3
+    /* Set */
+    && // Set objects are atomic since they have no keys.
+    !has(parentState.assigned_, prop) // Skip deep patches for assigned keys.
+    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.
+
+    var res = finalize(rootScope, childValue, path);
+    set(targetObject, prop, res); // Drafts from another scope must prevented to be frozen
+    // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze
+
+    if (isDraft(res)) {
+      rootScope.canAutoFreeze_ = false;
+    } else return;
+  } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.
+
+
+  if (isDraftable(childValue) && !isFrozen(childValue)) {
+    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
+      // optimization: if an object is not a draft, and we don't have to
+      // deepfreeze everything, and we are sure that no drafts are left in the remaining object
+      // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.
+      // This benefits especially adding large data tree's without further processing.
+      // See add-data.js perf test
+      return;
+    }
+
+    finalize(rootScope, childValue); // immer deep freezes plain objects, so if there is no parent state, we freeze as well
+
+    if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);
+  }
+}
+
+function maybeFreeze(scope, value, deep) {
+  if (deep === void 0) {
+    deep = false;
+  }
+
+  if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
+    freeze(value, deep);
+  }
+}
+
+/**
+* Returns a new draft of the `base` object.
+*
+* The second argument is the parent draft-state (used internally).
+*/
+
+function createProxyProxy(base, parent) {
+  var isArray = Array.isArray(base);
+  var state = {
+    type_: isArray ? 1
+    /* ProxyArray */
+    : 0
+    /* ProxyObject */
+    ,
+    // Track which produce call this is associated with.
+    scope_: parent ? parent.scope_ : getCurrentScope(),
+    // True for both shallow and deep changes.
+    modified_: false,
+    // Used during finalization.
+    finalized_: false,
+    // Track which properties have been assigned (true) or deleted (false).
+    assigned_: {},
+    // The parent draft state.
+    parent_: parent,
+    // The base state.
+    base_: base,
+    // The base proxy.
+    draft_: null,
+    // The base copy with any updated values.
+    copy_: null,
+    // Called by the `produce` function.
+    revoke_: null,
+    isManual_: false
+  }; // the traps must target something, a bit like the 'real' base.
+  // but also, we need to be able to determine from the target what the relevant state is
+  // (to avoid creating traps per instance to capture the state in closure,
+  // and to avoid creating weird hidden properties as well)
+  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)
+  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb
+
+  var target = state;
+  var traps = objectTraps;
+
+  if (isArray) {
+    target = [state];
+    traps = arrayTraps;
+  }
+
+  var _Proxy$revocable = Proxy.revocable(target, traps),
+      revoke = _Proxy$revocable.revoke,
+      proxy = _Proxy$revocable.proxy;
+
+  state.draft_ = proxy;
+  state.revoke_ = revoke;
+  return proxy;
+}
+/**
+* Object drafts
+*/
+
+var objectTraps = {
+  get: function get(state, prop) {
+    if (prop === DRAFT_STATE) return state;
+    var source = latest(state);
+
+    if (!has(source, prop)) {
+      // non-existing or non-own property...
+      return readPropFromProto(state, source, prop);
+    }
+
+    var value = source[prop];
+
+    if (state.finalized_ || !isDraftable(value)) {
+      return value;
+    } // Check for existing draft in modified state.
+    // Assigned values are never drafted. This catches any drafts we created, too.
+
+
+    if (value === peek(state.base_, prop)) {
+      prepareCopy(state);
+      return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);
+    }
+
+    return value;
+  },
+  has: function has(state, prop) {
+    return prop in latest(state);
+  },
+  ownKeys: function ownKeys(state) {
+    return Reflect.ownKeys(latest(state));
+  },
+  set: function set(state, prop
+  /* strictly not, but helps TS */
+  , value) {
+    var desc = getDescriptorFromProto(latest(state), prop);
+
+    if (desc === null || desc === void 0 ? void 0 : desc.set) {
+      // special case: if this write is captured by a setter, we have
+      // to trigger it with the correct context
+      desc.set.call(state.draft_, value);
+      return true;
+    }
+
+    if (!state.modified_) {
+      // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)
+      // from setting an existing property with value undefined to undefined (which is not a change)
+      var current = peek(latest(state), prop); // special case, if we assigning the original value to a draft, we can ignore the assignment
+
+      var currentState = current === null || current === void 0 ? void 0 : current[DRAFT_STATE];
+
+      if (currentState && currentState.base_ === value) {
+        state.copy_[prop] = value;
+        state.assigned_[prop] = false;
+        return true;
+      }
+
+      if (is(value, current) && (value !== undefined || has(state.base_, prop))) return true;
+      prepareCopy(state);
+      markChanged(state);
+    }
+
+    if (state.copy_[prop] === value && ( // special case: handle new props with value 'undefined'
+    value !== undefined || prop in state.copy_) || // special case: NaN
+    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true; // @ts-ignore
+
+    state.copy_[prop] = value;
+    state.assigned_[prop] = true;
+    return true;
+  },
+  deleteProperty: function deleteProperty(state, prop) {
+    // The `undefined` check is a fast path for pre-existing keys.
+    if (peek(state.base_, prop) !== undefined || prop in state.base_) {
+      state.assigned_[prop] = false;
+      prepareCopy(state);
+      markChanged(state);
+    } else {
+      // if an originally not assigned property was deleted
+      delete state.assigned_[prop];
+    } // @ts-ignore
+
+
+    if (state.copy_) delete state.copy_[prop];
+    return true;
+  },
+  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
+  // the same guarantee in ES5 mode.
+  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
+    var owner = latest(state);
+    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
+    if (!desc) return desc;
+    return {
+      writable: true,
+      configurable: state.type_ !== 1
+      /* ProxyArray */
+      || prop !== "length",
+      enumerable: desc.enumerable,
+      value: owner[prop]
+    };
+  },
+  defineProperty: function defineProperty() {
+    die(11);
+  },
+  getPrototypeOf: function getPrototypeOf(state) {
+    return Object.getPrototypeOf(state.base_);
+  },
+  setPrototypeOf: function setPrototypeOf() {
+    die(12);
+  }
+};
+/**
+* Array drafts
+*/
+
+var arrayTraps = {};
+each(objectTraps, function (key, fn) {
+  // @ts-ignore
+  arrayTraps[key] = function () {
+    arguments[0] = arguments[0][0];
+    return fn.apply(this, arguments);
+  };
+});
+
+arrayTraps.deleteProperty = function (state, prop) {
+  if (process.env.NODE_ENV !== "production" && isNaN(parseInt(prop))) die(13); // @ts-ignore
+
+  return arrayTraps.set.call(this, state, prop, undefined);
+};
+
+arrayTraps.set = function (state, prop, value) {
+  if (process.env.NODE_ENV !== "production" && prop !== "length" && isNaN(parseInt(prop))) die(14);
+  return objectTraps.set.call(this, state[0], prop, value, state[0]);
+}; // Access a property without creating an Immer draft.
+
+
+function peek(draft, prop) {
+  var state = draft[DRAFT_STATE];
+  var source = state ? latest(state) : draft;
+  return source[prop];
+}
+
+function readPropFromProto(state, source, prop) {
+  var _desc$get;
+
+  var desc = getDescriptorFromProto(source, prop);
+  return desc ? "value" in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the
+  // prototype, we should invoke it with the draft as context!
+  (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : undefined;
+}
+
+function getDescriptorFromProto(source, prop) {
+  // 'in' checks proto!
+  if (!(prop in source)) return undefined;
+  var proto = Object.getPrototypeOf(source);
+
+  while (proto) {
+    var desc = Object.getOwnPropertyDescriptor(proto, prop);
+    if (desc) return desc;
+    proto = Object.getPrototypeOf(proto);
+  }
+
+  return undefined;
+}
+
+function markChanged(state) {
+  if (!state.modified_) {
+    state.modified_ = true;
+
+    if (state.parent_) {
+      markChanged(state.parent_);
+    }
+  }
+}
+function prepareCopy(state) {
+  if (!state.copy_) {
+    state.copy_ = shallowCopy(state.base_);
+  }
+}
+
+var Immer =
+/*#__PURE__*/
+function () {
+  function Immer(config) {
+    var _this = this;
+
+    this.useProxies_ = hasProxies;
+    this.autoFreeze_ = true;
+    /**
+            * The `produce` function takes a value and a "recipe function" (whose
+            * return value often depends on the base state). The recipe function is
+            * free to mutate its first argument however it wants. All mutations are
+            * only ever applied to a __copy__ of the base state.
+            *
+            * Pass only a function to create a "curried producer" which relieves you
+            * from passing the recipe function every time.
+            *
+            * Only plain objects and arrays are made mutable. All other objects are
+            * considered uncopyable.
+            *
+            * Note: This function is __bound__ to its `Immer` instance.
+            *
+            * @param {any} base - the initial state
+            * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+            * @param {Function} patchListener - optional function that will be called with all the patches produced here
+            * @returns {any} a new state, or the initial state if nothing was modified
+            */
+
+    this.produce = function (base, recipe, patchListener) {
+      // curried invocation
+      if (typeof base === "function" && typeof recipe !== "function") {
+        var defaultBase = recipe;
+        recipe = base;
+        var self = _this;
+        return function curriedProduce(base) {
+          var _this2 = this;
+
+          if (base === void 0) {
+            base = defaultBase;
+          }
+
+          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
+            args[_key - 1] = arguments[_key];
+          }
+
+          return self.produce(base, function (draft) {
+            var _recipe;
+
+            return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));
+          }); // prettier-ignore
+        };
+      }
+
+      if (typeof recipe !== "function") die(6);
+      if (patchListener !== undefined && typeof patchListener !== "function") die(7);
+      var result; // Only plain objects, arrays, and "immerable classes" are drafted.
+
+      if (isDraftable(base)) {
+        var scope = enterScope(_this);
+        var proxy = createProxy(_this, base, undefined);
+        var hasError = true;
+
+        try {
+          result = recipe(proxy);
+          hasError = false;
+        } finally {
+          // finally instead of catch + rethrow better preserves original stack
+          if (hasError) revokeScope(scope);else leaveScope(scope);
+        }
+
+        if (typeof Promise !== "undefined" && result instanceof Promise) {
+          return result.then(function (result) {
+            usePatchesInScope(scope, patchListener);
+            return processResult(result, scope);
+          }, function (error) {
+            revokeScope(scope);
+            throw error;
+          });
+        }
+
+        usePatchesInScope(scope, patchListener);
+        return processResult(result, scope);
+      } else if (!base || typeof base !== "object") {
+        result = recipe(base);
+        if (result === undefined) result = base;
+        if (result === NOTHING) result = undefined;
+        if (_this.autoFreeze_) freeze(result, true);
+
+        if (patchListener) {
+          var p = [];
+          var ip = [];
+          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
+          patchListener(p, ip);
+        }
+
+        return result;
+      } else die(21, base);
+    };
+
+    this.produceWithPatches = function (base, recipe) {
+      // curried invocation
+      if (typeof base === "function") {
+        return function (state) {
+          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
+            args[_key2 - 1] = arguments[_key2];
+          }
+
+          return _this.produceWithPatches(state, function (draft) {
+            return base.apply(void 0, [draft].concat(args));
+          });
+        };
+      }
+
+      var patches, inversePatches;
+
+      var result = _this.produce(base, recipe, function (p, ip) {
+        patches = p;
+        inversePatches = ip;
+      });
+
+      if (typeof Promise !== "undefined" && result instanceof Promise) {
+        return result.then(function (nextState) {
+          return [nextState, patches, inversePatches];
+        });
+      }
+
+      return [result, patches, inversePatches];
+    };
+
+    if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === "boolean") this.setUseProxies(config.useProxies);
+    if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean") this.setAutoFreeze(config.autoFreeze);
+  }
+
+  var _proto = Immer.prototype;
+
+  _proto.createDraft = function createDraft(base) {
+    if (!isDraftable(base)) die(8);
+    if (isDraft(base)) base = current(base);
+    var scope = enterScope(this);
+    var proxy = createProxy(this, base, undefined);
+    proxy[DRAFT_STATE].isManual_ = true;
+    leaveScope(scope);
+    return proxy;
+  };
+
+  _proto.finishDraft = function finishDraft(draft, patchListener) {
+    var state = draft && draft[DRAFT_STATE];
+
+    if (process.env.NODE_ENV !== "production") {
+      if (!state || !state.isManual_) die(9);
+      if (state.finalized_) die(10);
+    }
+
+    var scope = state.scope_;
+    usePatchesInScope(scope, patchListener);
+    return processResult(undefined, scope);
+  }
+  /**
+          * Pass true to automatically freeze all copies created by Immer.
+          *
+          * By default, auto-freezing is enabled.
+          */
+  ;
+
+  _proto.setAutoFreeze = function setAutoFreeze(value) {
+    this.autoFreeze_ = value;
+  }
+  /**
+          * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+          * always faster than using ES5 proxies.
+          *
+          * By default, feature detection is used, so calling this is rarely necessary.
+          */
+  ;
+
+  _proto.setUseProxies = function setUseProxies(value) {
+    if (value && !hasProxies) {
+      die(20);
+    }
+
+    this.useProxies_ = value;
+  };
+
+  _proto.applyPatches = function applyPatches(base, patches) {
+    // If a patch replaces the entire state, take that replacement as base
+    // before applying patches
+    var i;
+
+    for (i = patches.length - 1; i >= 0; i--) {
+      var patch = patches[i];
+
+      if (patch.path.length === 0 && patch.op === "replace") {
+        base = patch.value;
+        break;
+      }
+    } // If there was a patch that replaced the entire state, start from the
+    // patch after that.
+
+
+    if (i > -1) {
+      patches = patches.slice(i + 1);
+    }
+
+    var applyPatchesImpl = getPlugin("Patches").applyPatches_;
+
+    if (isDraft(base)) {
+      // N.B: never hits if some patch a replacement, patches are never drafts
+      return applyPatchesImpl(base, patches);
+    } // Otherwise, produce a copy of the base state.
+
+
+    return this.produce(base, function (draft) {
+      return applyPatchesImpl(draft, patches);
+    });
+  };
+
+  return Immer;
+}();
+function createProxy(immer, value, parent) {
+  // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft
+  var draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : immer.useProxies_ ? createProxyProxy(value, parent) : getPlugin("ES5").createES5Proxy_(value, parent);
+  var scope = parent ? parent.scope_ : getCurrentScope();
+  scope.drafts_.push(draft);
+  return draft;
+}
+
+function current(value) {
+  if (!isDraft(value)) die(22, value);
+  return currentImpl(value);
+}
+
+function currentImpl(value) {
+  if (!isDraftable(value)) return value;
+  var state = value[DRAFT_STATE];
+  var copy;
+  var archType = getArchtype(value);
+
+  if (state) {
+    if (!state.modified_ && (state.type_ < 4 || !getPlugin("ES5").hasChanges_(state))) return state.base_; // Optimization: avoid generating new drafts during copying
+
+    state.finalized_ = true;
+    copy = copyHelper(value, archType);
+    state.finalized_ = false;
+  } else {
+    copy = copyHelper(value, archType);
+  }
+
+  each(copy, function (key, childValue) {
+    if (state && get(state.base_, key) === childValue) return; // no need to copy or search in something that didn't change
+
+    set(copy, key, currentImpl(childValue));
+  }); // In the future, we might consider freezing here, based on the current settings
+
+  return archType === 3
+  /* Set */
+  ? new Set(copy) : copy;
+}
+
+function copyHelper(value, archType) {
+  // creates a shallow copy, even if it is a map or set
+  switch (archType) {
+    case 2
+    /* Map */
+    :
+      return new Map(value);
+
+    case 3
+    /* Set */
+    :
+      // Set will be cloned as array temporarily, so that we can replace individual items
+      return Array.from(value);
+  }
+
+  return shallowCopy(value);
+}
+
+function enableES5() {
+  function willFinalizeES5_(scope, result, isReplaced) {
+    if (!isReplaced) {
+      if (scope.patches_) {
+        markChangesRecursively(scope.drafts_[0]);
+      } // This is faster when we don't care about which attributes changed.
+
+
+      markChangesSweep(scope.drafts_);
+    } // When a child draft is returned, look for changes.
+    else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {
+        markChangesSweep(scope.drafts_);
+      }
+  }
+
+  function createES5Draft(isArray, base) {
+    if (isArray) {
+      var draft = new Array(base.length);
+
+      for (var i = 0; i < base.length; i++) {
+        Object.defineProperty(draft, "" + i, proxyProperty(i, true));
+      }
+
+      return draft;
+    } else {
+      var _descriptors = getOwnPropertyDescriptors(base);
+
+      delete _descriptors[DRAFT_STATE];
+      var keys = ownKeys(_descriptors);
+
+      for (var _i = 0; _i < keys.length; _i++) {
+        var key = keys[_i];
+        _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);
+      }
+
+      return Object.create(Object.getPrototypeOf(base), _descriptors);
+    }
+  }
+
+  function createES5Proxy_(base, parent) {
+    var isArray = Array.isArray(base);
+    var draft = createES5Draft(isArray, base);
+    var state = {
+      type_: isArray ? 5
+      /* ES5Array */
+      : 4
+      /* ES5Object */
+      ,
+      scope_: parent ? parent.scope_ : getCurrentScope(),
+      modified_: false,
+      finalized_: false,
+      assigned_: {},
+      parent_: parent,
+      // base is the object we are drafting
+      base_: base,
+      // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)
+      draft_: draft,
+      copy_: null,
+      revoked_: false,
+      isManual_: false
+    };
+    Object.defineProperty(draft, DRAFT_STATE, {
+      value: state,
+      // enumerable: false <- the default
+      writable: true
+    });
+    return draft;
+  } // property descriptors are recycled to make sure we don't create a get and set closure per property,
+  // but share them all instead
+
+
+  var descriptors = {};
+
+  function proxyProperty(prop, enumerable) {
+    var desc = descriptors[prop];
+
+    if (desc) {
+      desc.enumerable = enumerable;
+    } else {
+      descriptors[prop] = desc = {
+        configurable: true,
+        enumerable: enumerable,
+        get: function get() {
+          var state = this[DRAFT_STATE];
+          if (process.env.NODE_ENV !== "production") assertUnrevoked(state); // @ts-ignore
+
+          return objectTraps.get(state, prop);
+        },
+        set: function set(value) {
+          var state = this[DRAFT_STATE];
+          if (process.env.NODE_ENV !== "production") assertUnrevoked(state); // @ts-ignore
+
+          objectTraps.set(state, prop, value);
+        }
+      };
+    }
+
+    return desc;
+  } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.
+
+
+  function markChangesSweep(drafts) {
+    // The natural order of drafts in the `scope` array is based on when they
+    // were accessed. By processing drafts in reverse natural order, we have a
+    // better chance of processing leaf nodes first. When a leaf node is known to
+    // have changed, we can avoid any traversal of its ancestor nodes.
+    for (var i = drafts.length - 1; i >= 0; i--) {
+      var state = drafts[i][DRAFT_STATE];
+
+      if (!state.modified_) {
+        switch (state.type_) {
+          case 5
+          /* ES5Array */
+          :
+            if (hasArrayChanges(state)) markChanged(state);
+            break;
+
+          case 4
+          /* ES5Object */
+          :
+            if (hasObjectChanges(state)) markChanged(state);
+            break;
+        }
+      }
+    }
+  }
+
+  function markChangesRecursively(object) {
+    if (!object || typeof object !== "object") return;
+    var state = object[DRAFT_STATE];
+    if (!state) return;
+    var base_ = state.base_,
+        draft_ = state.draft_,
+        assigned_ = state.assigned_,
+        type_ = state.type_;
+
+    if (type_ === 4
+    /* ES5Object */
+    ) {
+        // Look for added keys.
+        // probably there is a faster way to detect changes, as sweep + recurse seems to do some
+        // unnecessary work.
+        // also: probably we can store the information we detect here, to speed up tree finalization!
+        each(draft_, function (key) {
+          if (key === DRAFT_STATE) return; // The `undefined` check is a fast path for pre-existing keys.
+
+          if (base_[key] === undefined && !has(base_, key)) {
+            assigned_[key] = true;
+            markChanged(state);
+          } else if (!assigned_[key]) {
+            // Only untouched properties trigger recursion.
+            markChangesRecursively(draft_[key]);
+          }
+        }); // Look for removed keys.
+
+        each(base_, function (key) {
+          // The `undefined` check is a fast path for pre-existing keys.
+          if (draft_[key] === undefined && !has(draft_, key)) {
+            assigned_[key] = false;
+            markChanged(state);
+          }
+        });
+      } else if (type_ === 5
+    /* ES5Array */
+    ) {
+        if (hasArrayChanges(state)) {
+          markChanged(state);
+          assigned_.length = true;
+        }
+
+        if (draft_.length < base_.length) {
+          for (var i = draft_.length; i < base_.length; i++) {
+            assigned_[i] = false;
+          }
+        } else {
+          for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {
+            assigned_[_i2] = true;
+          }
+        } // Minimum count is enough, the other parts has been processed.
+
+
+        var min = Math.min(draft_.length, base_.length);
+
+        for (var _i3 = 0; _i3 < min; _i3++) {
+          // Only untouched indices trigger recursion.
+          if (!draft_.hasOwnProperty(_i3)) {
+            assigned_[_i3] = true;
+          }
+
+          if (assigned_[_i3] === undefined) markChangesRecursively(draft_[_i3]);
+        }
+      }
+  }
+
+  function hasObjectChanges(state) {
+    var base_ = state.base_,
+        draft_ = state.draft_; // Search for added keys and changed keys. Start at the back, because
+    // non-numeric keys are ordered by time of definition on the object.
+
+    var keys = ownKeys(draft_);
+
+    for (var i = keys.length - 1; i >= 0; i--) {
+      var key = keys[i];
+      if (key === DRAFT_STATE) continue;
+      var baseValue = base_[key]; // The `undefined` check is a fast path for pre-existing keys.
+
+      if (baseValue === undefined && !has(base_, key)) {
+        return true;
+      } // Once a base key is deleted, future changes go undetected, because its
+      // descriptor is erased. This branch detects any missed changes.
+      else {
+          var value = draft_[key];
+
+          var _state = value && value[DRAFT_STATE];
+
+          if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {
+            return true;
+          }
+        }
+    } // At this point, no keys were added or changed.
+    // Compare key count to determine if keys were deleted.
+
+
+    var baseIsDraft = !!base_[DRAFT_STATE];
+    return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE
+  }
+
+  function hasArrayChanges(state) {
+    var draft_ = state.draft_;
+    if (draft_.length !== state.base_.length) return true; // See #116
+    // If we first shorten the length, our array interceptors will be removed.
+    // If after that new items are added, result in the same original length,
+    // those last items will have no intercepting property.
+    // So if there is no own descriptor on the last position, we know that items were removed and added
+    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
+    // the last one
+    // last descriptor can be not a trap, if the array was extended
+
+    var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)
+
+    if (descriptor && !descriptor.get) return true; // if we miss a property, it has been deleted, so array probobaly changed
+
+    for (var i = 0; i < draft_.length; i++) {
+      if (!draft_.hasOwnProperty(i)) return true;
+    } // For all other cases, we don't have to compare, as they would have been picked up by the index setters
+
+
+    return false;
+  }
+
+  function hasChanges_(state) {
+    return state.type_ === 4
+    /* ES5Object */
+    ? hasObjectChanges(state) : hasArrayChanges(state);
+  }
+
+  function assertUnrevoked(state
+  /*ES5State | MapState | SetState*/
+  ) {
+    if (state.revoked_) die(3, JSON.stringify(latest(state)));
+  }
+
+  loadPlugin("ES5", {
+    createES5Proxy_: createES5Proxy_,
+    willFinalizeES5_: willFinalizeES5_,
+    hasChanges_: hasChanges_
+  });
+}
+
+// types only!
+function enableMapSet() {
+  /* istanbul ignore next */
+  var _extendStatics = function extendStatics(d, b) {
+    _extendStatics = Object.setPrototypeOf || {
+      __proto__: []
+    } instanceof Array && function (d, b) {
+      d.__proto__ = b;
+    } || function (d, b) {
+      for (var p in b) {
+        if (b.hasOwnProperty(p)) d[p] = b[p];
+      }
+    };
+
+    return _extendStatics(d, b);
+  }; // Ugly hack to resolve #502 and inherit built in Map / Set
+
+
+  function __extends(d, b) {
+    _extendStatics(d, b);
+
+    function __() {
+      Object.defineProperty(this, "constructor", {
+        value: d
+      });
+    }
+
+    d.prototype = ( // @ts-ignore
+    __.prototype = b.prototype, new __());
+  }
+
+  var DraftMap = function (_super) {
+    var _Object$definePropert;
+
+    __extends(DraftMap, _super); // Create class manually, cause #502
+
+
+    function DraftMap(target, parent) {
+      this[DRAFT_STATE] = {
+        type_: 2
+        /* Map */
+        ,
+        parent_: parent,
+        scope_: parent ? parent.scope_ : getCurrentScope(),
+        modified_: false,
+        finalized_: false,
+        copy_: undefined,
+        assigned_: undefined,
+        base_: target,
+        draft_: this,
+        isManual_: false,
+        revoked_: false
+      };
+      return this;
+    }
+
+    var p = DraftMap.prototype;
+    Object.defineProperties(p, (_Object$definePropert = {
+      size: {
+        get: function get() {
+          return latest(this[DRAFT_STATE]).size;
+        },
+        configurable: true
+      },
+      has: {
+        configurable: true,
+        writable: true,
+        value: function value(key) {
+          return latest(this[DRAFT_STATE]).has(key);
+        }
+      },
+      set: {
+        configurable: true,
+        writable: true,
+        value: function value(key, _value2) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (!latest(state).has(key) || latest(state).get(key) !== _value2) {
+            prepareMapCopy(state);
+            markChanged(state);
+            state.assigned_.set(key, true);
+            state.copy_.set(key, _value2);
+            state.assigned_.set(key, true);
+          }
+
+          return this;
+        }
+      },
+      delete: {
+        configurable: true,
+        writable: true,
+        value: function value(key) {
+          if (!this.has(key)) {
+            return false;
+          }
+
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareMapCopy(state);
+          markChanged(state);
+
+          if (state.base_.has(key)) {
+            state.assigned_.set(key, false);
+          } else {
+            state.assigned_.delete(key);
+          }
+
+          state.copy_.delete(key);
+          return true;
+        }
+      },
+      clear: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (latest(state).size) {
+            prepareMapCopy(state);
+            markChanged(state);
+            state.assigned_ = new Map();
+            each(state.base_, function (key) {
+              state.assigned_.set(key, false);
+            });
+            state.copy_.clear();
+          }
+        }
+      },
+      forEach: {
+        configurable: true,
+        writable: true,
+        value: function value(cb, thisArg) {
+          var _this = this;
+
+          var state = this[DRAFT_STATE];
+          latest(state).forEach(function (_value, key, _map) {
+            cb.call(thisArg, _this.get(key), key, _this);
+          });
+        }
+      },
+      get: {
+        configurable: true,
+        writable: true,
+        value: function value(key) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          var value = latest(state).get(key);
+
+          if (state.finalized_ || !isDraftable(value)) {
+            return value;
+          }
+
+          if (value !== state.base_.get(key)) {
+            return value; // either already drafted or reassigned
+          } // despite what it looks, this creates a draft only once, see above condition
+
+
+          var draft = createProxy(state.scope_.immer_, value, state);
+          prepareMapCopy(state);
+          state.copy_.set(key, draft);
+          return draft;
+        }
+      },
+      keys: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          return latest(this[DRAFT_STATE]).keys();
+        }
+      },
+      values: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var _this2 = this,
+              _ref;
+
+          var iterator = this.keys();
+          return _ref = {}, _ref[iteratorSymbol] = function () {
+            return _this2.values();
+          }, _ref.next = function next() {
+            var r = iterator.next();
+            /* istanbul ignore next */
+
+            if (r.done) return r;
+
+            var value = _this2.get(r.value);
+
+            return {
+              done: false,
+              value: value
+            };
+          }, _ref;
+        }
+      },
+      entries: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var _this3 = this,
+              _ref2;
+
+          var iterator = this.keys();
+          return _ref2 = {}, _ref2[iteratorSymbol] = function () {
+            return _this3.entries();
+          }, _ref2.next = function next() {
+            var r = iterator.next();
+            /* istanbul ignore next */
+
+            if (r.done) return r;
+
+            var value = _this3.get(r.value);
+
+            return {
+              done: false,
+              value: [r.value, value]
+            };
+          }, _ref2;
+        }
+      }
+    }, _Object$definePropert[iteratorSymbol] = {
+      configurable: true,
+      writable: true,
+      value: function value() {
+        return this.entries();
+      }
+    }, _Object$definePropert));
+    return DraftMap;
+  }(Map);
+
+  function proxyMap_(target, parent) {
+    // @ts-ignore
+    return new DraftMap(target, parent);
+  }
+
+  function prepareMapCopy(state) {
+    if (!state.copy_) {
+      state.assigned_ = new Map();
+      state.copy_ = new Map(state.base_);
+    }
+  }
+
+  var DraftSet = function (_super) {
+    var _Object$definePropert2;
+
+    __extends(DraftSet, _super); // Create class manually, cause #502
+
+
+    function DraftSet(target, parent) {
+      this[DRAFT_STATE] = {
+        type_: 3
+        /* Set */
+        ,
+        parent_: parent,
+        scope_: parent ? parent.scope_ : getCurrentScope(),
+        modified_: false,
+        finalized_: false,
+        copy_: undefined,
+        base_: target,
+        draft_: this,
+        drafts_: new Map(),
+        revoked_: false,
+        isManual_: false
+      };
+      return this;
+    }
+
+    var p = DraftSet.prototype;
+    Object.defineProperties(p, (_Object$definePropert2 = {
+      size: {
+        get: function get() {
+          return latest(this[DRAFT_STATE]).size;
+        },
+        configurable: true
+      },
+      has: {
+        configurable: true,
+        writable: true,
+        value: function value(_value3) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value
+
+          if (!state.copy_) {
+            return state.base_.has(_value3);
+          }
+
+          if (state.copy_.has(_value3)) return true;
+          if (state.drafts_.has(_value3) && state.copy_.has(state.drafts_.get(_value3))) return true;
+          return false;
+        }
+      },
+      add: {
+        configurable: true,
+        writable: true,
+        value: function value(_value4) {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (!this.has(_value4)) {
+            prepareSetCopy(state);
+            markChanged(state);
+            state.copy_.add(_value4);
+          }
+
+          return this;
+        }
+      },
+      delete: {
+        configurable: true,
+        writable: true,
+        value: function value(_value5) {
+          if (!this.has(_value5)) {
+            return false;
+          }
+
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareSetCopy(state);
+          markChanged(state);
+          return state.copy_.delete(_value5) || (state.drafts_.has(_value5) ? state.copy_.delete(state.drafts_.get(_value5)) :
+          /* istanbul ignore next */
+          false);
+        }
+      },
+      clear: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+
+          if (latest(state).size) {
+            prepareSetCopy(state);
+            markChanged(state);
+            state.copy_.clear();
+          }
+        }
+      },
+      values: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareSetCopy(state);
+          return state.copy_.values();
+        }
+      },
+      entries: {
+        configurable: true,
+        writable: true,
+        value: function entries() {
+          var state = this[DRAFT_STATE];
+          assertUnrevoked(state);
+          prepareSetCopy(state);
+          return state.copy_.entries();
+        }
+      },
+      keys: {
+        configurable: true,
+        writable: true,
+        value: function value() {
+          return this.values();
+        }
+      }
+    }, _Object$definePropert2[iteratorSymbol] = {
+      configurable: true,
+      writable: true,
+      value: function value() {
+        return this.values();
+      }
+    }, _Object$definePropert2.forEach = {
+      configurable: true,
+      writable: true,
+      value: function forEach(cb, thisArg) {
+        var iterator = this.values();
+        var result = iterator.next();
+
+        while (!result.done) {
+          cb.call(thisArg, result.value, result.value, this);
+          result = iterator.next();
+        }
+      }
+    }, _Object$definePropert2));
+    return DraftSet;
+  }(Set);
+
+  function proxySet_(target, parent) {
+    // @ts-ignore
+    return new DraftSet(target, parent);
+  }
+
+  function prepareSetCopy(state) {
+    if (!state.copy_) {
+      // create drafts for all entries to preserve insertion order
+      state.copy_ = new Set();
+      state.base_.forEach(function (value) {
+        if (isDraftable(value)) {
+          var draft = createProxy(state.scope_.immer_, value, state);
+          state.drafts_.set(value, draft);
+          state.copy_.add(draft);
+        } else {
+          state.copy_.add(value);
+        }
+      });
+    }
+  }
+
+  function assertUnrevoked(state
+  /*ES5State | MapState | SetState*/
+  ) {
+    if (state.revoked_) die(3, JSON.stringify(latest(state)));
+  }
+
+  loadPlugin("MapSet", {
+    proxyMap_: proxyMap_,
+    proxySet_: proxySet_
+  });
+}
+
+function enableAllPlugins() {
+  enableES5();
+  enableMapSet();
+  enablePatches();
+}
+
+function enablePatches() {
+  var REPLACE = "replace";
+  var ADD = "add";
+  var REMOVE = "remove";
+
+  function generatePatches_(state, basePath, patches, inversePatches) {
+    switch (state.type_) {
+      case 0
+      /* ProxyObject */
+      :
+      case 4
+      /* ES5Object */
+      :
+      case 2
+      /* Map */
+      :
+        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
+
+      case 5
+      /* ES5Array */
+      :
+      case 1
+      /* ProxyArray */
+      :
+        return generateArrayPatches(state, basePath, patches, inversePatches);
+
+      case 3
+      /* Set */
+      :
+        return generateSetPatches(state, basePath, patches, inversePatches);
+    }
+  }
+
+  function generateArrayPatches(state, basePath, patches, inversePatches) {
+    var base_ = state.base_,
+        assigned_ = state.assigned_;
+    var copy_ = state.copy_; // Reduce complexity by ensuring `base` is never longer.
+
+    if (copy_.length < base_.length) {
+      var _ref = [copy_, base_];
+      base_ = _ref[0];
+      copy_ = _ref[1];
+      var _ref2 = [inversePatches, patches];
+      patches = _ref2[0];
+      inversePatches = _ref2[1];
+    } // Process replaced indices.
+
+
+    for (var i = 0; i < base_.length; i++) {
+      if (assigned_[i] && copy_[i] !== base_[i]) {
+        var path = basePath.concat([i]);
+        patches.push({
+          op: REPLACE,
+          path: path,
+          // Need to maybe clone it, as it can in fact be the original value
+          // due to the base/copy inversion at the start of this function
+          value: clonePatchValueIfNeeded(copy_[i])
+        });
+        inversePatches.push({
+          op: REPLACE,
+          path: path,
+          value: clonePatchValueIfNeeded(base_[i])
+        });
+      }
+    } // Process added indices.
+
+
+    for (var _i = base_.length; _i < copy_.length; _i++) {
+      var _path = basePath.concat([_i]);
+
+      patches.push({
+        op: ADD,
+        path: _path,
+        // Need to maybe clone it, as it can in fact be the original value
+        // due to the base/copy inversion at the start of this function
+        value: clonePatchValueIfNeeded(copy_[_i])
+      });
+    }
+
+    if (base_.length < copy_.length) {
+      inversePatches.push({
+        op: REPLACE,
+        path: basePath.concat(["length"]),
+        value: base_.length
+      });
+    }
+  } // This is used for both Map objects and normal objects.
+
+
+  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
+    var base_ = state.base_,
+        copy_ = state.copy_;
+    each(state.assigned_, function (key, assignedValue) {
+      var origValue = get(base_, key);
+      var value = get(copy_, key);
+      var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
+      if (origValue === value && op === REPLACE) return;
+      var path = basePath.concat(key);
+      patches.push(op === REMOVE ? {
+        op: op,
+        path: path
+      } : {
+        op: op,
+        path: path,
+        value: value
+      });
+      inversePatches.push(op === ADD ? {
+        op: REMOVE,
+        path: path
+      } : op === REMOVE ? {
+        op: ADD,
+        path: path,
+        value: clonePatchValueIfNeeded(origValue)
+      } : {
+        op: REPLACE,
+        path: path,
+        value: clonePatchValueIfNeeded(origValue)
+      });
+    });
+  }
+
+  function generateSetPatches(state, basePath, patches, inversePatches) {
+    var base_ = state.base_,
+        copy_ = state.copy_;
+    var i = 0;
+    base_.forEach(function (value) {
+      if (!copy_.has(value)) {
+        var path = basePath.concat([i]);
+        patches.push({
+          op: REMOVE,
+          path: path,
+          value: value
+        });
+        inversePatches.unshift({
+          op: ADD,
+          path: path,
+          value: value
+        });
+      }
+
+      i++;
+    });
+    i = 0;
+    copy_.forEach(function (value) {
+      if (!base_.has(value)) {
+        var path = basePath.concat([i]);
+        patches.push({
+          op: ADD,
+          path: path,
+          value: value
+        });
+        inversePatches.unshift({
+          op: REMOVE,
+          path: path,
+          value: value
+        });
+      }
+
+      i++;
+    });
+  }
+
+  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
+    patches.push({
+      op: REPLACE,
+      path: [],
+      value: replacement === NOTHING ? undefined : replacement
+    });
+    inversePatches.push({
+      op: REPLACE,
+      path: [],
+      value: baseValue
+    });
+  }
+
+  function applyPatches_(draft, patches) {
+    patches.forEach(function (patch) {
+      var path = patch.path,
+          op = patch.op;
+      var base = draft;
+
+      for (var i = 0; i < path.length - 1; i++) {
+        var parentType = getArchtype(base);
+        var p = "" + path[i]; // See #738, avoid prototype pollution
+
+        if ((parentType === 0
+        /* Object */
+        || parentType === 1
+        /* Array */
+        ) && (p === "__proto__" || p === "constructor")) die(24);
+        if (typeof base === "function" && p === "prototype") die(24);
+        base = get(base, p);
+        if (typeof base !== "object") die(15, path.join("/"));
+      }
+
+      var type = getArchtype(base);
+      var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411
+
+      var key = path[path.length - 1];
+
+      switch (op) {
+        case REPLACE:
+          switch (type) {
+            case 2
+            /* Map */
+            :
+              return base.set(key, value);
+
+            /* istanbul ignore next */
+
+            case 3
+            /* Set */
+            :
+              die(16);
+
+            default:
+              // if value is an object, then it's assigned by reference
+              // in the following add or remove ops, the value field inside the patch will also be modifyed
+              // so we use value from the cloned patch
+              // @ts-ignore
+              return base[key] = value;
+          }
+
+        case ADD:
+          switch (type) {
+            case 1
+            /* Array */
+            :
+              return key === "-" ? base.push(value) : base.splice(key, 0, value);
+
+            case 2
+            /* Map */
+            :
+              return base.set(key, value);
+
+            case 3
+            /* Set */
+            :
+              return base.add(value);
+
+            default:
+              return base[key] = value;
+          }
+
+        case REMOVE:
+          switch (type) {
+            case 1
+            /* Array */
+            :
+              return base.splice(key, 1);
+
+            case 2
+            /* Map */
+            :
+              return base.delete(key);
+
+            case 3
+            /* Set */
+            :
+              return base.delete(patch.value);
+
+            default:
+              return delete base[key];
+          }
+
+        default:
+          die(17, op);
+      }
+    });
+    return draft;
+  }
+
+  function deepClonePatchValue(obj) {
+    if (!isDraftable(obj)) return obj;
+    if (Array.isArray(obj)) return obj.map(deepClonePatchValue);
+    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function (_ref3) {
+      var k = _ref3[0],
+          v = _ref3[1];
+      return [k, deepClonePatchValue(v)];
+    }));
+    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
+    var cloned = Object.create(Object.getPrototypeOf(obj));
+
+    for (var key in obj) {
+      cloned[key] = deepClonePatchValue(obj[key]);
+    }
+
+    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
+    return cloned;
+  }
+
+  function clonePatchValueIfNeeded(obj) {
+    if (isDraft(obj)) {
+      return deepClonePatchValue(obj);
+    } else return obj;
+  }
+
+  loadPlugin("Patches", {
+    applyPatches_: applyPatches_,
+    generatePatches_: generatePatches_,
+    generateReplacementPatches_: generateReplacementPatches_
+  });
+}
+
+var immer =
+/*#__PURE__*/
+new Immer();
+/**
+* The `produce` function takes a value and a "recipe function" (whose
+* return value often depends on the base state). The recipe function is
+* free to mutate its first argument however it wants. All mutations are
+* only ever applied to a __copy__ of the base state.
+*
+* Pass only a function to create a "curried producer" which relieves you
+* from passing the recipe function every time.
+*
+* Only plain objects and arrays are made mutable. All other objects are
+* considered uncopyable.
+*
+* Note: This function is __bound__ to its `Immer` instance.
+*
+* @param {any} base - the initial state
+* @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+* @param {Function} patchListener - optional function that will be called with all the patches produced here
+* @returns {any} a new state, or the initial state if nothing was modified
+*/
+
+var produce = immer.produce;
+/**
+* Like `produce`, but `produceWithPatches` always returns a tuple
+* [nextState, patches, inversePatches] (instead of just the next state)
+*/
+
+var produceWithPatches =
+/*#__PURE__*/
+immer.produceWithPatches.bind(immer);
+/**
+* Pass true to automatically freeze all copies created by Immer.
+*
+* Always freeze by default, even in production mode
+*/
+
+var setAutoFreeze =
+/*#__PURE__*/
+immer.setAutoFreeze.bind(immer);
+/**
+* Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+* always faster than using ES5 proxies.
+*
+* By default, feature detection is used, so calling this is rarely necessary.
+*/
+
+var setUseProxies =
+/*#__PURE__*/
+immer.setUseProxies.bind(immer);
+/**
+* Apply an array of Immer patches to the first argument.
+*
+* This function is a producer, which means copy-on-write is in effect.
+*/
+
+var applyPatches =
+/*#__PURE__*/
+immer.applyPatches.bind(immer);
+/**
+* Create an Immer draft from the given base state, which may be a draft itself.
+* The draft can be modified until you finalize it with the `finishDraft` function.
+*/
+
+var createDraft =
+/*#__PURE__*/
+immer.createDraft.bind(immer);
+/**
+* Finalize an Immer draft from a `createDraft` call, returning the base state
+* (if no changes were made) or a modified copy. The draft must *not* be
+* mutated afterwards.
+*
+* Pass a function as the 2nd argument to generate Immer patches based on the
+* changes that were made.
+*/
+
+var finishDraft =
+/*#__PURE__*/
+immer.finishDraft.bind(immer);
+/**
+* This function is actually a no-op, but can be used to cast an immutable type
+* to an draft type and make TypeScript happy
+*
+* @param value
+*/
+
+function castDraft(value) {
+  return value;
+}
+/**
+* This function is actually a no-op, but can be used to cast a mutable type
+* to an immutable type and make TypeScript happy
+* @param value
+*/
+
+function castImmutable(value) {
+  return value;
+}
+
+export default produce;
+export { Immer, applyPatches, castDraft, castImmutable, createDraft, current, enableAllPlugins, enableES5, enableMapSet, enablePatches, finishDraft, freeze, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };
 //# sourceMappingURL=immer.esm.js.map
diff --git a/dist/immer.umd.development.js b/dist/immer.umd.development.js
index c88f78a37fbada3abd543dd06889250bb7197115..233a83b981e3992d5079848d1207d5b78aaf667c 100644
--- a/dist/immer.umd.development.js
+++ b/dist/immer.umd.development.js
@@ -272,7 +272,17 @@
 	  if (getArchtype(obj) > 1
 	  /* Map or Set */
 	  ) {
-	      obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
+	      var desc = {
+	        configurable: true,
+	        writable: true,
+	        value: dontMutateFrozenCollections
+	      };
+	      Object.defineProperties(obj, {
+	        set: desc,
+	        add: desc,
+	        clear: desc,
+	        delete: desc
+	      });
 	    }
 
 	  Object.freeze(obj);
@@ -493,10 +503,10 @@
 	}
 
 	/**
-	 * Returns a new draft of the `base` object.
-	 *
-	 * The second argument is the parent draft-state (used internally).
-	 */
+	* Returns a new draft of the `base` object.
+	*
+	* The second argument is the parent draft-state (used internally).
+	*/
 
 	function createProxyProxy(base, parent) {
 	  var isArray = Array.isArray(base);
@@ -549,8 +559,8 @@
 	  return proxy;
 	}
 	/**
-	 * Object drafts
-	 */
+	* Object drafts
+	*/
 
 	var objectTraps = {
 	  get: function get(state, prop) {
@@ -613,9 +623,9 @@
 	      markChanged(state);
 	    }
 
-	    if (state.copy_[prop] === value && // special case: NaN
-	    typeof value !== "number" && ( // special case: handle new props with value 'undefined'
-	    value !== undefined || prop in state.copy_)) return true; // @ts-ignore
+	    if (state.copy_[prop] === value && ( // special case: handle new props with value 'undefined'
+	    value !== undefined || prop in state.copy_) || // special case: NaN
+	    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true; // @ts-ignore
 
 	    state.copy_[prop] = value;
 	    state.assigned_[prop] = true;
@@ -662,8 +672,8 @@
 	  }
 	};
 	/**
-	 * Array drafts
-	 */
+	* Array drafts
+	*/
 
 	var arrayTraps = {};
 	each(objectTraps, function (key, fn) {
@@ -739,24 +749,24 @@
 	    this.useProxies_ = hasProxies;
 	    this.autoFreeze_ = true;
 	    /**
-	     * The `produce` function takes a value and a "recipe function" (whose
-	     * return value often depends on the base state). The recipe function is
-	     * free to mutate its first argument however it wants. All mutations are
-	     * only ever applied to a __copy__ of the base state.
-	     *
-	     * Pass only a function to create a "curried producer" which relieves you
-	     * from passing the recipe function every time.
-	     *
-	     * Only plain objects and arrays are made mutable. All other objects are
-	     * considered uncopyable.
-	     *
-	     * Note: This function is __bound__ to its `Immer` instance.
-	     *
-	     * @param {any} base - the initial state
-	     * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
-	     * @param {Function} patchListener - optional function that will be called with all the patches produced here
-	     * @returns {any} a new state, or the initial state if nothing was modified
-	     */
+	            * The `produce` function takes a value and a "recipe function" (whose
+	            * return value often depends on the base state). The recipe function is
+	            * free to mutate its first argument however it wants. All mutations are
+	            * only ever applied to a __copy__ of the base state.
+	            *
+	            * Pass only a function to create a "curried producer" which relieves you
+	            * from passing the recipe function every time.
+	            *
+	            * Only plain objects and arrays are made mutable. All other objects are
+	            * considered uncopyable.
+	            *
+	            * Note: This function is __bound__ to its `Immer` instance.
+	            *
+	            * @param {any} base - the initial state
+	            * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+	            * @param {Function} patchListener - optional function that will be called with all the patches produced here
+	            * @returns {any} a new state, or the initial state if nothing was modified
+	            */
 
 	    this.produce = function (base, recipe, patchListener) {
 	      // curried invocation
@@ -888,21 +898,21 @@
 	    return processResult(undefined, scope);
 	  }
 	  /**
-	   * Pass true to automatically freeze all copies created by Immer.
-	   *
-	   * By default, auto-freezing is enabled.
-	   */
+	          * Pass true to automatically freeze all copies created by Immer.
+	          *
+	          * By default, auto-freezing is enabled.
+	          */
 	  ;
 
 	  _proto.setAutoFreeze = function setAutoFreeze(value) {
 	    this.autoFreeze_ = value;
 	  }
 	  /**
-	   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
-	   * always faster than using ES5 proxies.
-	   *
-	   * By default, feature detection is used, so calling this is rarely necessary.
-	   */
+	          * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+	          * always faster than using ES5 proxies.
+	          *
+	          * By default, feature detection is used, so calling this is rarely necessary.
+	          */
 	  ;
 
 	  _proto.setUseProxies = function setUseProxies(value) {
@@ -1275,6 +1285,434 @@
 	  });
 	}
 
+	// types only!
+	function enableMapSet() {
+	  /* istanbul ignore next */
+	  var _extendStatics = function extendStatics(d, b) {
+	    _extendStatics = Object.setPrototypeOf || {
+	      __proto__: []
+	    } instanceof Array && function (d, b) {
+	      d.__proto__ = b;
+	    } || function (d, b) {
+	      for (var p in b) {
+	        if (b.hasOwnProperty(p)) d[p] = b[p];
+	      }
+	    };
+
+	    return _extendStatics(d, b);
+	  }; // Ugly hack to resolve #502 and inherit built in Map / Set
+
+
+	  function __extends(d, b) {
+	    _extendStatics(d, b);
+
+	    function __() {
+	      Object.defineProperty(this, "constructor", {
+	        value: d
+	      });
+	    }
+
+	    d.prototype = ( // @ts-ignore
+	    __.prototype = b.prototype, new __());
+	  }
+
+	  var DraftMap = function (_super) {
+	    var _Object$definePropert;
+
+	    __extends(DraftMap, _super); // Create class manually, cause #502
+
+
+	    function DraftMap(target, parent) {
+	      this[DRAFT_STATE] = {
+	        type_: 2
+	        /* Map */
+	        ,
+	        parent_: parent,
+	        scope_: parent ? parent.scope_ : getCurrentScope(),
+	        modified_: false,
+	        finalized_: false,
+	        copy_: undefined,
+	        assigned_: undefined,
+	        base_: target,
+	        draft_: this,
+	        isManual_: false,
+	        revoked_: false
+	      };
+	      return this;
+	    }
+
+	    var p = DraftMap.prototype;
+	    Object.defineProperties(p, (_Object$definePropert = {
+	      size: {
+	        get: function get() {
+	          return latest(this[DRAFT_STATE]).size;
+	        },
+	        configurable: true
+	      },
+	      has: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(key) {
+	          return latest(this[DRAFT_STATE]).has(key);
+	        }
+	      },
+	      set: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(key, _value2) {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+
+	          if (!latest(state).has(key) || latest(state).get(key) !== _value2) {
+	            prepareMapCopy(state);
+	            markChanged(state);
+	            state.assigned_.set(key, true);
+	            state.copy_.set(key, _value2);
+	            state.assigned_.set(key, true);
+	          }
+
+	          return this;
+	        }
+	      },
+	      delete: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(key) {
+	          if (!this.has(key)) {
+	            return false;
+	          }
+
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+	          prepareMapCopy(state);
+	          markChanged(state);
+
+	          if (state.base_.has(key)) {
+	            state.assigned_.set(key, false);
+	          } else {
+	            state.assigned_.delete(key);
+	          }
+
+	          state.copy_.delete(key);
+	          return true;
+	        }
+	      },
+	      clear: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+
+	          if (latest(state).size) {
+	            prepareMapCopy(state);
+	            markChanged(state);
+	            state.assigned_ = new Map();
+	            each(state.base_, function (key) {
+	              state.assigned_.set(key, false);
+	            });
+	            state.copy_.clear();
+	          }
+	        }
+	      },
+	      forEach: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(cb, thisArg) {
+	          var _this = this;
+
+	          var state = this[DRAFT_STATE];
+	          latest(state).forEach(function (_value, key, _map) {
+	            cb.call(thisArg, _this.get(key), key, _this);
+	          });
+	        }
+	      },
+	      get: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(key) {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+	          var value = latest(state).get(key);
+
+	          if (state.finalized_ || !isDraftable(value)) {
+	            return value;
+	          }
+
+	          if (value !== state.base_.get(key)) {
+	            return value; // either already drafted or reassigned
+	          } // despite what it looks, this creates a draft only once, see above condition
+
+
+	          var draft = createProxy(state.scope_.immer_, value, state);
+	          prepareMapCopy(state);
+	          state.copy_.set(key, draft);
+	          return draft;
+	        }
+	      },
+	      keys: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          return latest(this[DRAFT_STATE]).keys();
+	        }
+	      },
+	      values: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          var _this2 = this,
+	              _ref;
+
+	          var iterator = this.keys();
+	          return _ref = {}, _ref[iteratorSymbol] = function () {
+	            return _this2.values();
+	          }, _ref.next = function next() {
+	            var r = iterator.next();
+	            /* istanbul ignore next */
+
+	            if (r.done) return r;
+
+	            var value = _this2.get(r.value);
+
+	            return {
+	              done: false,
+	              value: value
+	            };
+	          }, _ref;
+	        }
+	      },
+	      entries: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          var _this3 = this,
+	              _ref2;
+
+	          var iterator = this.keys();
+	          return _ref2 = {}, _ref2[iteratorSymbol] = function () {
+	            return _this3.entries();
+	          }, _ref2.next = function next() {
+	            var r = iterator.next();
+	            /* istanbul ignore next */
+
+	            if (r.done) return r;
+
+	            var value = _this3.get(r.value);
+
+	            return {
+	              done: false,
+	              value: [r.value, value]
+	            };
+	          }, _ref2;
+	        }
+	      }
+	    }, _Object$definePropert[iteratorSymbol] = {
+	      configurable: true,
+	      writable: true,
+	      value: function value() {
+	        return this.entries();
+	      }
+	    }, _Object$definePropert));
+	    return DraftMap;
+	  }(Map);
+
+	  function proxyMap_(target, parent) {
+	    // @ts-ignore
+	    return new DraftMap(target, parent);
+	  }
+
+	  function prepareMapCopy(state) {
+	    if (!state.copy_) {
+	      state.assigned_ = new Map();
+	      state.copy_ = new Map(state.base_);
+	    }
+	  }
+
+	  var DraftSet = function (_super) {
+	    var _Object$definePropert2;
+
+	    __extends(DraftSet, _super); // Create class manually, cause #502
+
+
+	    function DraftSet(target, parent) {
+	      this[DRAFT_STATE] = {
+	        type_: 3
+	        /* Set */
+	        ,
+	        parent_: parent,
+	        scope_: parent ? parent.scope_ : getCurrentScope(),
+	        modified_: false,
+	        finalized_: false,
+	        copy_: undefined,
+	        base_: target,
+	        draft_: this,
+	        drafts_: new Map(),
+	        revoked_: false,
+	        isManual_: false
+	      };
+	      return this;
+	    }
+
+	    var p = DraftSet.prototype;
+	    Object.defineProperties(p, (_Object$definePropert2 = {
+	      size: {
+	        get: function get() {
+	          return latest(this[DRAFT_STATE]).size;
+	        },
+	        configurable: true
+	      },
+	      has: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(_value3) {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value
+
+	          if (!state.copy_) {
+	            return state.base_.has(_value3);
+	          }
+
+	          if (state.copy_.has(_value3)) return true;
+	          if (state.drafts_.has(_value3) && state.copy_.has(state.drafts_.get(_value3))) return true;
+	          return false;
+	        }
+	      },
+	      add: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(_value4) {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+
+	          if (!this.has(_value4)) {
+	            prepareSetCopy(state);
+	            markChanged(state);
+	            state.copy_.add(_value4);
+	          }
+
+	          return this;
+	        }
+	      },
+	      delete: {
+	        configurable: true,
+	        writable: true,
+	        value: function value(_value5) {
+	          if (!this.has(_value5)) {
+	            return false;
+	          }
+
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+	          prepareSetCopy(state);
+	          markChanged(state);
+	          return state.copy_.delete(_value5) || (state.drafts_.has(_value5) ? state.copy_.delete(state.drafts_.get(_value5)) :
+	          /* istanbul ignore next */
+	          false);
+	        }
+	      },
+	      clear: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+
+	          if (latest(state).size) {
+	            prepareSetCopy(state);
+	            markChanged(state);
+	            state.copy_.clear();
+	          }
+	        }
+	      },
+	      values: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+	          prepareSetCopy(state);
+	          return state.copy_.values();
+	        }
+	      },
+	      entries: {
+	        configurable: true,
+	        writable: true,
+	        value: function entries() {
+	          var state = this[DRAFT_STATE];
+	          assertUnrevoked(state);
+	          prepareSetCopy(state);
+	          return state.copy_.entries();
+	        }
+	      },
+	      keys: {
+	        configurable: true,
+	        writable: true,
+	        value: function value() {
+	          return this.values();
+	        }
+	      }
+	    }, _Object$definePropert2[iteratorSymbol] = {
+	      configurable: true,
+	      writable: true,
+	      value: function value() {
+	        return this.values();
+	      }
+	    }, _Object$definePropert2.forEach = {
+	      configurable: true,
+	      writable: true,
+	      value: function forEach(cb, thisArg) {
+	        var iterator = this.values();
+	        var result = iterator.next();
+
+	        while (!result.done) {
+	          cb.call(thisArg, result.value, result.value, this);
+	          result = iterator.next();
+	        }
+	      }
+	    }, _Object$definePropert2));
+	    return DraftSet;
+	  }(Set);
+
+	  function proxySet_(target, parent) {
+	    // @ts-ignore
+	    return new DraftSet(target, parent);
+	  }
+
+	  function prepareSetCopy(state) {
+	    if (!state.copy_) {
+	      // create drafts for all entries to preserve insertion order
+	      state.copy_ = new Set();
+	      state.base_.forEach(function (value) {
+	        if (isDraftable(value)) {
+	          var draft = createProxy(state.scope_.immer_, value, state);
+	          state.drafts_.set(value, draft);
+	          state.copy_.add(draft);
+	        } else {
+	          state.copy_.add(value);
+	        }
+	      });
+	    }
+	  }
+
+	  function assertUnrevoked(state
+	  /*ES5State | MapState | SetState*/
+	  ) {
+	    if (state.revoked_) die(3, JSON.stringify(latest(state)));
+	  }
+
+	  loadPlugin("MapSet", {
+	    proxyMap_: proxyMap_,
+	    proxySet_: proxySet_
+	  });
+	}
+
+	function enableAllPlugins() {
+	  enableES5();
+	  enableMapSet();
+	  enablePatches();
+	}
+
 	function enablePatches() {
 	  var REPLACE = "replace";
 	  var ADD = "add";
@@ -1579,468 +2017,101 @@
 	  });
 	}
 
-	// types only!
-	function enableMapSet() {
-	  /* istanbul ignore next */
-	  var _extendStatics = function extendStatics(d, b) {
-	    _extendStatics = Object.setPrototypeOf || {
-	      __proto__: []
-	    } instanceof Array && function (d, b) {
-	      d.__proto__ = b;
-	    } || function (d, b) {
-	      for (var p in b) {
-	        if (b.hasOwnProperty(p)) d[p] = b[p];
-	      }
-	    };
-
-	    return _extendStatics(d, b);
-	  }; // Ugly hack to resolve #502 and inherit built in Map / Set
-
-
-	  function __extends(d, b) {
-	    _extendStatics(d, b);
-
-	    function __() {
-	      this.constructor = d;
-	    }
-
-	    d.prototype = ( // @ts-ignore
-	    __.prototype = b.prototype, new __());
-	  }
-
-	  var DraftMap = function (_super) {
-	    __extends(DraftMap, _super); // Create class manually, cause #502
-
-
-	    function DraftMap(target, parent) {
-	      this[DRAFT_STATE] = {
-	        type_: 2
-	        /* Map */
-	        ,
-	        parent_: parent,
-	        scope_: parent ? parent.scope_ : getCurrentScope(),
-	        modified_: false,
-	        finalized_: false,
-	        copy_: undefined,
-	        assigned_: undefined,
-	        base_: target,
-	        draft_: this,
-	        isManual_: false,
-	        revoked_: false
-	      };
-	      return this;
-	    }
-
-	    var p = DraftMap.prototype;
-	    Object.defineProperty(p, "size", {
-	      get: function get() {
-	        return latest(this[DRAFT_STATE]).size;
-	      } // enumerable: false,
-	      // configurable: true
-
-	    });
-
-	    p.has = function (key) {
-	      return latest(this[DRAFT_STATE]).has(key);
-	    };
-
-	    p.set = function (key, value) {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-
-	      if (!latest(state).has(key) || latest(state).get(key) !== value) {
-	        prepareMapCopy(state);
-	        markChanged(state);
-	        state.assigned_.set(key, true);
-	        state.copy_.set(key, value);
-	        state.assigned_.set(key, true);
-	      }
-
-	      return this;
-	    };
-
-	    p.delete = function (key) {
-	      if (!this.has(key)) {
-	        return false;
-	      }
-
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-	      prepareMapCopy(state);
-	      markChanged(state);
-
-	      if (state.base_.has(key)) {
-	        state.assigned_.set(key, false);
-	      } else {
-	        state.assigned_.delete(key);
-	      }
-
-	      state.copy_.delete(key);
-	      return true;
-	    };
-
-	    p.clear = function () {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-
-	      if (latest(state).size) {
-	        prepareMapCopy(state);
-	        markChanged(state);
-	        state.assigned_ = new Map();
-	        each(state.base_, function (key) {
-	          state.assigned_.set(key, false);
-	        });
-	        state.copy_.clear();
-	      }
-	    };
-
-	    p.forEach = function (cb, thisArg) {
-	      var _this = this;
-
-	      var state = this[DRAFT_STATE];
-	      latest(state).forEach(function (_value, key, _map) {
-	        cb.call(thisArg, _this.get(key), key, _this);
-	      });
-	    };
-
-	    p.get = function (key) {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-	      var value = latest(state).get(key);
-
-	      if (state.finalized_ || !isDraftable(value)) {
-	        return value;
-	      }
-
-	      if (value !== state.base_.get(key)) {
-	        return value; // either already drafted or reassigned
-	      } // despite what it looks, this creates a draft only once, see above condition
-
-
-	      var draft = createProxy(state.scope_.immer_, value, state);
-	      prepareMapCopy(state);
-	      state.copy_.set(key, draft);
-	      return draft;
-	    };
-
-	    p.keys = function () {
-	      return latest(this[DRAFT_STATE]).keys();
-	    };
-
-	    p.values = function () {
-	      var _this2 = this,
-	          _ref;
-
-	      var iterator = this.keys();
-	      return _ref = {}, _ref[iteratorSymbol] = function () {
-	        return _this2.values();
-	      }, _ref.next = function next() {
-	        var r = iterator.next();
-	        /* istanbul ignore next */
-
-	        if (r.done) return r;
-
-	        var value = _this2.get(r.value);
-
-	        return {
-	          done: false,
-	          value: value
-	        };
-	      }, _ref;
-	    };
-
-	    p.entries = function () {
-	      var _this3 = this,
-	          _ref2;
-
-	      var iterator = this.keys();
-	      return _ref2 = {}, _ref2[iteratorSymbol] = function () {
-	        return _this3.entries();
-	      }, _ref2.next = function next() {
-	        var r = iterator.next();
-	        /* istanbul ignore next */
-
-	        if (r.done) return r;
-
-	        var value = _this3.get(r.value);
-
-	        return {
-	          done: false,
-	          value: [r.value, value]
-	        };
-	      }, _ref2;
-	    };
-
-	    p[iteratorSymbol] = function () {
-	      return this.entries();
-	    };
-
-	    return DraftMap;
-	  }(Map);
-
-	  function proxyMap_(target, parent) {
-	    // @ts-ignore
-	    return new DraftMap(target, parent);
-	  }
-
-	  function prepareMapCopy(state) {
-	    if (!state.copy_) {
-	      state.assigned_ = new Map();
-	      state.copy_ = new Map(state.base_);
-	    }
-	  }
-
-	  var DraftSet = function (_super) {
-	    __extends(DraftSet, _super); // Create class manually, cause #502
-
-
-	    function DraftSet(target, parent) {
-	      this[DRAFT_STATE] = {
-	        type_: 3
-	        /* Set */
-	        ,
-	        parent_: parent,
-	        scope_: parent ? parent.scope_ : getCurrentScope(),
-	        modified_: false,
-	        finalized_: false,
-	        copy_: undefined,
-	        base_: target,
-	        draft_: this,
-	        drafts_: new Map(),
-	        revoked_: false,
-	        isManual_: false
-	      };
-	      return this;
-	    }
-
-	    var p = DraftSet.prototype;
-	    Object.defineProperty(p, "size", {
-	      get: function get() {
-	        return latest(this[DRAFT_STATE]).size;
-	      } // enumerable: true,
-
-	    });
-
-	    p.has = function (value) {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value
-
-	      if (!state.copy_) {
-	        return state.base_.has(value);
-	      }
-
-	      if (state.copy_.has(value)) return true;
-	      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
-	      return false;
-	    };
-
-	    p.add = function (value) {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-
-	      if (!this.has(value)) {
-	        prepareSetCopy(state);
-	        markChanged(state);
-	        state.copy_.add(value);
-	      }
-
-	      return this;
-	    };
-
-	    p.delete = function (value) {
-	      if (!this.has(value)) {
-	        return false;
-	      }
-
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-	      prepareSetCopy(state);
-	      markChanged(state);
-	      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) :
-	      /* istanbul ignore next */
-	      false);
-	    };
-
-	    p.clear = function () {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-
-	      if (latest(state).size) {
-	        prepareSetCopy(state);
-	        markChanged(state);
-	        state.copy_.clear();
-	      }
-	    };
-
-	    p.values = function () {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-	      prepareSetCopy(state);
-	      return state.copy_.values();
-	    };
-
-	    p.entries = function entries() {
-	      var state = this[DRAFT_STATE];
-	      assertUnrevoked(state);
-	      prepareSetCopy(state);
-	      return state.copy_.entries();
-	    };
-
-	    p.keys = function () {
-	      return this.values();
-	    };
-
-	    p[iteratorSymbol] = function () {
-	      return this.values();
-	    };
-
-	    p.forEach = function forEach(cb, thisArg) {
-	      var iterator = this.values();
-	      var result = iterator.next();
-
-	      while (!result.done) {
-	        cb.call(thisArg, result.value, result.value, this);
-	        result = iterator.next();
-	      }
-	    };
-
-	    return DraftSet;
-	  }(Set);
-
-	  function proxySet_(target, parent) {
-	    // @ts-ignore
-	    return new DraftSet(target, parent);
-	  }
-
-	  function prepareSetCopy(state) {
-	    if (!state.copy_) {
-	      // create drafts for all entries to preserve insertion order
-	      state.copy_ = new Set();
-	      state.base_.forEach(function (value) {
-	        if (isDraftable(value)) {
-	          var draft = createProxy(state.scope_.immer_, value, state);
-	          state.drafts_.set(value, draft);
-	          state.copy_.add(draft);
-	        } else {
-	          state.copy_.add(value);
-	        }
-	      });
-	    }
-	  }
-
-	  function assertUnrevoked(state
-	  /*ES5State | MapState | SetState*/
-	  ) {
-	    if (state.revoked_) die(3, JSON.stringify(latest(state)));
-	  }
-
-	  loadPlugin("MapSet", {
-	    proxyMap_: proxyMap_,
-	    proxySet_: proxySet_
-	  });
-	}
-
-	function enableAllPlugins() {
-	  enableES5();
-	  enableMapSet();
-	  enablePatches();
-	}
-
 	var immer =
 	/*#__PURE__*/
 	new Immer();
 	/**
-	 * The `produce` function takes a value and a "recipe function" (whose
-	 * return value often depends on the base state). The recipe function is
-	 * free to mutate its first argument however it wants. All mutations are
-	 * only ever applied to a __copy__ of the base state.
-	 *
-	 * Pass only a function to create a "curried producer" which relieves you
-	 * from passing the recipe function every time.
-	 *
-	 * Only plain objects and arrays are made mutable. All other objects are
-	 * considered uncopyable.
-	 *
-	 * Note: This function is __bound__ to its `Immer` instance.
-	 *
-	 * @param {any} base - the initial state
-	 * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
-	 * @param {Function} patchListener - optional function that will be called with all the patches produced here
-	 * @returns {any} a new state, or the initial state if nothing was modified
-	 */
+	* The `produce` function takes a value and a "recipe function" (whose
+	* return value often depends on the base state). The recipe function is
+	* free to mutate its first argument however it wants. All mutations are
+	* only ever applied to a __copy__ of the base state.
+	*
+	* Pass only a function to create a "curried producer" which relieves you
+	* from passing the recipe function every time.
+	*
+	* Only plain objects and arrays are made mutable. All other objects are
+	* considered uncopyable.
+	*
+	* Note: This function is __bound__ to its `Immer` instance.
+	*
+	* @param {any} base - the initial state
+	* @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+	* @param {Function} patchListener - optional function that will be called with all the patches produced here
+	* @returns {any} a new state, or the initial state if nothing was modified
+	*/
 
 	var produce = immer.produce;
 	/**
-	 * Like `produce`, but `produceWithPatches` always returns a tuple
-	 * [nextState, patches, inversePatches] (instead of just the next state)
-	 */
+	* Like `produce`, but `produceWithPatches` always returns a tuple
+	* [nextState, patches, inversePatches] (instead of just the next state)
+	*/
 
 	var produceWithPatches =
 	/*#__PURE__*/
 	immer.produceWithPatches.bind(immer);
 	/**
-	 * Pass true to automatically freeze all copies created by Immer.
-	 *
-	 * Always freeze by default, even in production mode
-	 */
+	* Pass true to automatically freeze all copies created by Immer.
+	*
+	* Always freeze by default, even in production mode
+	*/
 
 	var setAutoFreeze =
 	/*#__PURE__*/
 	immer.setAutoFreeze.bind(immer);
 	/**
-	 * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
-	 * always faster than using ES5 proxies.
-	 *
-	 * By default, feature detection is used, so calling this is rarely necessary.
-	 */
+	* Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+	* always faster than using ES5 proxies.
+	*
+	* By default, feature detection is used, so calling this is rarely necessary.
+	*/
 
 	var setUseProxies =
 	/*#__PURE__*/
 	immer.setUseProxies.bind(immer);
 	/**
-	 * Apply an array of Immer patches to the first argument.
-	 *
-	 * This function is a producer, which means copy-on-write is in effect.
-	 */
+	* Apply an array of Immer patches to the first argument.
+	*
+	* This function is a producer, which means copy-on-write is in effect.
+	*/
 
 	var applyPatches =
 	/*#__PURE__*/
 	immer.applyPatches.bind(immer);
 	/**
-	 * Create an Immer draft from the given base state, which may be a draft itself.
-	 * The draft can be modified until you finalize it with the `finishDraft` function.
-	 */
+	* Create an Immer draft from the given base state, which may be a draft itself.
+	* The draft can be modified until you finalize it with the `finishDraft` function.
+	*/
 
 	var createDraft =
 	/*#__PURE__*/
 	immer.createDraft.bind(immer);
 	/**
-	 * Finalize an Immer draft from a `createDraft` call, returning the base state
-	 * (if no changes were made) or a modified copy. The draft must *not* be
-	 * mutated afterwards.
-	 *
-	 * Pass a function as the 2nd argument to generate Immer patches based on the
-	 * changes that were made.
-	 */
+	* Finalize an Immer draft from a `createDraft` call, returning the base state
+	* (if no changes were made) or a modified copy. The draft must *not* be
+	* mutated afterwards.
+	*
+	* Pass a function as the 2nd argument to generate Immer patches based on the
+	* changes that were made.
+	*/
 
 	var finishDraft =
 	/*#__PURE__*/
 	immer.finishDraft.bind(immer);
 	/**
-	 * This function is actually a no-op, but can be used to cast an immutable type
-	 * to an draft type and make TypeScript happy
-	 *
-	 * @param value
-	 */
+	* This function is actually a no-op, but can be used to cast an immutable type
+	* to an draft type and make TypeScript happy
+	*
+	* @param value
+	*/
 
 	function castDraft(value) {
 	  return value;
 	}
 	/**
-	 * This function is actually a no-op, but can be used to cast a mutable type
-	 * to an immutable type and make TypeScript happy
-	 * @param value
-	 */
+	* This function is actually a no-op, but can be used to cast a mutable type
+	* to an immutable type and make TypeScript happy
+	* @param value
+	*/
 
 	function castImmutable(value) {
 	  return value;
diff --git a/dist/immer.umd.development.js.map b/dist/immer.umd.development.js.map
index 8f995f72bb504716ae68c37d67c1b536663c0c7d..6a37da6ef5567815c3d556bdf570ba9c6f4649ba 100644
--- a/dist/immer.umd.development.js.map
+++ b/dist/immer.umd.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"immer.umd.development.js","sources":["../src/utils/env.ts","../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/patches.ts","../src/plugins/mapset.ts","../src/plugins/all.ts","../src/immer.ts"],"sourcesContent":["// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\tbase: any,\n\t\trecipe?: any,\n\t): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tthis.constructor = d\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: false,\n\t\t\t// configurable: true\n\t\t})\n\n\t\tp.has = function(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tp.set = function(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.forEach = function(\n\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\tthisArg?: any\n\t\t) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tp.get = function(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp.entries = function(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.entries()\n\t\t}\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: true,\n\t\t})\n\n\t\tp.has = function(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tp.add = function(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tp.entries = function entries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp.forEach = function forEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n"],"names":["hasSymbol","Symbol","hasMap","Map","hasSet","Set","hasProxies","Proxy","revocable","Reflect","NOTHING","for","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","errors","data","path","op","plugin","thing","die","error","args","e","msg","apply","Error","isDraft","value","isDraftable","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","Object","prototype","toString","proto","getPrototypeOf","Ctor","hasOwnProperty","call","Function","original","base_","ownKeys","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","getOwnPropertyDescriptors","target","res","forEach","key","getOwnPropertyDescriptor","each","iter","enumerableOnly","getArchtype","keys","entry","index","state","type_","has","prop","get","set","propOrOldValue","t","delete","add","is","x","y","latest","copy_","shallowCopy","base","slice","descriptors","i","length","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","plugins","getPlugin","pluginKey","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","autoFreeze_","createProxyProxy","parent","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","source","readPropFromProto","peek","prepareCopy","createProxy","getDescriptorFromProto","current","currentState","markChanged","deleteProperty","owner","defineProperty","setPrototypeOf","fn","arguments","isNaN","parseInt","Immer","config","recipe","defaultBase","self","curriedProduce","produce","hasError","Promise","then","p","ip","produceWithPatches","patches","inversePatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","createES5Proxy_","push","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","markChangesRecursively","markChangesSweep","createES5Draft","proxyProperty","assertUnrevoked","drafts","hasArrayChanges","hasObjectChanges","object","min","Math","baseValue","baseIsDraft","descriptor","JSON","stringify","enablePatches","REPLACE","ADD","REMOVE","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","clonePatchValueIfNeeded","assignedValue","origValue","unshift","replacement","parentType","join","type","deepClonePatchValue","splice","map","entries","k","v","cloned","immerable","enableMapSet","extendStatics","d","b","__proto__","__extends","__","DraftMap","_super","size","prepareMapCopy","cb","thisArg","_value","_map","values","next","r","done","DraftSet","prepareSetCopy","enableAllPlugins","bind","castDraft","castImmutable"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"immer.umd.development.js","sources":["../src/utils/env.ts","../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/mapset.ts","../src/plugins/all.ts","../src/plugins/patches.ts","../src/immer.ts"],"sourcesContent":["// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import { DRAFT_STATE, DRAFTABLE, hasSet, Objectish, Drafted, AnyObject, AnyMap, AnySet, ImmerState, hasMap, Archtype, die } from \"../internal.js\";\r\n\n /** Returns true if the given value is an Immer draft */\r\n/*#__PURE__*/\r\nexport function isDraft(value: any): boolean {\r\n    return !!value && !!value[DRAFT_STATE];\r\n}\r\n\n /** Returns true if the given value can be drafted by Immer */\r\n/*#__PURE__*/\r\nexport function isDraftable(value: any): boolean {\r\n    if (!value)\r\n        return false;\r\n    return (isPlainObject(value) ||\r\n        Array.isArray(value) ||\r\n        !!value[DRAFTABLE] ||\r\n        !!value.constructor?.[DRAFTABLE] ||\r\n        isMap(value) ||\r\n        isSet(value));\r\n}\r\n\n const objectCtorString = Object.prototype.constructor.toString();\r\n/*#__PURE__*/\r\nexport function isPlainObject(value: any): boolean {\r\n    if (!value || typeof value !== \"object\")\r\n        return false;\r\n    const proto = Object.getPrototypeOf(value);\r\n    if (proto === null) {\r\n        return true;\r\n    }\r\n    const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\r\n    \n if (Ctor === Object)\r\n        return true;\r\n    \n return (typeof Ctor == \"function\" &&\r\n        Function.toString.call(Ctor) === objectCtorString);\r\n}\r\n\n /** Get the underlying object that is represented by the given draft */\r\n/*#__PURE__*/\r\nexport function original<T>(value: T): T | undefined;\r\nexport function original(value: Drafted<any>): any {\r\n    if (!isDraft(value))\r\n        die(23, value);\r\n    return value[DRAFT_STATE].base_;\r\n}\r\n\n /*#__PURE__*/\r\nexport const ownKeys: (target: AnyObject) => PropertyKey[] = typeof Reflect !== \"undefined\" && Reflect.ownKeys\r\n    ? Reflect.ownKeys\r\n    : typeof Object.getOwnPropertySymbols !== \"undefined\"\r\n        ? obj => Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj) as any)\r\n        : /* istanbul ignore next */ Object.getOwnPropertyNames;\r\n\n export const getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\r\n    function getOwnPropertyDescriptors(target: any) {\r\n        // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\r\n        const res: any = {};\r\n        ownKeys(target).forEach(key => {\r\n            res[key] = Object.getOwnPropertyDescriptor(target, key);\r\n        });\r\n        return res;\r\n    };\r\n\n export function each<T extends Objectish>(obj: T, iter: (key: string | number, value: any, source: T) => void, enumerableOnly?: boolean): void;\r\nexport function each(obj: any, iter: any, enumerableOnly = false) {\r\n    if (getArchtype(obj) === Archtype.Object) {\r\n        ;\r\n        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\r\n            if (!enumerableOnly || typeof key !== \"symbol\")\r\n                iter(key, obj[key], obj);\r\n        });\r\n    }\r\n    else {\r\n        obj.forEach((entry: any, index: any) => iter(index, entry, obj));\r\n    }\r\n}\r\n\n /*#__PURE__*/\r\nexport function getArchtype(thing: any): Archtype {\r\n    /* istanbul ignore next */\r\n    const state: undefined | ImmerState = thing[DRAFT_STATE];\r\n    return state\r\n        ? state.type_ > 3\r\n            ? state.type_ - 4 // cause Object and Array map back from 4 and 5\r\n            : (state.type_ as any) // others are the same\r\n        : Array.isArray(thing)\r\n            ? Archtype.Array\r\n            : isMap(thing)\r\n                ? Archtype.Map\r\n                : isSet(thing)\r\n                    ? Archtype.Set\r\n                    : Archtype.Object;\r\n}\r\n\n /*#__PURE__*/\r\nexport function has(thing: any, prop: PropertyKey): boolean {\r\n    return getArchtype(thing) === Archtype.Map\r\n        ? thing.has(prop)\r\n        : Object.prototype.hasOwnProperty.call(thing, prop);\r\n}\r\n\n /*#__PURE__*/\r\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\r\n    // @ts-ignore\r\n    return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop];\r\n}\r\n\n /*#__PURE__*/\r\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\r\n    const t = getArchtype(thing);\r\n    if (t === Archtype.Map)\r\n        thing.set(propOrOldValue, value);\r\n    else if (t === Archtype.Set) {\r\n        thing.delete(propOrOldValue);\r\n        thing.add(value);\r\n    }\r\n    else\r\n        thing[propOrOldValue] = value;\r\n}\r\n\n /*#__PURE__*/\r\nexport function is(x: any, y: any): boolean {\r\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\r\n    if (x === y) {\r\n        return x !== 0 || 1 / x === 1 / y;\r\n    }\r\n    else {\r\n        return x !== x && y !== y;\r\n    }\r\n}\r\n\n /*#__PURE__*/\r\nexport function isMap(target: any): target is AnyMap {\r\n    return hasMap && target instanceof Map;\r\n}\r\n\n /*#__PURE__*/\r\nexport function isSet(target: any): target is AnySet {\r\n    return hasSet && target instanceof Set;\r\n}\r\n/*#__PURE__*/\r\nexport function latest(state: ImmerState): any {\r\n    return state.copy_ || state.base_;\r\n}\r\n\n /*#__PURE__*/\r\nexport function shallowCopy(base: any) {\r\n    if (Array.isArray(base))\r\n        return Array.prototype.slice.call(base);\r\n    const descriptors = getOwnPropertyDescriptors(base);\r\n    delete descriptors[DRAFT_STATE as any];\r\n    let keys = ownKeys(descriptors);\r\n    for (let i = 0; i < keys.length; i++) {\r\n        const key: any = keys[i];\r\n        const desc = descriptors[key];\r\n        if (desc.writable === false) {\r\n            desc.writable = true;\r\n            desc.configurable = true;\r\n        }\r\n        // like object.assign, we will read any _own_, get/set accessors. This helps in dealing\r\n        // with libraries that trap values, like mobx or vue\r\n        // unlike object.assign, non-enumerables will be copied as well\r\n        if (desc.get || desc.set)\r\n            descriptors[key] = {\r\n                configurable: true,\r\n                writable: true,\r\n                enumerable: desc.enumerable,\r\n                value: base[key]\r\n            };\r\n    }\r\n    return Object.create(Object.getPrototypeOf(base), descriptors);\r\n}\r\n\n /**\r\n * Freezes draftable objects. Returns the original object.\r\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\r\n *\r\n * @param obj\r\n * @param deep\r\n */\r\nexport function freeze<T>(obj: T, deep?: boolean): T;\r\nexport function freeze<T>(obj: any, deep: boolean = false): T {\r\n    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))\r\n        return obj;\r\n    if (getArchtype(obj) > 1 /* Map or Set */) {\r\n        const desc: PropertyDescriptor = {\r\n            configurable: true,\r\n            writable: true,\r\n            value: dontMutateFrozenCollections\r\n        };\r\n        Object.defineProperties(obj, {\r\n            set: desc,\r\n            add: desc,\r\n            clear: desc,\r\n            delete: desc\r\n        });\r\n    }\r\n    Object.freeze(obj);\r\n    if (deep)\r\n        each(obj, (key, value) => freeze(value, true), true);\r\n    return obj;\r\n}\r\n\n function dontMutateFrozenCollections() {\r\n    die(2);\r\n}\r\n\n export function isFrozen(obj: any): boolean {\r\n    if (obj == null || typeof obj !== \"object\")\r\n        return true;\r\n    // See #600, IE dies on non-objects in Object.isFrozen\r\n    return Object.isFrozen(obj);\r\n}\r\n","import { ImmerState, Patch, ImmerScope, Drafted, AnyObject, ImmerBaseState, AnyMap, AnySet, ProxyType, die } from \"../internal.js\";\r\n\n /** Plugin utilities */\r\nconst plugins: {\r\n    Patches?: {\r\n        generatePatches_(state: ImmerState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]): void;\r\n        generateReplacementPatches_(base: any, replacement: any, patches: Patch[], inversePatches: Patch[]): void;\r\n        applyPatches_<T>(draft: T, patches: Patch[]): T;\r\n    };\r\n    ES5?: {\r\n        willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void;\r\n        createES5Proxy_<T>(base: T, parent?: ImmerState): Drafted<T, ES5ObjectState | ES5ArrayState>;\r\n        hasChanges_(state: ES5ArrayState | ES5ObjectState): boolean;\r\n    };\r\n    MapSet?: {\r\n        proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T;\r\n        proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T;\r\n    };\r\n} = {};\r\n\n type Plugins = typeof plugins;\r\n\n export function getPlugin<K extends keyof Plugins>(pluginKey: K): Exclude<Plugins[K], undefined> {\r\n    const plugin = plugins[pluginKey];\r\n    if (!plugin) {\r\n        die(18, pluginKey);\r\n    }\r\n    // @ts-ignore\r\n    return plugin;\r\n}\r\n\n export function loadPlugin<K extends keyof Plugins>(pluginKey: K, implementation: Plugins[K]): void {\r\n    if (!plugins[pluginKey])\r\n        plugins[pluginKey] = implementation;\r\n}\r\n\n /** ES5 Plugin */\r\n\n interface ES5BaseState extends ImmerBaseState {\r\n    assigned_: {\r\n        [key: string]: any;\r\n    };\r\n    parent_?: ImmerState;\r\n    revoked_: boolean;\r\n}\r\n\n export interface ES5ObjectState extends ES5BaseState {\r\n    type_: ProxyType.ES5Object;\r\n    draft_: Drafted<AnyObject, ES5ObjectState>;\r\n    base_: AnyObject;\r\n    copy_: AnyObject | null;\r\n}\r\n\n export interface ES5ArrayState extends ES5BaseState {\r\n    type_: ProxyType.ES5Array;\r\n    draft_: Drafted<AnyObject, ES5ArrayState>;\r\n    base_: any;\r\n    copy_: any;\r\n}\r\n\n /** Map / Set plugin */\r\n\n export interface MapState extends ImmerBaseState {\r\n    type_: ProxyType.Map;\r\n    copy_: AnyMap | undefined;\r\n    assigned_: Map<any, boolean> | undefined;\r\n    base_: AnyMap;\r\n    revoked_: boolean;\r\n    draft_: Drafted<AnyMap, MapState>;\r\n}\r\n\n export interface SetState extends ImmerBaseState {\r\n    type_: ProxyType.Set;\r\n    copy_: AnySet | undefined;\r\n    base_: AnySet;\r\n    drafts_: Map<any, Drafted>; // maps the original value to the draft value in the new set\r\n    revoked_: boolean;\r\n    draft_: Drafted<AnySet, SetState>;\r\n}\r\n\n /** Patches plugin */\r\n\n export type PatchPath = (string | number)[];\r\n","import { Patch, PatchListener, Drafted, Immer, DRAFT_STATE, ImmerState, ProxyType, getPlugin } from \"../internal.js\";\r\nimport { die } from \"../utils/errors.js\";\r\n\n /** Each scope represents a `produce` call. */\r\n\n export interface ImmerScope {\r\n    patches_?: Patch[];\r\n    inversePatches_?: Patch[];\r\n    canAutoFreeze_: boolean;\r\n    drafts_: any[];\r\n    parent_?: ImmerScope;\r\n    patchListener_?: PatchListener;\r\n    immer_: Immer;\r\n    unfinalizedDrafts_: number;\r\n}\r\n\n let currentScope: ImmerScope | undefined;\r\n\n export function getCurrentScope() {\r\n    if (__DEV__ && !currentScope)\r\n        die(0);\r\n    return currentScope!;\r\n}\r\n\n function createScope(parent_: ImmerScope | undefined, immer_: Immer): ImmerScope {\r\n    return {\r\n        drafts_: [],\r\n        parent_,\r\n        immer_,\r\n        // Whenever the modified draft contains a draft from another scope, we\r\n        // need to prevent auto-freezing so the unowned draft can be finalized.\r\n        canAutoFreeze_: true,\r\n        unfinalizedDrafts_: 0\r\n    };\r\n}\r\n\n export function usePatchesInScope(scope: ImmerScope, patchListener?: PatchListener) {\r\n    if (patchListener) {\r\n        getPlugin(\"Patches\"); // assert we have the plugin\r\n        scope.patches_ = [];\r\n        scope.inversePatches_ = [];\r\n        scope.patchListener_ = patchListener;\r\n    }\r\n}\r\n\n export function revokeScope(scope: ImmerScope) {\r\n    leaveScope(scope);\r\n    scope.drafts_.forEach(revokeDraft);\r\n    // @ts-ignore\r\n    scope.drafts_ = null;\r\n}\r\n\n export function leaveScope(scope: ImmerScope) {\r\n    if (scope === currentScope) {\r\n        currentScope = scope.parent_;\r\n    }\r\n}\r\n\n export function enterScope(immer: Immer) {\r\n    return (currentScope = createScope(currentScope, immer));\r\n}\r\n\n function revokeDraft(draft: Drafted) {\r\n    const state: ImmerState = draft[DRAFT_STATE];\r\n    if (state.type_ === ProxyType.ProxyObject ||\r\n        state.type_ === ProxyType.ProxyArray)\r\n        state.revoke_();\r\n    else\r\n        state.revoked_ = true;\r\n}\r\n","import { ImmerScope, DRAFT_STATE, isDraftable, NOTHING, PatchPath, each, has, freeze, ImmerState, isDraft, SetState, set, ProxyType, getPlugin, die, revokeScope, isFrozen, shallowCopy } from \"../internal.js\";\r\n\n export function processResult(result: any, scope: ImmerScope) {\r\n    scope.unfinalizedDrafts_ = scope.drafts_.length;\r\n    const baseDraft = scope.drafts_![0];\r\n    const isReplaced = result !== undefined && result !== baseDraft;\r\n    if (!scope.immer_.useProxies_)\r\n        getPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced);\r\n    if (isReplaced) {\r\n        if (baseDraft[DRAFT_STATE].modified_) {\r\n            revokeScope(scope);\r\n            die(4);\r\n        }\r\n        if (isDraftable(result)) {\r\n            // Finalize the result in case it contains (or is) a subset of the draft.\r\n            result = finalize(scope, result);\r\n            if (!scope.parent_)\r\n                maybeFreeze(scope, result);\r\n        }\r\n        if (scope.patches_) {\r\n            getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_!);\r\n        }\r\n    }\r\n    else {\r\n        // Finalize the base draft.\r\n        result = finalize(scope, baseDraft, []);\r\n    }\r\n    revokeScope(scope);\r\n    if (scope.patches_) {\r\n        scope.patchListener_!(scope.patches_, scope.inversePatches_!);\r\n    }\r\n    return result !== NOTHING ? result : undefined;\r\n}\r\n\n function finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\r\n    // Don't recurse in tho recursive data structures\r\n    if (isFrozen(value))\r\n        return value;\r\n    \n const state: ImmerState = value[DRAFT_STATE];\r\n    // A plain object, might need freezing, might contain drafts\r\n    if (!state) {\r\n        each(value, (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path), true // See #590, don't recurse into non-enumerable of non drafted objects\r\n        );\r\n        return value;\r\n    }\r\n    // Never finalize drafts owned by another scope.\r\n    if (state.scope_ !== rootScope)\r\n        return value;\r\n    // Unmodified draft, return the (frozen) original\r\n    if (!state.modified_) {\r\n        maybeFreeze(rootScope, state.base_, true);\r\n        return state.base_;\r\n    }\r\n    // Not finalized yet, let's do that now\r\n    if (!state.finalized_) {\r\n        state.finalized_ = true;\r\n        state.scope_.unfinalizedDrafts_--;\r\n        const result = \r\n        // For ES5, create a good copy from the draft first, with added keys and without deleted keys.\r\n        state.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\r\n            ? (state.copy_ = shallowCopy(state.draft_))\r\n            : state.copy_;\r\n        // Finalize all children of the copy\r\n        // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\r\n        // Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\r\n        // back to each(result, ....)\r\n        each(state.type_ === ProxyType.Set ? new Set(result) : result, (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path));\r\n        // everything inside is frozen, we can freeze here\r\n        maybeFreeze(rootScope, result, false);\r\n        // first time finalizing, let's create those patches\r\n        if (path && rootScope.patches_) {\r\n            getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_!);\r\n        }\r\n    }\r\n    return state.copy_;\r\n}\r\n\n function finalizeProperty(rootScope: ImmerScope, parentState: undefined | ImmerState, targetObject: any, prop: string | number, childValue: any, rootPath?: PatchPath) {\r\n    if (__DEV__ && childValue === targetObject)\r\n        die(5);\r\n    if (isDraft(childValue)) {\r\n        const path = rootPath &&\r\n            parentState &&\r\n            parentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\r\n            !has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\r\n            ? rootPath!.concat(prop)\r\n            : undefined;\r\n        // Drafts owned by `scope` are finalized here.\r\n        const res = finalize(rootScope, childValue, path);\r\n        set(targetObject, prop, res);\r\n        // Drafts from another scope must prevented to be frozen\r\n        // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\r\n        if (isDraft(res)) {\r\n            rootScope.canAutoFreeze_ = false;\r\n        }\r\n        else\r\n            return;\r\n    }\r\n    // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\r\n    if (isDraftable(childValue) && !isFrozen(childValue)) {\r\n        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\r\n            // optimization: if an object is not a draft, and we don't have to\r\n            // deepfreeze everything, and we are sure that no drafts are left in the remaining object\r\n            // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\r\n            // This benefits especially adding large data tree's without further processing.\r\n            // See add-data.js perf test\r\n            return;\r\n        }\r\n        finalize(rootScope, childValue);\r\n        // immer deep freezes plain objects, so if there is no parent state, we freeze as well\r\n        if (!parentState || !parentState.scope_.parent_)\r\n            maybeFreeze(rootScope, childValue);\r\n    }\r\n}\r\n\n function maybeFreeze(scope: ImmerScope, value: any, deep = false) {\r\n    if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\r\n        freeze(value, deep);\r\n    }\r\n}\r\n","import { each, has, is, isDraftable, shallowCopy, latest, ImmerBaseState, ImmerState, Drafted, AnyObject, AnyArray, Objectish, getCurrentScope, DRAFT_STATE, die, createProxy, ProxyType } from \"../internal.js\";\r\n\n interface ProxyBaseState extends ImmerBaseState {\r\n    assigned_: {\r\n        [property: string]: boolean;\r\n    };\r\n    parent_?: ImmerState;\r\n    revoke_(): void;\r\n}\r\n\n export interface ProxyObjectState extends ProxyBaseState {\r\n    type_: ProxyType.ProxyObject;\r\n    base_: any;\r\n    copy_: any;\r\n    draft_: Drafted<AnyObject, ProxyObjectState>;\r\n}\r\n\n export interface ProxyArrayState extends ProxyBaseState {\r\n    type_: ProxyType.ProxyArray;\r\n    base_: AnyArray;\r\n    copy_: AnyArray | null;\r\n    draft_: Drafted<AnyArray, ProxyArrayState>;\r\n}\r\n\n type ProxyState = ProxyObjectState | ProxyArrayState;\r\n\n /**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */\r\nexport function createProxyProxy<T extends Objectish>(base: T, parent?: ImmerState): Drafted<T, ProxyState> {\r\n    const isArray = Array.isArray(base);\r\n    const state: ProxyState = {\r\n        type_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\r\n        // Track which produce call this is associated with.\r\n        scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n        // True for both shallow and deep changes.\r\n        modified_: false,\r\n        // Used during finalization.\r\n        finalized_: false,\r\n        // Track which properties have been assigned (true) or deleted (false).\r\n        assigned_: {},\r\n        // The parent draft state.\r\n        parent_: parent,\r\n        // The base state.\r\n        base_: base,\r\n        // The base proxy.\r\n        draft_: null as any,\r\n        // The base copy with any updated values.\r\n        copy_: null,\r\n        // Called by the `produce` function.\r\n        revoke_: null as any,\r\n        isManual_: false\r\n    };\r\n    \n // the traps must target something, a bit like the 'real' base.\r\n    // but also, we need to be able to determine from the target what the relevant state is\r\n    // (to avoid creating traps per instance to capture the state in closure,\r\n    // and to avoid creating weird hidden properties as well)\r\n    // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\r\n    // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\r\n    let target: T = state as any;\r\n    let traps: ProxyHandler<object | Array<any>> = objectTraps;\r\n    if (isArray) {\r\n        target = [state] as any;\r\n        traps = arrayTraps;\r\n    }\r\n    \n const { revoke, proxy } = Proxy.revocable(target, traps);\r\n    state.draft_ = proxy as any;\r\n    state.revoke_ = revoke;\r\n    return proxy as any;\r\n}\r\n\n /**\r\n * Object drafts\r\n */\r\nexport const objectTraps: ProxyHandler<ProxyState> = {\r\n    get(state, prop) {\r\n        if (prop === DRAFT_STATE)\r\n            return state;\r\n        \n const source = latest(state);\r\n        if (!has(source, prop)) {\r\n            // non-existing or non-own property...\r\n            return readPropFromProto(state, source, prop);\r\n        }\r\n        const value = source[prop];\r\n        if (state.finalized_ || !isDraftable(value)) {\r\n            return value;\r\n        }\r\n        // Check for existing draft in modified state.\r\n        // Assigned values are never drafted. This catches any drafts we created, too.\r\n        if (value === peek(state.base_, prop)) {\r\n            prepareCopy(state);\r\n            return (state.copy_![prop as any] = createProxy(state.scope_.immer_, value, state));\r\n        }\r\n        return value;\r\n    },\r\n    has(state, prop) {\r\n        return prop in latest(state);\r\n    },\r\n    ownKeys(state) {\r\n        return Reflect.ownKeys(latest(state));\r\n    },\r\n    set(state: ProxyObjectState, prop: string /* strictly not, but helps TS */, value) {\r\n        const desc = getDescriptorFromProto(latest(state), prop);\r\n        if (desc?.set) {\r\n            // special case: if this write is captured by a setter, we have\r\n            // to trigger it with the correct context\r\n            desc.set.call(state.draft_, value);\r\n            return true;\r\n        }\r\n        if (!state.modified_) {\r\n            // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\r\n            // from setting an existing property with value undefined to undefined (which is not a change)\r\n            const current = peek(latest(state), prop);\r\n            // special case, if we assigning the original value to a draft, we can ignore the assignment\r\n            const currentState: ProxyObjectState = current?.[DRAFT_STATE];\r\n            if (currentState && currentState.base_ === value) {\r\n                state.copy_![prop] = value;\r\n                state.assigned_[prop] = false;\r\n                return true;\r\n            }\r\n            if (is(value, current) && (value !== undefined || has(state.base_, prop)))\r\n                return true;\r\n            prepareCopy(state);\r\n            markChanged(state);\r\n        }\r\n        \n if ((state.copy_![prop] === value &&\r\n            // special case: handle new props with value 'undefined'\r\n            (value !== undefined || prop in state.copy_)) ||\r\n            // special case: NaN\r\n            (Number.isNaN(value) && Number.isNaN(state.copy_![prop])))\r\n            return true;\r\n        \n // @ts-ignore\r\n        state.copy_![prop] = value;\r\n        state.assigned_[prop] = true;\r\n        return true;\r\n    },\r\n    deleteProperty(state, prop: string) {\r\n        // The `undefined` check is a fast path for pre-existing keys.\r\n        if (peek(state.base_, prop) !== undefined || prop in state.base_) {\r\n            state.assigned_[prop] = false;\r\n            prepareCopy(state);\r\n            markChanged(state);\r\n        }\r\n        else {\r\n            // if an originally not assigned property was deleted\r\n            delete state.assigned_[prop];\r\n        }\r\n        // @ts-ignore\r\n        if (state.copy_)\r\n            delete state.copy_[prop];\r\n        return true;\r\n    },\r\n    // Note: We never coerce `desc.value` into an Immer draft, because we can't make\r\n    // the same guarantee in ES5 mode.\r\n    getOwnPropertyDescriptor(state, prop) {\r\n        const owner = latest(state);\r\n        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\r\n        if (!desc)\r\n            return desc;\r\n        return {\r\n            writable: true,\r\n            configurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\r\n            enumerable: desc.enumerable,\r\n            value: owner[prop]\r\n        };\r\n    },\r\n    defineProperty() {\r\n        die(11);\r\n    },\r\n    getPrototypeOf(state) {\r\n        return Object.getPrototypeOf(state.base_);\r\n    },\r\n    setPrototypeOf() {\r\n        die(12);\r\n    }\r\n};\r\n\n /**\r\n * Array drafts\r\n */\r\n\n const arrayTraps: ProxyHandler<[\r\n    ProxyArrayState\r\n]> = {};\r\neach(objectTraps, (key, fn) => {\r\n    // @ts-ignore\r\n    arrayTraps[key] = function () {\r\n        arguments[0] = arguments[0][0];\r\n        return fn.apply(this, arguments);\r\n    };\r\n});\r\narrayTraps.deleteProperty = function (state, prop) {\r\n    if (__DEV__ && isNaN(parseInt(prop as any)))\r\n        die(13);\r\n    // @ts-ignore\r\n    return arrayTraps.set!.call(this, state, prop, undefined);\r\n};\r\narrayTraps.set = function (state, prop, value) {\r\n    if (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any)))\r\n        die(14);\r\n    return objectTraps.set!.call(this, state[0], prop, value, state[0]);\r\n};\r\n\n // Access a property without creating an Immer draft.\r\nfunction peek(draft: Drafted, prop: PropertyKey) {\r\n    const state = draft[DRAFT_STATE];\r\n    const source = state ? latest(state) : draft;\r\n    return source[prop];\r\n}\r\n\n function readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\r\n    const desc = getDescriptorFromProto(source, prop);\r\n    return desc\r\n        ? `value` in desc\r\n            ? desc.value\r\n            : // This is a very special case, if the prop is a getter defined by the\r\n                // prototype, we should invoke it with the draft as context!\r\n                desc.get?.call(state.draft_)\r\n        : undefined;\r\n}\r\n\n function getDescriptorFromProto(source: any, prop: PropertyKey): PropertyDescriptor | undefined {\r\n    // 'in' checks proto!\r\n    if (!(prop in source))\r\n        return undefined;\r\n    let proto = Object.getPrototypeOf(source);\r\n    while (proto) {\r\n        const desc = Object.getOwnPropertyDescriptor(proto, prop);\r\n        if (desc)\r\n            return desc;\r\n        proto = Object.getPrototypeOf(proto);\r\n    }\r\n    return undefined;\r\n}\r\n\n export function markChanged(state: ImmerState) {\r\n    if (!state.modified_) {\r\n        state.modified_ = true;\r\n        if (state.parent_) {\r\n            markChanged(state.parent_);\r\n        }\r\n    }\r\n}\r\n\n export function prepareCopy(state: {\r\n    base_: any;\r\n    copy_: any;\r\n}) {\r\n    if (!state.copy_) {\r\n        state.copy_ = shallowCopy(state.base_);\r\n    }\r\n}\r\n","import { IProduceWithPatches, IProduce, ImmerState, Drafted, isDraftable, processResult, Patch, Objectish, DRAFT_STATE, Draft, PatchListener, isDraft, isMap, isSet, createProxyProxy, getPlugin, die, hasProxies, enterScope, revokeScope, leaveScope, usePatchesInScope, getCurrentScope, NOTHING, freeze, current } from \"../internal.js\";\r\n\n interface ProducersFns {\r\n    produce: IProduce;\r\n    produceWithPatches: IProduceWithPatches;\r\n}\r\n\n export class Immer implements ProducersFns {\r\n    useProxies_: boolean = hasProxies;\r\n    \n autoFreeze_: boolean = true;\r\n    \n constructor(config?: {\r\n        useProxies?: boolean;\r\n        autoFreeze?: boolean;\r\n    }) {\r\n        if (typeof config?.useProxies === \"boolean\")\r\n            this.setUseProxies(config!.useProxies);\r\n        if (typeof config?.autoFreeze === \"boolean\")\r\n            this.setAutoFreeze(config!.autoFreeze);\r\n    }\r\n    \n /**\r\n         * The `produce` function takes a value and a \"recipe function\" (whose\r\n         * return value often depends on the base state). The recipe function is\r\n         * free to mutate its first argument however it wants. All mutations are\r\n         * only ever applied to a __copy__ of the base state.\r\n         *\r\n         * Pass only a function to create a \"curried producer\" which relieves you\r\n         * from passing the recipe function every time.\r\n         *\r\n         * Only plain objects and arrays are made mutable. All other objects are\r\n         * considered uncopyable.\r\n         *\r\n         * Note: This function is __bound__ to its `Immer` instance.\r\n         *\r\n         * @param {any} base - the initial state\r\n         * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n         * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n         * @returns {any} a new state, or the initial state if nothing was modified\r\n         */\r\n    produce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\r\n        // curried invocation\r\n        if (typeof base === \"function\" && typeof recipe !== \"function\") {\r\n            const defaultBase = recipe;\r\n            recipe = base;\r\n            \n const self = this;\r\n            return function curriedProduce(this: any, base = defaultBase, ...args: any[]) {\r\n                return self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)); // prettier-ignore\r\n            };\r\n        }\r\n        \n if (typeof recipe !== \"function\")\r\n            die(6);\r\n        if (patchListener !== undefined && typeof patchListener !== \"function\")\r\n            die(7);\r\n        \n let result;\r\n        \n // Only plain objects, arrays, and \"immerable classes\" are drafted.\r\n        if (isDraftable(base)) {\r\n            const scope = enterScope(this);\r\n            const proxy = createProxy(this, base, undefined);\r\n            let hasError = true;\r\n            try {\r\n                result = recipe(proxy);\r\n                hasError = false;\r\n            }\r\n            finally {\r\n                // finally instead of catch + rethrow better preserves original stack\r\n                if (hasError)\r\n                    revokeScope(scope);\r\n                else\r\n                    leaveScope(scope);\r\n            }\r\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n                return result.then(result => {\r\n                    usePatchesInScope(scope, patchListener);\r\n                    return processResult(result, scope);\r\n                }, error => {\r\n                    revokeScope(scope);\r\n                    throw error;\r\n                });\r\n            }\r\n            usePatchesInScope(scope, patchListener);\r\n            return processResult(result, scope);\r\n        }\r\n        else if (!base || typeof base !== \"object\") {\r\n            result = recipe(base);\r\n            if (result === undefined)\r\n                result = base;\r\n            if (result === NOTHING)\r\n                result = undefined;\r\n            if (this.autoFreeze_)\r\n                freeze(result, true);\r\n            if (patchListener) {\r\n                const p: Patch[] = [];\r\n                const ip: Patch[] = [];\r\n                getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\r\n                patchListener(p, ip);\r\n            }\r\n            return result;\r\n        }\r\n        else\r\n            die(21, base);\r\n    };\r\n    \n produceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\r\n        // curried invocation\r\n        if (typeof base === \"function\") {\r\n            return (state: any, ...args: any[]) => this.produceWithPatches(state, (draft: any) => base(draft, ...args));\r\n        }\r\n        \n let patches: Patch[], inversePatches: Patch[];\r\n        const result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\r\n            patches = p;\r\n            inversePatches = ip;\r\n        });\r\n        \n if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n            return result.then(nextState => [nextState, patches!, inversePatches!]);\r\n        }\r\n        return [result, patches!, inversePatches!];\r\n    };\r\n    \n createDraft<T extends Objectish>(base: T): Draft<T> {\r\n        if (!isDraftable(base))\r\n            die(8);\r\n        if (isDraft(base))\r\n            base = current(base);\r\n        const scope = enterScope(this);\r\n        const proxy = createProxy(this, base, undefined);\r\n        proxy[DRAFT_STATE].isManual_ = true;\r\n        leaveScope(scope);\r\n        return proxy as any;\r\n    }\r\n    \n finishDraft<D extends Draft<any>>(draft: D, patchListener?: PatchListener): D extends Draft<infer T> ? T : never {\r\n        const state: ImmerState = draft && (draft as any)[DRAFT_STATE];\r\n        if (__DEV__) {\r\n            if (!state || !state.isManual_)\r\n                die(9);\r\n            if (state.finalized_)\r\n                die(10);\r\n        }\r\n        const { scope_: scope } = state;\r\n        usePatchesInScope(scope, patchListener);\r\n        return processResult(undefined, scope);\r\n    }\r\n    \n /**\r\n         * Pass true to automatically freeze all copies created by Immer.\r\n         *\r\n         * By default, auto-freezing is enabled.\r\n         */\r\n    setAutoFreeze(value: boolean) {\r\n        this.autoFreeze_ = value;\r\n    }\r\n    \n /**\r\n         * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n         * always faster than using ES5 proxies.\r\n         *\r\n         * By default, feature detection is used, so calling this is rarely necessary.\r\n         */\r\n    setUseProxies(value: boolean) {\r\n        if (value && !hasProxies) {\r\n            die(20);\r\n        }\r\n        this.useProxies_ = value;\r\n    }\r\n    \n applyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\r\n        // If a patch replaces the entire state, take that replacement as base\r\n        // before applying patches\r\n        let i: number;\r\n        for (i = patches.length - 1; i >= 0; i--) {\r\n            const patch = patches[i];\r\n            if (patch.path.length === 0 && patch.op === \"replace\") {\r\n                base = patch.value;\r\n                break;\r\n            }\r\n        }\r\n        // If there was a patch that replaced the entire state, start from the\r\n        // patch after that.\r\n        if (i > -1) {\r\n            patches = patches.slice(i + 1);\r\n        }\r\n        \n const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\r\n        if (isDraft(base)) {\r\n            // N.B: never hits if some patch a replacement, patches are never drafts\r\n            return applyPatchesImpl(base, patches);\r\n        }\r\n        // Otherwise, produce a copy of the base state.\r\n        return this.produce(base, (draft: Drafted) => applyPatchesImpl(draft, patches));\r\n    }\r\n}\r\n\n export function createProxy<T extends Objectish>(immer: Immer, value: T, parent?: ImmerState): Drafted<T, ImmerState> {\r\n    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\r\n    const draft: Drafted = isMap(value)\r\n        ? getPlugin(\"MapSet\").proxyMap_(value, parent)\r\n        : isSet(value)\r\n            ? getPlugin(\"MapSet\").proxySet_(value, parent)\r\n            : immer.useProxies_\r\n                ? createProxyProxy(value, parent)\r\n                : getPlugin(\"ES5\").createES5Proxy_(value, parent);\r\n    \n const scope = parent ? parent.scope_ : getCurrentScope();\r\n    scope.drafts_.push(draft);\r\n    return draft;\r\n}\r\n","import { die, isDraft, shallowCopy, each, DRAFT_STATE, get, set, ImmerState, isDraftable, Archtype, getArchtype, getPlugin } from \"../internal.js\";\r\n\n /** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\r\nexport function current<T>(value: T): T;\r\nexport function current(value: any): any {\r\n    if (!isDraft(value))\r\n        die(22, value);\r\n    return currentImpl(value);\r\n}\r\n\n function currentImpl(value: any): any {\r\n    if (!isDraftable(value))\r\n        return value;\r\n    const state: ImmerState | undefined = value[DRAFT_STATE];\r\n    let copy: any;\r\n    const archType = getArchtype(value);\r\n    if (state) {\r\n        if (!state.modified_ &&\r\n            (state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any)))\r\n            return state.base_;\r\n        // Optimization: avoid generating new drafts during copying\r\n        state.finalized_ = true;\r\n        copy = copyHelper(value, archType);\r\n        state.finalized_ = false;\r\n    }\r\n    else {\r\n        copy = copyHelper(value, archType);\r\n    }\r\n    \n each(copy, (key, childValue) => {\r\n        if (state && get(state.base_, key) === childValue)\r\n            return; // no need to copy or search in something that didn't change\r\n        set(copy, key, currentImpl(childValue));\r\n    });\r\n    // In the future, we might consider freezing here, based on the current settings\r\n    return archType === Archtype.Set ? new Set(copy) : copy;\r\n}\r\n\n function copyHelper(value: any, archType: number): any {\r\n    // creates a shallow copy, even if it is a map or set\r\n    switch (archType) {\r\n        case Archtype.Map:\r\n            return new Map(value);\r\n        case Archtype.Set:\r\n            // Set will be cloned as array temporarily, so that we can replace individual items\r\n            return Array.from(value);\r\n    }\r\n    return shallowCopy(value);\r\n}\r\n","import { ImmerState, Drafted, ES5ArrayState, ES5ObjectState, each, has, isDraft, latest, DRAFT_STATE, is, loadPlugin, ImmerScope, ProxyType, getCurrentScope, die, markChanged, objectTraps, ownKeys, getOwnPropertyDescriptors } from \"../internal.js\";\r\n\n type ES5State = ES5ArrayState | ES5ObjectState;\r\n\n export function enableES5() {\r\n    function willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean) {\r\n        if (!isReplaced) {\r\n            if (scope.patches_) {\r\n                markChangesRecursively(scope.drafts_![0]);\r\n            }\r\n            // This is faster when we don't care about which attributes changed.\r\n            markChangesSweep(scope.drafts_);\r\n        }\r\n        // When a child draft is returned, look for changes.\r\n        else if (isDraft(result) &&\r\n            (result[DRAFT_STATE] as ES5State).scope_ === scope) {\r\n            markChangesSweep(scope.drafts_);\r\n        }\r\n    }\r\n    \n function createES5Draft(isArray: boolean, base: any) {\r\n        if (isArray) {\r\n            const draft = new Array(base.length);\r\n            for (let i = 0; i < base.length; i++)\r\n                Object.defineProperty(draft, \"\" + i, proxyProperty(i, true));\r\n            return draft;\r\n        }\r\n        else {\r\n            const descriptors = getOwnPropertyDescriptors(base);\r\n            delete descriptors[DRAFT_STATE as any];\r\n            const keys = ownKeys(descriptors);\r\n            for (let i = 0; i < keys.length; i++) {\r\n                const key: any = keys[i];\r\n                descriptors[key] = proxyProperty(key, isArray || !!descriptors[key].enumerable);\r\n            }\r\n            return Object.create(Object.getPrototypeOf(base), descriptors);\r\n        }\r\n    }\r\n    \n function createES5Proxy_<T>(base: T, parent?: ImmerState): Drafted<T, ES5ObjectState | ES5ArrayState> {\r\n        const isArray = Array.isArray(base);\r\n        const draft = createES5Draft(isArray, base);\r\n        \n const state: ES5ObjectState | ES5ArrayState = {\r\n            type_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\r\n            scope_: parent ? parent.scope_ : getCurrentScope(),\r\n            modified_: false,\r\n            finalized_: false,\r\n            assigned_: {},\r\n            parent_: parent,\r\n            // base is the object we are drafting\r\n            base_: base,\r\n            // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\r\n            draft_: draft,\r\n            copy_: null,\r\n            revoked_: false,\r\n            isManual_: false\r\n        };\r\n        \n Object.defineProperty(draft, DRAFT_STATE, {\r\n            value: state,\r\n            // enumerable: false <- the default\r\n            writable: true\r\n        });\r\n        return draft;\r\n    }\r\n    \n // property descriptors are recycled to make sure we don't create a get and set closure per property,\r\n    // but share them all instead\r\n    const descriptors: {\r\n        [prop: string]: PropertyDescriptor;\r\n    } = {};\r\n    \n function proxyProperty(prop: string | number, enumerable: boolean): PropertyDescriptor {\r\n        let desc = descriptors[prop];\r\n        if (desc) {\r\n            desc.enumerable = enumerable;\r\n        }\r\n        else {\r\n            descriptors[prop] = desc = {\r\n                configurable: true,\r\n                enumerable,\r\n                get(this: any) {\r\n                    const state = this[DRAFT_STATE];\r\n                    if (__DEV__)\r\n                        assertUnrevoked(state);\r\n                    // @ts-ignore\r\n                    return objectTraps.get(state, prop);\r\n                },\r\n                set(this: any, value) {\r\n                    const state = this[DRAFT_STATE];\r\n                    if (__DEV__)\r\n                        assertUnrevoked(state);\r\n                    // @ts-ignore\r\n                    objectTraps.set(state, prop, value);\r\n                }\r\n            };\r\n        }\r\n        return desc;\r\n    }\r\n    \n // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\r\n    function markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\r\n        // The natural order of drafts in the `scope` array is based on when they\r\n        // were accessed. By processing drafts in reverse natural order, we have a\r\n        // better chance of processing leaf nodes first. When a leaf node is known to\r\n        // have changed, we can avoid any traversal of its ancestor nodes.\r\n        for (let i = drafts.length - 1; i >= 0; i--) {\r\n            const state: ES5State = drafts[i][DRAFT_STATE];\r\n            if (!state.modified_) {\r\n                switch (state.type_) {\r\n                    case ProxyType.ES5Array:\r\n                        if (hasArrayChanges(state))\r\n                            markChanged(state);\r\n                        break;\r\n                    case ProxyType.ES5Object:\r\n                        if (hasObjectChanges(state))\r\n                            markChanged(state);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \n function markChangesRecursively(object: any) {\r\n        if (!object || typeof object !== \"object\")\r\n            return;\r\n        const state: ES5State | undefined = object[DRAFT_STATE];\r\n        if (!state)\r\n            return;\r\n        const { base_, draft_, assigned_, type_ } = state;\r\n        if (type_ === ProxyType.ES5Object) {\r\n            // Look for added keys.\r\n            // probably there is a faster way to detect changes, as sweep + recurse seems to do some\r\n            // unnecessary work.\r\n            // also: probably we can store the information we detect here, to speed up tree finalization!\r\n            each(draft_, key => {\r\n                if ((key as any) === DRAFT_STATE)\r\n                    return;\r\n                // The `undefined` check is a fast path for pre-existing keys.\r\n                if ((base_ as any)[key] === undefined && !has(base_, key)) {\r\n                    assigned_[key] = true;\r\n                    markChanged(state);\r\n                }\r\n                else if (!assigned_[key]) {\r\n                    // Only untouched properties trigger recursion.\r\n                    markChangesRecursively(draft_[key]);\r\n                }\r\n            });\r\n            // Look for removed keys.\r\n            each(base_, key => {\r\n                // The `undefined` check is a fast path for pre-existing keys.\r\n                if (draft_[key] === undefined && !has(draft_, key)) {\r\n                    assigned_[key] = false;\r\n                    markChanged(state);\r\n                }\r\n            });\r\n        }\r\n        else if (type_ === ProxyType.ES5Array) {\r\n            if (hasArrayChanges(state as ES5ArrayState)) {\r\n                markChanged(state);\r\n                assigned_.length = true;\r\n            }\r\n            \n if (draft_.length < base_.length) {\r\n                for (let i = draft_.length; i < base_.length; i++)\r\n                    assigned_[i] = false;\r\n            }\r\n            else {\r\n                for (let i = base_.length; i < draft_.length; i++)\r\n                    assigned_[i] = true;\r\n            }\r\n            \n // Minimum count is enough, the other parts has been processed.\r\n            const min = Math.min(draft_.length, base_.length);\r\n            \n for (let i = 0; i < min; i++) {\r\n                // Only untouched indices trigger recursion.\r\n                if (!draft_.hasOwnProperty(i)) {\r\n                    assigned_[i] = true;\r\n                }\r\n                if (assigned_[i] === undefined)\r\n                    markChangesRecursively(draft_[i]);\r\n            }\r\n        }\r\n    }\r\n    \n function hasObjectChanges(state: ES5ObjectState) {\r\n        const { base_, draft_ } = state;\r\n        \n // Search for added keys and changed keys. Start at the back, because\r\n        // non-numeric keys are ordered by time of definition on the object.\r\n        const keys = ownKeys(draft_);\r\n        for (let i = keys.length - 1; i >= 0; i--) {\r\n            const key: any = keys[i];\r\n            if (key === DRAFT_STATE)\r\n                continue;\r\n            const baseValue = base_[key];\r\n            // The `undefined` check is a fast path for pre-existing keys.\r\n            if (baseValue === undefined && !has(base_, key)) {\r\n                return true;\r\n            }\r\n            // Once a base key is deleted, future changes go undetected, because its\r\n            // descriptor is erased. This branch detects any missed changes.\r\n            else {\r\n                const value = draft_[key];\r\n                const state: ImmerState = value && value[DRAFT_STATE];\r\n                if (state ? state.base_ !== baseValue : !is(value, baseValue)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        \n // At this point, no keys were added or changed.\r\n        // Compare key count to determine if keys were deleted.\r\n        const baseIsDraft = !!base_[DRAFT_STATE as any];\r\n        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE\r\n    }\r\n    \n function hasArrayChanges(state: ES5ArrayState) {\r\n        const { draft_ } = state;\r\n        if (draft_.length !== state.base_.length)\r\n            return true;\r\n        // See #116\r\n        // If we first shorten the length, our array interceptors will be removed.\r\n        // If after that new items are added, result in the same original length,\r\n        // those last items will have no intercepting property.\r\n        // So if there is no own descriptor on the last position, we know that items were removed and added\r\n        // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\r\n        // the last one\r\n        // last descriptor can be not a trap, if the array was extended\r\n        const descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1);\r\n        // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\r\n        if (descriptor && !descriptor.get)\r\n            return true;\r\n        // if we miss a property, it has been deleted, so array probobaly changed\r\n        for (let i = 0; i < draft_.length; i++) {\r\n            if (!draft_.hasOwnProperty(i))\r\n                return true;\r\n        }\r\n        // For all other cases, we don't have to compare, as they would have been picked up by the index setters\r\n        return false;\r\n    }\r\n    \n function hasChanges_(state: ES5State) {\r\n        return state.type_ === ProxyType.ES5Object\r\n            ? hasObjectChanges(state)\r\n            : hasArrayChanges(state);\r\n    }\r\n    \n function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\r\n        if (state.revoked_)\r\n            die(3, JSON.stringify(latest(state)));\r\n    }\r\n    \n loadPlugin(\"ES5\", {\r\n        createES5Proxy_,\r\n        willFinalizeES5_,\r\n        hasChanges_\r\n    });\r\n}\r\n","// types only!\r\nimport { ImmerState, AnyMap, AnySet, MapState, SetState, DRAFT_STATE, getCurrentScope, latest, iteratorSymbol, isDraftable, createProxy, loadPlugin, markChanged, ProxyType, die, each } from \"../internal.js\";\r\n\n export function enableMapSet() {\r\n    /* istanbul ignore next */\r\n    var extendStatics = function (d: any, b: any): any {\r\n        extendStatics =\r\n            Object.setPrototypeOf ||\r\n                ({ __proto__: [] } instanceof Array &&\r\n                    function (d, b) {\r\n                        d.__proto__ = b;\r\n                    }) ||\r\n                function (d, b) {\r\n                    for (var p in b)\r\n                        if (b.hasOwnProperty(p))\r\n                            d[p] = b[p];\r\n                };\r\n        return extendStatics(d, b);\r\n    };\r\n    \n // Ugly hack to resolve #502 and inherit built in Map / Set\r\n    function __extends(d: any, b: any): any {\r\n        extendStatics(d, b);\r\n        function __(this: any): any {\r\n            Object.defineProperty(this, \"constructor\", {\r\n                value: d\r\n            });\r\n        }\r\n        d.prototype =\r\n            // @ts-ignore\r\n            ((__.prototype = b.prototype), new __());\r\n    }\r\n    \n const DraftMap = (function (_super) {\r\n        __extends(DraftMap, _super);\r\n        // Create class manually, cause #502\r\n        function DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\r\n            this[DRAFT_STATE] = {\r\n                type_: ProxyType.Map,\r\n                parent_: parent,\r\n                scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n                modified_: false,\r\n                finalized_: false,\r\n                copy_: undefined,\r\n                assigned_: undefined,\r\n                base_: target,\r\n                draft_: this as any,\r\n                isManual_: false,\r\n                revoked_: false\r\n            } as MapState;\r\n            return this;\r\n        }\r\n        const p = DraftMap.prototype;\r\n        \n Object.defineProperties(p, {\r\n            size: {\r\n                get: function () {\r\n                    return latest(this[DRAFT_STATE]).size;\r\n                },\r\n                configurable: true\r\n            },\r\n            has: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): boolean {\r\n                    return latest(this[DRAFT_STATE]).has(key);\r\n                }\r\n            },\r\n            set: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any, value: any) {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (!latest(state).has(key) || latest(state).get(key) !== value) {\r\n                        prepareMapCopy(state);\r\n                        markChanged(state);\r\n                        state.assigned_!.set(key, true);\r\n                        state.copy_!.set(key, value);\r\n                        state.assigned_!.set(key, true);\r\n                    }\r\n                    return this;\r\n                }\r\n            },\r\n            delete: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): boolean {\r\n                    if (!this.has(key)) {\r\n                        return false;\r\n                    }\r\n                    \n const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareMapCopy(state);\r\n                    markChanged(state);\r\n                    if (state.base_.has(key)) {\r\n                        state.assigned_!.set(key, false);\r\n                    }\r\n                    else {\r\n                        state.assigned_!.delete(key);\r\n                    }\r\n                    state.copy_!.delete(key);\r\n                    return true;\r\n                }\r\n            },\r\n            clear: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (latest(state).size) {\r\n                        prepareMapCopy(state);\r\n                        markChanged(state);\r\n                        state.assigned_ = new Map();\r\n                        each(state.base_, key => {\r\n                            state.assigned_!.set(key, false);\r\n                        });\r\n                        state.copy_!.clear();\r\n                    }\r\n                }\r\n            },\r\n            forEach: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (cb: (value: any, key: any, self: any) => void, thisArg?: any) {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    latest(state).forEach((_value: any, key: any, _map: any) => {\r\n                        cb.call(thisArg, this.get(key), key, this);\r\n                    });\r\n                }\r\n            },\r\n            get: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): any {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    const value = latest(state).get(key);\r\n                    if (state.finalized_ || !isDraftable(value)) {\r\n                        return value;\r\n                    }\r\n                    if (value !== state.base_.get(key)) {\r\n                        return value; // either already drafted or reassigned\r\n                    }\r\n                    // despite what it looks, this creates a draft only once, see above condition\r\n                    const draft = createProxy(state.scope_.immer_, value, state);\r\n                    prepareMapCopy(state);\r\n                    state.copy_!.set(key, draft);\r\n                    return draft;\r\n                }\r\n            },\r\n            keys: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    return latest(this[DRAFT_STATE]).keys();\r\n                }\r\n            },\r\n            values: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    const iterator = this.keys();\r\n                    return {\r\n                        [iteratorSymbol]: () => this.values(),\r\n                        next: () => {\r\n                            const r = iterator.next();\r\n                            /* istanbul ignore next */\r\n                            if (r.done)\r\n                                return r;\r\n                            const value = this.get(r.value);\r\n                            return {\r\n                                done: false,\r\n                                value\r\n                            };\r\n                        }\r\n                    } as any;\r\n                }\r\n            },\r\n            entries: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<[\r\n                    any,\r\n                    any\r\n                ]> {\r\n                    const iterator = this.keys();\r\n                    return {\r\n                        [iteratorSymbol]: () => this.entries(),\r\n                        next: () => {\r\n                            const r = iterator.next();\r\n                            /* istanbul ignore next */\r\n                            if (r.done)\r\n                                return r;\r\n                            const value = this.get(r.value);\r\n                            return {\r\n                                done: false,\r\n                                value: [r.value, value]\r\n                            };\r\n                        }\r\n                    } as any;\r\n                }\r\n            },\r\n            [iteratorSymbol]: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    return this.entries();\r\n                }\r\n            }\r\n        });\r\n        \n return DraftMap;\r\n    })(Map);\r\n    \n function proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\r\n        // @ts-ignore\r\n        return new DraftMap(target, parent);\r\n    }\r\n    \n function prepareMapCopy(state: MapState) {\r\n        if (!state.copy_) {\r\n            state.assigned_ = new Map();\r\n            state.copy_ = new Map(state.base_);\r\n        }\r\n    }\r\n    \n const DraftSet = (function (_super) {\r\n        __extends(DraftSet, _super);\r\n        // Create class manually, cause #502\r\n        function DraftSet(this: any, target: AnySet, parent?: ImmerState) {\r\n            this[DRAFT_STATE] = {\r\n                type_: ProxyType.Set,\r\n                parent_: parent,\r\n                scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n                modified_: false,\r\n                finalized_: false,\r\n                copy_: undefined,\r\n                base_: target,\r\n                draft_: this,\r\n                drafts_: new Map(),\r\n                revoked_: false,\r\n                isManual_: false\r\n            } as SetState;\r\n            return this;\r\n        }\r\n        const p = DraftSet.prototype;\r\n        \n Object.defineProperties(p, {\r\n            size: {\r\n                get: function () {\r\n                    return latest(this[DRAFT_STATE]).size;\r\n                },\r\n                configurable: true\r\n            },\r\n            has: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): boolean {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    // bit of trickery here, to be able to recognize both the value, and the draft of its value\r\n                    if (!state.copy_) {\r\n                        return state.base_.has(value);\r\n                    }\r\n                    if (state.copy_.has(value))\r\n                        return true;\r\n                    if (state.drafts_.has(value) &&\r\n                        state.copy_.has(state.drafts_.get(value)))\r\n                        return true;\r\n                    return false;\r\n                }\r\n            },\r\n            add: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): any {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (!this.has(value)) {\r\n                        prepareSetCopy(state);\r\n                        markChanged(state);\r\n                        state.copy_!.add(value);\r\n                    }\r\n                    return this;\r\n                }\r\n            },\r\n            delete: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): any {\r\n                    if (!this.has(value)) {\r\n                        return false;\r\n                    }\r\n                    \n const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    markChanged(state);\r\n                    return (state.copy_!.delete(value) ||\r\n                        (state.drafts_.has(value)\r\n                            ? state.copy_!.delete(state.drafts_.get(value))\r\n                            : /* istanbul ignore next */ false));\r\n                }\r\n            },\r\n            clear: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (latest(state).size) {\r\n                        prepareSetCopy(state);\r\n                        markChanged(state);\r\n                        state.copy_!.clear();\r\n                    }\r\n                }\r\n            },\r\n            values: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    return state.copy_!.values();\r\n                }\r\n            },\r\n            entries: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function entries(): IterableIterator<[\r\n                    any,\r\n                    any\r\n                ]> {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    return state.copy_!.entries();\r\n                }\r\n            },\r\n            keys: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    return this.values();\r\n                }\r\n            },\r\n            [iteratorSymbol]: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    return this.values();\r\n                }\r\n            },\r\n            forEach: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function forEach(cb: any, thisArg?: any) {\r\n                    const iterator = this.values();\r\n                    let result = iterator.next();\r\n                    while (!result.done) {\r\n                        cb.call(thisArg, result.value, result.value, this);\r\n                        result = iterator.next();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        \n return DraftSet;\r\n    })(Set);\r\n    \n function proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\r\n        // @ts-ignore\r\n        return new DraftSet(target, parent);\r\n    }\r\n    \n function prepareSetCopy(state: SetState) {\r\n        if (!state.copy_) {\r\n            // create drafts for all entries to preserve insertion order\r\n            state.copy_ = new Set();\r\n            state.base_.forEach(value => {\r\n                if (isDraftable(value)) {\r\n                    const draft = createProxy(state.scope_.immer_, value, state);\r\n                    state.drafts_.set(value, draft);\r\n                    state.copy_!.add(draft);\r\n                }\r\n                else {\r\n                    state.copy_!.add(value);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    \n function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\r\n        if (state.revoked_)\r\n            die(3, JSON.stringify(latest(state)));\r\n    }\r\n    \n loadPlugin(\"MapSet\", { proxyMap_, proxySet_ });\r\n}\r\n","import { enableES5 } from \"./es5.js\";\r\nimport { enableMapSet } from \"./mapset.js\";\r\nimport { enablePatches } from \"./patches.js\";\r\n\n export function enableAllPlugins() {\r\n    enableES5();\r\n    enableMapSet();\r\n    enablePatches();\r\n}\r\n","import { immerable } from \"../immer.js\";\r\nimport { ImmerState, Patch, SetState, ES5ArrayState, ProxyArrayState, MapState, ES5ObjectState, ProxyObjectState, PatchPath, get, each, has, getArchtype, isSet, isMap, loadPlugin, ProxyType, Archtype, die, isDraft, isDraftable, NOTHING } from \"../internal.js\";\r\n\n export function enablePatches() {\r\n    const REPLACE = \"replace\";\r\n    const ADD = \"add\";\r\n    const REMOVE = \"remove\";\r\n    \n function generatePatches_(state: ImmerState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]): void {\r\n        switch (state.type_) {\r\n            case ProxyType.ProxyObject:\r\n            case ProxyType.ES5Object:\r\n            case ProxyType.Map:\r\n                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\r\n            case ProxyType.ES5Array:\r\n            case ProxyType.ProxyArray:\r\n                return generateArrayPatches(state, basePath, patches, inversePatches);\r\n            case ProxyType.Set:\r\n                return generateSetPatches((state as any) as SetState, basePath, patches, inversePatches);\r\n        }\r\n    }\r\n    \n function generateArrayPatches(state: ES5ArrayState | ProxyArrayState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        let { base_, assigned_ } = state;\r\n        let copy_ = state.copy_!;\r\n        \n // Reduce complexity by ensuring `base` is never longer.\r\n        if (copy_.length < base_.length) {\r\n            // @ts-ignore\r\n            ;\r\n            [base_, copy_] = [copy_, base_];\r\n            [patches, inversePatches] = [inversePatches, patches];\r\n        }\r\n        \n // Process replaced indices.\r\n        for (let i = 0; i < base_.length; i++) {\r\n            if (assigned_[i] && copy_[i] !== base_[i]) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: REPLACE,\r\n                    path,\r\n                    // Need to maybe clone it, as it can in fact be the original value\r\n                    // due to the base/copy inversion at the start of this function\r\n                    value: clonePatchValueIfNeeded(copy_[i])\r\n                });\r\n                inversePatches.push({\r\n                    op: REPLACE,\r\n                    path,\r\n                    value: clonePatchValueIfNeeded(base_[i])\r\n                });\r\n            }\r\n        }\r\n        \n // Process added indices.\r\n        for (let i = base_.length; i < copy_.length; i++) {\r\n            const path = basePath.concat([i]);\r\n            patches.push({\r\n                op: ADD,\r\n                path,\r\n                // Need to maybe clone it, as it can in fact be the original value\r\n                // due to the base/copy inversion at the start of this function\r\n                value: clonePatchValueIfNeeded(copy_[i])\r\n            });\r\n        }\r\n        if (base_.length < copy_.length) {\r\n            inversePatches.push({\r\n                op: REPLACE,\r\n                path: basePath.concat([\"length\"]),\r\n                value: base_.length\r\n            });\r\n        }\r\n    }\r\n    \n // This is used for both Map objects and normal objects.\r\n    function generatePatchesFromAssigned(state: MapState | ES5ObjectState | ProxyObjectState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        const { base_, copy_ } = state;\r\n        each(state.assigned_!, (key, assignedValue) => {\r\n            const origValue = get(base_, key);\r\n            const value = get(copy_!, key);\r\n            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\r\n            if (origValue === value && op === REPLACE)\r\n                return;\r\n            const path = basePath.concat(key as any);\r\n            patches.push(op === REMOVE ? { op, path } : { op, path, value });\r\n            inversePatches.push(op === ADD\r\n                ? { op: REMOVE, path }\r\n                : op === REMOVE\r\n                    ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) }\r\n                    : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) });\r\n        });\r\n    }\r\n    \n function generateSetPatches(state: SetState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        let { base_, copy_ } = state;\r\n        \n let i = 0;\r\n        base_.forEach((value: any) => {\r\n            if (!copy_!.has(value)) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: REMOVE,\r\n                    path,\r\n                    value\r\n                });\r\n                inversePatches.unshift({\r\n                    op: ADD,\r\n                    path,\r\n                    value\r\n                });\r\n            }\r\n            i++;\r\n        });\r\n        i = 0;\r\n        copy_!.forEach((value: any) => {\r\n            if (!base_.has(value)) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: ADD,\r\n                    path,\r\n                    value\r\n                });\r\n                inversePatches.unshift({\r\n                    op: REMOVE,\r\n                    path,\r\n                    value\r\n                });\r\n            }\r\n            i++;\r\n        });\r\n    }\r\n    \n function generateReplacementPatches_(baseValue: any, replacement: any, patches: Patch[], inversePatches: Patch[]): void {\r\n        patches.push({\r\n            op: REPLACE,\r\n            path: [],\r\n            value: replacement === NOTHING ? undefined : replacement\r\n        });\r\n        inversePatches.push({\r\n            op: REPLACE,\r\n            path: [],\r\n            value: baseValue\r\n        });\r\n    }\r\n    \n function applyPatches_<T>(draft: T, patches: Patch[]): T {\r\n        patches.forEach(patch => {\r\n            const { path, op } = patch;\r\n            \n let base: any = draft;\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                const parentType = getArchtype(base);\r\n                const p = \"\" + path[i];\r\n                // See #738, avoid prototype pollution\r\n                if ((parentType === Archtype.Object || parentType === Archtype.Array) &&\r\n                    (p === \"__proto__\" || p === \"constructor\"))\r\n                    die(24);\r\n                if (typeof base === \"function\" && p === \"prototype\")\r\n                    die(24);\r\n                base = get(base, p);\r\n                if (typeof base !== \"object\")\r\n                    die(15, path.join(\"/\"));\r\n            }\r\n            \n const type = getArchtype(base);\r\n            const value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\r\n            const key = path[path.length - 1];\r\n            switch (op) {\r\n                case REPLACE:\r\n                    switch (type) {\r\n                        case Archtype.Map:\r\n                            return base.set(key, value);\r\n                        /* istanbul ignore next */\r\n                        case Archtype.Set:\r\n                            die(16);\r\n                        default:\r\n                            // if value is an object, then it's assigned by reference\r\n                            // in the following add or remove ops, the value field inside the patch will also be modifyed\r\n                            // so we use value from the cloned patch\r\n                            // @ts-ignore\r\n                            return (base[key] = value);\r\n                    }\r\n                case ADD:\r\n                    switch (type) {\r\n                        case Archtype.Array:\r\n                            return key === \"-\"\r\n                                ? base.push(value)\r\n                                : base.splice(key as any, 0, value);\r\n                        case Archtype.Map:\r\n                            return base.set(key, value);\r\n                        case Archtype.Set:\r\n                            return base.add(value);\r\n                        default:\r\n                            return (base[key] = value);\r\n                    }\r\n                case REMOVE:\r\n                    switch (type) {\r\n                        case Archtype.Array:\r\n                            return base.splice(key as any, 1);\r\n                        case Archtype.Map:\r\n                            return base.delete(key);\r\n                        case Archtype.Set:\r\n                            return base.delete(patch.value);\r\n                        default:\r\n                            return delete base[key];\r\n                    }\r\n                default:\r\n                    die(17, op);\r\n            }\r\n        });\r\n        \n return draft;\r\n    }\r\n    \n // optimize: this is quite a performance hit, can we detect intelligently when it is needed?\r\n    // E.g. auto-draft when new objects from outside are assigned and modified?\r\n    // (See failing test when deepClone just returns obj)\r\n    function deepClonePatchValue<T>(obj: T): T;\r\n    function deepClonePatchValue(obj: any) {\r\n        if (!isDraftable(obj))\r\n            return obj;\r\n        if (Array.isArray(obj))\r\n            return obj.map(deepClonePatchValue);\r\n        if (isMap(obj))\r\n            return new Map(Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)]));\r\n        if (isSet(obj))\r\n            return new Set(Array.from(obj).map(deepClonePatchValue));\r\n        const cloned = Object.create(Object.getPrototypeOf(obj));\r\n        for (const key in obj)\r\n            cloned[key] = deepClonePatchValue(obj[key]);\r\n        if (has(obj, immerable))\r\n            cloned[immerable] = obj[immerable];\r\n        return cloned;\r\n    }\r\n    \n function clonePatchValueIfNeeded<T>(obj: T): T {\r\n        if (isDraft(obj)) {\r\n            return deepClonePatchValue(obj);\r\n        }\r\n        else\r\n            return obj;\r\n    }\r\n    \n loadPlugin(\"Patches\", {\r\n        applyPatches_,\r\n        generatePatches_,\r\n        generateReplacementPatches_\r\n    });\r\n}\r\n","import { IProduce, IProduceWithPatches, Immer, Draft, Immutable } from \"./internal.js\";\r\n\n export { Draft, Immutable, Patch, PatchListener, original, current, isDraft, isDraftable, NOTHING as nothing, DRAFTABLE as immerable, freeze } from \"./internal.js\";\r\n\n const immer = new Immer();\r\n\n /**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */\r\nexport const produce: IProduce = immer.produce;\r\nexport default produce;\r\n\n /**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */\r\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(immer);\r\n\n /**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * Always freeze by default, even in production mode\r\n */\r\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer);\r\n\n /**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */\r\nexport const setUseProxies = immer.setUseProxies.bind(immer);\r\n\n /**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */\r\nexport const applyPatches = immer.applyPatches.bind(immer);\r\n\n /**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */\r\nexport const createDraft = immer.createDraft.bind(immer);\r\n\n /**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */\r\nexport const finishDraft = immer.finishDraft.bind(immer);\r\n\n /**\r\n * This function is actually a no-op, but can be used to cast an immutable type\r\n * to an draft type and make TypeScript happy\r\n *\r\n * @param value\r\n */\r\nexport function castDraft<T>(value: T): Draft<T> {\r\n    return value as any;\r\n}\r\n\n /**\r\n * This function is actually a no-op, but can be used to cast a mutable type\r\n * to an immutable type and make TypeScript happy\r\n * @param value\r\n */\r\nexport function castImmutable<T>(value: T): Immutable<T> {\r\n    return value as any;\r\n}\r\n\n export { Immer };\r\n\n export { enableES5 } from \"./plugins/es5.js\";\r\nexport { enablePatches } from \"./plugins/patches.js\";\r\nexport { enableMapSet } from \"./plugins/mapset.js\";\r\nexport { enableAllPlugins } from \"./plugins/all.js\";\r\n"],"names":["hasSymbol","Symbol","hasMap","Map","hasSet","Set","hasProxies","Proxy","revocable","Reflect","NOTHING","for","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","errors","data","path","op","plugin","thing","die","error","args","e","msg","apply","Error","isDraft","value","isDraftable","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","Object","prototype","toString","proto","getPrototypeOf","Ctor","hasOwnProperty","call","Function","original","base_","ownKeys","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","getOwnPropertyDescriptors","target","res","forEach","key","getOwnPropertyDescriptor","each","iter","enumerableOnly","getArchtype","keys","entry","index","state","type_","has","prop","get","set","propOrOldValue","t","delete","add","is","x","y","latest","copy_","shallowCopy","base","slice","descriptors","i","length","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","dontMutateFrozenCollections","defineProperties","clear","plugins","getPlugin","pluginKey","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","autoFreeze_","createProxyProxy","parent","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","source","readPropFromProto","peek","prepareCopy","createProxy","getDescriptorFromProto","current","currentState","markChanged","Number","isNaN","deleteProperty","owner","defineProperty","setPrototypeOf","fn","arguments","parseInt","Immer","config","recipe","defaultBase","self","curriedProduce","produce","hasError","Promise","then","p","ip","produceWithPatches","patches","inversePatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","createES5Proxy_","push","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","markChangesRecursively","markChangesSweep","createES5Draft","proxyProperty","assertUnrevoked","drafts","hasArrayChanges","hasObjectChanges","object","min","Math","baseValue","baseIsDraft","descriptor","JSON","stringify","enableMapSet","extendStatics","d","b","__proto__","__extends","__","DraftMap","_super","size","prepareMapCopy","cb","thisArg","_value","_map","values","next","r","done","entries","DraftSet","prepareSetCopy","enableAllPlugins","enablePatches","REPLACE","ADD","REMOVE","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","clonePatchValueIfNeeded","assignedValue","origValue","unshift","replacement","parentType","join","type","deepClonePatchValue","splice","map","k","v","cloned","immerable","bind","castDraft","castImmutable"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/immer.umd.production.min.js b/dist/immer.umd.production.min.js
index d5bee1ed0e86ddc630eee199fc06cd708bb30195..c11392ac00e9e63248abcc801928f9b81e8a3b7b 100644
--- a/dist/immer.umd.production.min.js
+++ b/dist/immer.umd.production.min.js
@@ -1,2 +1,2 @@
-!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((n=n||self).immer={})}(this,(function(n){function t(n){for(var t=arguments.length,r=Array(t>1?t-1:0),e=1;e<t;e++)r[e-1]=arguments[e];throw Error("[Immer] minified error nr: "+n+(r.length?" "+r.map((function(n){return"'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r(n){return!!n&&!!n[L]}function e(n){var t;return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var t=Object.getPrototypeOf(n);if(null===t)return!0;var r=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return r===Object||"function"==typeof r&&Function.toString.call(r)===T}(n)||Array.isArray(n)||!!n[H]||!!(null===(t=n.constructor)||void 0===t?void 0:t[H])||v(n)||s(n))}function i(n,t,r){void 0===r&&(r=!1),0===u(n)?(r?Object.keys:U)(n).forEach((function(e){r&&"symbol"==typeof e||t(e,n[e],n)})):n.forEach((function(r,e){return t(e,r,n)}))}function u(n){var t=n[L];return t?t.t>3?t.t-4:t.t:Array.isArray(n)?1:v(n)?2:s(n)?3:0}function o(n,t){return 2===u(n)?n.has(t):Object.prototype.hasOwnProperty.call(n,t)}function f(n,t){return 2===u(n)?n.get(t):n[t]}function a(n,t,r){var e=u(n);2===e?n.set(t,r):3===e?(n.delete(t),n.add(r)):n[t]=r}function c(n,t){return n===t?0!==n||1/n==1/t:n!=n&&t!=t}function v(n){return X&&n instanceof Map}function s(n){return q&&n instanceof Set}function l(n){return n.i||n.u}function p(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var t=V(n);delete t[L];for(var r=U(t),e=0;e<r.length;e++){var i=r[e],u=t[i];!1===u.writable&&(u.writable=!0,u.configurable=!0),(u.get||u.set)&&(t[i]={configurable:!0,writable:!0,enumerable:u.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),t)}function d(n,t){return void 0===t&&(t=!1),y(n)||r(n)||!e(n)?n:(u(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),t&&i(n,(function(n,t){return d(t,!0)}),!0),n)}function h(){t(2)}function y(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function _(n){var r=Y[n];return r||t(18,n),r}function b(n,t){Y[n]||(Y[n]=t)}function m(){return N}function j(n,t){t&&(_("Patches"),n.o=[],n.v=[],n.s=t)}function O(n){w(n),n.l.forEach(P),n.l=null}function w(n){n===N&&(N=n.p)}function S(n){return N={l:[],p:N,h:n,_:!0,m:0}}function P(n){var t=n[L];0===t.t||1===t.t?t.j():t.O=!0}function M(n,r){r.m=r.l.length;var i=r.l[0],u=void 0!==n&&n!==i;return r.h.S||_("ES5").P(r,n,u),u?(i[L].M&&(O(r),t(4)),e(n)&&(n=g(r,n),r.p||x(r,n)),r.o&&_("Patches").g(i[L].u,n,r.o,r.v)):n=g(r,i,[]),O(r),r.o&&r.s(r.o,r.v),n!==G?n:void 0}function g(n,t,r){if(y(t))return t;var e=t[L];if(!e)return i(t,(function(i,u){return A(n,e,t,i,u,r)}),!0),t;if(e.A!==n)return t;if(!e.M)return x(n,e.u,!0),e.u;if(!e.R){e.R=!0,e.A.m--;var u=4===e.t||5===e.t?e.i=p(e.k):e.i;i(3===e.t?new Set(u):u,(function(t,i){return A(n,e,u,t,i,r)})),x(n,u,!1),r&&n.o&&_("Patches").F(e,r,n.o,n.v)}return e.i}function A(n,t,i,u,f,c){if(r(f)){var v=g(n,f,c&&t&&3!==t.t&&!o(t.D,u)?c.concat(u):void 0);if(a(i,u,v),!r(v))return;n._=!1}if(e(f)&&!y(f)){if(!n.h.K&&n.m<1)return;g(n,f),t&&t.A.p||x(n,f)}}function x(n,t,r){void 0===r&&(r=!1),n.h.K&&n._&&d(t,r)}function z(n,t){var r=n[L];return(r?l(r):n)[t]}function E(n,t){if(t in n)for(var r=Object.getPrototypeOf(n);r;){var e=Object.getOwnPropertyDescriptor(r,t);if(e)return e;r=Object.getPrototypeOf(r)}}function R(n){n.M||(n.M=!0,n.p&&R(n.p))}function k(n){n.i||(n.i=p(n.u))}function F(n,t,r){var e=v(t)?_("MapSet").$(t,r):s(t)?_("MapSet").C(t,r):n.S?function(n,t){var r=Array.isArray(n),e={t:r?1:0,A:t?t.A:m(),M:!1,R:!1,D:{},p:t,u:n,k:null,i:null,j:null,I:!1},i=e,u=Z;r&&(i=[e],u=nn);var o=Proxy.revocable(i,u),f=o.revoke,a=o.proxy;return e.k=a,e.j=f,a}(t,r):_("ES5").J(t,r);return(r?r.A:m()).l.push(e),e}function D(n){return r(n)||t(22,n),function n(t){if(!e(t))return t;var r,o=t[L],c=u(t);if(o){if(!o.M&&(o.t<4||!_("ES5").N(o)))return o.u;o.R=!0,r=K(t,c),o.R=!1}else r=K(t,c);return i(r,(function(t,e){o&&f(o.u,t)===e||a(r,t,n(e))})),3===c?new Set(r):r}(n)}function K(n,t){switch(t){case 2:return new Map(n);case 3:return Array.from(n)}return p(n)}function $(){function n(n,t){var r=f[n];return r?r.enumerable=t:f[n]=r={configurable:!0,enumerable:t,get:function(){return Z.get(this[L],n)},set:function(t){Z.set(this[L],n,t)}},r}function t(n){for(var t=n.length-1;t>=0;t--){var r=n[t][L];if(!r.M)switch(r.t){case 5:u(r)&&R(r);break;case 4:e(r)&&R(r)}}}function e(n){for(var t=n.u,r=n.k,e=U(r),i=e.length-1;i>=0;i--){var u=e[i];if(u!==L){var f=t[u];if(void 0===f&&!o(t,u))return!0;var a=r[u],v=a&&a[L];if(v?v.u!==f:!c(a,f))return!0}}var s=!!t[L];return e.length!==U(t).length+(s?0:1)}function u(n){var t=n.k;if(t.length!==n.u.length)return!0;var r=Object.getOwnPropertyDescriptor(t,t.length-1);if(r&&!r.get)return!0;for(var e=0;e<t.length;e++)if(!t.hasOwnProperty(e))return!0;return!1}var f={};b("ES5",{J:function(t,r){var e=Array.isArray(t),i=function(t,r){if(t){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,""+i,n(i,!0));return e}var u=V(r);delete u[L];for(var o=U(u),f=0;f<o.length;f++){var a=o[f];u[a]=n(a,t||!!u[a].enumerable)}return Object.create(Object.getPrototypeOf(r),u)}(e,t),u={t:e?5:4,A:r?r.A:m(),M:!1,R:!1,D:{},p:r,u:t,k:i,i:null,O:!1,I:!1};return Object.defineProperty(i,L,{value:u,writable:!0}),i},P:function(n,e,f){f?r(e)&&e[L].A===n&&t(n.l):(n.o&&function n(t){if(t&&"object"==typeof t){var r=t[L];if(r){var e=r.u,f=r.k,a=r.D,c=r.t;if(4===c)i(f,(function(t){t!==L&&(void 0!==e[t]||o(e,t)?a[t]||n(f[t]):(a[t]=!0,R(r)))})),i(e,(function(n){void 0!==f[n]||o(f,n)||(a[n]=!1,R(r))}));else if(5===c){if(u(r)&&(R(r),a.length=!0),f.length<e.length)for(var v=f.length;v<e.length;v++)a[v]=!1;else for(var s=e.length;s<f.length;s++)a[s]=!0;for(var l=Math.min(f.length,e.length),p=0;p<l;p++)f.hasOwnProperty(p)||(a[p]=!0),void 0===a[p]&&n(f[p])}}}}(n.l[0]),t(n.l))},N:function(n){return 4===n.t?e(n):u(n)}})}function C(){function n(t){if(!e(t))return t;if(Array.isArray(t))return t.map(n);if(v(t))return new Map(Array.from(t.entries()).map((function(t){return[t[0],n(t[1])]})));if(s(t))return new Set(Array.from(t).map(n));var r=Object.create(Object.getPrototypeOf(t));for(var i in t)r[i]=n(t[i]);return o(t,H)&&(r[H]=t[H]),r}function a(t){return r(t)?n(t):t}var c="add";b("Patches",{W:function(r,e){return e.forEach((function(e){for(var i=e.path,o=e.op,a=r,v=0;v<i.length-1;v++){var s=u(a),l=""+i[v];0!==s&&1!==s||"__proto__"!==l&&"constructor"!==l||t(24),"function"==typeof a&&"prototype"===l&&t(24),"object"!=typeof(a=f(a,l))&&t(15,i.join("/"))}var p=u(a),d=n(e.value),h=i[i.length-1];switch(o){case"replace":switch(p){case 2:return a.set(h,d);case 3:t(16);default:return a[h]=d}case c:switch(p){case 1:return"-"===h?a.push(d):a.splice(h,0,d);case 2:return a.set(h,d);case 3:return a.add(d);default:return a[h]=d}case"remove":switch(p){case 1:return a.splice(h,1);case 2:return a.delete(h);case 3:return a.delete(e.value);default:return delete a[h]}default:t(17,o)}})),r},F:function(n,t,r,e){switch(n.t){case 0:case 4:case 2:return function(n,t,r,e){var u=n.u,v=n.i;i(n.D,(function(n,i){var s=f(u,n),l=f(v,n),p=i?o(u,n)?"replace":c:"remove";if(s!==l||"replace"!==p){var d=t.concat(n);r.push("remove"===p?{op:p,path:d}:{op:p,path:d,value:l}),e.push(p===c?{op:"remove",path:d}:"remove"===p?{op:c,path:d,value:a(s)}:{op:"replace",path:d,value:a(s)})}}))}(n,t,r,e);case 5:case 1:return function(n,t,r,e){var i=n.u,u=n.D,o=n.i;if(o.length<i.length){var f=[o,i];i=f[0],o=f[1];var v=[e,r];r=v[0],e=v[1]}for(var s=0;s<i.length;s++)if(u[s]&&o[s]!==i[s]){var l=t.concat([s]);r.push({op:"replace",path:l,value:a(o[s])}),e.push({op:"replace",path:l,value:a(i[s])})}for(var p=i.length;p<o.length;p++){var d=t.concat([p]);r.push({op:c,path:d,value:a(o[p])})}i.length<o.length&&e.push({op:"replace",path:t.concat(["length"]),value:i.length})}(n,t,r,e);case 3:return function(n,t,r,e){var i=n.u,u=n.i,o=0;i.forEach((function(n){if(!u.has(n)){var i=t.concat([o]);r.push({op:"remove",path:i,value:n}),e.unshift({op:c,path:i,value:n})}o++})),o=0,u.forEach((function(n){if(!i.has(n)){var u=t.concat([o]);r.push({op:c,path:u,value:n}),e.unshift({op:"remove",path:u,value:n})}o++}))}(n,t,r,e)}},g:function(n,t,r,e){r.push({op:"replace",path:[],value:t===G?void 0:t}),e.push({op:"replace",path:[],value:n})}})}function I(){function n(n,t){function r(){this.constructor=n}f(n,t),n.prototype=(r.prototype=t.prototype,new r)}function r(n){n.i||(n.D=new Map,n.i=new Map(n.u))}function u(n){n.i||(n.i=new Set,n.u.forEach((function(t){if(e(t)){var r=F(n.A.h,t,n);n.l.set(t,r),n.i.add(r)}else n.i.add(t)})))}function o(n){n.O&&t(3,JSON.stringify(l(n)))}var f=function(n,t){return(f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,t){n.__proto__=t}||function(n,t){for(var r in t)t.hasOwnProperty(r)&&(n[r]=t[r])})(n,t)},a=function(){function t(n,t){return this[L]={t:2,p:t,A:t?t.A:m(),M:!1,R:!1,i:void 0,D:void 0,u:n,k:this,I:!1,O:!1},this}n(t,Map);var u=t.prototype;return Object.defineProperty(u,"size",{get:function(){return l(this[L]).size}}),u.has=function(n){return l(this[L]).has(n)},u.set=function(n,t){var e=this[L];return o(e),l(e).has(n)&&l(e).get(n)===t||(r(e),R(e),e.D.set(n,!0),e.i.set(n,t),e.D.set(n,!0)),this},u.delete=function(n){if(!this.has(n))return!1;var t=this[L];return o(t),r(t),R(t),t.u.has(n)?t.D.set(n,!1):t.D.delete(n),t.i.delete(n),!0},u.clear=function(){var n=this[L];o(n),l(n).size&&(r(n),R(n),n.D=new Map,i(n.u,(function(t){n.D.set(t,!1)})),n.i.clear())},u.forEach=function(n,t){var r=this;l(this[L]).forEach((function(e,i){n.call(t,r.get(i),i,r)}))},u.get=function(n){var t=this[L];o(t);var i=l(t).get(n);if(t.R||!e(i))return i;if(i!==t.u.get(n))return i;var u=F(t.A.h,i,t);return r(t),t.i.set(n,u),u},u.keys=function(){return l(this[L]).keys()},u.values=function(){var n,t=this,r=this.keys();return(n={})[Q]=function(){return t.values()},n.next=function(){var n=r.next();return n.done?n:{done:!1,value:t.get(n.value)}},n},u.entries=function(){var n,t=this,r=this.keys();return(n={})[Q]=function(){return t.entries()},n.next=function(){var n=r.next();if(n.done)return n;var e=t.get(n.value);return{done:!1,value:[n.value,e]}},n},u[Q]=function(){return this.entries()},t}(),c=function(){function t(n,t){return this[L]={t:3,p:t,A:t?t.A:m(),M:!1,R:!1,i:void 0,u:n,k:this,l:new Map,O:!1,I:!1},this}n(t,Set);var r=t.prototype;return Object.defineProperty(r,"size",{get:function(){return l(this[L]).size}}),r.has=function(n){var t=this[L];return o(t),t.i?!!t.i.has(n)||!(!t.l.has(n)||!t.i.has(t.l.get(n))):t.u.has(n)},r.add=function(n){var t=this[L];return o(t),this.has(n)||(u(t),R(t),t.i.add(n)),this},r.delete=function(n){if(!this.has(n))return!1;var t=this[L];return o(t),u(t),R(t),t.i.delete(n)||!!t.l.has(n)&&t.i.delete(t.l.get(n))},r.clear=function(){var n=this[L];o(n),l(n).size&&(u(n),R(n),n.i.clear())},r.values=function(){var n=this[L];return o(n),u(n),n.i.values()},r.entries=function(){var n=this[L];return o(n),u(n),n.i.entries()},r.keys=function(){return this.values()},r[Q]=function(){return this.values()},r.forEach=function(n,t){for(var r=this.values(),e=r.next();!e.done;)n.call(t,e.value,e.value,this),e=r.next()},t}();b("MapSet",{$:function(n,t){return new a(n,t)},C:function(n,t){return new c(n,t)}})}var J,N,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,G=W?Symbol.for("immer-nothing"):((J={})["immer-nothing"]=!0,J),H=W?Symbol.for("immer-draftable"):"__$immer_draftable",L=W?Symbol.for("immer-state"):"__$immer_state",Q="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",T=""+Object.prototype.constructor,U="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,V=Object.getOwnPropertyDescriptors||function(n){var t={};return U(n).forEach((function(r){t[r]=Object.getOwnPropertyDescriptor(n,r)})),t},Y={},Z={get:function(n,t){if(t===L)return n;var r=l(n);if(!o(r,t))return function(n,t,r){var e,i=E(t,r);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,r,t);var i=r[t];return n.R||!e(i)?i:i===z(n.u,t)?(k(n),n.i[t]=F(n.A.h,i,n)):i},has:function(n,t){return t in l(n)},ownKeys:function(n){return Reflect.ownKeys(l(n))},set:function(n,t,r){var e=E(l(n),t);if(null==e?void 0:e.set)return e.set.call(n.k,r),!0;if(!n.M){var i=z(l(n),t),u=null==i?void 0:i[L];if(u&&u.u===r)return n.i[t]=r,n.D[t]=!1,!0;if(c(r,i)&&(void 0!==r||o(n.u,t)))return!0;k(n),R(n)}return n.i[t]===r&&"number"!=typeof r&&(void 0!==r||t in n.i)||(n.i[t]=r,n.D[t]=!0,!0)},deleteProperty:function(n,t){return void 0!==z(n.u,t)||t in n.u?(n.D[t]=!1,k(n),R(n)):delete n.D[t],n.i&&delete n.i[t],!0},getOwnPropertyDescriptor:function(n,t){var r=l(n),e=Reflect.getOwnPropertyDescriptor(r,t);return e?{writable:!0,configurable:1!==n.t||"length"!==t,enumerable:e.enumerable,value:r[t]}:e},defineProperty:function(){t(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.u)},setPrototypeOf:function(){t(12)}},nn={};i(Z,(function(n,t){nn[n]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),nn.deleteProperty=function(n,t){return nn.set.call(this,n,t,void 0)},nn.set=function(n,t,r){return Z.set.call(this,n[0],t,r,n[0])};var tn=function(){function n(n){var r=this;this.S=B,this.K=!0,this.produce=function(n,i,u){if("function"==typeof n&&"function"!=typeof i){var o=i;i=n;var f=r;return function(n){var t=this;void 0===n&&(n=o);for(var r=arguments.length,e=Array(r>1?r-1:0),u=1;u<r;u++)e[u-1]=arguments[u];return f.produce(n,(function(n){var r;return(r=i).call.apply(r,[t,n].concat(e))}))}}var a;if("function"!=typeof i&&t(6),void 0!==u&&"function"!=typeof u&&t(7),e(n)){var c=S(r),v=F(r,n,void 0),s=!0;try{a=i(v),s=!1}finally{s?O(c):w(c)}return"undefined"!=typeof Promise&&a instanceof Promise?a.then((function(n){return j(c,u),M(n,c)}),(function(n){throw O(c),n})):(j(c,u),M(a,c))}if(!n||"object"!=typeof n){if(void 0===(a=i(n))&&(a=n),a===G&&(a=void 0),r.K&&d(a,!0),u){var l=[],p=[];_("Patches").g(n,a,l,p),u(l,p)}return a}t(21,n)},this.produceWithPatches=function(n,t){if("function"==typeof n)return function(t){for(var e=arguments.length,i=Array(e>1?e-1:0),u=1;u<e;u++)i[u-1]=arguments[u];return r.produceWithPatches(t,(function(t){return n.apply(void 0,[t].concat(i))}))};var e,i,u=r.produce(n,t,(function(n,t){e=n,i=t}));return"undefined"!=typeof Promise&&u instanceof Promise?u.then((function(n){return[n,e,i]})):[u,e,i]},"boolean"==typeof(null==n?void 0:n.useProxies)&&this.setUseProxies(n.useProxies),"boolean"==typeof(null==n?void 0:n.autoFreeze)&&this.setAutoFreeze(n.autoFreeze)}var i=n.prototype;return i.createDraft=function(n){e(n)||t(8),r(n)&&(n=D(n));var i=S(this),u=F(this,n,void 0);return u[L].I=!0,w(i),u},i.finishDraft=function(n,t){var r=(n&&n[L]).A;return j(r,t),M(void 0,r)},i.setAutoFreeze=function(n){this.K=n},i.setUseProxies=function(n){n&&!B&&t(20),this.S=n},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var u=_("Patches").W;return r(n)?u(n,t):this.produce(n,(function(n){return u(n,t)}))},n}(),rn=new tn,en=rn.produce,un=rn.produceWithPatches.bind(rn),on=rn.setAutoFreeze.bind(rn),fn=rn.setUseProxies.bind(rn),an=rn.applyPatches.bind(rn),cn=rn.createDraft.bind(rn),vn=rn.finishDraft.bind(rn);n.Immer=tn,n.applyPatches=an,n.castDraft=function(n){return n},n.castImmutable=function(n){return n},n.createDraft=cn,n.current=D,n.default=en,n.enableAllPlugins=function(){$(),I(),C()},n.enableES5=$,n.enableMapSet=I,n.enablePatches=C,n.finishDraft=vn,n.freeze=d,n.immerable=H,n.isDraft=r,n.isDraftable=e,n.nothing=G,n.original=function(n){return r(n)||t(23,n),n[L].u},n.produce=en,n.produceWithPatches=un,n.setAutoFreeze=on,n.setUseProxies=fn,Object.defineProperty(n,"__esModule",{value:!0})}));
+!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e=e||self).immer={})}(this,(function(e){"use strict";var t,r="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),n="undefined"!=typeof Map,a="undefined"!=typeof Set,o="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,i=r?Symbol.for("immer-nothing"):((t={})["immer-nothing"]=!0,t),u=r?Symbol.for("immer-draftable"):"__$immer_draftable",c=r?Symbol.for("immer-state"):"__$immer_state",f="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator";function s(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];throw new Error("[Immer] minified error nr: "+e+(r.length?" "+r.map((function(e){return"'"+e+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function l(e){return!!e&&!!e[c]}function p(e){var t;return!!e&&(function(e){if(!e||"object"!=typeof e)return!1;var t=Object.getPrototypeOf(e);if(null===t)return!0;var r=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return r===Object||"function"==typeof r&&Function.toString.call(r)===_}(e)||Array.isArray(e)||!!e[u]||!!(null===(t=e.constructor)||void 0===t?void 0:t[u])||w(e)||O(e))}var _=Object.prototype.constructor.toString(),v="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:Object.getOwnPropertyNames,h=Object.getOwnPropertyDescriptors||function(e){var t={};return v(e).forEach((function(r){t[r]=Object.getOwnPropertyDescriptor(e,r)})),t};function d(e,t,r){void 0===r&&(r=!1),0===y(e)?(r?Object.keys:v)(e).forEach((function(n){r&&"symbol"==typeof n||t(n,e[n],e)})):e.forEach((function(r,n){return t(n,r,e)}))}function y(e){var t=e[c];return t?t.type_>3?t.type_-4:t.type_:Array.isArray(e)?1:w(e)?2:O(e)?3:0}function b(e,t){return 2===y(e)?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function g(e,t){return 2===y(e)?e.get(t):e[t]}function m(e,t,r){var n=y(e);2===n?e.set(t,r):3===n?(e.delete(t),e.add(r)):e[t]=r}function P(e,t){return e===t?0!==e||1/e==1/t:e!=e&&t!=t}function w(e){return n&&e instanceof Map}function O(e){return a&&e instanceof Set}function j(e){return e.copy_||e.base_}function z(e){if(Array.isArray(e))return Array.prototype.slice.call(e);var t=h(e);delete t[c];for(var r=v(t),n=0;n<r.length;n++){var a=r[n],o=t[a];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(t[a]={configurable:!0,writable:!0,enumerable:o.enumerable,value:e[a]})}return Object.create(Object.getPrototypeOf(e),t)}function S(e,t){if(void 0===t&&(t=!1),A(e)||l(e)||!p(e))return e;if(y(e)>1){var r={configurable:!0,writable:!0,value:x};Object.defineProperties(e,{set:r,add:r,clear:r,delete:r})}return Object.freeze(e),t&&d(e,(function(e,t){return S(t,!0)}),!0),e}function x(){s(2)}function A(e){return null==e||"object"!=typeof e||Object.isFrozen(e)}var E,M={};function D(e){var t=M[e];return t||s(18,e),t}function F(e,t){M[e]||(M[e]=t)}function k(){return E}function N(e,t){t&&(D("Patches"),e.patches_=[],e.inversePatches_=[],e.patchListener_=t)}function R(e){K(e),e.drafts_.forEach(U),e.drafts_=null}function K(e){e===E&&(E=e.parent_)}function W(e){return E={drafts_:[],parent_:E,immer_:e,canAutoFreeze_:!0,unfinalizedDrafts_:0}}function U(e){var t=e[c];0===t.type_||1===t.type_?t.revoke_():t.revoked_=!0}function I(e,t){t.unfinalizedDrafts_=t.drafts_.length;var r=t.drafts_[0],n=void 0!==e&&e!==r;return t.immer_.useProxies_||D("ES5").willFinalizeES5_(t,e,n),n?(r[c].modified_&&(R(t),s(4)),p(e)&&(e=C(t,e),t.parent_||$(t,e)),t.patches_&&D("Patches").generateReplacementPatches_(r[c].base_,e,t.patches_,t.inversePatches_)):e=C(t,r,[]),R(t),t.patches_&&t.patchListener_(t.patches_,t.inversePatches_),e!==i?e:void 0}function C(e,t,r){if(A(t))return t;var n=t[c];if(!n)return d(t,(function(a,o){return L(e,n,t,a,o,r)}),!0),t;if(n.scope_!==e)return t;if(!n.modified_)return $(e,n.base_,!0),n.base_;if(!n.finalized_){n.finalized_=!0,n.scope_.unfinalizedDrafts_--;var a=4===n.type_||5===n.type_?n.copy_=z(n.draft_):n.copy_;d(3===n.type_?new Set(a):a,(function(t,o){return L(e,n,a,t,o,r)})),$(e,a,!1),r&&e.patches_&&D("Patches").generatePatches_(n,r,e.patches_,e.inversePatches_)}return n.copy_}function L(e,t,r,n,a,o){if(l(a)){var i=C(e,a,o&&t&&3!==t.type_&&!b(t.assigned_,n)?o.concat(n):void 0);if(m(r,n,i),!l(i))return;e.canAutoFreeze_=!1}if(p(a)&&!A(a)){if(!e.immer_.autoFreeze_&&e.unfinalizedDrafts_<1)return;C(e,a),t&&t.scope_.parent_||$(e,a)}}function $(e,t,r){void 0===r&&(r=!1),e.immer_.autoFreeze_&&e.canAutoFreeze_&&S(t,r)}var J={get:function(e,t){if(t===c)return e;var r=j(e);if(!b(r,t))return function(e,t,r){var n,a=B(t,r);return a?"value"in a?a.value:null===(n=a.get)||void 0===n?void 0:n.call(e.draft_):void 0}(e,r,t);var n=r[t];return e.finalized_||!p(n)?n:n===q(e.base_,t)?(H(e),e.copy_[t]=T(e.scope_.immer_,n,e)):n},has:function(e,t){return t in j(e)},ownKeys:function(e){return Reflect.ownKeys(j(e))},set:function(e,t,r){var n=B(j(e),t);if(null==n?void 0:n.set)return n.set.call(e.draft_,r),!0;if(!e.modified_){var a=q(j(e),t),o=null==a?void 0:a[c];if(o&&o.base_===r)return e.copy_[t]=r,e.assigned_[t]=!1,!0;if(P(r,a)&&(void 0!==r||b(e.base_,t)))return!0;H(e),G(e)}return!!(e.copy_[t]===r&&(void 0!==r||t in e.copy_)||Number.isNaN(r)&&Number.isNaN(e.copy_[t]))||(e.copy_[t]=r,e.assigned_[t]=!0,!0)},deleteProperty:function(e,t){return void 0!==q(e.base_,t)||t in e.base_?(e.assigned_[t]=!1,H(e),G(e)):delete e.assigned_[t],e.copy_&&delete e.copy_[t],!0},getOwnPropertyDescriptor:function(e,t){var r=j(e),n=Reflect.getOwnPropertyDescriptor(r,t);return n?{writable:!0,configurable:1!==e.type_||"length"!==t,enumerable:n.enumerable,value:r[t]}:n},defineProperty:function(){s(11)},getPrototypeOf:function(e){return Object.getPrototypeOf(e.base_)},setPrototypeOf:function(){s(12)}},X={};function q(e,t){var r=e[c];return(r?j(r):e)[t]}function B(e,t){if(t in e)for(var r=Object.getPrototypeOf(e);r;){var n=Object.getOwnPropertyDescriptor(r,t);if(n)return n;r=Object.getPrototypeOf(r)}}function G(e){e.modified_||(e.modified_=!0,e.parent_&&G(e.parent_))}function H(e){e.copy_||(e.copy_=z(e.base_))}d(J,(function(e,t){X[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),X.deleteProperty=function(e,t){return X.set.call(this,e,t,void 0)},X.set=function(e,t,r){return J.set.call(this,e[0],t,r,e[0])};var Q=function(){function e(e){var t=this;this.useProxies_=o,this.autoFreeze_=!0,this.produce=function(e,r,n){if("function"==typeof e&&"function"!=typeof r){var a=r;r=e;var o=t;return function(e){var t=this;void 0===e&&(e=a);for(var n=arguments.length,i=new Array(n>1?n-1:0),u=1;u<n;u++)i[u-1]=arguments[u];return o.produce(e,(function(e){var n;return(n=r).call.apply(n,[t,e].concat(i))}))}}var u;if("function"!=typeof r&&s(6),void 0!==n&&"function"!=typeof n&&s(7),p(e)){var c=W(t),f=T(t,e,void 0),l=!0;try{u=r(f),l=!1}finally{l?R(c):K(c)}return"undefined"!=typeof Promise&&u instanceof Promise?u.then((function(e){return N(c,n),I(e,c)}),(function(e){throw R(c),e})):(N(c,n),I(u,c))}if(!e||"object"!=typeof e){if(void 0===(u=r(e))&&(u=e),u===i&&(u=void 0),t.autoFreeze_&&S(u,!0),n){var _=[],v=[];D("Patches").generateReplacementPatches_(e,u,_,v),n(_,v)}return u}s(21,e)},this.produceWithPatches=function(e,r){if("function"==typeof e)return function(r){for(var n=arguments.length,a=new Array(n>1?n-1:0),o=1;o<n;o++)a[o-1]=arguments[o];return t.produceWithPatches(r,(function(t){return e.apply(void 0,[t].concat(a))}))};var n,a,o=t.produce(e,r,(function(e,t){n=e,a=t}));return"undefined"!=typeof Promise&&o instanceof Promise?o.then((function(e){return[e,n,a]})):[o,n,a]},"boolean"==typeof(null==e?void 0:e.useProxies)&&this.setUseProxies(e.useProxies),"boolean"==typeof(null==e?void 0:e.autoFreeze)&&this.setAutoFreeze(e.autoFreeze)}var t=e.prototype;return t.createDraft=function(e){p(e)||s(8),l(e)&&(e=V(e));var t=W(this),r=T(this,e,void 0);return r[c].isManual_=!0,K(t),r},t.finishDraft=function(e,t){var r=(e&&e[c]).scope_;return N(r,t),I(void 0,r)},t.setAutoFreeze=function(e){this.autoFreeze_=e},t.setUseProxies=function(e){e&&!o&&s(20),this.useProxies_=e},t.applyPatches=function(e,t){var r;for(r=t.length-1;r>=0;r--){var n=t[r];if(0===n.path.length&&"replace"===n.op){e=n.value;break}}r>-1&&(t=t.slice(r+1));var a=D("Patches").applyPatches_;return l(e)?a(e,t):this.produce(e,(function(e){return a(e,t)}))},e}();function T(e,t,r){var n=w(t)?D("MapSet").proxyMap_(t,r):O(t)?D("MapSet").proxySet_(t,r):e.useProxies_?function(e,t){var r=Array.isArray(e),n={type_:r?1:0,scope_:t?t.scope_:k(),modified_:!1,finalized_:!1,assigned_:{},parent_:t,base_:e,draft_:null,copy_:null,revoke_:null,isManual_:!1},a=n,o=J;r&&(a=[n],o=X);var i=Proxy.revocable(a,o),u=i.revoke,c=i.proxy;return n.draft_=c,n.revoke_=u,c}(t,r):D("ES5").createES5Proxy_(t,r);return(r?r.scope_:k()).drafts_.push(n),n}function V(e){return l(e)||s(22,e),function e(t){if(!p(t))return t;var r,n=t[c],a=y(t);if(n){if(!n.modified_&&(n.type_<4||!D("ES5").hasChanges_(n)))return n.base_;n.finalized_=!0,r=Y(t,a),n.finalized_=!1}else r=Y(t,a);return d(r,(function(t,a){n&&g(n.base_,t)===a||m(r,t,e(a))})),3===a?new Set(r):r}(e)}function Y(e,t){switch(t){case 2:return new Map(e);case 3:return Array.from(e)}return z(e)}function Z(){var e={};function t(t,r){var n=e[t];return n?n.enumerable=r:e[t]=n={configurable:!0,enumerable:r,get:function(){return J.get(this[c],t)},set:function(e){J.set(this[c],t,e)}},n}function r(e){for(var t=e.length-1;t>=0;t--){var r=e[t][c];if(!r.modified_)switch(r.type_){case 5:a(r)&&G(r);break;case 4:n(r)&&G(r)}}}function n(e){for(var t=e.base_,r=e.draft_,n=v(r),a=n.length-1;a>=0;a--){var o=n[a];if(o!==c){var i=t[o];if(void 0===i&&!b(t,o))return!0;var u=r[o],f=u&&u[c];if(f?f.base_!==i:!P(u,i))return!0}}var s=!!t[c];return n.length!==v(t).length+(s?0:1)}function a(e){var t=e.draft_;if(t.length!==e.base_.length)return!0;var r=Object.getOwnPropertyDescriptor(t,t.length-1);if(r&&!r.get)return!0;for(var n=0;n<t.length;n++)if(!t.hasOwnProperty(n))return!0;return!1}F("ES5",{createES5Proxy_:function(e,r){var n=Array.isArray(e),a=function(e,r){if(e){for(var n=new Array(r.length),a=0;a<r.length;a++)Object.defineProperty(n,""+a,t(a,!0));return n}var o=h(r);delete o[c];for(var i=v(o),u=0;u<i.length;u++){var f=i[u];o[f]=t(f,e||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(r),o)}(n,e),o={type_:n?5:4,scope_:r?r.scope_:k(),modified_:!1,finalized_:!1,assigned_:{},parent_:r,base_:e,draft_:a,copy_:null,revoked_:!1,isManual_:!1};return Object.defineProperty(a,c,{value:o,writable:!0}),a},willFinalizeES5_:function(e,t,n){n?l(t)&&t[c].scope_===e&&r(e.drafts_):(e.patches_&&function e(t){if(t&&"object"==typeof t){var r=t[c];if(r){var n=r.base_,o=r.draft_,i=r.assigned_,u=r.type_;if(4===u)d(o,(function(t){t!==c&&(void 0!==n[t]||b(n,t)?i[t]||e(o[t]):(i[t]=!0,G(r)))})),d(n,(function(e){void 0!==o[e]||b(o,e)||(i[e]=!1,G(r))}));else if(5===u){if(a(r)&&(G(r),i.length=!0),o.length<n.length)for(var f=o.length;f<n.length;f++)i[f]=!1;else for(var s=n.length;s<o.length;s++)i[s]=!0;for(var l=Math.min(o.length,n.length),p=0;p<l;p++)o.hasOwnProperty(p)||(i[p]=!0),void 0===i[p]&&e(o[p])}}}}(e.drafts_[0]),r(e.drafts_))},hasChanges_:function(e){return 4===e.type_?n(e):a(e)}})}function ee(){var e=function(t,r){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(t,r)};function t(t,r){function n(){Object.defineProperty(this,"constructor",{value:t})}e(t,r),t.prototype=(n.prototype=r.prototype,new n)}var r=function(e){var r;function a(e,t){return this[c]={type_:2,parent_:t,scope_:t?t.scope_:k(),modified_:!1,finalized_:!1,copy_:void 0,assigned_:void 0,base_:e,draft_:this,isManual_:!1,revoked_:!1},this}return t(a,Map),Object.defineProperties(a.prototype,((r={size:{get:function(){return j(this[c]).size},configurable:!0},has:{configurable:!0,writable:!0,value:function(e){return j(this[c]).has(e)}},set:{configurable:!0,writable:!0,value:function(e,t){var r=this[c];return i(r),j(r).has(e)&&j(r).get(e)===t||(n(r),G(r),r.assigned_.set(e,!0),r.copy_.set(e,t),r.assigned_.set(e,!0)),this}},delete:{configurable:!0,writable:!0,value:function(e){if(!this.has(e))return!1;var t=this[c];return i(t),n(t),G(t),t.base_.has(e)?t.assigned_.set(e,!1):t.assigned_.delete(e),t.copy_.delete(e),!0}},clear:{configurable:!0,writable:!0,value:function(){var e=this[c];i(e),j(e).size&&(n(e),G(e),e.assigned_=new Map,d(e.base_,(function(t){e.assigned_.set(t,!1)})),e.copy_.clear())}},forEach:{configurable:!0,writable:!0,value:function(e,t){var r=this;j(this[c]).forEach((function(n,a,o){e.call(t,r.get(a),a,r)}))}},get:{configurable:!0,writable:!0,value:function(e){var t=this[c];i(t);var r=j(t).get(e);if(t.finalized_||!p(r))return r;if(r!==t.base_.get(e))return r;var a=T(t.scope_.immer_,r,t);return n(t),t.copy_.set(e,a),a}},keys:{configurable:!0,writable:!0,value:function(){return j(this[c]).keys()}},values:{configurable:!0,writable:!0,value:function(){var e,t=this,r=this.keys();return(e={})[f]=function(){return t.values()},e.next=function(){var e=r.next();return e.done?e:{done:!1,value:t.get(e.value)}},e}},entries:{configurable:!0,writable:!0,value:function(){var e,t=this,r=this.keys();return(e={})[f]=function(){return t.entries()},e.next=function(){var e=r.next();if(e.done)return e;var n=t.get(e.value);return{done:!1,value:[e.value,n]}},e}}})[f]={configurable:!0,writable:!0,value:function(){return this.entries()}},r)),a}();function n(e){e.copy_||(e.assigned_=new Map,e.copy_=new Map(e.base_))}var a=function(e){var r;function n(e,t){return this[c]={type_:3,parent_:t,scope_:t?t.scope_:k(),modified_:!1,finalized_:!1,copy_:void 0,base_:e,draft_:this,drafts_:new Map,revoked_:!1,isManual_:!1},this}return t(n,Set),Object.defineProperties(n.prototype,((r={size:{get:function(){return j(this[c]).size},configurable:!0},has:{configurable:!0,writable:!0,value:function(e){var t=this[c];return i(t),t.copy_?!!t.copy_.has(e)||!(!t.drafts_.has(e)||!t.copy_.has(t.drafts_.get(e))):t.base_.has(e)}},add:{configurable:!0,writable:!0,value:function(e){var t=this[c];return i(t),this.has(e)||(o(t),G(t),t.copy_.add(e)),this}},delete:{configurable:!0,writable:!0,value:function(e){if(!this.has(e))return!1;var t=this[c];return i(t),o(t),G(t),t.copy_.delete(e)||!!t.drafts_.has(e)&&t.copy_.delete(t.drafts_.get(e))}},clear:{configurable:!0,writable:!0,value:function(){var e=this[c];i(e),j(e).size&&(o(e),G(e),e.copy_.clear())}},values:{configurable:!0,writable:!0,value:function(){var e=this[c];return i(e),o(e),e.copy_.values()}},entries:{configurable:!0,writable:!0,value:function(){var e=this[c];return i(e),o(e),e.copy_.entries()}},keys:{configurable:!0,writable:!0,value:function(){return this.values()}}})[f]={configurable:!0,writable:!0,value:function(){return this.values()}},r.forEach={configurable:!0,writable:!0,value:function(e,t){for(var r=this.values(),n=r.next();!n.done;)e.call(t,n.value,n.value,this),n=r.next()}},r)),n}();function o(e){e.copy_||(e.copy_=new Set,e.base_.forEach((function(t){if(p(t)){var r=T(e.scope_.immer_,t,e);e.drafts_.set(t,r),e.copy_.add(r)}else e.copy_.add(t)})))}function i(e){e.revoked_&&s(3,JSON.stringify(j(e)))}F("MapSet",{proxyMap_:function(e,t){return new r(e,t)},proxySet_:function(e,t){return new a(e,t)}})}function te(){var e="add";function t(e){if(!p(e))return e;if(Array.isArray(e))return e.map(t);if(w(e))return new Map(Array.from(e.entries()).map((function(e){return[e[0],t(e[1])]})));if(O(e))return new Set(Array.from(e).map(t));var r=Object.create(Object.getPrototypeOf(e));for(var n in e)r[n]=t(e[n]);return b(e,u)&&(r[u]=e[u]),r}function r(e){return l(e)?t(e):e}F("Patches",{applyPatches_:function(r,n){return n.forEach((function(n){for(var a=n.path,o=n.op,i=r,u=0;u<a.length-1;u++){var c=y(i),f=""+a[u];0!==c&&1!==c||"__proto__"!==f&&"constructor"!==f||s(24),"function"==typeof i&&"prototype"===f&&s(24),"object"!=typeof(i=g(i,f))&&s(15,a.join("/"))}var l=y(i),p=t(n.value),_=a[a.length-1];switch(o){case"replace":switch(l){case 2:return i.set(_,p);case 3:s(16);default:return i[_]=p}case e:switch(l){case 1:return"-"===_?i.push(p):i.splice(_,0,p);case 2:return i.set(_,p);case 3:return i.add(p);default:return i[_]=p}case"remove":switch(l){case 1:return i.splice(_,1);case 2:return i.delete(_);case 3:return i.delete(n.value);default:return delete i[_]}default:s(17,o)}})),r},generatePatches_:function(t,n,a,o){switch(t.type_){case 0:case 4:case 2:return function(t,n,a,o){var i=t.base_,u=t.copy_;d(t.assigned_,(function(t,c){var f=g(i,t),s=g(u,t),l=c?b(i,t)?"replace":e:"remove";if(f!==s||"replace"!==l){var p=n.concat(t);a.push("remove"===l?{op:l,path:p}:{op:l,path:p,value:s}),o.push(l===e?{op:"remove",path:p}:"remove"===l?{op:e,path:p,value:r(f)}:{op:"replace",path:p,value:r(f)})}}))}(t,n,a,o);case 5:case 1:return function(t,n,a,o){var i=t.base_,u=t.assigned_,c=t.copy_;if(c.length<i.length){var f=[c,i];i=f[0],c=f[1];var s=[o,a];a=s[0],o=s[1]}for(var l=0;l<i.length;l++)if(u[l]&&c[l]!==i[l]){var p=n.concat([l]);a.push({op:"replace",path:p,value:r(c[l])}),o.push({op:"replace",path:p,value:r(i[l])})}for(var _=i.length;_<c.length;_++){var v=n.concat([_]);a.push({op:e,path:v,value:r(c[_])})}i.length<c.length&&o.push({op:"replace",path:n.concat(["length"]),value:i.length})}(t,n,a,o);case 3:return function(t,r,n,a){var o=t.base_,i=t.copy_,u=0;o.forEach((function(t){if(!i.has(t)){var o=r.concat([u]);n.push({op:"remove",path:o,value:t}),a.unshift({op:e,path:o,value:t})}u++})),u=0,i.forEach((function(t){if(!o.has(t)){var i=r.concat([u]);n.push({op:e,path:i,value:t}),a.unshift({op:"remove",path:i,value:t})}u++}))}(t,n,a,o)}},generateReplacementPatches_:function(e,t,r,n){r.push({op:"replace",path:[],value:t===i?void 0:t}),n.push({op:"replace",path:[],value:e})}})}var re=new Q,ne=re.produce,ae=re.produceWithPatches.bind(re),oe=re.setAutoFreeze.bind(re),ie=re.setUseProxies.bind(re),ue=re.applyPatches.bind(re),ce=re.createDraft.bind(re),fe=re.finishDraft.bind(re);e.Immer=Q,e.applyPatches=ue,e.castDraft=function(e){return e},e.castImmutable=function(e){return e},e.createDraft=ce,e.current=V,e.default=ne,e.enableAllPlugins=function(){Z(),ee(),te()},e.enableES5=Z,e.enableMapSet=ee,e.enablePatches=te,e.finishDraft=fe,e.freeze=S,e.immerable=u,e.isDraft=l,e.isDraftable=p,e.nothing=i,e.original=function(e){return l(e)||s(23,e),e[c].base_},e.produce=ne,e.produceWithPatches=ae,e.setAutoFreeze=oe,e.setUseProxies=ie,Object.defineProperty(e,"__esModule",{value:!0})}));
 //# sourceMappingURL=immer.umd.production.min.js.map
diff --git a/dist/immer.umd.production.min.js.map b/dist/immer.umd.production.min.js.map
index 66f9c9ab90a53465b321391d48463509317116b5..7b332027087a8b71994093dce43bf3e1fe45ad79 100644
--- a/dist/immer.umd.production.min.js.map
+++ b/dist/immer.umd.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"immer.umd.production.min.js","sources":["../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/patches.ts","../src/plugins/mapset.ts","../src/utils/env.ts","../src/immer.ts","../src/plugins/all.ts"],"sourcesContent":["const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\tbase: any,\n\t\trecipe?: any,\n\t): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\titeratorSymbol,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tProxyType,\n\tdie,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\t/* istanbul ignore next */\n\tvar extendStatics = function(d: any, b: any): any {\n\t\textendStatics =\n\t\t\tObject.setPrototypeOf ||\n\t\t\t({__proto__: []} instanceof Array &&\n\t\t\t\tfunction(d, b) {\n\t\t\t\t\td.__proto__ = b\n\t\t\t\t}) ||\n\t\t\tfunction(d, b) {\n\t\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t\t}\n\t\treturn extendStatics(d, b)\n\t}\n\n\t// Ugly hack to resolve #502 and inherit built in Map / Set\n\tfunction __extends(d: any, b: any): any {\n\t\textendStatics(d, b)\n\t\tfunction __(this: any): any {\n\t\t\tthis.constructor = d\n\t\t}\n\t\td.prototype =\n\t\t\t// @ts-ignore\n\t\t\t((__.prototype = b.prototype), new __())\n\t}\n\n\tconst DraftMap = (function(_super) {\n\t\t__extends(DraftMap, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t} as MapState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftMap.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: false,\n\t\t\t// configurable: true\n\t\t})\n\n\t\tp.has = function(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tp.set = function(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.forEach = function(\n\t\t\tcb: (value: any, key: any, self: any) => void,\n\t\t\tthisArg?: any\n\t\t) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tp.get = function(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp.entries = function(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.entries()\n\t\t}\n\n\t\treturn DraftMap\n\t})(Map)\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tconst DraftSet = (function(_super) {\n\t\t__extends(DraftSet, _super)\n\t\t// Create class manually, cause #502\n\t\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ProxyType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t} as SetState\n\t\t\treturn this\n\t\t}\n\t\tconst p = DraftSet.prototype\n\n\t\tObject.defineProperty(p, \"size\", {\n\t\t\tget: function() {\n\t\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t\t}\n\t\t\t// enumerable: true,\n\t\t})\n\n\t\tp.has = function(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tp.add = function(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tp.delete = function(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tp.clear = function() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tp.values = function(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tp.entries = function entries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tp.keys = function(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp[iteratorSymbol] = function() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tp.forEach = function forEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\n\t\treturn DraftSet\n\t})(Set)\n\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_.immer_, value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","import {enableES5} from \"./es5\"\nimport {enableMapSet} from \"./mapset\"\nimport {enablePatches} from \"./patches\"\n\nexport function enableAllPlugins() {\n\tenableES5()\n\tenableMapSet()\n\tenablePatches()\n}\n"],"names":["die","error","args","Error","length","map","s","join","isDraft","value","DRAFT_STATE","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","toString","objectCtorString","Array","isArray","DRAFTABLE","_value$constructor","isMap","isSet","each","obj","iter","enumerableOnly","getArchtype","keys","ownKeys","forEach","key","entry","index","thing","state","type_","has","prop","prototype","get","set","propOrOldValue","t","delete","add","is","x","y","target","hasMap","Map","hasSet","Set","latest","copy_","base_","shallowCopy","base","slice","descriptors","getOwnPropertyDescriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","loadPlugin","implementation","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","push","current","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","proxyProperty","this","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","defineProperty","markChangesRecursively","object","min","Math","enablePatches","deepClonePatchValue","entries","cloned","immerable","clonePatchValueIfNeeded","ADD","applyPatches_","patches","patch","op","parentType","p","type","splice","basePath","inversePatches","assignedValue","origValue","unshift","replacement","enableMapSet","__extends","d","b","__","extendStatics","prepareMapCopy","prepareSetCopy","assertUnrevoked","JSON","stringify","setPrototypeOf","__proto__","DraftMap","size","cb","thisArg","_value","_this","values","iterator","iteratorSymbol","_this2","next","r","done","_this3","DraftSet","hasSymbol","Symbol","hasProxies","Reflect","for","getOwnPropertySymbols","getOwnPropertyNames","_desc$get","currentState","deleteProperty","owner","fn","arguments","apply","Immer","config","recipe","defaultBase","self","produce","hasError","Promise","then","ip","produceWithPatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","applyPatchesImpl","bind"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"immer.umd.production.min.js","sources":["../src/utils/env.ts","../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/es5.ts","../src/plugins/mapset.ts","../src/plugins/patches.ts","../src/immer.ts","../src/plugins/all.ts"],"sourcesContent":["// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import { DRAFT_STATE, DRAFTABLE, hasSet, Objectish, Drafted, AnyObject, AnyMap, AnySet, ImmerState, hasMap, Archtype, die } from \"../internal.js\";\r\n\n /** Returns true if the given value is an Immer draft */\r\n/*#__PURE__*/\r\nexport function isDraft(value: any): boolean {\r\n    return !!value && !!value[DRAFT_STATE];\r\n}\r\n\n /** Returns true if the given value can be drafted by Immer */\r\n/*#__PURE__*/\r\nexport function isDraftable(value: any): boolean {\r\n    if (!value)\r\n        return false;\r\n    return (isPlainObject(value) ||\r\n        Array.isArray(value) ||\r\n        !!value[DRAFTABLE] ||\r\n        !!value.constructor?.[DRAFTABLE] ||\r\n        isMap(value) ||\r\n        isSet(value));\r\n}\r\n\n const objectCtorString = Object.prototype.constructor.toString();\r\n/*#__PURE__*/\r\nexport function isPlainObject(value: any): boolean {\r\n    if (!value || typeof value !== \"object\")\r\n        return false;\r\n    const proto = Object.getPrototypeOf(value);\r\n    if (proto === null) {\r\n        return true;\r\n    }\r\n    const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\r\n    \n if (Ctor === Object)\r\n        return true;\r\n    \n return (typeof Ctor == \"function\" &&\r\n        Function.toString.call(Ctor) === objectCtorString);\r\n}\r\n\n /** Get the underlying object that is represented by the given draft */\r\n/*#__PURE__*/\r\nexport function original<T>(value: T): T | undefined;\r\nexport function original(value: Drafted<any>): any {\r\n    if (!isDraft(value))\r\n        die(23, value);\r\n    return value[DRAFT_STATE].base_;\r\n}\r\n\n /*#__PURE__*/\r\nexport const ownKeys: (target: AnyObject) => PropertyKey[] = typeof Reflect !== \"undefined\" && Reflect.ownKeys\r\n    ? Reflect.ownKeys\r\n    : typeof Object.getOwnPropertySymbols !== \"undefined\"\r\n        ? obj => Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj) as any)\r\n        : /* istanbul ignore next */ Object.getOwnPropertyNames;\r\n\n export const getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\r\n    function getOwnPropertyDescriptors(target: any) {\r\n        // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\r\n        const res: any = {};\r\n        ownKeys(target).forEach(key => {\r\n            res[key] = Object.getOwnPropertyDescriptor(target, key);\r\n        });\r\n        return res;\r\n    };\r\n\n export function each<T extends Objectish>(obj: T, iter: (key: string | number, value: any, source: T) => void, enumerableOnly?: boolean): void;\r\nexport function each(obj: any, iter: any, enumerableOnly = false) {\r\n    if (getArchtype(obj) === Archtype.Object) {\r\n        ;\r\n        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\r\n            if (!enumerableOnly || typeof key !== \"symbol\")\r\n                iter(key, obj[key], obj);\r\n        });\r\n    }\r\n    else {\r\n        obj.forEach((entry: any, index: any) => iter(index, entry, obj));\r\n    }\r\n}\r\n\n /*#__PURE__*/\r\nexport function getArchtype(thing: any): Archtype {\r\n    /* istanbul ignore next */\r\n    const state: undefined | ImmerState = thing[DRAFT_STATE];\r\n    return state\r\n        ? state.type_ > 3\r\n            ? state.type_ - 4 // cause Object and Array map back from 4 and 5\r\n            : (state.type_ as any) // others are the same\r\n        : Array.isArray(thing)\r\n            ? Archtype.Array\r\n            : isMap(thing)\r\n                ? Archtype.Map\r\n                : isSet(thing)\r\n                    ? Archtype.Set\r\n                    : Archtype.Object;\r\n}\r\n\n /*#__PURE__*/\r\nexport function has(thing: any, prop: PropertyKey): boolean {\r\n    return getArchtype(thing) === Archtype.Map\r\n        ? thing.has(prop)\r\n        : Object.prototype.hasOwnProperty.call(thing, prop);\r\n}\r\n\n /*#__PURE__*/\r\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\r\n    // @ts-ignore\r\n    return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop];\r\n}\r\n\n /*#__PURE__*/\r\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\r\n    const t = getArchtype(thing);\r\n    if (t === Archtype.Map)\r\n        thing.set(propOrOldValue, value);\r\n    else if (t === Archtype.Set) {\r\n        thing.delete(propOrOldValue);\r\n        thing.add(value);\r\n    }\r\n    else\r\n        thing[propOrOldValue] = value;\r\n}\r\n\n /*#__PURE__*/\r\nexport function is(x: any, y: any): boolean {\r\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\r\n    if (x === y) {\r\n        return x !== 0 || 1 / x === 1 / y;\r\n    }\r\n    else {\r\n        return x !== x && y !== y;\r\n    }\r\n}\r\n\n /*#__PURE__*/\r\nexport function isMap(target: any): target is AnyMap {\r\n    return hasMap && target instanceof Map;\r\n}\r\n\n /*#__PURE__*/\r\nexport function isSet(target: any): target is AnySet {\r\n    return hasSet && target instanceof Set;\r\n}\r\n/*#__PURE__*/\r\nexport function latest(state: ImmerState): any {\r\n    return state.copy_ || state.base_;\r\n}\r\n\n /*#__PURE__*/\r\nexport function shallowCopy(base: any) {\r\n    if (Array.isArray(base))\r\n        return Array.prototype.slice.call(base);\r\n    const descriptors = getOwnPropertyDescriptors(base);\r\n    delete descriptors[DRAFT_STATE as any];\r\n    let keys = ownKeys(descriptors);\r\n    for (let i = 0; i < keys.length; i++) {\r\n        const key: any = keys[i];\r\n        const desc = descriptors[key];\r\n        if (desc.writable === false) {\r\n            desc.writable = true;\r\n            desc.configurable = true;\r\n        }\r\n        // like object.assign, we will read any _own_, get/set accessors. This helps in dealing\r\n        // with libraries that trap values, like mobx or vue\r\n        // unlike object.assign, non-enumerables will be copied as well\r\n        if (desc.get || desc.set)\r\n            descriptors[key] = {\r\n                configurable: true,\r\n                writable: true,\r\n                enumerable: desc.enumerable,\r\n                value: base[key]\r\n            };\r\n    }\r\n    return Object.create(Object.getPrototypeOf(base), descriptors);\r\n}\r\n\n /**\r\n * Freezes draftable objects. Returns the original object.\r\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\r\n *\r\n * @param obj\r\n * @param deep\r\n */\r\nexport function freeze<T>(obj: T, deep?: boolean): T;\r\nexport function freeze<T>(obj: any, deep: boolean = false): T {\r\n    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))\r\n        return obj;\r\n    if (getArchtype(obj) > 1 /* Map or Set */) {\r\n        const desc: PropertyDescriptor = {\r\n            configurable: true,\r\n            writable: true,\r\n            value: dontMutateFrozenCollections\r\n        };\r\n        Object.defineProperties(obj, {\r\n            set: desc,\r\n            add: desc,\r\n            clear: desc,\r\n            delete: desc\r\n        });\r\n    }\r\n    Object.freeze(obj);\r\n    if (deep)\r\n        each(obj, (key, value) => freeze(value, true), true);\r\n    return obj;\r\n}\r\n\n function dontMutateFrozenCollections() {\r\n    die(2);\r\n}\r\n\n export function isFrozen(obj: any): boolean {\r\n    if (obj == null || typeof obj !== \"object\")\r\n        return true;\r\n    // See #600, IE dies on non-objects in Object.isFrozen\r\n    return Object.isFrozen(obj);\r\n}\r\n","import { ImmerState, Patch, ImmerScope, Drafted, AnyObject, ImmerBaseState, AnyMap, AnySet, ProxyType, die } from \"../internal.js\";\r\n\n /** Plugin utilities */\r\nconst plugins: {\r\n    Patches?: {\r\n        generatePatches_(state: ImmerState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]): void;\r\n        generateReplacementPatches_(base: any, replacement: any, patches: Patch[], inversePatches: Patch[]): void;\r\n        applyPatches_<T>(draft: T, patches: Patch[]): T;\r\n    };\r\n    ES5?: {\r\n        willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void;\r\n        createES5Proxy_<T>(base: T, parent?: ImmerState): Drafted<T, ES5ObjectState | ES5ArrayState>;\r\n        hasChanges_(state: ES5ArrayState | ES5ObjectState): boolean;\r\n    };\r\n    MapSet?: {\r\n        proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T;\r\n        proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T;\r\n    };\r\n} = {};\r\n\n type Plugins = typeof plugins;\r\n\n export function getPlugin<K extends keyof Plugins>(pluginKey: K): Exclude<Plugins[K], undefined> {\r\n    const plugin = plugins[pluginKey];\r\n    if (!plugin) {\r\n        die(18, pluginKey);\r\n    }\r\n    // @ts-ignore\r\n    return plugin;\r\n}\r\n\n export function loadPlugin<K extends keyof Plugins>(pluginKey: K, implementation: Plugins[K]): void {\r\n    if (!plugins[pluginKey])\r\n        plugins[pluginKey] = implementation;\r\n}\r\n\n /** ES5 Plugin */\r\n\n interface ES5BaseState extends ImmerBaseState {\r\n    assigned_: {\r\n        [key: string]: any;\r\n    };\r\n    parent_?: ImmerState;\r\n    revoked_: boolean;\r\n}\r\n\n export interface ES5ObjectState extends ES5BaseState {\r\n    type_: ProxyType.ES5Object;\r\n    draft_: Drafted<AnyObject, ES5ObjectState>;\r\n    base_: AnyObject;\r\n    copy_: AnyObject | null;\r\n}\r\n\n export interface ES5ArrayState extends ES5BaseState {\r\n    type_: ProxyType.ES5Array;\r\n    draft_: Drafted<AnyObject, ES5ArrayState>;\r\n    base_: any;\r\n    copy_: any;\r\n}\r\n\n /** Map / Set plugin */\r\n\n export interface MapState extends ImmerBaseState {\r\n    type_: ProxyType.Map;\r\n    copy_: AnyMap | undefined;\r\n    assigned_: Map<any, boolean> | undefined;\r\n    base_: AnyMap;\r\n    revoked_: boolean;\r\n    draft_: Drafted<AnyMap, MapState>;\r\n}\r\n\n export interface SetState extends ImmerBaseState {\r\n    type_: ProxyType.Set;\r\n    copy_: AnySet | undefined;\r\n    base_: AnySet;\r\n    drafts_: Map<any, Drafted>; // maps the original value to the draft value in the new set\r\n    revoked_: boolean;\r\n    draft_: Drafted<AnySet, SetState>;\r\n}\r\n\n /** Patches plugin */\r\n\n export type PatchPath = (string | number)[];\r\n","import { Patch, PatchListener, Drafted, Immer, DRAFT_STATE, ImmerState, ProxyType, getPlugin } from \"../internal.js\";\r\nimport { die } from \"../utils/errors.js\";\r\n\n /** Each scope represents a `produce` call. */\r\n\n export interface ImmerScope {\r\n    patches_?: Patch[];\r\n    inversePatches_?: Patch[];\r\n    canAutoFreeze_: boolean;\r\n    drafts_: any[];\r\n    parent_?: ImmerScope;\r\n    patchListener_?: PatchListener;\r\n    immer_: Immer;\r\n    unfinalizedDrafts_: number;\r\n}\r\n\n let currentScope: ImmerScope | undefined;\r\n\n export function getCurrentScope() {\r\n    if (__DEV__ && !currentScope)\r\n        die(0);\r\n    return currentScope!;\r\n}\r\n\n function createScope(parent_: ImmerScope | undefined, immer_: Immer): ImmerScope {\r\n    return {\r\n        drafts_: [],\r\n        parent_,\r\n        immer_,\r\n        // Whenever the modified draft contains a draft from another scope, we\r\n        // need to prevent auto-freezing so the unowned draft can be finalized.\r\n        canAutoFreeze_: true,\r\n        unfinalizedDrafts_: 0\r\n    };\r\n}\r\n\n export function usePatchesInScope(scope: ImmerScope, patchListener?: PatchListener) {\r\n    if (patchListener) {\r\n        getPlugin(\"Patches\"); // assert we have the plugin\r\n        scope.patches_ = [];\r\n        scope.inversePatches_ = [];\r\n        scope.patchListener_ = patchListener;\r\n    }\r\n}\r\n\n export function revokeScope(scope: ImmerScope) {\r\n    leaveScope(scope);\r\n    scope.drafts_.forEach(revokeDraft);\r\n    // @ts-ignore\r\n    scope.drafts_ = null;\r\n}\r\n\n export function leaveScope(scope: ImmerScope) {\r\n    if (scope === currentScope) {\r\n        currentScope = scope.parent_;\r\n    }\r\n}\r\n\n export function enterScope(immer: Immer) {\r\n    return (currentScope = createScope(currentScope, immer));\r\n}\r\n\n function revokeDraft(draft: Drafted) {\r\n    const state: ImmerState = draft[DRAFT_STATE];\r\n    if (state.type_ === ProxyType.ProxyObject ||\r\n        state.type_ === ProxyType.ProxyArray)\r\n        state.revoke_();\r\n    else\r\n        state.revoked_ = true;\r\n}\r\n","import { ImmerScope, DRAFT_STATE, isDraftable, NOTHING, PatchPath, each, has, freeze, ImmerState, isDraft, SetState, set, ProxyType, getPlugin, die, revokeScope, isFrozen, shallowCopy } from \"../internal.js\";\r\n\n export function processResult(result: any, scope: ImmerScope) {\r\n    scope.unfinalizedDrafts_ = scope.drafts_.length;\r\n    const baseDraft = scope.drafts_![0];\r\n    const isReplaced = result !== undefined && result !== baseDraft;\r\n    if (!scope.immer_.useProxies_)\r\n        getPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced);\r\n    if (isReplaced) {\r\n        if (baseDraft[DRAFT_STATE].modified_) {\r\n            revokeScope(scope);\r\n            die(4);\r\n        }\r\n        if (isDraftable(result)) {\r\n            // Finalize the result in case it contains (or is) a subset of the draft.\r\n            result = finalize(scope, result);\r\n            if (!scope.parent_)\r\n                maybeFreeze(scope, result);\r\n        }\r\n        if (scope.patches_) {\r\n            getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_!);\r\n        }\r\n    }\r\n    else {\r\n        // Finalize the base draft.\r\n        result = finalize(scope, baseDraft, []);\r\n    }\r\n    revokeScope(scope);\r\n    if (scope.patches_) {\r\n        scope.patchListener_!(scope.patches_, scope.inversePatches_!);\r\n    }\r\n    return result !== NOTHING ? result : undefined;\r\n}\r\n\n function finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\r\n    // Don't recurse in tho recursive data structures\r\n    if (isFrozen(value))\r\n        return value;\r\n    \n const state: ImmerState = value[DRAFT_STATE];\r\n    // A plain object, might need freezing, might contain drafts\r\n    if (!state) {\r\n        each(value, (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path), true // See #590, don't recurse into non-enumerable of non drafted objects\r\n        );\r\n        return value;\r\n    }\r\n    // Never finalize drafts owned by another scope.\r\n    if (state.scope_ !== rootScope)\r\n        return value;\r\n    // Unmodified draft, return the (frozen) original\r\n    if (!state.modified_) {\r\n        maybeFreeze(rootScope, state.base_, true);\r\n        return state.base_;\r\n    }\r\n    // Not finalized yet, let's do that now\r\n    if (!state.finalized_) {\r\n        state.finalized_ = true;\r\n        state.scope_.unfinalizedDrafts_--;\r\n        const result = \r\n        // For ES5, create a good copy from the draft first, with added keys and without deleted keys.\r\n        state.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\r\n            ? (state.copy_ = shallowCopy(state.draft_))\r\n            : state.copy_;\r\n        // Finalize all children of the copy\r\n        // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\r\n        // Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\r\n        // back to each(result, ....)\r\n        each(state.type_ === ProxyType.Set ? new Set(result) : result, (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path));\r\n        // everything inside is frozen, we can freeze here\r\n        maybeFreeze(rootScope, result, false);\r\n        // first time finalizing, let's create those patches\r\n        if (path && rootScope.patches_) {\r\n            getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_!);\r\n        }\r\n    }\r\n    return state.copy_;\r\n}\r\n\n function finalizeProperty(rootScope: ImmerScope, parentState: undefined | ImmerState, targetObject: any, prop: string | number, childValue: any, rootPath?: PatchPath) {\r\n    if (__DEV__ && childValue === targetObject)\r\n        die(5);\r\n    if (isDraft(childValue)) {\r\n        const path = rootPath &&\r\n            parentState &&\r\n            parentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\r\n            !has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\r\n            ? rootPath!.concat(prop)\r\n            : undefined;\r\n        // Drafts owned by `scope` are finalized here.\r\n        const res = finalize(rootScope, childValue, path);\r\n        set(targetObject, prop, res);\r\n        // Drafts from another scope must prevented to be frozen\r\n        // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\r\n        if (isDraft(res)) {\r\n            rootScope.canAutoFreeze_ = false;\r\n        }\r\n        else\r\n            return;\r\n    }\r\n    // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\r\n    if (isDraftable(childValue) && !isFrozen(childValue)) {\r\n        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\r\n            // optimization: if an object is not a draft, and we don't have to\r\n            // deepfreeze everything, and we are sure that no drafts are left in the remaining object\r\n            // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\r\n            // This benefits especially adding large data tree's without further processing.\r\n            // See add-data.js perf test\r\n            return;\r\n        }\r\n        finalize(rootScope, childValue);\r\n        // immer deep freezes plain objects, so if there is no parent state, we freeze as well\r\n        if (!parentState || !parentState.scope_.parent_)\r\n            maybeFreeze(rootScope, childValue);\r\n    }\r\n}\r\n\n function maybeFreeze(scope: ImmerScope, value: any, deep = false) {\r\n    if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\r\n        freeze(value, deep);\r\n    }\r\n}\r\n","import { each, has, is, isDraftable, shallowCopy, latest, ImmerBaseState, ImmerState, Drafted, AnyObject, AnyArray, Objectish, getCurrentScope, DRAFT_STATE, die, createProxy, ProxyType } from \"../internal.js\";\r\n\n interface ProxyBaseState extends ImmerBaseState {\r\n    assigned_: {\r\n        [property: string]: boolean;\r\n    };\r\n    parent_?: ImmerState;\r\n    revoke_(): void;\r\n}\r\n\n export interface ProxyObjectState extends ProxyBaseState {\r\n    type_: ProxyType.ProxyObject;\r\n    base_: any;\r\n    copy_: any;\r\n    draft_: Drafted<AnyObject, ProxyObjectState>;\r\n}\r\n\n export interface ProxyArrayState extends ProxyBaseState {\r\n    type_: ProxyType.ProxyArray;\r\n    base_: AnyArray;\r\n    copy_: AnyArray | null;\r\n    draft_: Drafted<AnyArray, ProxyArrayState>;\r\n}\r\n\n type ProxyState = ProxyObjectState | ProxyArrayState;\r\n\n /**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */\r\nexport function createProxyProxy<T extends Objectish>(base: T, parent?: ImmerState): Drafted<T, ProxyState> {\r\n    const isArray = Array.isArray(base);\r\n    const state: ProxyState = {\r\n        type_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\r\n        // Track which produce call this is associated with.\r\n        scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n        // True for both shallow and deep changes.\r\n        modified_: false,\r\n        // Used during finalization.\r\n        finalized_: false,\r\n        // Track which properties have been assigned (true) or deleted (false).\r\n        assigned_: {},\r\n        // The parent draft state.\r\n        parent_: parent,\r\n        // The base state.\r\n        base_: base,\r\n        // The base proxy.\r\n        draft_: null as any,\r\n        // The base copy with any updated values.\r\n        copy_: null,\r\n        // Called by the `produce` function.\r\n        revoke_: null as any,\r\n        isManual_: false\r\n    };\r\n    \n // the traps must target something, a bit like the 'real' base.\r\n    // but also, we need to be able to determine from the target what the relevant state is\r\n    // (to avoid creating traps per instance to capture the state in closure,\r\n    // and to avoid creating weird hidden properties as well)\r\n    // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\r\n    // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\r\n    let target: T = state as any;\r\n    let traps: ProxyHandler<object | Array<any>> = objectTraps;\r\n    if (isArray) {\r\n        target = [state] as any;\r\n        traps = arrayTraps;\r\n    }\r\n    \n const { revoke, proxy } = Proxy.revocable(target, traps);\r\n    state.draft_ = proxy as any;\r\n    state.revoke_ = revoke;\r\n    return proxy as any;\r\n}\r\n\n /**\r\n * Object drafts\r\n */\r\nexport const objectTraps: ProxyHandler<ProxyState> = {\r\n    get(state, prop) {\r\n        if (prop === DRAFT_STATE)\r\n            return state;\r\n        \n const source = latest(state);\r\n        if (!has(source, prop)) {\r\n            // non-existing or non-own property...\r\n            return readPropFromProto(state, source, prop);\r\n        }\r\n        const value = source[prop];\r\n        if (state.finalized_ || !isDraftable(value)) {\r\n            return value;\r\n        }\r\n        // Check for existing draft in modified state.\r\n        // Assigned values are never drafted. This catches any drafts we created, too.\r\n        if (value === peek(state.base_, prop)) {\r\n            prepareCopy(state);\r\n            return (state.copy_![prop as any] = createProxy(state.scope_.immer_, value, state));\r\n        }\r\n        return value;\r\n    },\r\n    has(state, prop) {\r\n        return prop in latest(state);\r\n    },\r\n    ownKeys(state) {\r\n        return Reflect.ownKeys(latest(state));\r\n    },\r\n    set(state: ProxyObjectState, prop: string /* strictly not, but helps TS */, value) {\r\n        const desc = getDescriptorFromProto(latest(state), prop);\r\n        if (desc?.set) {\r\n            // special case: if this write is captured by a setter, we have\r\n            // to trigger it with the correct context\r\n            desc.set.call(state.draft_, value);\r\n            return true;\r\n        }\r\n        if (!state.modified_) {\r\n            // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\r\n            // from setting an existing property with value undefined to undefined (which is not a change)\r\n            const current = peek(latest(state), prop);\r\n            // special case, if we assigning the original value to a draft, we can ignore the assignment\r\n            const currentState: ProxyObjectState = current?.[DRAFT_STATE];\r\n            if (currentState && currentState.base_ === value) {\r\n                state.copy_![prop] = value;\r\n                state.assigned_[prop] = false;\r\n                return true;\r\n            }\r\n            if (is(value, current) && (value !== undefined || has(state.base_, prop)))\r\n                return true;\r\n            prepareCopy(state);\r\n            markChanged(state);\r\n        }\r\n        \n if ((state.copy_![prop] === value &&\r\n            // special case: handle new props with value 'undefined'\r\n            (value !== undefined || prop in state.copy_)) ||\r\n            // special case: NaN\r\n            (Number.isNaN(value) && Number.isNaN(state.copy_![prop])))\r\n            return true;\r\n        \n // @ts-ignore\r\n        state.copy_![prop] = value;\r\n        state.assigned_[prop] = true;\r\n        return true;\r\n    },\r\n    deleteProperty(state, prop: string) {\r\n        // The `undefined` check is a fast path for pre-existing keys.\r\n        if (peek(state.base_, prop) !== undefined || prop in state.base_) {\r\n            state.assigned_[prop] = false;\r\n            prepareCopy(state);\r\n            markChanged(state);\r\n        }\r\n        else {\r\n            // if an originally not assigned property was deleted\r\n            delete state.assigned_[prop];\r\n        }\r\n        // @ts-ignore\r\n        if (state.copy_)\r\n            delete state.copy_[prop];\r\n        return true;\r\n    },\r\n    // Note: We never coerce `desc.value` into an Immer draft, because we can't make\r\n    // the same guarantee in ES5 mode.\r\n    getOwnPropertyDescriptor(state, prop) {\r\n        const owner = latest(state);\r\n        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\r\n        if (!desc)\r\n            return desc;\r\n        return {\r\n            writable: true,\r\n            configurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\r\n            enumerable: desc.enumerable,\r\n            value: owner[prop]\r\n        };\r\n    },\r\n    defineProperty() {\r\n        die(11);\r\n    },\r\n    getPrototypeOf(state) {\r\n        return Object.getPrototypeOf(state.base_);\r\n    },\r\n    setPrototypeOf() {\r\n        die(12);\r\n    }\r\n};\r\n\n /**\r\n * Array drafts\r\n */\r\n\n const arrayTraps: ProxyHandler<[\r\n    ProxyArrayState\r\n]> = {};\r\neach(objectTraps, (key, fn) => {\r\n    // @ts-ignore\r\n    arrayTraps[key] = function () {\r\n        arguments[0] = arguments[0][0];\r\n        return fn.apply(this, arguments);\r\n    };\r\n});\r\narrayTraps.deleteProperty = function (state, prop) {\r\n    if (__DEV__ && isNaN(parseInt(prop as any)))\r\n        die(13);\r\n    // @ts-ignore\r\n    return arrayTraps.set!.call(this, state, prop, undefined);\r\n};\r\narrayTraps.set = function (state, prop, value) {\r\n    if (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any)))\r\n        die(14);\r\n    return objectTraps.set!.call(this, state[0], prop, value, state[0]);\r\n};\r\n\n // Access a property without creating an Immer draft.\r\nfunction peek(draft: Drafted, prop: PropertyKey) {\r\n    const state = draft[DRAFT_STATE];\r\n    const source = state ? latest(state) : draft;\r\n    return source[prop];\r\n}\r\n\n function readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\r\n    const desc = getDescriptorFromProto(source, prop);\r\n    return desc\r\n        ? `value` in desc\r\n            ? desc.value\r\n            : // This is a very special case, if the prop is a getter defined by the\r\n                // prototype, we should invoke it with the draft as context!\r\n                desc.get?.call(state.draft_)\r\n        : undefined;\r\n}\r\n\n function getDescriptorFromProto(source: any, prop: PropertyKey): PropertyDescriptor | undefined {\r\n    // 'in' checks proto!\r\n    if (!(prop in source))\r\n        return undefined;\r\n    let proto = Object.getPrototypeOf(source);\r\n    while (proto) {\r\n        const desc = Object.getOwnPropertyDescriptor(proto, prop);\r\n        if (desc)\r\n            return desc;\r\n        proto = Object.getPrototypeOf(proto);\r\n    }\r\n    return undefined;\r\n}\r\n\n export function markChanged(state: ImmerState) {\r\n    if (!state.modified_) {\r\n        state.modified_ = true;\r\n        if (state.parent_) {\r\n            markChanged(state.parent_);\r\n        }\r\n    }\r\n}\r\n\n export function prepareCopy(state: {\r\n    base_: any;\r\n    copy_: any;\r\n}) {\r\n    if (!state.copy_) {\r\n        state.copy_ = shallowCopy(state.base_);\r\n    }\r\n}\r\n","import { IProduceWithPatches, IProduce, ImmerState, Drafted, isDraftable, processResult, Patch, Objectish, DRAFT_STATE, Draft, PatchListener, isDraft, isMap, isSet, createProxyProxy, getPlugin, die, hasProxies, enterScope, revokeScope, leaveScope, usePatchesInScope, getCurrentScope, NOTHING, freeze, current } from \"../internal.js\";\r\n\n interface ProducersFns {\r\n    produce: IProduce;\r\n    produceWithPatches: IProduceWithPatches;\r\n}\r\n\n export class Immer implements ProducersFns {\r\n    useProxies_: boolean = hasProxies;\r\n    \n autoFreeze_: boolean = true;\r\n    \n constructor(config?: {\r\n        useProxies?: boolean;\r\n        autoFreeze?: boolean;\r\n    }) {\r\n        if (typeof config?.useProxies === \"boolean\")\r\n            this.setUseProxies(config!.useProxies);\r\n        if (typeof config?.autoFreeze === \"boolean\")\r\n            this.setAutoFreeze(config!.autoFreeze);\r\n    }\r\n    \n /**\r\n         * The `produce` function takes a value and a \"recipe function\" (whose\r\n         * return value often depends on the base state). The recipe function is\r\n         * free to mutate its first argument however it wants. All mutations are\r\n         * only ever applied to a __copy__ of the base state.\r\n         *\r\n         * Pass only a function to create a \"curried producer\" which relieves you\r\n         * from passing the recipe function every time.\r\n         *\r\n         * Only plain objects and arrays are made mutable. All other objects are\r\n         * considered uncopyable.\r\n         *\r\n         * Note: This function is __bound__ to its `Immer` instance.\r\n         *\r\n         * @param {any} base - the initial state\r\n         * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n         * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n         * @returns {any} a new state, or the initial state if nothing was modified\r\n         */\r\n    produce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\r\n        // curried invocation\r\n        if (typeof base === \"function\" && typeof recipe !== \"function\") {\r\n            const defaultBase = recipe;\r\n            recipe = base;\r\n            \n const self = this;\r\n            return function curriedProduce(this: any, base = defaultBase, ...args: any[]) {\r\n                return self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)); // prettier-ignore\r\n            };\r\n        }\r\n        \n if (typeof recipe !== \"function\")\r\n            die(6);\r\n        if (patchListener !== undefined && typeof patchListener !== \"function\")\r\n            die(7);\r\n        \n let result;\r\n        \n // Only plain objects, arrays, and \"immerable classes\" are drafted.\r\n        if (isDraftable(base)) {\r\n            const scope = enterScope(this);\r\n            const proxy = createProxy(this, base, undefined);\r\n            let hasError = true;\r\n            try {\r\n                result = recipe(proxy);\r\n                hasError = false;\r\n            }\r\n            finally {\r\n                // finally instead of catch + rethrow better preserves original stack\r\n                if (hasError)\r\n                    revokeScope(scope);\r\n                else\r\n                    leaveScope(scope);\r\n            }\r\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n                return result.then(result => {\r\n                    usePatchesInScope(scope, patchListener);\r\n                    return processResult(result, scope);\r\n                }, error => {\r\n                    revokeScope(scope);\r\n                    throw error;\r\n                });\r\n            }\r\n            usePatchesInScope(scope, patchListener);\r\n            return processResult(result, scope);\r\n        }\r\n        else if (!base || typeof base !== \"object\") {\r\n            result = recipe(base);\r\n            if (result === undefined)\r\n                result = base;\r\n            if (result === NOTHING)\r\n                result = undefined;\r\n            if (this.autoFreeze_)\r\n                freeze(result, true);\r\n            if (patchListener) {\r\n                const p: Patch[] = [];\r\n                const ip: Patch[] = [];\r\n                getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\r\n                patchListener(p, ip);\r\n            }\r\n            return result;\r\n        }\r\n        else\r\n            die(21, base);\r\n    };\r\n    \n produceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\r\n        // curried invocation\r\n        if (typeof base === \"function\") {\r\n            return (state: any, ...args: any[]) => this.produceWithPatches(state, (draft: any) => base(draft, ...args));\r\n        }\r\n        \n let patches: Patch[], inversePatches: Patch[];\r\n        const result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\r\n            patches = p;\r\n            inversePatches = ip;\r\n        });\r\n        \n if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n            return result.then(nextState => [nextState, patches!, inversePatches!]);\r\n        }\r\n        return [result, patches!, inversePatches!];\r\n    };\r\n    \n createDraft<T extends Objectish>(base: T): Draft<T> {\r\n        if (!isDraftable(base))\r\n            die(8);\r\n        if (isDraft(base))\r\n            base = current(base);\r\n        const scope = enterScope(this);\r\n        const proxy = createProxy(this, base, undefined);\r\n        proxy[DRAFT_STATE].isManual_ = true;\r\n        leaveScope(scope);\r\n        return proxy as any;\r\n    }\r\n    \n finishDraft<D extends Draft<any>>(draft: D, patchListener?: PatchListener): D extends Draft<infer T> ? T : never {\r\n        const state: ImmerState = draft && (draft as any)[DRAFT_STATE];\r\n        if (__DEV__) {\r\n            if (!state || !state.isManual_)\r\n                die(9);\r\n            if (state.finalized_)\r\n                die(10);\r\n        }\r\n        const { scope_: scope } = state;\r\n        usePatchesInScope(scope, patchListener);\r\n        return processResult(undefined, scope);\r\n    }\r\n    \n /**\r\n         * Pass true to automatically freeze all copies created by Immer.\r\n         *\r\n         * By default, auto-freezing is enabled.\r\n         */\r\n    setAutoFreeze(value: boolean) {\r\n        this.autoFreeze_ = value;\r\n    }\r\n    \n /**\r\n         * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n         * always faster than using ES5 proxies.\r\n         *\r\n         * By default, feature detection is used, so calling this is rarely necessary.\r\n         */\r\n    setUseProxies(value: boolean) {\r\n        if (value && !hasProxies) {\r\n            die(20);\r\n        }\r\n        this.useProxies_ = value;\r\n    }\r\n    \n applyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\r\n        // If a patch replaces the entire state, take that replacement as base\r\n        // before applying patches\r\n        let i: number;\r\n        for (i = patches.length - 1; i >= 0; i--) {\r\n            const patch = patches[i];\r\n            if (patch.path.length === 0 && patch.op === \"replace\") {\r\n                base = patch.value;\r\n                break;\r\n            }\r\n        }\r\n        // If there was a patch that replaced the entire state, start from the\r\n        // patch after that.\r\n        if (i > -1) {\r\n            patches = patches.slice(i + 1);\r\n        }\r\n        \n const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\r\n        if (isDraft(base)) {\r\n            // N.B: never hits if some patch a replacement, patches are never drafts\r\n            return applyPatchesImpl(base, patches);\r\n        }\r\n        // Otherwise, produce a copy of the base state.\r\n        return this.produce(base, (draft: Drafted) => applyPatchesImpl(draft, patches));\r\n    }\r\n}\r\n\n export function createProxy<T extends Objectish>(immer: Immer, value: T, parent?: ImmerState): Drafted<T, ImmerState> {\r\n    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\r\n    const draft: Drafted = isMap(value)\r\n        ? getPlugin(\"MapSet\").proxyMap_(value, parent)\r\n        : isSet(value)\r\n            ? getPlugin(\"MapSet\").proxySet_(value, parent)\r\n            : immer.useProxies_\r\n                ? createProxyProxy(value, parent)\r\n                : getPlugin(\"ES5\").createES5Proxy_(value, parent);\r\n    \n const scope = parent ? parent.scope_ : getCurrentScope();\r\n    scope.drafts_.push(draft);\r\n    return draft;\r\n}\r\n","import { die, isDraft, shallowCopy, each, DRAFT_STATE, get, set, ImmerState, isDraftable, Archtype, getArchtype, getPlugin } from \"../internal.js\";\r\n\n /** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\r\nexport function current<T>(value: T): T;\r\nexport function current(value: any): any {\r\n    if (!isDraft(value))\r\n        die(22, value);\r\n    return currentImpl(value);\r\n}\r\n\n function currentImpl(value: any): any {\r\n    if (!isDraftable(value))\r\n        return value;\r\n    const state: ImmerState | undefined = value[DRAFT_STATE];\r\n    let copy: any;\r\n    const archType = getArchtype(value);\r\n    if (state) {\r\n        if (!state.modified_ &&\r\n            (state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any)))\r\n            return state.base_;\r\n        // Optimization: avoid generating new drafts during copying\r\n        state.finalized_ = true;\r\n        copy = copyHelper(value, archType);\r\n        state.finalized_ = false;\r\n    }\r\n    else {\r\n        copy = copyHelper(value, archType);\r\n    }\r\n    \n each(copy, (key, childValue) => {\r\n        if (state && get(state.base_, key) === childValue)\r\n            return; // no need to copy or search in something that didn't change\r\n        set(copy, key, currentImpl(childValue));\r\n    });\r\n    // In the future, we might consider freezing here, based on the current settings\r\n    return archType === Archtype.Set ? new Set(copy) : copy;\r\n}\r\n\n function copyHelper(value: any, archType: number): any {\r\n    // creates a shallow copy, even if it is a map or set\r\n    switch (archType) {\r\n        case Archtype.Map:\r\n            return new Map(value);\r\n        case Archtype.Set:\r\n            // Set will be cloned as array temporarily, so that we can replace individual items\r\n            return Array.from(value);\r\n    }\r\n    return shallowCopy(value);\r\n}\r\n","import { ImmerState, Drafted, ES5ArrayState, ES5ObjectState, each, has, isDraft, latest, DRAFT_STATE, is, loadPlugin, ImmerScope, ProxyType, getCurrentScope, die, markChanged, objectTraps, ownKeys, getOwnPropertyDescriptors } from \"../internal.js\";\r\n\n type ES5State = ES5ArrayState | ES5ObjectState;\r\n\n export function enableES5() {\r\n    function willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean) {\r\n        if (!isReplaced) {\r\n            if (scope.patches_) {\r\n                markChangesRecursively(scope.drafts_![0]);\r\n            }\r\n            // This is faster when we don't care about which attributes changed.\r\n            markChangesSweep(scope.drafts_);\r\n        }\r\n        // When a child draft is returned, look for changes.\r\n        else if (isDraft(result) &&\r\n            (result[DRAFT_STATE] as ES5State).scope_ === scope) {\r\n            markChangesSweep(scope.drafts_);\r\n        }\r\n    }\r\n    \n function createES5Draft(isArray: boolean, base: any) {\r\n        if (isArray) {\r\n            const draft = new Array(base.length);\r\n            for (let i = 0; i < base.length; i++)\r\n                Object.defineProperty(draft, \"\" + i, proxyProperty(i, true));\r\n            return draft;\r\n        }\r\n        else {\r\n            const descriptors = getOwnPropertyDescriptors(base);\r\n            delete descriptors[DRAFT_STATE as any];\r\n            const keys = ownKeys(descriptors);\r\n            for (let i = 0; i < keys.length; i++) {\r\n                const key: any = keys[i];\r\n                descriptors[key] = proxyProperty(key, isArray || !!descriptors[key].enumerable);\r\n            }\r\n            return Object.create(Object.getPrototypeOf(base), descriptors);\r\n        }\r\n    }\r\n    \n function createES5Proxy_<T>(base: T, parent?: ImmerState): Drafted<T, ES5ObjectState | ES5ArrayState> {\r\n        const isArray = Array.isArray(base);\r\n        const draft = createES5Draft(isArray, base);\r\n        \n const state: ES5ObjectState | ES5ArrayState = {\r\n            type_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\r\n            scope_: parent ? parent.scope_ : getCurrentScope(),\r\n            modified_: false,\r\n            finalized_: false,\r\n            assigned_: {},\r\n            parent_: parent,\r\n            // base is the object we are drafting\r\n            base_: base,\r\n            // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\r\n            draft_: draft,\r\n            copy_: null,\r\n            revoked_: false,\r\n            isManual_: false\r\n        };\r\n        \n Object.defineProperty(draft, DRAFT_STATE, {\r\n            value: state,\r\n            // enumerable: false <- the default\r\n            writable: true\r\n        });\r\n        return draft;\r\n    }\r\n    \n // property descriptors are recycled to make sure we don't create a get and set closure per property,\r\n    // but share them all instead\r\n    const descriptors: {\r\n        [prop: string]: PropertyDescriptor;\r\n    } = {};\r\n    \n function proxyProperty(prop: string | number, enumerable: boolean): PropertyDescriptor {\r\n        let desc = descriptors[prop];\r\n        if (desc) {\r\n            desc.enumerable = enumerable;\r\n        }\r\n        else {\r\n            descriptors[prop] = desc = {\r\n                configurable: true,\r\n                enumerable,\r\n                get(this: any) {\r\n                    const state = this[DRAFT_STATE];\r\n                    if (__DEV__)\r\n                        assertUnrevoked(state);\r\n                    // @ts-ignore\r\n                    return objectTraps.get(state, prop);\r\n                },\r\n                set(this: any, value) {\r\n                    const state = this[DRAFT_STATE];\r\n                    if (__DEV__)\r\n                        assertUnrevoked(state);\r\n                    // @ts-ignore\r\n                    objectTraps.set(state, prop, value);\r\n                }\r\n            };\r\n        }\r\n        return desc;\r\n    }\r\n    \n // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\r\n    function markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\r\n        // The natural order of drafts in the `scope` array is based on when they\r\n        // were accessed. By processing drafts in reverse natural order, we have a\r\n        // better chance of processing leaf nodes first. When a leaf node is known to\r\n        // have changed, we can avoid any traversal of its ancestor nodes.\r\n        for (let i = drafts.length - 1; i >= 0; i--) {\r\n            const state: ES5State = drafts[i][DRAFT_STATE];\r\n            if (!state.modified_) {\r\n                switch (state.type_) {\r\n                    case ProxyType.ES5Array:\r\n                        if (hasArrayChanges(state))\r\n                            markChanged(state);\r\n                        break;\r\n                    case ProxyType.ES5Object:\r\n                        if (hasObjectChanges(state))\r\n                            markChanged(state);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \n function markChangesRecursively(object: any) {\r\n        if (!object || typeof object !== \"object\")\r\n            return;\r\n        const state: ES5State | undefined = object[DRAFT_STATE];\r\n        if (!state)\r\n            return;\r\n        const { base_, draft_, assigned_, type_ } = state;\r\n        if (type_ === ProxyType.ES5Object) {\r\n            // Look for added keys.\r\n            // probably there is a faster way to detect changes, as sweep + recurse seems to do some\r\n            // unnecessary work.\r\n            // also: probably we can store the information we detect here, to speed up tree finalization!\r\n            each(draft_, key => {\r\n                if ((key as any) === DRAFT_STATE)\r\n                    return;\r\n                // The `undefined` check is a fast path for pre-existing keys.\r\n                if ((base_ as any)[key] === undefined && !has(base_, key)) {\r\n                    assigned_[key] = true;\r\n                    markChanged(state);\r\n                }\r\n                else if (!assigned_[key]) {\r\n                    // Only untouched properties trigger recursion.\r\n                    markChangesRecursively(draft_[key]);\r\n                }\r\n            });\r\n            // Look for removed keys.\r\n            each(base_, key => {\r\n                // The `undefined` check is a fast path for pre-existing keys.\r\n                if (draft_[key] === undefined && !has(draft_, key)) {\r\n                    assigned_[key] = false;\r\n                    markChanged(state);\r\n                }\r\n            });\r\n        }\r\n        else if (type_ === ProxyType.ES5Array) {\r\n            if (hasArrayChanges(state as ES5ArrayState)) {\r\n                markChanged(state);\r\n                assigned_.length = true;\r\n            }\r\n            \n if (draft_.length < base_.length) {\r\n                for (let i = draft_.length; i < base_.length; i++)\r\n                    assigned_[i] = false;\r\n            }\r\n            else {\r\n                for (let i = base_.length; i < draft_.length; i++)\r\n                    assigned_[i] = true;\r\n            }\r\n            \n // Minimum count is enough, the other parts has been processed.\r\n            const min = Math.min(draft_.length, base_.length);\r\n            \n for (let i = 0; i < min; i++) {\r\n                // Only untouched indices trigger recursion.\r\n                if (!draft_.hasOwnProperty(i)) {\r\n                    assigned_[i] = true;\r\n                }\r\n                if (assigned_[i] === undefined)\r\n                    markChangesRecursively(draft_[i]);\r\n            }\r\n        }\r\n    }\r\n    \n function hasObjectChanges(state: ES5ObjectState) {\r\n        const { base_, draft_ } = state;\r\n        \n // Search for added keys and changed keys. Start at the back, because\r\n        // non-numeric keys are ordered by time of definition on the object.\r\n        const keys = ownKeys(draft_);\r\n        for (let i = keys.length - 1; i >= 0; i--) {\r\n            const key: any = keys[i];\r\n            if (key === DRAFT_STATE)\r\n                continue;\r\n            const baseValue = base_[key];\r\n            // The `undefined` check is a fast path for pre-existing keys.\r\n            if (baseValue === undefined && !has(base_, key)) {\r\n                return true;\r\n            }\r\n            // Once a base key is deleted, future changes go undetected, because its\r\n            // descriptor is erased. This branch detects any missed changes.\r\n            else {\r\n                const value = draft_[key];\r\n                const state: ImmerState = value && value[DRAFT_STATE];\r\n                if (state ? state.base_ !== baseValue : !is(value, baseValue)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        \n // At this point, no keys were added or changed.\r\n        // Compare key count to determine if keys were deleted.\r\n        const baseIsDraft = !!base_[DRAFT_STATE as any];\r\n        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE\r\n    }\r\n    \n function hasArrayChanges(state: ES5ArrayState) {\r\n        const { draft_ } = state;\r\n        if (draft_.length !== state.base_.length)\r\n            return true;\r\n        // See #116\r\n        // If we first shorten the length, our array interceptors will be removed.\r\n        // If after that new items are added, result in the same original length,\r\n        // those last items will have no intercepting property.\r\n        // So if there is no own descriptor on the last position, we know that items were removed and added\r\n        // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\r\n        // the last one\r\n        // last descriptor can be not a trap, if the array was extended\r\n        const descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1);\r\n        // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\r\n        if (descriptor && !descriptor.get)\r\n            return true;\r\n        // if we miss a property, it has been deleted, so array probobaly changed\r\n        for (let i = 0; i < draft_.length; i++) {\r\n            if (!draft_.hasOwnProperty(i))\r\n                return true;\r\n        }\r\n        // For all other cases, we don't have to compare, as they would have been picked up by the index setters\r\n        return false;\r\n    }\r\n    \n function hasChanges_(state: ES5State) {\r\n        return state.type_ === ProxyType.ES5Object\r\n            ? hasObjectChanges(state)\r\n            : hasArrayChanges(state);\r\n    }\r\n    \n function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\r\n        if (state.revoked_)\r\n            die(3, JSON.stringify(latest(state)));\r\n    }\r\n    \n loadPlugin(\"ES5\", {\r\n        createES5Proxy_,\r\n        willFinalizeES5_,\r\n        hasChanges_\r\n    });\r\n}\r\n","// types only!\r\nimport { ImmerState, AnyMap, AnySet, MapState, SetState, DRAFT_STATE, getCurrentScope, latest, iteratorSymbol, isDraftable, createProxy, loadPlugin, markChanged, ProxyType, die, each } from \"../internal.js\";\r\n\n export function enableMapSet() {\r\n    /* istanbul ignore next */\r\n    var extendStatics = function (d: any, b: any): any {\r\n        extendStatics =\r\n            Object.setPrototypeOf ||\r\n                ({ __proto__: [] } instanceof Array &&\r\n                    function (d, b) {\r\n                        d.__proto__ = b;\r\n                    }) ||\r\n                function (d, b) {\r\n                    for (var p in b)\r\n                        if (b.hasOwnProperty(p))\r\n                            d[p] = b[p];\r\n                };\r\n        return extendStatics(d, b);\r\n    };\r\n    \n // Ugly hack to resolve #502 and inherit built in Map / Set\r\n    function __extends(d: any, b: any): any {\r\n        extendStatics(d, b);\r\n        function __(this: any): any {\r\n            Object.defineProperty(this, \"constructor\", {\r\n                value: d\r\n            });\r\n        }\r\n        d.prototype =\r\n            // @ts-ignore\r\n            ((__.prototype = b.prototype), new __());\r\n    }\r\n    \n const DraftMap = (function (_super) {\r\n        __extends(DraftMap, _super);\r\n        // Create class manually, cause #502\r\n        function DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\r\n            this[DRAFT_STATE] = {\r\n                type_: ProxyType.Map,\r\n                parent_: parent,\r\n                scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n                modified_: false,\r\n                finalized_: false,\r\n                copy_: undefined,\r\n                assigned_: undefined,\r\n                base_: target,\r\n                draft_: this as any,\r\n                isManual_: false,\r\n                revoked_: false\r\n            } as MapState;\r\n            return this;\r\n        }\r\n        const p = DraftMap.prototype;\r\n        \n Object.defineProperties(p, {\r\n            size: {\r\n                get: function () {\r\n                    return latest(this[DRAFT_STATE]).size;\r\n                },\r\n                configurable: true\r\n            },\r\n            has: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): boolean {\r\n                    return latest(this[DRAFT_STATE]).has(key);\r\n                }\r\n            },\r\n            set: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any, value: any) {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (!latest(state).has(key) || latest(state).get(key) !== value) {\r\n                        prepareMapCopy(state);\r\n                        markChanged(state);\r\n                        state.assigned_!.set(key, true);\r\n                        state.copy_!.set(key, value);\r\n                        state.assigned_!.set(key, true);\r\n                    }\r\n                    return this;\r\n                }\r\n            },\r\n            delete: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): boolean {\r\n                    if (!this.has(key)) {\r\n                        return false;\r\n                    }\r\n                    \n const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareMapCopy(state);\r\n                    markChanged(state);\r\n                    if (state.base_.has(key)) {\r\n                        state.assigned_!.set(key, false);\r\n                    }\r\n                    else {\r\n                        state.assigned_!.delete(key);\r\n                    }\r\n                    state.copy_!.delete(key);\r\n                    return true;\r\n                }\r\n            },\r\n            clear: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (latest(state).size) {\r\n                        prepareMapCopy(state);\r\n                        markChanged(state);\r\n                        state.assigned_ = new Map();\r\n                        each(state.base_, key => {\r\n                            state.assigned_!.set(key, false);\r\n                        });\r\n                        state.copy_!.clear();\r\n                    }\r\n                }\r\n            },\r\n            forEach: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (cb: (value: any, key: any, self: any) => void, thisArg?: any) {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    latest(state).forEach((_value: any, key: any, _map: any) => {\r\n                        cb.call(thisArg, this.get(key), key, this);\r\n                    });\r\n                }\r\n            },\r\n            get: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (key: any): any {\r\n                    const state: MapState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    const value = latest(state).get(key);\r\n                    if (state.finalized_ || !isDraftable(value)) {\r\n                        return value;\r\n                    }\r\n                    if (value !== state.base_.get(key)) {\r\n                        return value; // either already drafted or reassigned\r\n                    }\r\n                    // despite what it looks, this creates a draft only once, see above condition\r\n                    const draft = createProxy(state.scope_.immer_, value, state);\r\n                    prepareMapCopy(state);\r\n                    state.copy_!.set(key, draft);\r\n                    return draft;\r\n                }\r\n            },\r\n            keys: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    return latest(this[DRAFT_STATE]).keys();\r\n                }\r\n            },\r\n            values: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    const iterator = this.keys();\r\n                    return {\r\n                        [iteratorSymbol]: () => this.values(),\r\n                        next: () => {\r\n                            const r = iterator.next();\r\n                            /* istanbul ignore next */\r\n                            if (r.done)\r\n                                return r;\r\n                            const value = this.get(r.value);\r\n                            return {\r\n                                done: false,\r\n                                value\r\n                            };\r\n                        }\r\n                    } as any;\r\n                }\r\n            },\r\n            entries: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<[\r\n                    any,\r\n                    any\r\n                ]> {\r\n                    const iterator = this.keys();\r\n                    return {\r\n                        [iteratorSymbol]: () => this.entries(),\r\n                        next: () => {\r\n                            const r = iterator.next();\r\n                            /* istanbul ignore next */\r\n                            if (r.done)\r\n                                return r;\r\n                            const value = this.get(r.value);\r\n                            return {\r\n                                done: false,\r\n                                value: [r.value, value]\r\n                            };\r\n                        }\r\n                    } as any;\r\n                }\r\n            },\r\n            [iteratorSymbol]: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    return this.entries();\r\n                }\r\n            }\r\n        });\r\n        \n return DraftMap;\r\n    })(Map);\r\n    \n function proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\r\n        // @ts-ignore\r\n        return new DraftMap(target, parent);\r\n    }\r\n    \n function prepareMapCopy(state: MapState) {\r\n        if (!state.copy_) {\r\n            state.assigned_ = new Map();\r\n            state.copy_ = new Map(state.base_);\r\n        }\r\n    }\r\n    \n const DraftSet = (function (_super) {\r\n        __extends(DraftSet, _super);\r\n        // Create class manually, cause #502\r\n        function DraftSet(this: any, target: AnySet, parent?: ImmerState) {\r\n            this[DRAFT_STATE] = {\r\n                type_: ProxyType.Set,\r\n                parent_: parent,\r\n                scope_: parent ? parent.scope_ : getCurrentScope()!,\r\n                modified_: false,\r\n                finalized_: false,\r\n                copy_: undefined,\r\n                base_: target,\r\n                draft_: this,\r\n                drafts_: new Map(),\r\n                revoked_: false,\r\n                isManual_: false\r\n            } as SetState;\r\n            return this;\r\n        }\r\n        const p = DraftSet.prototype;\r\n        \n Object.defineProperties(p, {\r\n            size: {\r\n                get: function () {\r\n                    return latest(this[DRAFT_STATE]).size;\r\n                },\r\n                configurable: true\r\n            },\r\n            has: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): boolean {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    // bit of trickery here, to be able to recognize both the value, and the draft of its value\r\n                    if (!state.copy_) {\r\n                        return state.base_.has(value);\r\n                    }\r\n                    if (state.copy_.has(value))\r\n                        return true;\r\n                    if (state.drafts_.has(value) &&\r\n                        state.copy_.has(state.drafts_.get(value)))\r\n                        return true;\r\n                    return false;\r\n                }\r\n            },\r\n            add: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): any {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (!this.has(value)) {\r\n                        prepareSetCopy(state);\r\n                        markChanged(state);\r\n                        state.copy_!.add(value);\r\n                    }\r\n                    return this;\r\n                }\r\n            },\r\n            delete: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (value: any): any {\r\n                    if (!this.has(value)) {\r\n                        return false;\r\n                    }\r\n                    \n const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    markChanged(state);\r\n                    return (state.copy_!.delete(value) ||\r\n                        (state.drafts_.has(value)\r\n                            ? state.copy_!.delete(state.drafts_.get(value))\r\n                            : /* istanbul ignore next */ false));\r\n                }\r\n            },\r\n            clear: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    if (latest(state).size) {\r\n                        prepareSetCopy(state);\r\n                        markChanged(state);\r\n                        state.copy_!.clear();\r\n                    }\r\n                }\r\n            },\r\n            values: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    return state.copy_!.values();\r\n                }\r\n            },\r\n            entries: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function entries(): IterableIterator<[\r\n                    any,\r\n                    any\r\n                ]> {\r\n                    const state: SetState = this[DRAFT_STATE];\r\n                    assertUnrevoked(state);\r\n                    prepareSetCopy(state);\r\n                    return state.copy_!.entries();\r\n                }\r\n            },\r\n            keys: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function (): IterableIterator<any> {\r\n                    return this.values();\r\n                }\r\n            },\r\n            [iteratorSymbol]: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function () {\r\n                    return this.values();\r\n                }\r\n            },\r\n            forEach: {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function forEach(cb: any, thisArg?: any) {\r\n                    const iterator = this.values();\r\n                    let result = iterator.next();\r\n                    while (!result.done) {\r\n                        cb.call(thisArg, result.value, result.value, this);\r\n                        result = iterator.next();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        \n return DraftSet;\r\n    })(Set);\r\n    \n function proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\r\n        // @ts-ignore\r\n        return new DraftSet(target, parent);\r\n    }\r\n    \n function prepareSetCopy(state: SetState) {\r\n        if (!state.copy_) {\r\n            // create drafts for all entries to preserve insertion order\r\n            state.copy_ = new Set();\r\n            state.base_.forEach(value => {\r\n                if (isDraftable(value)) {\r\n                    const draft = createProxy(state.scope_.immer_, value, state);\r\n                    state.drafts_.set(value, draft);\r\n                    state.copy_!.add(draft);\r\n                }\r\n                else {\r\n                    state.copy_!.add(value);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    \n function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\r\n        if (state.revoked_)\r\n            die(3, JSON.stringify(latest(state)));\r\n    }\r\n    \n loadPlugin(\"MapSet\", { proxyMap_, proxySet_ });\r\n}\r\n","import { immerable } from \"../immer.js\";\r\nimport { ImmerState, Patch, SetState, ES5ArrayState, ProxyArrayState, MapState, ES5ObjectState, ProxyObjectState, PatchPath, get, each, has, getArchtype, isSet, isMap, loadPlugin, ProxyType, Archtype, die, isDraft, isDraftable, NOTHING } from \"../internal.js\";\r\n\n export function enablePatches() {\r\n    const REPLACE = \"replace\";\r\n    const ADD = \"add\";\r\n    const REMOVE = \"remove\";\r\n    \n function generatePatches_(state: ImmerState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]): void {\r\n        switch (state.type_) {\r\n            case ProxyType.ProxyObject:\r\n            case ProxyType.ES5Object:\r\n            case ProxyType.Map:\r\n                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\r\n            case ProxyType.ES5Array:\r\n            case ProxyType.ProxyArray:\r\n                return generateArrayPatches(state, basePath, patches, inversePatches);\r\n            case ProxyType.Set:\r\n                return generateSetPatches((state as any) as SetState, basePath, patches, inversePatches);\r\n        }\r\n    }\r\n    \n function generateArrayPatches(state: ES5ArrayState | ProxyArrayState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        let { base_, assigned_ } = state;\r\n        let copy_ = state.copy_!;\r\n        \n // Reduce complexity by ensuring `base` is never longer.\r\n        if (copy_.length < base_.length) {\r\n            // @ts-ignore\r\n            ;\r\n            [base_, copy_] = [copy_, base_];\r\n            [patches, inversePatches] = [inversePatches, patches];\r\n        }\r\n        \n // Process replaced indices.\r\n        for (let i = 0; i < base_.length; i++) {\r\n            if (assigned_[i] && copy_[i] !== base_[i]) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: REPLACE,\r\n                    path,\r\n                    // Need to maybe clone it, as it can in fact be the original value\r\n                    // due to the base/copy inversion at the start of this function\r\n                    value: clonePatchValueIfNeeded(copy_[i])\r\n                });\r\n                inversePatches.push({\r\n                    op: REPLACE,\r\n                    path,\r\n                    value: clonePatchValueIfNeeded(base_[i])\r\n                });\r\n            }\r\n        }\r\n        \n // Process added indices.\r\n        for (let i = base_.length; i < copy_.length; i++) {\r\n            const path = basePath.concat([i]);\r\n            patches.push({\r\n                op: ADD,\r\n                path,\r\n                // Need to maybe clone it, as it can in fact be the original value\r\n                // due to the base/copy inversion at the start of this function\r\n                value: clonePatchValueIfNeeded(copy_[i])\r\n            });\r\n        }\r\n        if (base_.length < copy_.length) {\r\n            inversePatches.push({\r\n                op: REPLACE,\r\n                path: basePath.concat([\"length\"]),\r\n                value: base_.length\r\n            });\r\n        }\r\n    }\r\n    \n // This is used for both Map objects and normal objects.\r\n    function generatePatchesFromAssigned(state: MapState | ES5ObjectState | ProxyObjectState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        const { base_, copy_ } = state;\r\n        each(state.assigned_!, (key, assignedValue) => {\r\n            const origValue = get(base_, key);\r\n            const value = get(copy_!, key);\r\n            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\r\n            if (origValue === value && op === REPLACE)\r\n                return;\r\n            const path = basePath.concat(key as any);\r\n            patches.push(op === REMOVE ? { op, path } : { op, path, value });\r\n            inversePatches.push(op === ADD\r\n                ? { op: REMOVE, path }\r\n                : op === REMOVE\r\n                    ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) }\r\n                    : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) });\r\n        });\r\n    }\r\n    \n function generateSetPatches(state: SetState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {\r\n        let { base_, copy_ } = state;\r\n        \n let i = 0;\r\n        base_.forEach((value: any) => {\r\n            if (!copy_!.has(value)) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: REMOVE,\r\n                    path,\r\n                    value\r\n                });\r\n                inversePatches.unshift({\r\n                    op: ADD,\r\n                    path,\r\n                    value\r\n                });\r\n            }\r\n            i++;\r\n        });\r\n        i = 0;\r\n        copy_!.forEach((value: any) => {\r\n            if (!base_.has(value)) {\r\n                const path = basePath.concat([i]);\r\n                patches.push({\r\n                    op: ADD,\r\n                    path,\r\n                    value\r\n                });\r\n                inversePatches.unshift({\r\n                    op: REMOVE,\r\n                    path,\r\n                    value\r\n                });\r\n            }\r\n            i++;\r\n        });\r\n    }\r\n    \n function generateReplacementPatches_(baseValue: any, replacement: any, patches: Patch[], inversePatches: Patch[]): void {\r\n        patches.push({\r\n            op: REPLACE,\r\n            path: [],\r\n            value: replacement === NOTHING ? undefined : replacement\r\n        });\r\n        inversePatches.push({\r\n            op: REPLACE,\r\n            path: [],\r\n            value: baseValue\r\n        });\r\n    }\r\n    \n function applyPatches_<T>(draft: T, patches: Patch[]): T {\r\n        patches.forEach(patch => {\r\n            const { path, op } = patch;\r\n            \n let base: any = draft;\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                const parentType = getArchtype(base);\r\n                const p = \"\" + path[i];\r\n                // See #738, avoid prototype pollution\r\n                if ((parentType === Archtype.Object || parentType === Archtype.Array) &&\r\n                    (p === \"__proto__\" || p === \"constructor\"))\r\n                    die(24);\r\n                if (typeof base === \"function\" && p === \"prototype\")\r\n                    die(24);\r\n                base = get(base, p);\r\n                if (typeof base !== \"object\")\r\n                    die(15, path.join(\"/\"));\r\n            }\r\n            \n const type = getArchtype(base);\r\n            const value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\r\n            const key = path[path.length - 1];\r\n            switch (op) {\r\n                case REPLACE:\r\n                    switch (type) {\r\n                        case Archtype.Map:\r\n                            return base.set(key, value);\r\n                        /* istanbul ignore next */\r\n                        case Archtype.Set:\r\n                            die(16);\r\n                        default:\r\n                            // if value is an object, then it's assigned by reference\r\n                            // in the following add or remove ops, the value field inside the patch will also be modifyed\r\n                            // so we use value from the cloned patch\r\n                            // @ts-ignore\r\n                            return (base[key] = value);\r\n                    }\r\n                case ADD:\r\n                    switch (type) {\r\n                        case Archtype.Array:\r\n                            return key === \"-\"\r\n                                ? base.push(value)\r\n                                : base.splice(key as any, 0, value);\r\n                        case Archtype.Map:\r\n                            return base.set(key, value);\r\n                        case Archtype.Set:\r\n                            return base.add(value);\r\n                        default:\r\n                            return (base[key] = value);\r\n                    }\r\n                case REMOVE:\r\n                    switch (type) {\r\n                        case Archtype.Array:\r\n                            return base.splice(key as any, 1);\r\n                        case Archtype.Map:\r\n                            return base.delete(key);\r\n                        case Archtype.Set:\r\n                            return base.delete(patch.value);\r\n                        default:\r\n                            return delete base[key];\r\n                    }\r\n                default:\r\n                    die(17, op);\r\n            }\r\n        });\r\n        \n return draft;\r\n    }\r\n    \n // optimize: this is quite a performance hit, can we detect intelligently when it is needed?\r\n    // E.g. auto-draft when new objects from outside are assigned and modified?\r\n    // (See failing test when deepClone just returns obj)\r\n    function deepClonePatchValue<T>(obj: T): T;\r\n    function deepClonePatchValue(obj: any) {\r\n        if (!isDraftable(obj))\r\n            return obj;\r\n        if (Array.isArray(obj))\r\n            return obj.map(deepClonePatchValue);\r\n        if (isMap(obj))\r\n            return new Map(Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)]));\r\n        if (isSet(obj))\r\n            return new Set(Array.from(obj).map(deepClonePatchValue));\r\n        const cloned = Object.create(Object.getPrototypeOf(obj));\r\n        for (const key in obj)\r\n            cloned[key] = deepClonePatchValue(obj[key]);\r\n        if (has(obj, immerable))\r\n            cloned[immerable] = obj[immerable];\r\n        return cloned;\r\n    }\r\n    \n function clonePatchValueIfNeeded<T>(obj: T): T {\r\n        if (isDraft(obj)) {\r\n            return deepClonePatchValue(obj);\r\n        }\r\n        else\r\n            return obj;\r\n    }\r\n    \n loadPlugin(\"Patches\", {\r\n        applyPatches_,\r\n        generatePatches_,\r\n        generateReplacementPatches_\r\n    });\r\n}\r\n","import { IProduce, IProduceWithPatches, Immer, Draft, Immutable } from \"./internal.js\";\r\n\n export { Draft, Immutable, Patch, PatchListener, original, current, isDraft, isDraftable, NOTHING as nothing, DRAFTABLE as immerable, freeze } from \"./internal.js\";\r\n\n const immer = new Immer();\r\n\n /**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */\r\nexport const produce: IProduce = immer.produce;\r\nexport default produce;\r\n\n /**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */\r\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(immer);\r\n\n /**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * Always freeze by default, even in production mode\r\n */\r\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer);\r\n\n /**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */\r\nexport const setUseProxies = immer.setUseProxies.bind(immer);\r\n\n /**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */\r\nexport const applyPatches = immer.applyPatches.bind(immer);\r\n\n /**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */\r\nexport const createDraft = immer.createDraft.bind(immer);\r\n\n /**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */\r\nexport const finishDraft = immer.finishDraft.bind(immer);\r\n\n /**\r\n * This function is actually a no-op, but can be used to cast an immutable type\r\n * to an draft type and make TypeScript happy\r\n *\r\n * @param value\r\n */\r\nexport function castDraft<T>(value: T): Draft<T> {\r\n    return value as any;\r\n}\r\n\n /**\r\n * This function is actually a no-op, but can be used to cast a mutable type\r\n * to an immutable type and make TypeScript happy\r\n * @param value\r\n */\r\nexport function castImmutable<T>(value: T): Immutable<T> {\r\n    return value as any;\r\n}\r\n\n export { Immer };\r\n\n export { enableES5 } from \"./plugins/es5.js\";\r\nexport { enablePatches } from \"./plugins/patches.js\";\r\nexport { enableMapSet } from \"./plugins/mapset.js\";\r\nexport { enableAllPlugins } from \"./plugins/all.js\";\r\n","import { enableES5 } from \"./es5.js\";\r\nimport { enableMapSet } from \"./mapset.js\";\r\nimport { enablePatches } from \"./patches.js\";\r\n\n export function enableAllPlugins() {\r\n    enableES5();\r\n    enableMapSet();\r\n    enablePatches();\r\n}\r\n"],"names":["hasSymbol","Symbol","hasMap","Map","hasSet","Set","hasProxies","Proxy","revocable","Reflect","NOTHING","for","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","die","error","args","Error","length","map","s","join","isDraft","value","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","toString","objectCtorString","isPlainObject","Array","isArray","_value$constructor","isMap","isSet","prototype","ownKeys","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","getOwnPropertyDescriptors","target","res","forEach","key","getOwnPropertyDescriptor","each","iter","enumerableOnly","getArchtype","keys","entry","index","thing","state","type_","has","prop","get","set","propOrOldValue","t","delete","add","is","x","y","latest","copy_","base_","shallowCopy","base","slice","descriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","dontMutateFrozenCollections","defineProperties","clear","currentScope","plugins","getPlugin","pluginKey","plugin","loadPlugin","implementation","getCurrentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","undefined","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","autoFreeze_","objectTraps","source","getDescriptorFromProto","_desc$get","readPropFromProto","peek","prepareCopy","createProxy","current","currentState","markChanged","Number","isNaN","deleteProperty","owner","defineProperty","setPrototypeOf","arrayTraps","fn","arguments","apply","this","Immer","config","recipe","defaultBase","self","_this","produce","_this2","proxy","hasError","Promise","then","p","ip","produceWithPatches","patches","inversePatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","isManual_","finishDraft","applyPatches","patch","op","applyPatchesImpl","applyPatches_","parent","proxyMap_","proxySet_","traps","revoke","createProxyProxy","createES5Proxy_","push","currentImpl","copy","archType","hasChanges_","copyHelper","from","enableES5","proxyProperty","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","createES5Draft","markChangesRecursively","object","min","Math","enableMapSet","extendStatics","d","b","__proto__","__extends","__","DraftMap","_super","size","assertUnrevoked","prepareMapCopy","cb","thisArg","_value","_map","values","next","r","done","entries","_this3","DraftSet","prepareSetCopy","JSON","stringify","enablePatches","ADD","deepClonePatchValue","cloned","immerable","clonePatchValueIfNeeded","parentType","type","splice","basePath","assignedValue","origValue","generatePatchesFromAssigned","generateArrayPatches","unshift","generateSetPatches","replacement","bind"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/internal.d.ts b/dist/internal.d.ts
index fb2a91a0b68282504ba4b060b751b531f0f32d32..6b651abb437eb9afb08cbbf4fd645b2dbd307009 100644
--- a/dist/internal.d.ts
+++ b/dist/internal.d.ts
@@ -1,12 +1,12 @@
-export * from "./utils/env";
-export * from "./utils/errors";
-export * from "./types/types-external";
-export * from "./types/types-internal";
-export * from "./utils/common";
-export * from "./utils/plugins";
-export * from "./core/scope";
-export * from "./core/finalize";
-export * from "./core/proxy";
-export * from "./core/immerClass";
-export * from "./core/current";
+export * from "./utils/env.js";
+export * from "./utils/errors.js";
+export * from "./types/types-external.js";
+export * from "./types/types-internal.js";
+export * from "./utils/common.js";
+export * from "./utils/plugins.js";
+export * from "./core/scope.js";
+export * from "./core/finalize.js";
+export * from "./core/proxy.js";
+export * from "./core/immerClass.js";
+export * from "./core/current.js";
 //# sourceMappingURL=internal.d.ts.map
\ No newline at end of file
diff --git a/dist/internal.d.ts.map b/dist/internal.d.ts.map
index 612e424e184f6d1aa65b06c9ce926678da0dc664..b0cb9fec27c30ec05151c31c9c439bfd6d4ea98c 100644
--- a/dist/internal.d.ts.map
+++ b/dist/internal.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"internal.d.ts","sourceRoot":"","sources":["src/internal.ts"],"names":[],"mappings":"AAAA,cAAc,aAAa,CAAA;AAC3B,cAAc,gBAAgB,CAAA;AAC9B,cAAc,wBAAwB,CAAA;AACtC,cAAc,wBAAwB,CAAA;AACtC,cAAc,gBAAgB,CAAA;AAC9B,cAAc,iBAAiB,CAAA;AAC/B,cAAc,cAAc,CAAA;AAC5B,cAAc,iBAAiB,CAAA;AAC/B,cAAc,cAAc,CAAA;AAC5B,cAAc,mBAAmB,CAAA;AACjC,cAAc,gBAAgB,CAAA"}
\ No newline at end of file
+{"version":3,"file":"internal.d.ts","sourceRoot":"","sources":["src/internal.ts"],"names":[],"mappings":"AAAA,cAAc,gBAAgB,CAAC;AAC/B,cAAc,mBAAmB,CAAC;AAClC,cAAc,2BAA2B,CAAC;AAC1C,cAAc,2BAA2B,CAAC;AAC1C,cAAc,mBAAmB,CAAC;AAClC,cAAc,oBAAoB,CAAC;AACnC,cAAc,iBAAiB,CAAC;AAChC,cAAc,oBAAoB,CAAC;AACnC,cAAc,iBAAiB,CAAC;AAChC,cAAc,sBAAsB,CAAC;AACrC,cAAc,mBAAmB,CAAC"}
\ No newline at end of file
diff --git a/dist/plugins/all.d.ts.map b/dist/plugins/all.d.ts.map
index a03c9a9886d9d94573529085488a8f3101d1df03..5a96b7ecdc0ada889c0a99f1fbd0e3783739ae50 100644
--- a/dist/plugins/all.d.ts.map
+++ b/dist/plugins/all.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"all.d.ts","sourceRoot":"","sources":["../src/plugins/all.ts"],"names":[],"mappings":"AAIA,wBAAgB,gBAAgB,SAI/B"}
\ No newline at end of file
+{"version":3,"file":"all.d.ts","sourceRoot":"","sources":["../src/plugins/all.ts"],"names":[],"mappings":"AAIC,wBAAgB,gBAAgB,SAIhC"}
\ No newline at end of file
diff --git a/dist/plugins/es5.d.ts.map b/dist/plugins/es5.d.ts.map
index 9063c67dd0227a7b23313e8daac6fc4d0f5bdf57..209dfade5d10fcce99f6025da4ea96b63126e259 100644
--- a/dist/plugins/es5.d.ts.map
+++ b/dist/plugins/es5.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"es5.d.ts","sourceRoot":"","sources":["../src/plugins/es5.ts"],"names":[],"mappings":"AAwBA,wBAAgB,SAAS,SA4PxB"}
\ No newline at end of file
+{"version":3,"file":"es5.d.ts","sourceRoot":"","sources":["../src/plugins/es5.ts"],"names":[],"mappings":"AAIC,wBAAgB,SAAS,SAgQzB"}
\ No newline at end of file
diff --git a/dist/plugins/mapset.d.ts.map b/dist/plugins/mapset.d.ts.map
index 6e88bba075cff0f8c659e0a85b1d076e916f2b58..4f7c764e8fc183e1c706025c0e6ca3de67b2a5f6 100644
--- a/dist/plugins/mapset.d.ts.map
+++ b/dist/plugins/mapset.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"mapset.d.ts","sourceRoot":"","sources":["../src/plugins/mapset.ts"],"names":[],"mappings":"AAoBA,wBAAgB,YAAY,SAuU3B"}
\ No newline at end of file
+{"version":3,"file":"mapset.d.ts","sourceRoot":"","sources":["../src/plugins/mapset.ts"],"names":[],"mappings":"AAGC,wBAAgB,YAAY,SA+Y5B"}
\ No newline at end of file
diff --git a/dist/plugins/patches.d.ts.map b/dist/plugins/patches.d.ts.map
index 53a1e0080305c6f92d2d606fefbd33d2bca6909b..9b6864ae4db725a35838fe6a4662a33eccd9e113 100644
--- a/dist/plugins/patches.d.ts.map
+++ b/dist/plugins/patches.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"patches.d.ts","sourceRoot":"","sources":["../src/plugins/patches.ts"],"names":[],"mappings":"AA0BA,wBAAgB,aAAa,SAkR5B"}
\ No newline at end of file
+{"version":3,"file":"patches.d.ts","sourceRoot":"","sources":["../src/plugins/patches.ts"],"names":[],"mappings":"AAGC,wBAAgB,aAAa,SAoP7B"}
\ No newline at end of file
diff --git a/dist/types/types-external.d.ts b/dist/types/types-external.d.ts
index a59d7a12ea9fe496053828f58d0fef6fafbc8a1d..1b36f54926d7ef63ece032a539792e9f2e1a5810 100644
--- a/dist/types/types-external.d.ts
+++ b/dist/types/types-external.d.ts
@@ -1,20 +1,20 @@
-import { Nothing } from "../internal";
+import { Nothing } from "../internal.js";
 declare type AnyFunc = (...args: any[]) => any;
 declare type PrimitiveType = number | string | boolean;
 /** Object types that should never be mapped */
 declare type AtomicObject = Function | Promise<any> | Date | RegExp;
 /**
- * If the lib "ES2015.Collection" is not included in tsconfig.json,
- * types like ReadonlyArray, WeakMap etc. fall back to `any` (specified nowhere)
- * or `{}` (from the node types), in both cases entering an infinite recursion in
- * pattern matching type mappings
- * This type can be used to cast these types to `void` in these cases.
- */
+* If the lib "ES2015.Collection" is not included in tsconfig.json,
+* types like ReadonlyArray, WeakMap etc. fall back to `any` (specified nowhere)
+* or `{}` (from the node types), in both cases entering an infinite recursion in
+* pattern matching type mappings
+* This type can be used to cast these types to `void` in these cases.
+*/
 export declare type IfAvailable<T, Fallback = void> = true | false extends (T extends never ? true : false) ? Fallback : keyof T extends never ? Fallback : T;
 /**
- * These should also never be mapped but must be tested after regular Map and
- * Set
- */
+* These should also never be mapped but must be tested after regular Map and
+* Set
+*/
 declare type WeakReferences = IfAvailable<WeakMap<any, any>> | IfAvailable<WeakSet<any>>;
 export declare type WritableDraft<T> = {
     -readonly [K in keyof T]: Draft<T[K]>;
@@ -36,38 +36,38 @@ declare type FromNothing<T> = T extends Nothing ? undefined : T;
 /** The inferred return type of `produce` */
 export declare type Produced<Base, Return> = Return extends void ? Base : Return extends Promise<infer Result> ? Promise<Result extends void ? Base : FromNothing<Result>> : FromNothing<Return>;
 /**
- * Utility types
- */
+* Utility types
+*/
 declare type PatchesTuple<T> = readonly [T, Patch[], Patch[]];
 declare type ValidRecipeReturnType<State> = State | void | undefined | (State extends undefined ? Nothing : never);
 declare type ValidRecipeReturnTypePossiblyPromise<State> = ValidRecipeReturnType<State> | Promise<ValidRecipeReturnType<State>>;
 declare type PromisifyReturnIfNeeded<State, Recipe extends AnyFunc, UsePatches extends boolean> = ReturnType<Recipe> extends Promise<any> ? Promise<UsePatches extends true ? PatchesTuple<State> : State> : UsePatches extends true ? PatchesTuple<State> : State;
 /**
- * Core Producer inference
- */
+* Core Producer inference
+*/
 declare type InferRecipeFromCurried<Curried> = Curried extends (base: infer State, ...rest: infer Args) => any ? ReturnType<Curried> extends State ? (draft: Draft<State>, ...rest: Args) => ValidRecipeReturnType<Draft<State>> : never : never;
 declare type InferInitialStateFromCurried<Curried> = Curried extends (base: infer State, ...rest: any[]) => any ? State : never;
 declare type InferCurriedFromRecipe<Recipe, UsePatches extends boolean> = Recipe extends (draft: infer DraftState, ...args: infer RestArgs) => any ? ReturnType<Recipe> extends ValidRecipeReturnTypePossiblyPromise<DraftState> ? (base: Immutable<DraftState>, ...args: RestArgs) => PromisifyReturnIfNeeded<DraftState, Recipe, UsePatches> : never : never;
 declare type InferCurriedFromInitialStateAndRecipe<State, Recipe, UsePatches extends boolean> = Recipe extends (draft: Draft<State>, ...rest: infer RestArgs) => ValidRecipeReturnTypePossiblyPromise<State> ? (base?: State | undefined, ...args: RestArgs) => PromisifyReturnIfNeeded<State, Recipe, UsePatches> : never;
 /**
- * The `produce` function takes a value and a "recipe function" (whose
- * return value often depends on the base state). The recipe function is
- * free to mutate its first argument however it wants. All mutations are
- * only ever applied to a __copy__ of the base state.
- *
- * Pass only a function to create a "curried producer" which relieves you
- * from passing the recipe function every time.
- *
- * Only plain objects and arrays are made mutable. All other objects are
- * considered uncopyable.
- *
- * Note: This function is __bound__ to its `Immer` instance.
- *
- * @param {any} base - the initial state
- * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
- * @param {Function} patchListener - optional function that will be called with all the patches produced here
- * @returns {any} a new state, or the initial state if nothing was modified
- */
+* The `produce` function takes a value and a "recipe function" (whose
+* return value often depends on the base state). The recipe function is
+* free to mutate its first argument however it wants. All mutations are
+* only ever applied to a __copy__ of the base state.
+*
+* Pass only a function to create a "curried producer" which relieves you
+* from passing the recipe function every time.
+*
+* Only plain objects and arrays are made mutable. All other objects are
+* considered uncopyable.
+*
+* Note: This function is __bound__ to its `Immer` instance.
+*
+* @param {any} base - the initial state
+* @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+* @param {Function} patchListener - optional function that will be called with all the patches produced here
+* @returns {any} a new state, or the initial state if nothing was modified
+*/
 export interface IProduce {
     /** Curried producer that infers the recipe from the curried output function (e.g. when passing to setState) */
     <Curried>(recipe: InferRecipeFromCurried<Curried>, initialState?: InferInitialStateFromCurried<Curried>): Curried;
@@ -87,11 +87,11 @@ export interface IProduce {
     <Base, D = Draft<Base>>(base: Base, recipe: (draft: D) => Promise<ValidRecipeReturnType<D>>, listener?: PatchListener): Promise<Base>;
 }
 /**
- * Like `produce`, but instead of just returning the new state,
- * a tuple is returned with [nextState, patches, inversePatches]
- *
- * Like produce, this function supports currying
- */
+* Like `produce`, but instead of just returning the new state,
+* a tuple is returned with [nextState, patches, inversePatches]
+*
+* Like produce, this function supports currying
+*/
 export interface IProduceWithPatches {
     <Recipe extends AnyFunc>(recipe: Recipe): InferCurriedFromRecipe<Recipe, true>;
     <State, Recipe extends Function>(recipe: Recipe, initialState: State): InferCurriedFromInitialStateAndRecipe<State, Recipe, true>;
diff --git a/dist/types/types-external.d.ts.map b/dist/types/types-external.d.ts.map
index 9b22e4b21f0389ddf1b3518605151f4642ce20e3..e914e3e656d436c7875bacbdd4c4729cdd67da77 100644
--- a/dist/types/types-external.d.ts.map
+++ b/dist/types/types-external.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"types-external.d.ts","sourceRoot":"","sources":["../src/types/types-external.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"types-external.d.ts","sourceRoot":"","sources":["../src/types/types-external.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/types/types-internal.d.ts b/dist/types/types-internal.d.ts
index 30c41c0cd8a982c86130a567da143135b212879d..be4bfbfa580a65d479fa04ef94b79dd50777e4b3 100644
--- a/dist/types/types-internal.d.ts
+++ b/dist/types/types-internal.d.ts
@@ -1,4 +1,4 @@
-import { SetState, ImmerScope, ProxyObjectState, ProxyArrayState, ES5ObjectState, ES5ArrayState, MapState, DRAFT_STATE } from "../internal";
+import { SetState, ImmerScope, ProxyObjectState, ProxyArrayState, ES5ObjectState, ES5ArrayState, MapState, DRAFT_STATE } from "../internal.js";
 export declare type Objectish = AnyObject | AnyArray | AnyMap | AnySet;
 export declare type ObjectishNoSet = AnyObject | AnyArray | AnyMap;
 export declare type AnyObject = {
diff --git a/dist/types/types-internal.d.ts.map b/dist/types/types-internal.d.ts.map
index 7e1a70babbeb20c0e52d1769d7b63567138591f9..d82898d7c0a6f89dbbd29fcaa1c01ed00882c212 100644
--- a/dist/types/types-internal.d.ts.map
+++ b/dist/types/types-internal.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"types-internal.d.ts","sourceRoot":"","sources":["../src/types/types-internal.ts"],"names":[],"mappings":"AAAA,OAAO,EACN,QAAQ,EACR,UAAU,EACV,gBAAgB,EAChB,eAAe,EACf,cAAc,EACd,aAAa,EACb,QAAQ,EACR,WAAW,EACX,MAAM,aAAa,CAAA;AAEpB,oBAAY,SAAS,GAAG,SAAS,GAAG,QAAQ,GAAG,MAAM,GAAG,MAAM,CAAA;AAC9D,oBAAY,cAAc,GAAG,SAAS,GAAG,QAAQ,GAAG,MAAM,CAAA;AAE1D,oBAAY,SAAS,GAAG;IAAC,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAC,CAAA;AAC5C,oBAAY,QAAQ,GAAG,KAAK,CAAC,GAAG,CAAC,CAAA;AACjC,oBAAY,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC,CAAA;AAC7B,oBAAY,MAAM,GAAG,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAA;AAElC,0BAAkB,QAAQ;IACzB,MAAM,IAAA;IACN,KAAK,IAAA;IACL,GAAG,IAAA;IACH,GAAG,IAAA;CACH;AAED,0BAAkB,SAAS;IAC1B,WAAW,IAAA;IACX,UAAU,IAAA;IACV,GAAG,IAAA;IACH,GAAG,IAAA;IACH,SAAS,IAAA;IACT,QAAQ,IAAA;CACR;AAED,MAAM,WAAW,cAAc;IAC9B,OAAO,CAAC,EAAE,UAAU,CAAA;IACpB,MAAM,EAAE,UAAU,CAAA;IAClB,SAAS,EAAE,OAAO,CAAA;IAClB,UAAU,EAAE,OAAO,CAAA;IACnB,SAAS,EAAE,OAAO,CAAA;CAClB;AAED,oBAAY,UAAU,GACnB,gBAAgB,GAChB,eAAe,GACf,cAAc,GACd,aAAa,GACb,QAAQ,GACR,QAAQ,CAAA;AAGX,oBAAY,OAAO,CAAC,IAAI,GAAG,GAAG,EAAE,CAAC,SAAS,UAAU,GAAG,UAAU,IAAI;IACpE,CAAC,WAAW,CAAC,EAAE,CAAC,CAAA;CAChB,GAAG,IAAI,CAAA"}
\ No newline at end of file
+{"version":3,"file":"types-internal.d.ts","sourceRoot":"","sources":["../src/types/types-internal.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,gBAAgB,EAAE,eAAe,EAAE,cAAc,EAAE,aAAa,EAAE,QAAQ,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;AAE9I,oBAAY,SAAS,GAAG,SAAS,GAAG,QAAQ,GAAG,MAAM,GAAG,MAAM,CAAC;AAChE,oBAAY,cAAc,GAAG,SAAS,GAAG,QAAQ,GAAG,MAAM,CAAC;AAE1D,oBAAY,SAAS,GAAG;IACrB,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACtB,CAAC;AACF,oBAAY,QAAQ,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;AAClC,oBAAY,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;AAC9B,oBAAY,MAAM,GAAG,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AAElC,0BAAkB,QAAQ;IACvB,MAAM,IAAA;IACN,KAAK,IAAA;IACL,GAAG,IAAA;IACH,GAAG,IAAA;CACN;AAEA,0BAAkB,SAAS;IACxB,WAAW,IAAA;IACX,UAAU,IAAA;IACV,GAAG,IAAA;IACH,GAAG,IAAA;IACH,SAAS,IAAA;IACT,QAAQ,IAAA;CACX;AAEA,MAAM,WAAW,cAAc;IAC5B,OAAO,CAAC,EAAE,UAAU,CAAC;IACrB,MAAM,EAAE,UAAU,CAAC;IACnB,SAAS,EAAE,OAAO,CAAC;IACnB,UAAU,EAAE,OAAO,CAAC;IACpB,SAAS,EAAE,OAAO,CAAC;CACtB;AAEA,oBAAY,UAAU,GAAG,gBAAgB,GAAG,eAAe,GAAG,cAAc,GAAG,aAAa,GAAG,QAAQ,GAAG,QAAQ,CAAC;AAGpH,oBAAY,OAAO,CAAC,IAAI,GAAG,GAAG,EAAE,CAAC,SAAS,UAAU,GAAG,UAAU,IAAI;IACjE,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;CACpB,GAAG,IAAI,CAAC"}
\ No newline at end of file
diff --git a/dist/utils/common.d.ts b/dist/utils/common.d.ts
index 8d69a41b3b2aba0c957f668b00f0457a79a727f9..f992e930401adf77d29b7549590e9f9c52efec9a 100644
--- a/dist/utils/common.d.ts
+++ b/dist/utils/common.d.ts
@@ -1,4 +1,4 @@
-import { Objectish, AnyObject, AnyMap, AnySet, ImmerState, Archtype } from "../internal";
+import { Objectish, AnyObject, AnyMap, AnySet, ImmerState, Archtype } from "../internal.js";
 /** Returns true if the given value is an Immer draft */
 export declare function isDraft(value: any): boolean;
 /** Returns true if the given value can be drafted by Immer */
@@ -21,12 +21,12 @@ export declare function isSet(target: any): target is AnySet;
 export declare function latest(state: ImmerState): any;
 export declare function shallowCopy(base: any): any;
 /**
- * Freezes draftable objects. Returns the original object.
- * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.
- *
- * @param obj
- * @param deep
- */
+* Freezes draftable objects. Returns the original object.
+* By default freezes shallowly, but if the second argument is `true` it will freeze recursively.
+*
+* @param obj
+* @param deep
+*/
 export declare function freeze<T>(obj: T, deep?: boolean): T;
 export declare function isFrozen(obj: any): boolean;
 //# sourceMappingURL=common.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/common.d.ts.map b/dist/utils/common.d.ts.map
index 88c931a2de8854a777a726038f0ac8d81034a2a6..6b1cf6578cfde262c223bf8d2bd6660427c245d0 100644
--- a/dist/utils/common.d.ts.map
+++ b/dist/utils/common.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"common.d.ts","sourceRoot":"","sources":["../src/utils/common.ts"],"names":[],"mappings":"AAAA,OAAO,EAIN,SAAS,EAET,SAAS,EACT,MAAM,EACN,MAAM,EACN,UAAU,EAEV,QAAQ,EAER,MAAM,aAAa,CAAA;AAEpB,wDAAwD;AAExD,wBAAgB,OAAO,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAE3C;AAED,8DAA8D;AAE9D,wBAAgB,WAAW,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAU/C;AAID,wBAAgB,aAAa,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAejD;AAED,uEAAuE;AAEvE,wBAAgB,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,CAAC,GAAG,SAAS,CAAA;AAOpD,eAAO,MAAM,OAAO,EAAE,CAAC,MAAM,EAAE,SAAS,KAAK,WAAW,EAQC,CAAA;AAEzD,eAAO,MAAM,yBAAyB;;CASpC,CAAA;AAEF,wBAAgB,IAAI,CAAC,CAAC,SAAS,SAAS,EACvC,GAAG,EAAE,CAAC,EACN,IAAI,EAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,CAAC,KAAK,IAAI,EAC3D,cAAc,CAAC,EAAE,OAAO,GACtB,IAAI,CAAA;AAYP,wBAAgB,WAAW,CAAC,KAAK,EAAE,GAAG,GAAG,QAAQ,CAchD;AAGD,wBAAgB,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,WAAW,GAAG,OAAO,CAI1D;AAGD,wBAAgB,GAAG,CAAC,KAAK,EAAE,MAAM,GAAG,SAAS,EAAE,IAAI,EAAE,WAAW,GAAG,GAAG,CAGrE;AAGD,wBAAgB,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,cAAc,EAAE,WAAW,EAAE,KAAK,EAAE,GAAG,QAOtE;AAGD,wBAAgB,EAAE,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,GAAG,OAAO,CAO1C;AAGD,wBAAgB,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,MAAM,IAAI,MAAM,CAEnD;AAGD,wBAAgB,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,MAAM,IAAI,MAAM,CAEnD;AAED,wBAAgB,MAAM,CAAC,KAAK,EAAE,UAAU,GAAG,GAAG,CAE7C;AAGD,wBAAgB,WAAW,CAAC,IAAI,EAAE,GAAG,OAwBpC;AAED;;;;;;GAMG;AACH,wBAAgB,MAAM,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE,OAAO,GAAG,CAAC,CAAA;AAepD,wBAAgB,QAAQ,CAAC,GAAG,EAAE,GAAG,GAAG,OAAO,CAI1C"}
\ No newline at end of file
+{"version":3,"file":"common.d.ts","sourceRoot":"","sources":["../src/utils/common.ts"],"names":[],"mappings":"AAAA,OAAO,EAAkC,SAAS,EAAW,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU,EAAU,QAAQ,EAAO,MAAM,gBAAgB,CAAC;AAEjJ,wDAAwD;AAEzD,wBAAgB,OAAO,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAE3C;AAEA,8DAA8D;AAE/D,wBAAgB,WAAW,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAS/C;AAID,wBAAgB,aAAa,CAAC,KAAK,EAAE,GAAG,GAAG,OAAO,CAcjD;AAEA,uEAAuE;AAExE,wBAAgB,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC;AAQrD,eAAO,MAAM,OAAO,EAAE,CAAC,MAAM,EAAE,SAAS,KAAK,WAAW,EAIO,CAAC;AAE/D,eAAO,MAAM,yBAAyB;;CAQlC,CAAC;AAEL,wBAAgB,IAAI,CAAC,CAAC,SAAS,SAAS,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,CAAC,KAAK,IAAI,EAAE,cAAc,CAAC,EAAE,OAAO,GAAG,IAAI,CAAC;AAehJ,wBAAgB,WAAW,CAAC,KAAK,EAAE,GAAG,GAAG,QAAQ,CAchD;AAGD,wBAAgB,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,WAAW,GAAG,OAAO,CAI1D;AAGD,wBAAgB,GAAG,CAAC,KAAK,EAAE,MAAM,GAAG,SAAS,EAAE,IAAI,EAAE,WAAW,GAAG,GAAG,CAGrE;AAGD,wBAAgB,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,cAAc,EAAE,WAAW,EAAE,KAAK,EAAE,GAAG,QAUtE;AAGD,wBAAgB,EAAE,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,GAAG,OAAO,CAQ1C;AAGD,wBAAgB,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,MAAM,IAAI,MAAM,CAEnD;AAGD,wBAAgB,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,MAAM,IAAI,MAAM,CAEnD;AAED,wBAAgB,MAAM,CAAC,KAAK,EAAE,UAAU,GAAG,GAAG,CAE7C;AAGD,wBAAgB,WAAW,CAAC,IAAI,EAAE,GAAG,OAyBpC;AAEA;;;;;;EAME;AACH,wBAAgB,MAAM,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE,OAAO,GAAG,CAAC,CAAC;AA2BpD,wBAAgB,QAAQ,CAAC,GAAG,EAAE,GAAG,GAAG,OAAO,CAK3C"}
\ No newline at end of file
diff --git a/dist/utils/plugins.d.ts b/dist/utils/plugins.d.ts
index 63a2e1bd4fd410d39859299e2e8f6adc5328cfbd..23c4634ac930911fabdd5a5502cc6e07d4fe729a 100644
--- a/dist/utils/plugins.d.ts
+++ b/dist/utils/plugins.d.ts
@@ -1,4 +1,4 @@
-import { ImmerState, Patch, ImmerScope, Drafted, AnyObject, ImmerBaseState, AnyMap, AnySet, ProxyType } from "../internal";
+import { ImmerState, Patch, ImmerScope, Drafted, AnyObject, ImmerBaseState, AnyMap, AnySet, ProxyType } from "../internal.js";
 /** Plugin utilities */
 declare const plugins: {
     Patches?: {
diff --git a/dist/utils/plugins.d.ts.map b/dist/utils/plugins.d.ts.map
index 3eb85a0551b9a97af18f0b213c0062f58941bed6..3f84826c1286f5b6531357dce4bb3a3c25336c23 100644
--- a/dist/utils/plugins.d.ts.map
+++ b/dist/utils/plugins.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"plugins.d.ts","sourceRoot":"","sources":["../src/utils/plugins.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"plugins.d.ts","sourceRoot":"","sources":["../src/utils/plugins.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package.json b/package.json
index e5c13862e921cb75502191ca1fc284339f3c1a1d..02df06ead38deaa380e3994767020ad5fd2c63f3 100644
--- a/package.json
+++ b/package.json
@@ -2,16 +2,8 @@
   "name": "immer",
   "version": "9.0.16",
   "description": "Create your next immutable state by mutating the current one",
-  "main": "dist/index.js",
-  "module": "dist/immer.esm.js",
-  "exports": {
-    ".": {
-      "import": "./dist/immer.esm.mjs",
-      "require": "./dist/index.js",
-      "types": "./dist/immer.d.ts"
-    },
-    "./*": "./*"
-  },
+  "main": "dist/immer.esm.js",
+  "type": "module",
   "umd:main": "dist/immer.umd.production.min.js",
   "unpkg": "dist/immer.umd.production.min.js",
   "jsdelivr": "dist/immer.umd.production.min.js",
diff --git a/src/core/current.ts b/src/core/current.ts
index 3a20198868d48b6d59144501bd79623476feeb26..caf4d95046625f73e4f13fca77bd84cb6fa033e9 100644
--- a/src/core/current.ts
+++ b/src/core/current.ts
@@ -1,60 +1,49 @@
-import {
-	die,
-	isDraft,
-	shallowCopy,
-	each,
-	DRAFT_STATE,
-	get,
-	set,
-	ImmerState,
-	isDraftable,
-	Archtype,
-	getArchtype,
-	getPlugin
-} from "../internal"
+import { die, isDraft, shallowCopy, each, DRAFT_STATE, get, set, ImmerState, isDraftable, Archtype, getArchtype, getPlugin } from "../internal.js";
 
-/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */
-export function current<T>(value: T): T
+ /** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */
+export function current<T>(value: T): T;
 export function current(value: any): any {
-	if (!isDraft(value)) die(22, value)
-	return currentImpl(value)
+    if (!isDraft(value))
+        die(22, value);
+    return currentImpl(value);
 }
 
-function currentImpl(value: any): any {
-	if (!isDraftable(value)) return value
-	const state: ImmerState | undefined = value[DRAFT_STATE]
-	let copy: any
-	const archType = getArchtype(value)
-	if (state) {
-		if (
-			!state.modified_ &&
-			(state.type_ < 4 || !getPlugin("ES5").hasChanges_(state as any))
-		)
-			return state.base_
-		// Optimization: avoid generating new drafts during copying
-		state.finalized_ = true
-		copy = copyHelper(value, archType)
-		state.finalized_ = false
-	} else {
-		copy = copyHelper(value, archType)
-	}
-
-	each(copy, (key, childValue) => {
-		if (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change
-		set(copy, key, currentImpl(childValue))
-	})
-	// In the future, we might consider freezing here, based on the current settings
-	return archType === Archtype.Set ? new Set(copy) : copy
+ function currentImpl(value: any): any {
+    if (!isDraftable(value))
+        return value;
+    const state: ImmerState | undefined = value[DRAFT_STATE];
+    let copy: any;
+    const archType = getArchtype(value);
+    if (state) {
+        if (!state.modified_ &&
+            (state.type_ < 4 || !getPlugin("ES5").hasChanges_(state as any)))
+            return state.base_;
+        // Optimization: avoid generating new drafts during copying
+        state.finalized_ = true;
+        copy = copyHelper(value, archType);
+        state.finalized_ = false;
+    }
+    else {
+        copy = copyHelper(value, archType);
+    }
+    
+ each(copy, (key, childValue) => {
+        if (state && get(state.base_, key) === childValue)
+            return; // no need to copy or search in something that didn't change
+        set(copy, key, currentImpl(childValue));
+    });
+    // In the future, we might consider freezing here, based on the current settings
+    return archType === Archtype.Set ? new Set(copy) : copy;
 }
 
-function copyHelper(value: any, archType: number): any {
-	// creates a shallow copy, even if it is a map or set
-	switch (archType) {
-		case Archtype.Map:
-			return new Map(value)
-		case Archtype.Set:
-			// Set will be cloned as array temporarily, so that we can replace individual items
-			return Array.from(value)
-	}
-	return shallowCopy(value)
+ function copyHelper(value: any, archType: number): any {
+    // creates a shallow copy, even if it is a map or set
+    switch (archType) {
+        case Archtype.Map:
+            return new Map(value);
+        case Archtype.Set:
+            // Set will be cloned as array temporarily, so that we can replace individual items
+            return Array.from(value);
+    }
+    return shallowCopy(value);
 }
diff --git a/src/core/finalize.ts b/src/core/finalize.ts
index ad95b1249b75c1fbb8c50f7fb7dc1f92839b89de..7a64c11df4cd08fd097e1a548d8f4a188e81c3e2 100644
--- a/src/core/finalize.ts
+++ b/src/core/finalize.ts
@@ -1,159 +1,121 @@
-import {
-	ImmerScope,
-	DRAFT_STATE,
-	isDraftable,
-	NOTHING,
-	PatchPath,
-	each,
-	has,
-	freeze,
-	ImmerState,
-	isDraft,
-	SetState,
-	set,
-	ProxyType,
-	getPlugin,
-	die,
-	revokeScope,
-	isFrozen,
-	shallowCopy
-} from "../internal"
+import { ImmerScope, DRAFT_STATE, isDraftable, NOTHING, PatchPath, each, has, freeze, ImmerState, isDraft, SetState, set, ProxyType, getPlugin, die, revokeScope, isFrozen, shallowCopy } from "../internal.js";
 
-export function processResult(result: any, scope: ImmerScope) {
-	scope.unfinalizedDrafts_ = scope.drafts_.length
-	const baseDraft = scope.drafts_![0]
-	const isReplaced = result !== undefined && result !== baseDraft
-	if (!scope.immer_.useProxies_)
-		getPlugin("ES5").willFinalizeES5_(scope, result, isReplaced)
-	if (isReplaced) {
-		if (baseDraft[DRAFT_STATE].modified_) {
-			revokeScope(scope)
-			die(4)
-		}
-		if (isDraftable(result)) {
-			// Finalize the result in case it contains (or is) a subset of the draft.
-			result = finalize(scope, result)
-			if (!scope.parent_) maybeFreeze(scope, result)
-		}
-		if (scope.patches_) {
-			getPlugin("Patches").generateReplacementPatches_(
-				baseDraft[DRAFT_STATE].base_,
-				result,
-				scope.patches_,
-				scope.inversePatches_!
-			)
-		}
-	} else {
-		// Finalize the base draft.
-		result = finalize(scope, baseDraft, [])
-	}
-	revokeScope(scope)
-	if (scope.patches_) {
-		scope.patchListener_!(scope.patches_, scope.inversePatches_!)
-	}
-	return result !== NOTHING ? result : undefined
+ export function processResult(result: any, scope: ImmerScope) {
+    scope.unfinalizedDrafts_ = scope.drafts_.length;
+    const baseDraft = scope.drafts_![0];
+    const isReplaced = result !== undefined && result !== baseDraft;
+    if (!scope.immer_.useProxies_)
+        getPlugin("ES5").willFinalizeES5_(scope, result, isReplaced);
+    if (isReplaced) {
+        if (baseDraft[DRAFT_STATE].modified_) {
+            revokeScope(scope);
+            die(4);
+        }
+        if (isDraftable(result)) {
+            // Finalize the result in case it contains (or is) a subset of the draft.
+            result = finalize(scope, result);
+            if (!scope.parent_)
+                maybeFreeze(scope, result);
+        }
+        if (scope.patches_) {
+            getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_!);
+        }
+    }
+    else {
+        // Finalize the base draft.
+        result = finalize(scope, baseDraft, []);
+    }
+    revokeScope(scope);
+    if (scope.patches_) {
+        scope.patchListener_!(scope.patches_, scope.inversePatches_!);
+    }
+    return result !== NOTHING ? result : undefined;
 }
 
-function finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {
-	// Don't recurse in tho recursive data structures
-	if (isFrozen(value)) return value
-
-	const state: ImmerState = value[DRAFT_STATE]
-	// A plain object, might need freezing, might contain drafts
-	if (!state) {
-		each(
-			value,
-			(key, childValue) =>
-				finalizeProperty(rootScope, state, value, key, childValue, path),
-			true // See #590, don't recurse into non-enumerable of non drafted objects
-		)
-		return value
-	}
-	// Never finalize drafts owned by another scope.
-	if (state.scope_ !== rootScope) return value
-	// Unmodified draft, return the (frozen) original
-	if (!state.modified_) {
-		maybeFreeze(rootScope, state.base_, true)
-		return state.base_
-	}
-	// Not finalized yet, let's do that now
-	if (!state.finalized_) {
-		state.finalized_ = true
-		state.scope_.unfinalizedDrafts_--
-		const result =
-			// For ES5, create a good copy from the draft first, with added keys and without deleted keys.
-			state.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array
-				? (state.copy_ = shallowCopy(state.draft_))
-				: state.copy_
-		// Finalize all children of the copy
-		// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628
-		// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line
-		// back to each(result, ....)
-		each(
-			state.type_ === ProxyType.Set ? new Set(result) : result,
-			(key, childValue) =>
-				finalizeProperty(rootScope, state, result, key, childValue, path)
-		)
-		// everything inside is frozen, we can freeze here
-		maybeFreeze(rootScope, result, false)
-		// first time finalizing, let's create those patches
-		if (path && rootScope.patches_) {
-			getPlugin("Patches").generatePatches_(
-				state,
-				path,
-				rootScope.patches_,
-				rootScope.inversePatches_!
-			)
-		}
-	}
-	return state.copy_
+ function finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {
+    // Don't recurse in tho recursive data structures
+    if (isFrozen(value))
+        return value;
+    
+ const state: ImmerState = value[DRAFT_STATE];
+    // A plain object, might need freezing, might contain drafts
+    if (!state) {
+        each(value, (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path), true // See #590, don't recurse into non-enumerable of non drafted objects
+        );
+        return value;
+    }
+    // Never finalize drafts owned by another scope.
+    if (state.scope_ !== rootScope)
+        return value;
+    // Unmodified draft, return the (frozen) original
+    if (!state.modified_) {
+        maybeFreeze(rootScope, state.base_, true);
+        return state.base_;
+    }
+    // Not finalized yet, let's do that now
+    if (!state.finalized_) {
+        state.finalized_ = true;
+        state.scope_.unfinalizedDrafts_--;
+        const result = 
+        // For ES5, create a good copy from the draft first, with added keys and without deleted keys.
+        state.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array
+            ? (state.copy_ = shallowCopy(state.draft_))
+            : state.copy_;
+        // Finalize all children of the copy
+        // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628
+        // Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line
+        // back to each(result, ....)
+        each(state.type_ === ProxyType.Set ? new Set(result) : result, (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path));
+        // everything inside is frozen, we can freeze here
+        maybeFreeze(rootScope, result, false);
+        // first time finalizing, let's create those patches
+        if (path && rootScope.patches_) {
+            getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_!);
+        }
+    }
+    return state.copy_;
 }
 
-function finalizeProperty(
-	rootScope: ImmerScope,
-	parentState: undefined | ImmerState,
-	targetObject: any,
-	prop: string | number,
-	childValue: any,
-	rootPath?: PatchPath
-) {
-	if (__DEV__ && childValue === targetObject) die(5)
-	if (isDraft(childValue)) {
-		const path =
-			rootPath &&
-			parentState &&
-			parentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.
-			!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.
-				? rootPath!.concat(prop)
-				: undefined
-		// Drafts owned by `scope` are finalized here.
-		const res = finalize(rootScope, childValue, path)
-		set(targetObject, prop, res)
-		// Drafts from another scope must prevented to be frozen
-		// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze
-		if (isDraft(res)) {
-			rootScope.canAutoFreeze_ = false
-		} else return
-	}
-	// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.
-	if (isDraftable(childValue) && !isFrozen(childValue)) {
-		if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
-			// optimization: if an object is not a draft, and we don't have to
-			// deepfreeze everything, and we are sure that no drafts are left in the remaining object
-			// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.
-			// This benefits especially adding large data tree's without further processing.
-			// See add-data.js perf test
-			return
-		}
-		finalize(rootScope, childValue)
-		// immer deep freezes plain objects, so if there is no parent state, we freeze as well
-		if (!parentState || !parentState.scope_.parent_)
-			maybeFreeze(rootScope, childValue)
-	}
+ function finalizeProperty(rootScope: ImmerScope, parentState: undefined | ImmerState, targetObject: any, prop: string | number, childValue: any, rootPath?: PatchPath) {
+    if (__DEV__ && childValue === targetObject)
+        die(5);
+    if (isDraft(childValue)) {
+        const path = rootPath &&
+            parentState &&
+            parentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.
+            !has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.
+            ? rootPath!.concat(prop)
+            : undefined;
+        // Drafts owned by `scope` are finalized here.
+        const res = finalize(rootScope, childValue, path);
+        set(targetObject, prop, res);
+        // Drafts from another scope must prevented to be frozen
+        // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze
+        if (isDraft(res)) {
+            rootScope.canAutoFreeze_ = false;
+        }
+        else
+            return;
+    }
+    // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.
+    if (isDraftable(childValue) && !isFrozen(childValue)) {
+        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
+            // optimization: if an object is not a draft, and we don't have to
+            // deepfreeze everything, and we are sure that no drafts are left in the remaining object
+            // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.
+            // This benefits especially adding large data tree's without further processing.
+            // See add-data.js perf test
+            return;
+        }
+        finalize(rootScope, childValue);
+        // immer deep freezes plain objects, so if there is no parent state, we freeze as well
+        if (!parentState || !parentState.scope_.parent_)
+            maybeFreeze(rootScope, childValue);
+    }
 }
 
-function maybeFreeze(scope: ImmerScope, value: any, deep = false) {
-	if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
-		freeze(value, deep)
-	}
+ function maybeFreeze(scope: ImmerScope, value: any, deep = false) {
+    if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
+        freeze(value, deep);
+    }
 }
diff --git a/src/core/immerClass.ts b/src/core/immerClass.ts
index 9b3791619f9841ba14f8586a642a6eb2568ab5ae..77b4356fc2dec49cb07efaf7386561ab5d3ac500 100644
--- a/src/core/immerClass.ts
+++ b/src/core/immerClass.ts
@@ -1,244 +1,214 @@
-import {
-	IProduceWithPatches,
-	IProduce,
-	ImmerState,
-	Drafted,
-	isDraftable,
-	processResult,
-	Patch,
-	Objectish,
-	DRAFT_STATE,
-	Draft,
-	PatchListener,
-	isDraft,
-	isMap,
-	isSet,
-	createProxyProxy,
-	getPlugin,
-	die,
-	hasProxies,
-	enterScope,
-	revokeScope,
-	leaveScope,
-	usePatchesInScope,
-	getCurrentScope,
-	NOTHING,
-	freeze,
-	current
-} from "../internal"
+import { IProduceWithPatches, IProduce, ImmerState, Drafted, isDraftable, processResult, Patch, Objectish, DRAFT_STATE, Draft, PatchListener, isDraft, isMap, isSet, createProxyProxy, getPlugin, die, hasProxies, enterScope, revokeScope, leaveScope, usePatchesInScope, getCurrentScope, NOTHING, freeze, current } from "../internal.js";
 
-interface ProducersFns {
-	produce: IProduce
-	produceWithPatches: IProduceWithPatches
+ interface ProducersFns {
+    produce: IProduce;
+    produceWithPatches: IProduceWithPatches;
 }
 
-export class Immer implements ProducersFns {
-	useProxies_: boolean = hasProxies
-
-	autoFreeze_: boolean = true
-
-	constructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {
-		if (typeof config?.useProxies === "boolean")
-			this.setUseProxies(config!.useProxies)
-		if (typeof config?.autoFreeze === "boolean")
-			this.setAutoFreeze(config!.autoFreeze)
-	}
-
-	/**
-	 * The `produce` function takes a value and a "recipe function" (whose
-	 * return value often depends on the base state). The recipe function is
-	 * free to mutate its first argument however it wants. All mutations are
-	 * only ever applied to a __copy__ of the base state.
-	 *
-	 * Pass only a function to create a "curried producer" which relieves you
-	 * from passing the recipe function every time.
-	 *
-	 * Only plain objects and arrays are made mutable. All other objects are
-	 * considered uncopyable.
-	 *
-	 * Note: This function is __bound__ to its `Immer` instance.
-	 *
-	 * @param {any} base - the initial state
-	 * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
-	 * @param {Function} patchListener - optional function that will be called with all the patches produced here
-	 * @returns {any} a new state, or the initial state if nothing was modified
-	 */
-	produce: IProduce = (base: any, recipe?: any, patchListener?: any) => {
-		// curried invocation
-		if (typeof base === "function" && typeof recipe !== "function") {
-			const defaultBase = recipe
-			recipe = base
-
-			const self = this
-			return function curriedProduce(
-				this: any,
-				base = defaultBase,
-				...args: any[]
-			) {
-				return self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore
-			}
-		}
-
-		if (typeof recipe !== "function") die(6)
-		if (patchListener !== undefined && typeof patchListener !== "function")
-			die(7)
-
-		let result
-
-		// Only plain objects, arrays, and "immerable classes" are drafted.
-		if (isDraftable(base)) {
-			const scope = enterScope(this)
-			const proxy = createProxy(this, base, undefined)
-			let hasError = true
-			try {
-				result = recipe(proxy)
-				hasError = false
-			} finally {
-				// finally instead of catch + rethrow better preserves original stack
-				if (hasError) revokeScope(scope)
-				else leaveScope(scope)
-			}
-			if (typeof Promise !== "undefined" && result instanceof Promise) {
-				return result.then(
-					result => {
-						usePatchesInScope(scope, patchListener)
-						return processResult(result, scope)
-					},
-					error => {
-						revokeScope(scope)
-						throw error
-					}
-				)
-			}
-			usePatchesInScope(scope, patchListener)
-			return processResult(result, scope)
-		} else if (!base || typeof base !== "object") {
-			result = recipe(base)
-			if (result === undefined) result = base
-			if (result === NOTHING) result = undefined
-			if (this.autoFreeze_) freeze(result, true)
-			if (patchListener) {
-				const p: Patch[] = []
-				const ip: Patch[] = []
-				getPlugin("Patches").generateReplacementPatches_(base, result, p, ip)
-				patchListener(p, ip)
-			}
-			return result
-		} else die(21, base)
-	}
-
-	produceWithPatches: IProduceWithPatches = (
-		base: any,
-		recipe?: any,
-	): any => {
-		// curried invocation
-		if (typeof base === "function") {
-			return (state: any, ...args: any[]) =>
-				this.produceWithPatches(state, (draft: any) => base(draft, ...args))
-		}
-
-		let patches: Patch[], inversePatches: Patch[]
-		const result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {
-			patches = p
-			inversePatches = ip
-		})
-
-		if (typeof Promise !== "undefined" && result instanceof Promise) {
-			return result.then(nextState => [nextState, patches!, inversePatches!])
-		}
-		return [result, patches!, inversePatches!]
-	}
-
-	createDraft<T extends Objectish>(base: T): Draft<T> {
-		if (!isDraftable(base)) die(8)
-		if (isDraft(base)) base = current(base)
-		const scope = enterScope(this)
-		const proxy = createProxy(this, base, undefined)
-		proxy[DRAFT_STATE].isManual_ = true
-		leaveScope(scope)
-		return proxy as any
-	}
-
-	finishDraft<D extends Draft<any>>(
-		draft: D,
-		patchListener?: PatchListener
-	): D extends Draft<infer T> ? T : never {
-		const state: ImmerState = draft && (draft as any)[DRAFT_STATE]
-		if (__DEV__) {
-			if (!state || !state.isManual_) die(9)
-			if (state.finalized_) die(10)
-		}
-		const {scope_: scope} = state
-		usePatchesInScope(scope, patchListener)
-		return processResult(undefined, scope)
-	}
-
-	/**
-	 * Pass true to automatically freeze all copies created by Immer.
-	 *
-	 * By default, auto-freezing is enabled.
-	 */
-	setAutoFreeze(value: boolean) {
-		this.autoFreeze_ = value
-	}
-
-	/**
-	 * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
-	 * always faster than using ES5 proxies.
-	 *
-	 * By default, feature detection is used, so calling this is rarely necessary.
-	 */
-	setUseProxies(value: boolean) {
-		if (value && !hasProxies) {
-			die(20)
-		}
-		this.useProxies_ = value
-	}
-
-	applyPatches<T extends Objectish>(base: T, patches: Patch[]): T {
-		// If a patch replaces the entire state, take that replacement as base
-		// before applying patches
-		let i: number
-		for (i = patches.length - 1; i >= 0; i--) {
-			const patch = patches[i]
-			if (patch.path.length === 0 && patch.op === "replace") {
-				base = patch.value
-				break
-			}
-		}
-		// If there was a patch that replaced the entire state, start from the
-		// patch after that.
-		if (i > -1) {
-			patches = patches.slice(i + 1)
-		}
-
-		const applyPatchesImpl = getPlugin("Patches").applyPatches_
-		if (isDraft(base)) {
-			// N.B: never hits if some patch a replacement, patches are never drafts
-			return applyPatchesImpl(base, patches)
-		}
-		// Otherwise, produce a copy of the base state.
-		return this.produce(base, (draft: Drafted) =>
-			applyPatchesImpl(draft, patches)
-		)
-	}
+ export class Immer implements ProducersFns {
+    useProxies_: boolean = hasProxies;
+    
+ autoFreeze_: boolean = true;
+    
+ constructor(config?: {
+        useProxies?: boolean;
+        autoFreeze?: boolean;
+    }) {
+        if (typeof config?.useProxies === "boolean")
+            this.setUseProxies(config!.useProxies);
+        if (typeof config?.autoFreeze === "boolean")
+            this.setAutoFreeze(config!.autoFreeze);
+    }
+    
+ /**
+         * The `produce` function takes a value and a "recipe function" (whose
+         * return value often depends on the base state). The recipe function is
+         * free to mutate its first argument however it wants. All mutations are
+         * only ever applied to a __copy__ of the base state.
+         *
+         * Pass only a function to create a "curried producer" which relieves you
+         * from passing the recipe function every time.
+         *
+         * Only plain objects and arrays are made mutable. All other objects are
+         * considered uncopyable.
+         *
+         * Note: This function is __bound__ to its `Immer` instance.
+         *
+         * @param {any} base - the initial state
+         * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+         * @param {Function} patchListener - optional function that will be called with all the patches produced here
+         * @returns {any} a new state, or the initial state if nothing was modified
+         */
+    produce: IProduce = (base: any, recipe?: any, patchListener?: any) => {
+        // curried invocation
+        if (typeof base === "function" && typeof recipe !== "function") {
+            const defaultBase = recipe;
+            recipe = base;
+            
+ const self = this;
+            return function curriedProduce(this: any, base = defaultBase, ...args: any[]) {
+                return self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)); // prettier-ignore
+            };
+        }
+        
+ if (typeof recipe !== "function")
+            die(6);
+        if (patchListener !== undefined && typeof patchListener !== "function")
+            die(7);
+        
+ let result;
+        
+ // Only plain objects, arrays, and "immerable classes" are drafted.
+        if (isDraftable(base)) {
+            const scope = enterScope(this);
+            const proxy = createProxy(this, base, undefined);
+            let hasError = true;
+            try {
+                result = recipe(proxy);
+                hasError = false;
+            }
+            finally {
+                // finally instead of catch + rethrow better preserves original stack
+                if (hasError)
+                    revokeScope(scope);
+                else
+                    leaveScope(scope);
+            }
+            if (typeof Promise !== "undefined" && result instanceof Promise) {
+                return result.then(result => {
+                    usePatchesInScope(scope, patchListener);
+                    return processResult(result, scope);
+                }, error => {
+                    revokeScope(scope);
+                    throw error;
+                });
+            }
+            usePatchesInScope(scope, patchListener);
+            return processResult(result, scope);
+        }
+        else if (!base || typeof base !== "object") {
+            result = recipe(base);
+            if (result === undefined)
+                result = base;
+            if (result === NOTHING)
+                result = undefined;
+            if (this.autoFreeze_)
+                freeze(result, true);
+            if (patchListener) {
+                const p: Patch[] = [];
+                const ip: Patch[] = [];
+                getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
+                patchListener(p, ip);
+            }
+            return result;
+        }
+        else
+            die(21, base);
+    };
+    
+ produceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {
+        // curried invocation
+        if (typeof base === "function") {
+            return (state: any, ...args: any[]) => this.produceWithPatches(state, (draft: any) => base(draft, ...args));
+        }
+        
+ let patches: Patch[], inversePatches: Patch[];
+        const result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {
+            patches = p;
+            inversePatches = ip;
+        });
+        
+ if (typeof Promise !== "undefined" && result instanceof Promise) {
+            return result.then(nextState => [nextState, patches!, inversePatches!]);
+        }
+        return [result, patches!, inversePatches!];
+    };
+    
+ createDraft<T extends Objectish>(base: T): Draft<T> {
+        if (!isDraftable(base))
+            die(8);
+        if (isDraft(base))
+            base = current(base);
+        const scope = enterScope(this);
+        const proxy = createProxy(this, base, undefined);
+        proxy[DRAFT_STATE].isManual_ = true;
+        leaveScope(scope);
+        return proxy as any;
+    }
+    
+ finishDraft<D extends Draft<any>>(draft: D, patchListener?: PatchListener): D extends Draft<infer T> ? T : never {
+        const state: ImmerState = draft && (draft as any)[DRAFT_STATE];
+        if (__DEV__) {
+            if (!state || !state.isManual_)
+                die(9);
+            if (state.finalized_)
+                die(10);
+        }
+        const { scope_: scope } = state;
+        usePatchesInScope(scope, patchListener);
+        return processResult(undefined, scope);
+    }
+    
+ /**
+         * Pass true to automatically freeze all copies created by Immer.
+         *
+         * By default, auto-freezing is enabled.
+         */
+    setAutoFreeze(value: boolean) {
+        this.autoFreeze_ = value;
+    }
+    
+ /**
+         * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+         * always faster than using ES5 proxies.
+         *
+         * By default, feature detection is used, so calling this is rarely necessary.
+         */
+    setUseProxies(value: boolean) {
+        if (value && !hasProxies) {
+            die(20);
+        }
+        this.useProxies_ = value;
+    }
+    
+ applyPatches<T extends Objectish>(base: T, patches: Patch[]): T {
+        // If a patch replaces the entire state, take that replacement as base
+        // before applying patches
+        let i: number;
+        for (i = patches.length - 1; i >= 0; i--) {
+            const patch = patches[i];
+            if (patch.path.length === 0 && patch.op === "replace") {
+                base = patch.value;
+                break;
+            }
+        }
+        // If there was a patch that replaced the entire state, start from the
+        // patch after that.
+        if (i > -1) {
+            patches = patches.slice(i + 1);
+        }
+        
+ const applyPatchesImpl = getPlugin("Patches").applyPatches_;
+        if (isDraft(base)) {
+            // N.B: never hits if some patch a replacement, patches are never drafts
+            return applyPatchesImpl(base, patches);
+        }
+        // Otherwise, produce a copy of the base state.
+        return this.produce(base, (draft: Drafted) => applyPatchesImpl(draft, patches));
+    }
 }
 
-export function createProxy<T extends Objectish>(
-	immer: Immer,
-	value: T,
-	parent?: ImmerState
-): Drafted<T, ImmerState> {
-	// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft
-	const draft: Drafted = isMap(value)
-		? getPlugin("MapSet").proxyMap_(value, parent)
-		: isSet(value)
-		? getPlugin("MapSet").proxySet_(value, parent)
-		: immer.useProxies_
-		? createProxyProxy(value, parent)
-		: getPlugin("ES5").createES5Proxy_(value, parent)
-
-	const scope = parent ? parent.scope_ : getCurrentScope()
-	scope.drafts_.push(draft)
-	return draft
+ export function createProxy<T extends Objectish>(immer: Immer, value: T, parent?: ImmerState): Drafted<T, ImmerState> {
+    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft
+    const draft: Drafted = isMap(value)
+        ? getPlugin("MapSet").proxyMap_(value, parent)
+        : isSet(value)
+            ? getPlugin("MapSet").proxySet_(value, parent)
+            : immer.useProxies_
+                ? createProxyProxy(value, parent)
+                : getPlugin("ES5").createES5Proxy_(value, parent);
+    
+ const scope = parent ? parent.scope_ : getCurrentScope();
+    scope.drafts_.push(draft);
+    return draft;
 }
diff --git a/src/core/proxy.ts b/src/core/proxy.ts
index 7e6503a9059a770ae077d53cd689134fea82794c..f8f0a640213b54a60e8b0f5855abdf2d074c555d 100644
--- a/src/core/proxy.ts
+++ b/src/core/proxy.ts
@@ -1,280 +1,259 @@
-import {
-	each,
-	has,
-	is,
-	isDraftable,
-	shallowCopy,
-	latest,
-	ImmerBaseState,
-	ImmerState,
-	Drafted,
-	AnyObject,
-	AnyArray,
-	Objectish,
-	getCurrentScope,
-	DRAFT_STATE,
-	die,
-	createProxy,
-	ProxyType
-} from "../internal"
+import { each, has, is, isDraftable, shallowCopy, latest, ImmerBaseState, ImmerState, Drafted, AnyObject, AnyArray, Objectish, getCurrentScope, DRAFT_STATE, die, createProxy, ProxyType } from "../internal.js";
 
-interface ProxyBaseState extends ImmerBaseState {
-	assigned_: {
-		[property: string]: boolean
-	}
-	parent_?: ImmerState
-	revoke_(): void
+ interface ProxyBaseState extends ImmerBaseState {
+    assigned_: {
+        [property: string]: boolean;
+    };
+    parent_?: ImmerState;
+    revoke_(): void;
 }
 
-export interface ProxyObjectState extends ProxyBaseState {
-	type_: ProxyType.ProxyObject
-	base_: any
-	copy_: any
-	draft_: Drafted<AnyObject, ProxyObjectState>
+ export interface ProxyObjectState extends ProxyBaseState {
+    type_: ProxyType.ProxyObject;
+    base_: any;
+    copy_: any;
+    draft_: Drafted<AnyObject, ProxyObjectState>;
 }
 
-export interface ProxyArrayState extends ProxyBaseState {
-	type_: ProxyType.ProxyArray
-	base_: AnyArray
-	copy_: AnyArray | null
-	draft_: Drafted<AnyArray, ProxyArrayState>
+ export interface ProxyArrayState extends ProxyBaseState {
+    type_: ProxyType.ProxyArray;
+    base_: AnyArray;
+    copy_: AnyArray | null;
+    draft_: Drafted<AnyArray, ProxyArrayState>;
 }
 
-type ProxyState = ProxyObjectState | ProxyArrayState
+ type ProxyState = ProxyObjectState | ProxyArrayState;
 
-/**
+ /**
  * Returns a new draft of the `base` object.
  *
  * The second argument is the parent draft-state (used internally).
  */
-export function createProxyProxy<T extends Objectish>(
-	base: T,
-	parent?: ImmerState
-): Drafted<T, ProxyState> {
-	const isArray = Array.isArray(base)
-	const state: ProxyState = {
-		type_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),
-		// Track which produce call this is associated with.
-		scope_: parent ? parent.scope_ : getCurrentScope()!,
-		// True for both shallow and deep changes.
-		modified_: false,
-		// Used during finalization.
-		finalized_: false,
-		// Track which properties have been assigned (true) or deleted (false).
-		assigned_: {},
-		// The parent draft state.
-		parent_: parent,
-		// The base state.
-		base_: base,
-		// The base proxy.
-		draft_: null as any, // set below
-		// The base copy with any updated values.
-		copy_: null,
-		// Called by the `produce` function.
-		revoke_: null as any,
-		isManual_: false
-	}
-
-	// the traps must target something, a bit like the 'real' base.
-	// but also, we need to be able to determine from the target what the relevant state is
-	// (to avoid creating traps per instance to capture the state in closure,
-	// and to avoid creating weird hidden properties as well)
-	// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)
-	// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb
-	let target: T = state as any
-	let traps: ProxyHandler<object | Array<any>> = objectTraps
-	if (isArray) {
-		target = [state] as any
-		traps = arrayTraps
-	}
-
-	const {revoke, proxy} = Proxy.revocable(target, traps)
-	state.draft_ = proxy as any
-	state.revoke_ = revoke
-	return proxy as any
+export function createProxyProxy<T extends Objectish>(base: T, parent?: ImmerState): Drafted<T, ProxyState> {
+    const isArray = Array.isArray(base);
+    const state: ProxyState = {
+        type_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),
+        // Track which produce call this is associated with.
+        scope_: parent ? parent.scope_ : getCurrentScope()!,
+        // True for both shallow and deep changes.
+        modified_: false,
+        // Used during finalization.
+        finalized_: false,
+        // Track which properties have been assigned (true) or deleted (false).
+        assigned_: {},
+        // The parent draft state.
+        parent_: parent,
+        // The base state.
+        base_: base,
+        // The base proxy.
+        draft_: null as any,
+        // The base copy with any updated values.
+        copy_: null,
+        // Called by the `produce` function.
+        revoke_: null as any,
+        isManual_: false
+    };
+    
+ // the traps must target something, a bit like the 'real' base.
+    // but also, we need to be able to determine from the target what the relevant state is
+    // (to avoid creating traps per instance to capture the state in closure,
+    // and to avoid creating weird hidden properties as well)
+    // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)
+    // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb
+    let target: T = state as any;
+    let traps: ProxyHandler<object | Array<any>> = objectTraps;
+    if (isArray) {
+        target = [state] as any;
+        traps = arrayTraps;
+    }
+    
+ const { revoke, proxy } = Proxy.revocable(target, traps);
+    state.draft_ = proxy as any;
+    state.revoke_ = revoke;
+    return proxy as any;
 }
 
-/**
+ /**
  * Object drafts
  */
 export const objectTraps: ProxyHandler<ProxyState> = {
-	get(state, prop) {
-		if (prop === DRAFT_STATE) return state
-
-		const source = latest(state)
-		if (!has(source, prop)) {
-			// non-existing or non-own property...
-			return readPropFromProto(state, source, prop)
-		}
-		const value = source[prop]
-		if (state.finalized_ || !isDraftable(value)) {
-			return value
-		}
-		// Check for existing draft in modified state.
-		// Assigned values are never drafted. This catches any drafts we created, too.
-		if (value === peek(state.base_, prop)) {
-			prepareCopy(state)
-			return (state.copy_![prop as any] = createProxy(
-				state.scope_.immer_,
-				value,
-				state
-			))
-		}
-		return value
-	},
-	has(state, prop) {
-		return prop in latest(state)
-	},
-	ownKeys(state) {
-		return Reflect.ownKeys(latest(state))
-	},
-	set(
-		state: ProxyObjectState,
-		prop: string /* strictly not, but helps TS */,
-		value
-	) {
-		const desc = getDescriptorFromProto(latest(state), prop)
-		if (desc?.set) {
-			// special case: if this write is captured by a setter, we have
-			// to trigger it with the correct context
-			desc.set.call(state.draft_, value)
-			return true
-		}
-		if (!state.modified_) {
-			// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)
-			// from setting an existing property with value undefined to undefined (which is not a change)
-			const current = peek(latest(state), prop)
-			// special case, if we assigning the original value to a draft, we can ignore the assignment
-			const currentState: ProxyObjectState = current?.[DRAFT_STATE]
-			if (currentState && currentState.base_ === value) {
-				state.copy_![prop] = value
-				state.assigned_[prop] = false
-				return true
-			}
-			if (is(value, current) && (value !== undefined || has(state.base_, prop)))
-				return true
-			prepareCopy(state)
-			markChanged(state)
-		}
-
-		if (
-			state.copy_![prop] === value &&
-			// special case: NaN
-			typeof value !== "number" &&
-			// special case: handle new props with value 'undefined'
-			(value !== undefined || prop in state.copy_)
-		)
-			return true
+    get(state, prop) {
+        if (prop === DRAFT_STATE)
+            return state;
+        
+ const source = latest(state);
+        if (!has(source, prop)) {
+            // non-existing or non-own property...
+            return readPropFromProto(state, source, prop);
+        }
+        const value = source[prop];
+        if (state.finalized_ || !isDraftable(value)) {
+            return value;
+        }
+        // Check for existing draft in modified state.
+        // Assigned values are never drafted. This catches any drafts we created, too.
+        if (value === peek(state.base_, prop)) {
+            prepareCopy(state);
+            return (state.copy_![prop as any] = createProxy(state.scope_.immer_, value, state));
+        }
+        return value;
+    },
+    has(state, prop) {
+        return prop in latest(state);
+    },
+    ownKeys(state) {
+        return Reflect.ownKeys(latest(state));
+    },
+    set(state: ProxyObjectState, prop: string /* strictly not, but helps TS */, value) {
+        const desc = getDescriptorFromProto(latest(state), prop);
+        if (desc?.set) {
+            // special case: if this write is captured by a setter, we have
+            // to trigger it with the correct context
+            desc.set.call(state.draft_, value);
+            return true;
+        }
+        if (!state.modified_) {
+            // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)
+            // from setting an existing property with value undefined to undefined (which is not a change)
+            const current = peek(latest(state), prop);
+            // special case, if we assigning the original value to a draft, we can ignore the assignment
+            const currentState: ProxyObjectState = current?.[DRAFT_STATE];
+            if (currentState && currentState.base_ === value) {
+                state.copy_![prop] = value;
+                state.assigned_[prop] = false;
+                return true;
+            }
+            if (is(value, current) && (value !== undefined || has(state.base_, prop)))
+                return true;
+            prepareCopy(state);
+            markChanged(state);
+        }
+        
+ if ((state.copy_![prop] === value &&
+            // special case: handle new props with value 'undefined'
+            (value !== undefined || prop in state.copy_)) ||
+            // special case: NaN
+            (Number.isNaN(value) && Number.isNaN(state.copy_![prop])))
+            return true;
+        
+ // @ts-ignore
+        state.copy_![prop] = value;
+        state.assigned_[prop] = true;
+        return true;
+    },
+    deleteProperty(state, prop: string) {
+        // The `undefined` check is a fast path for pre-existing keys.
+        if (peek(state.base_, prop) !== undefined || prop in state.base_) {
+            state.assigned_[prop] = false;
+            prepareCopy(state);
+            markChanged(state);
+        }
+        else {
+            // if an originally not assigned property was deleted
+            delete state.assigned_[prop];
+        }
+        // @ts-ignore
+        if (state.copy_)
+            delete state.copy_[prop];
+        return true;
+    },
+    // Note: We never coerce `desc.value` into an Immer draft, because we can't make
+    // the same guarantee in ES5 mode.
+    getOwnPropertyDescriptor(state, prop) {
+        const owner = latest(state);
+        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
+        if (!desc)
+            return desc;
+        return {
+            writable: true,
+            configurable: state.type_ !== ProxyType.ProxyArray || prop !== "length",
+            enumerable: desc.enumerable,
+            value: owner[prop]
+        };
+    },
+    defineProperty() {
+        die(11);
+    },
+    getPrototypeOf(state) {
+        return Object.getPrototypeOf(state.base_);
+    },
+    setPrototypeOf() {
+        die(12);
+    }
+};
 
-		// @ts-ignore
-		state.copy_![prop] = value
-		state.assigned_[prop] = true
-		return true
-	},
-	deleteProperty(state, prop: string) {
-		// The `undefined` check is a fast path for pre-existing keys.
-		if (peek(state.base_, prop) !== undefined || prop in state.base_) {
-			state.assigned_[prop] = false
-			prepareCopy(state)
-			markChanged(state)
-		} else {
-			// if an originally not assigned property was deleted
-			delete state.assigned_[prop]
-		}
-		// @ts-ignore
-		if (state.copy_) delete state.copy_[prop]
-		return true
-	},
-	// Note: We never coerce `desc.value` into an Immer draft, because we can't make
-	// the same guarantee in ES5 mode.
-	getOwnPropertyDescriptor(state, prop) {
-		const owner = latest(state)
-		const desc = Reflect.getOwnPropertyDescriptor(owner, prop)
-		if (!desc) return desc
-		return {
-			writable: true,
-			configurable: state.type_ !== ProxyType.ProxyArray || prop !== "length",
-			enumerable: desc.enumerable,
-			value: owner[prop]
-		}
-	},
-	defineProperty() {
-		die(11)
-	},
-	getPrototypeOf(state) {
-		return Object.getPrototypeOf(state.base_)
-	},
-	setPrototypeOf() {
-		die(12)
-	}
-}
-
-/**
+ /**
  * Array drafts
  */
 
-const arrayTraps: ProxyHandler<[ProxyArrayState]> = {}
+ const arrayTraps: ProxyHandler<[
+    ProxyArrayState
+]> = {};
 each(objectTraps, (key, fn) => {
-	// @ts-ignore
-	arrayTraps[key] = function() {
-		arguments[0] = arguments[0][0]
-		return fn.apply(this, arguments)
-	}
-})
-arrayTraps.deleteProperty = function(state, prop) {
-	if (__DEV__ && isNaN(parseInt(prop as any))) die(13)
-	// @ts-ignore
-	return arrayTraps.set!.call(this, state, prop, undefined)
-}
-arrayTraps.set = function(state, prop, value) {
-	if (__DEV__ && prop !== "length" && isNaN(parseInt(prop as any))) die(14)
-	return objectTraps.set!.call(this, state[0], prop, value, state[0])
-}
+    // @ts-ignore
+    arrayTraps[key] = function () {
+        arguments[0] = arguments[0][0];
+        return fn.apply(this, arguments);
+    };
+});
+arrayTraps.deleteProperty = function (state, prop) {
+    if (__DEV__ && isNaN(parseInt(prop as any)))
+        die(13);
+    // @ts-ignore
+    return arrayTraps.set!.call(this, state, prop, undefined);
+};
+arrayTraps.set = function (state, prop, value) {
+    if (__DEV__ && prop !== "length" && isNaN(parseInt(prop as any)))
+        die(14);
+    return objectTraps.set!.call(this, state[0], prop, value, state[0]);
+};
 
-// Access a property without creating an Immer draft.
+ // Access a property without creating an Immer draft.
 function peek(draft: Drafted, prop: PropertyKey) {
-	const state = draft[DRAFT_STATE]
-	const source = state ? latest(state) : draft
-	return source[prop]
+    const state = draft[DRAFT_STATE];
+    const source = state ? latest(state) : draft;
+    return source[prop];
 }
 
-function readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {
-	const desc = getDescriptorFromProto(source, prop)
-	return desc
-		? `value` in desc
-			? desc.value
-			: // This is a very special case, if the prop is a getter defined by the
-			  // prototype, we should invoke it with the draft as context!
-			  desc.get?.call(state.draft_)
-		: undefined
+ function readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {
+    const desc = getDescriptorFromProto(source, prop);
+    return desc
+        ? `value` in desc
+            ? desc.value
+            : // This is a very special case, if the prop is a getter defined by the
+                // prototype, we should invoke it with the draft as context!
+                desc.get?.call(state.draft_)
+        : undefined;
 }
 
-function getDescriptorFromProto(
-	source: any,
-	prop: PropertyKey
-): PropertyDescriptor | undefined {
-	// 'in' checks proto!
-	if (!(prop in source)) return undefined
-	let proto = Object.getPrototypeOf(source)
-	while (proto) {
-		const desc = Object.getOwnPropertyDescriptor(proto, prop)
-		if (desc) return desc
-		proto = Object.getPrototypeOf(proto)
-	}
-	return undefined
+ function getDescriptorFromProto(source: any, prop: PropertyKey): PropertyDescriptor | undefined {
+    // 'in' checks proto!
+    if (!(prop in source))
+        return undefined;
+    let proto = Object.getPrototypeOf(source);
+    while (proto) {
+        const desc = Object.getOwnPropertyDescriptor(proto, prop);
+        if (desc)
+            return desc;
+        proto = Object.getPrototypeOf(proto);
+    }
+    return undefined;
 }
 
-export function markChanged(state: ImmerState) {
-	if (!state.modified_) {
-		state.modified_ = true
-		if (state.parent_) {
-			markChanged(state.parent_)
-		}
-	}
+ export function markChanged(state: ImmerState) {
+    if (!state.modified_) {
+        state.modified_ = true;
+        if (state.parent_) {
+            markChanged(state.parent_);
+        }
+    }
 }
 
-export function prepareCopy(state: {base_: any; copy_: any}) {
-	if (!state.copy_) {
-		state.copy_ = shallowCopy(state.base_)
-	}
+ export function prepareCopy(state: {
+    base_: any;
+    copy_: any;
+}) {
+    if (!state.copy_) {
+        state.copy_ = shallowCopy(state.base_);
+    }
 }
diff --git a/src/core/scope.ts b/src/core/scope.ts
index 9cfd9ae900a13494d8b261e7544398bb60ca0b26..8911360a4e35597495d42f4fa5f023de9ac2c2ee 100644
--- a/src/core/scope.ts
+++ b/src/core/scope.ts
@@ -1,85 +1,70 @@
-import {
-	Patch,
-	PatchListener,
-	Drafted,
-	Immer,
-	DRAFT_STATE,
-	ImmerState,
-	ProxyType,
-	getPlugin
-} from "../internal"
-import {die} from "../utils/errors"
+import { Patch, PatchListener, Drafted, Immer, DRAFT_STATE, ImmerState, ProxyType, getPlugin } from "../internal.js";
+import { die } from "../utils/errors.js";
 
-/** Each scope represents a `produce` call. */
+ /** Each scope represents a `produce` call. */
 
-export interface ImmerScope {
-	patches_?: Patch[]
-	inversePatches_?: Patch[]
-	canAutoFreeze_: boolean
-	drafts_: any[]
-	parent_?: ImmerScope
-	patchListener_?: PatchListener
-	immer_: Immer
-	unfinalizedDrafts_: number
+ export interface ImmerScope {
+    patches_?: Patch[];
+    inversePatches_?: Patch[];
+    canAutoFreeze_: boolean;
+    drafts_: any[];
+    parent_?: ImmerScope;
+    patchListener_?: PatchListener;
+    immer_: Immer;
+    unfinalizedDrafts_: number;
 }
 
-let currentScope: ImmerScope | undefined
+ let currentScope: ImmerScope | undefined;
 
-export function getCurrentScope() {
-	if (__DEV__ && !currentScope) die(0)
-	return currentScope!
+ export function getCurrentScope() {
+    if (__DEV__ && !currentScope)
+        die(0);
+    return currentScope!;
 }
 
-function createScope(
-	parent_: ImmerScope | undefined,
-	immer_: Immer
-): ImmerScope {
-	return {
-		drafts_: [],
-		parent_,
-		immer_,
-		// Whenever the modified draft contains a draft from another scope, we
-		// need to prevent auto-freezing so the unowned draft can be finalized.
-		canAutoFreeze_: true,
-		unfinalizedDrafts_: 0
-	}
+ function createScope(parent_: ImmerScope | undefined, immer_: Immer): ImmerScope {
+    return {
+        drafts_: [],
+        parent_,
+        immer_,
+        // Whenever the modified draft contains a draft from another scope, we
+        // need to prevent auto-freezing so the unowned draft can be finalized.
+        canAutoFreeze_: true,
+        unfinalizedDrafts_: 0
+    };
 }
 
-export function usePatchesInScope(
-	scope: ImmerScope,
-	patchListener?: PatchListener
-) {
-	if (patchListener) {
-		getPlugin("Patches") // assert we have the plugin
-		scope.patches_ = []
-		scope.inversePatches_ = []
-		scope.patchListener_ = patchListener
-	}
+ export function usePatchesInScope(scope: ImmerScope, patchListener?: PatchListener) {
+    if (patchListener) {
+        getPlugin("Patches"); // assert we have the plugin
+        scope.patches_ = [];
+        scope.inversePatches_ = [];
+        scope.patchListener_ = patchListener;
+    }
 }
 
-export function revokeScope(scope: ImmerScope) {
-	leaveScope(scope)
-	scope.drafts_.forEach(revokeDraft)
-	// @ts-ignore
-	scope.drafts_ = null
+ export function revokeScope(scope: ImmerScope) {
+    leaveScope(scope);
+    scope.drafts_.forEach(revokeDraft);
+    // @ts-ignore
+    scope.drafts_ = null;
 }
 
-export function leaveScope(scope: ImmerScope) {
-	if (scope === currentScope) {
-		currentScope = scope.parent_
-	}
+ export function leaveScope(scope: ImmerScope) {
+    if (scope === currentScope) {
+        currentScope = scope.parent_;
+    }
 }
 
-export function enterScope(immer: Immer) {
-	return (currentScope = createScope(currentScope, immer))
+ export function enterScope(immer: Immer) {
+    return (currentScope = createScope(currentScope, immer));
 }
 
-function revokeDraft(draft: Drafted) {
-	const state: ImmerState = draft[DRAFT_STATE]
-	if (
-		state.type_ === ProxyType.ProxyObject ||
-		state.type_ === ProxyType.ProxyArray
-	)
-		state.revoke_()
-	else state.revoked_ = true
+ function revokeDraft(draft: Drafted) {
+    const state: ImmerState = draft[DRAFT_STATE];
+    if (state.type_ === ProxyType.ProxyObject ||
+        state.type_ === ProxyType.ProxyArray)
+        state.revoke_();
+    else
+        state.revoked_ = true;
 }
diff --git a/src/immer.ts b/src/immer.ts
index 0eacffe6144c878c9a961bf8e3e2f85f2ae7a1a3..f8573303bac13475aaab762e5cfb1912d4c89e54 100644
--- a/src/immer.ts
+++ b/src/immer.ts
@@ -1,28 +1,10 @@
-import {
-	IProduce,
-	IProduceWithPatches,
-	Immer,
-	Draft,
-	Immutable
-} from "./internal"
+import { IProduce, IProduceWithPatches, Immer, Draft, Immutable } from "./internal.js";
 
-export {
-	Draft,
-	Immutable,
-	Patch,
-	PatchListener,
-	original,
-	current,
-	isDraft,
-	isDraftable,
-	NOTHING as nothing,
-	DRAFTABLE as immerable,
-	freeze
-} from "./internal"
+ export { Draft, Immutable, Patch, PatchListener, original, current, isDraft, isDraftable, NOTHING as nothing, DRAFTABLE as immerable, freeze } from "./internal.js";
 
-const immer = new Immer()
+ const immer = new Immer();
 
-/**
+ /**
  * The `produce` function takes a value and a "recipe function" (whose
  * return value often depends on the base state). The recipe function is
  * free to mutate its first argument however it wants. All mutations are
@@ -41,46 +23,44 @@ const immer = new Immer()
  * @param {Function} patchListener - optional function that will be called with all the patches produced here
  * @returns {any} a new state, or the initial state if nothing was modified
  */
-export const produce: IProduce = immer.produce
-export default produce
+export const produce: IProduce = immer.produce;
+export default produce;
 
-/**
+ /**
  * Like `produce`, but `produceWithPatches` always returns a tuple
  * [nextState, patches, inversePatches] (instead of just the next state)
  */
-export const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(
-	immer
-)
+export const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(immer);
 
-/**
+ /**
  * Pass true to automatically freeze all copies created by Immer.
  *
  * Always freeze by default, even in production mode
  */
-export const setAutoFreeze = immer.setAutoFreeze.bind(immer)
+export const setAutoFreeze = immer.setAutoFreeze.bind(immer);
 
-/**
+ /**
  * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
  * always faster than using ES5 proxies.
  *
  * By default, feature detection is used, so calling this is rarely necessary.
  */
-export const setUseProxies = immer.setUseProxies.bind(immer)
+export const setUseProxies = immer.setUseProxies.bind(immer);
 
-/**
+ /**
  * Apply an array of Immer patches to the first argument.
  *
  * This function is a producer, which means copy-on-write is in effect.
  */
-export const applyPatches = immer.applyPatches.bind(immer)
+export const applyPatches = immer.applyPatches.bind(immer);
 
-/**
+ /**
  * Create an Immer draft from the given base state, which may be a draft itself.
  * The draft can be modified until you finalize it with the `finishDraft` function.
  */
-export const createDraft = immer.createDraft.bind(immer)
+export const createDraft = immer.createDraft.bind(immer);
 
-/**
+ /**
  * Finalize an Immer draft from a `createDraft` call, returning the base state
  * (if no changes were made) or a modified copy. The draft must *not* be
  * mutated afterwards.
@@ -88,30 +68,30 @@ export const createDraft = immer.createDraft.bind(immer)
  * Pass a function as the 2nd argument to generate Immer patches based on the
  * changes that were made.
  */
-export const finishDraft = immer.finishDraft.bind(immer)
+export const finishDraft = immer.finishDraft.bind(immer);
 
-/**
+ /**
  * This function is actually a no-op, but can be used to cast an immutable type
  * to an draft type and make TypeScript happy
  *
  * @param value
  */
 export function castDraft<T>(value: T): Draft<T> {
-	return value as any
+    return value as any;
 }
 
-/**
+ /**
  * This function is actually a no-op, but can be used to cast a mutable type
  * to an immutable type and make TypeScript happy
  * @param value
  */
 export function castImmutable<T>(value: T): Immutable<T> {
-	return value as any
+    return value as any;
 }
 
-export {Immer}
+ export { Immer };
 
-export {enableES5} from "./plugins/es5"
-export {enablePatches} from "./plugins/patches"
-export {enableMapSet} from "./plugins/mapset"
-export {enableAllPlugins} from "./plugins/all"
+ export { enableES5 } from "./plugins/es5.js";
+export { enablePatches } from "./plugins/patches.js";
+export { enableMapSet } from "./plugins/mapset.js";
+export { enableAllPlugins } from "./plugins/all.js";
diff --git a/src/internal.ts b/src/internal.ts
index de7236a6f02dd6a23480d8fcf0285fbc6afa5108..4e35f52cf3bf7daf3ffb8e8489521004f392abe3 100644
--- a/src/internal.ts
+++ b/src/internal.ts
@@ -1,11 +1,11 @@
-export * from "./utils/env"
-export * from "./utils/errors"
-export * from "./types/types-external"
-export * from "./types/types-internal"
-export * from "./utils/common"
-export * from "./utils/plugins"
-export * from "./core/scope"
-export * from "./core/finalize"
-export * from "./core/proxy"
-export * from "./core/immerClass"
-export * from "./core/current"
+export * from "./utils/env.js";
+export * from "./utils/errors.js";
+export * from "./types/types-external.js";
+export * from "./types/types-internal.js";
+export * from "./utils/common.js";
+export * from "./utils/plugins.js";
+export * from "./core/scope.js";
+export * from "./core/finalize.js";
+export * from "./core/proxy.js";
+export * from "./core/immerClass.js";
+export * from "./core/current.js";
diff --git a/src/plugins/all.ts b/src/plugins/all.ts
index 02073d592ab9286aab02841132dbbe1690e4cf19..82b7881f8a5950f3b37188acebb5815f9f35d536 100644
--- a/src/plugins/all.ts
+++ b/src/plugins/all.ts
@@ -1,9 +1,9 @@
-import {enableES5} from "./es5"
-import {enableMapSet} from "./mapset"
-import {enablePatches} from "./patches"
+import { enableES5 } from "./es5.js";
+import { enableMapSet } from "./mapset.js";
+import { enablePatches } from "./patches.js";
 
-export function enableAllPlugins() {
-	enableES5()
-	enableMapSet()
-	enablePatches()
+ export function enableAllPlugins() {
+    enableES5();
+    enableMapSet();
+    enablePatches();
 }
diff --git a/src/plugins/es5.ts b/src/plugins/es5.ts
index 0e16b403f829c90a5570dc6e11ddf5e58f71c0f7..69f3835f39fc460cc035dca5398798f713693e9a 100644
--- a/src/plugins/es5.ts
+++ b/src/plugins/es5.ts
@@ -1,277 +1,261 @@
-import {
-	ImmerState,
-	Drafted,
-	ES5ArrayState,
-	ES5ObjectState,
-	each,
-	has,
-	isDraft,
-	latest,
-	DRAFT_STATE,
-	is,
-	loadPlugin,
-	ImmerScope,
-	ProxyType,
-	getCurrentScope,
-	die,
-	markChanged,
-	objectTraps,
-	ownKeys,
-	getOwnPropertyDescriptors
-} from "../internal"
+import { ImmerState, Drafted, ES5ArrayState, ES5ObjectState, each, has, isDraft, latest, DRAFT_STATE, is, loadPlugin, ImmerScope, ProxyType, getCurrentScope, die, markChanged, objectTraps, ownKeys, getOwnPropertyDescriptors } from "../internal.js";
 
-type ES5State = ES5ArrayState | ES5ObjectState
+ type ES5State = ES5ArrayState | ES5ObjectState;
 
-export function enableES5() {
-	function willFinalizeES5_(
-		scope: ImmerScope,
-		result: any,
-		isReplaced: boolean
-	) {
-		if (!isReplaced) {
-			if (scope.patches_) {
-				markChangesRecursively(scope.drafts_![0])
-			}
-			// This is faster when we don't care about which attributes changed.
-			markChangesSweep(scope.drafts_)
-		}
-		// When a child draft is returned, look for changes.
-		else if (
-			isDraft(result) &&
-			(result[DRAFT_STATE] as ES5State).scope_ === scope
-		) {
-			markChangesSweep(scope.drafts_)
-		}
-	}
-
-	function createES5Draft(isArray: boolean, base: any) {
-		if (isArray) {
-			const draft = new Array(base.length)
-			for (let i = 0; i < base.length; i++)
-				Object.defineProperty(draft, "" + i, proxyProperty(i, true))
-			return draft
-		} else {
-			const descriptors = getOwnPropertyDescriptors(base)
-			delete descriptors[DRAFT_STATE as any]
-			const keys = ownKeys(descriptors)
-			for (let i = 0; i < keys.length; i++) {
-				const key: any = keys[i]
-				descriptors[key] = proxyProperty(
-					key,
-					isArray || !!descriptors[key].enumerable
-				)
-			}
-			return Object.create(Object.getPrototypeOf(base), descriptors)
-		}
-	}
-
-	function createES5Proxy_<T>(
-		base: T,
-		parent?: ImmerState
-	): Drafted<T, ES5ObjectState | ES5ArrayState> {
-		const isArray = Array.isArray(base)
-		const draft = createES5Draft(isArray, base)
-
-		const state: ES5ObjectState | ES5ArrayState = {
-			type_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),
-			scope_: parent ? parent.scope_ : getCurrentScope(),
-			modified_: false,
-			finalized_: false,
-			assigned_: {},
-			parent_: parent,
-			// base is the object we are drafting
-			base_: base,
-			// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)
-			draft_: draft,
-			copy_: null,
-			revoked_: false,
-			isManual_: false
-		}
-
-		Object.defineProperty(draft, DRAFT_STATE, {
-			value: state,
-			// enumerable: false <- the default
-			writable: true
-		})
-		return draft
-	}
-
-	// property descriptors are recycled to make sure we don't create a get and set closure per property,
-	// but share them all instead
-	const descriptors: {[prop: string]: PropertyDescriptor} = {}
-
-	function proxyProperty(
-		prop: string | number,
-		enumerable: boolean
-	): PropertyDescriptor {
-		let desc = descriptors[prop]
-		if (desc) {
-			desc.enumerable = enumerable
-		} else {
-			descriptors[prop] = desc = {
-				configurable: true,
-				enumerable,
-				get(this: any) {
-					const state = this[DRAFT_STATE]
-					if (__DEV__) assertUnrevoked(state)
-					// @ts-ignore
-					return objectTraps.get(state, prop)
-				},
-				set(this: any, value) {
-					const state = this[DRAFT_STATE]
-					if (__DEV__) assertUnrevoked(state)
-					// @ts-ignore
-					objectTraps.set(state, prop, value)
-				}
-			}
-		}
-		return desc
-	}
-
-	// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.
-	function markChangesSweep(drafts: Drafted<any, ImmerState>[]) {
-		// The natural order of drafts in the `scope` array is based on when they
-		// were accessed. By processing drafts in reverse natural order, we have a
-		// better chance of processing leaf nodes first. When a leaf node is known to
-		// have changed, we can avoid any traversal of its ancestor nodes.
-		for (let i = drafts.length - 1; i >= 0; i--) {
-			const state: ES5State = drafts[i][DRAFT_STATE]
-			if (!state.modified_) {
-				switch (state.type_) {
-					case ProxyType.ES5Array:
-						if (hasArrayChanges(state)) markChanged(state)
-						break
-					case ProxyType.ES5Object:
-						if (hasObjectChanges(state)) markChanged(state)
-						break
-				}
-			}
-		}
-	}
-
-	function markChangesRecursively(object: any) {
-		if (!object || typeof object !== "object") return
-		const state: ES5State | undefined = object[DRAFT_STATE]
-		if (!state) return
-		const {base_, draft_, assigned_, type_} = state
-		if (type_ === ProxyType.ES5Object) {
-			// Look for added keys.
-			// probably there is a faster way to detect changes, as sweep + recurse seems to do some
-			// unnecessary work.
-			// also: probably we can store the information we detect here, to speed up tree finalization!
-			each(draft_, key => {
-				if ((key as any) === DRAFT_STATE) return
-				// The `undefined` check is a fast path for pre-existing keys.
-				if ((base_ as any)[key] === undefined && !has(base_, key)) {
-					assigned_[key] = true
-					markChanged(state)
-				} else if (!assigned_[key]) {
-					// Only untouched properties trigger recursion.
-					markChangesRecursively(draft_[key])
-				}
-			})
-			// Look for removed keys.
-			each(base_, key => {
-				// The `undefined` check is a fast path for pre-existing keys.
-				if (draft_[key] === undefined && !has(draft_, key)) {
-					assigned_[key] = false
-					markChanged(state)
-				}
-			})
-		} else if (type_ === ProxyType.ES5Array) {
-			if (hasArrayChanges(state as ES5ArrayState)) {
-				markChanged(state)
-				assigned_.length = true
-			}
-
-			if (draft_.length < base_.length) {
-				for (let i = draft_.length; i < base_.length; i++) assigned_[i] = false
-			} else {
-				for (let i = base_.length; i < draft_.length; i++) assigned_[i] = true
-			}
-
-			// Minimum count is enough, the other parts has been processed.
-			const min = Math.min(draft_.length, base_.length)
-
-			for (let i = 0; i < min; i++) {
-				// Only untouched indices trigger recursion.
-				if (!draft_.hasOwnProperty(i)) {
-					assigned_[i] = true
-				}
-				if (assigned_[i] === undefined) markChangesRecursively(draft_[i])
-			}
-		}
-	}
-
-	function hasObjectChanges(state: ES5ObjectState) {
-		const {base_, draft_} = state
-
-		// Search for added keys and changed keys. Start at the back, because
-		// non-numeric keys are ordered by time of definition on the object.
-		const keys = ownKeys(draft_)
-		for (let i = keys.length - 1; i >= 0; i--) {
-			const key: any = keys[i]
-			if (key === DRAFT_STATE) continue
-			const baseValue = base_[key]
-			// The `undefined` check is a fast path for pre-existing keys.
-			if (baseValue === undefined && !has(base_, key)) {
-				return true
-			}
-			// Once a base key is deleted, future changes go undetected, because its
-			// descriptor is erased. This branch detects any missed changes.
-			else {
-				const value = draft_[key]
-				const state: ImmerState = value && value[DRAFT_STATE]
-				if (state ? state.base_ !== baseValue : !is(value, baseValue)) {
-					return true
-				}
-			}
-		}
-
-		// At this point, no keys were added or changed.
-		// Compare key count to determine if keys were deleted.
-		const baseIsDraft = !!base_[DRAFT_STATE as any]
-		return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE
-	}
-
-	function hasArrayChanges(state: ES5ArrayState) {
-		const {draft_} = state
-		if (draft_.length !== state.base_.length) return true
-		// See #116
-		// If we first shorten the length, our array interceptors will be removed.
-		// If after that new items are added, result in the same original length,
-		// those last items will have no intercepting property.
-		// So if there is no own descriptor on the last position, we know that items were removed and added
-		// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
-		// the last one
-		// last descriptor can be not a trap, if the array was extended
-		const descriptor = Object.getOwnPropertyDescriptor(
-			draft_,
-			draft_.length - 1
-		)
-		// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)
-		if (descriptor && !descriptor.get) return true
-		// if we miss a property, it has been deleted, so array probobaly changed
-		for (let i = 0; i < draft_.length; i++) {
-			if (!draft_.hasOwnProperty(i)) return true
-		}
-		// For all other cases, we don't have to compare, as they would have been picked up by the index setters
-		return false
-	}
-
-	function hasChanges_(state: ES5State) {
-		return state.type_ === ProxyType.ES5Object
-			? hasObjectChanges(state)
-			: hasArrayChanges(state)
-	}
-
-	function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {
-		if (state.revoked_) die(3, JSON.stringify(latest(state)))
-	}
-
-	loadPlugin("ES5", {
-		createES5Proxy_,
-		willFinalizeES5_,
-		hasChanges_
-	})
+ export function enableES5() {
+    function willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean) {
+        if (!isReplaced) {
+            if (scope.patches_) {
+                markChangesRecursively(scope.drafts_![0]);
+            }
+            // This is faster when we don't care about which attributes changed.
+            markChangesSweep(scope.drafts_);
+        }
+        // When a child draft is returned, look for changes.
+        else if (isDraft(result) &&
+            (result[DRAFT_STATE] as ES5State).scope_ === scope) {
+            markChangesSweep(scope.drafts_);
+        }
+    }
+    
+ function createES5Draft(isArray: boolean, base: any) {
+        if (isArray) {
+            const draft = new Array(base.length);
+            for (let i = 0; i < base.length; i++)
+                Object.defineProperty(draft, "" + i, proxyProperty(i, true));
+            return draft;
+        }
+        else {
+            const descriptors = getOwnPropertyDescriptors(base);
+            delete descriptors[DRAFT_STATE as any];
+            const keys = ownKeys(descriptors);
+            for (let i = 0; i < keys.length; i++) {
+                const key: any = keys[i];
+                descriptors[key] = proxyProperty(key, isArray || !!descriptors[key].enumerable);
+            }
+            return Object.create(Object.getPrototypeOf(base), descriptors);
+        }
+    }
+    
+ function createES5Proxy_<T>(base: T, parent?: ImmerState): Drafted<T, ES5ObjectState | ES5ArrayState> {
+        const isArray = Array.isArray(base);
+        const draft = createES5Draft(isArray, base);
+        
+ const state: ES5ObjectState | ES5ArrayState = {
+            type_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),
+            scope_: parent ? parent.scope_ : getCurrentScope(),
+            modified_: false,
+            finalized_: false,
+            assigned_: {},
+            parent_: parent,
+            // base is the object we are drafting
+            base_: base,
+            // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)
+            draft_: draft,
+            copy_: null,
+            revoked_: false,
+            isManual_: false
+        };
+        
+ Object.defineProperty(draft, DRAFT_STATE, {
+            value: state,
+            // enumerable: false <- the default
+            writable: true
+        });
+        return draft;
+    }
+    
+ // property descriptors are recycled to make sure we don't create a get and set closure per property,
+    // but share them all instead
+    const descriptors: {
+        [prop: string]: PropertyDescriptor;
+    } = {};
+    
+ function proxyProperty(prop: string | number, enumerable: boolean): PropertyDescriptor {
+        let desc = descriptors[prop];
+        if (desc) {
+            desc.enumerable = enumerable;
+        }
+        else {
+            descriptors[prop] = desc = {
+                configurable: true,
+                enumerable,
+                get(this: any) {
+                    const state = this[DRAFT_STATE];
+                    if (__DEV__)
+                        assertUnrevoked(state);
+                    // @ts-ignore
+                    return objectTraps.get(state, prop);
+                },
+                set(this: any, value) {
+                    const state = this[DRAFT_STATE];
+                    if (__DEV__)
+                        assertUnrevoked(state);
+                    // @ts-ignore
+                    objectTraps.set(state, prop, value);
+                }
+            };
+        }
+        return desc;
+    }
+    
+ // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.
+    function markChangesSweep(drafts: Drafted<any, ImmerState>[]) {
+        // The natural order of drafts in the `scope` array is based on when they
+        // were accessed. By processing drafts in reverse natural order, we have a
+        // better chance of processing leaf nodes first. When a leaf node is known to
+        // have changed, we can avoid any traversal of its ancestor nodes.
+        for (let i = drafts.length - 1; i >= 0; i--) {
+            const state: ES5State = drafts[i][DRAFT_STATE];
+            if (!state.modified_) {
+                switch (state.type_) {
+                    case ProxyType.ES5Array:
+                        if (hasArrayChanges(state))
+                            markChanged(state);
+                        break;
+                    case ProxyType.ES5Object:
+                        if (hasObjectChanges(state))
+                            markChanged(state);
+                        break;
+                }
+            }
+        }
+    }
+    
+ function markChangesRecursively(object: any) {
+        if (!object || typeof object !== "object")
+            return;
+        const state: ES5State | undefined = object[DRAFT_STATE];
+        if (!state)
+            return;
+        const { base_, draft_, assigned_, type_ } = state;
+        if (type_ === ProxyType.ES5Object) {
+            // Look for added keys.
+            // probably there is a faster way to detect changes, as sweep + recurse seems to do some
+            // unnecessary work.
+            // also: probably we can store the information we detect here, to speed up tree finalization!
+            each(draft_, key => {
+                if ((key as any) === DRAFT_STATE)
+                    return;
+                // The `undefined` check is a fast path for pre-existing keys.
+                if ((base_ as any)[key] === undefined && !has(base_, key)) {
+                    assigned_[key] = true;
+                    markChanged(state);
+                }
+                else if (!assigned_[key]) {
+                    // Only untouched properties trigger recursion.
+                    markChangesRecursively(draft_[key]);
+                }
+            });
+            // Look for removed keys.
+            each(base_, key => {
+                // The `undefined` check is a fast path for pre-existing keys.
+                if (draft_[key] === undefined && !has(draft_, key)) {
+                    assigned_[key] = false;
+                    markChanged(state);
+                }
+            });
+        }
+        else if (type_ === ProxyType.ES5Array) {
+            if (hasArrayChanges(state as ES5ArrayState)) {
+                markChanged(state);
+                assigned_.length = true;
+            }
+            
+ if (draft_.length < base_.length) {
+                for (let i = draft_.length; i < base_.length; i++)
+                    assigned_[i] = false;
+            }
+            else {
+                for (let i = base_.length; i < draft_.length; i++)
+                    assigned_[i] = true;
+            }
+            
+ // Minimum count is enough, the other parts has been processed.
+            const min = Math.min(draft_.length, base_.length);
+            
+ for (let i = 0; i < min; i++) {
+                // Only untouched indices trigger recursion.
+                if (!draft_.hasOwnProperty(i)) {
+                    assigned_[i] = true;
+                }
+                if (assigned_[i] === undefined)
+                    markChangesRecursively(draft_[i]);
+            }
+        }
+    }
+    
+ function hasObjectChanges(state: ES5ObjectState) {
+        const { base_, draft_ } = state;
+        
+ // Search for added keys and changed keys. Start at the back, because
+        // non-numeric keys are ordered by time of definition on the object.
+        const keys = ownKeys(draft_);
+        for (let i = keys.length - 1; i >= 0; i--) {
+            const key: any = keys[i];
+            if (key === DRAFT_STATE)
+                continue;
+            const baseValue = base_[key];
+            // The `undefined` check is a fast path for pre-existing keys.
+            if (baseValue === undefined && !has(base_, key)) {
+                return true;
+            }
+            // Once a base key is deleted, future changes go undetected, because its
+            // descriptor is erased. This branch detects any missed changes.
+            else {
+                const value = draft_[key];
+                const state: ImmerState = value && value[DRAFT_STATE];
+                if (state ? state.base_ !== baseValue : !is(value, baseValue)) {
+                    return true;
+                }
+            }
+        }
+        
+ // At this point, no keys were added or changed.
+        // Compare key count to determine if keys were deleted.
+        const baseIsDraft = !!base_[DRAFT_STATE as any];
+        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE
+    }
+    
+ function hasArrayChanges(state: ES5ArrayState) {
+        const { draft_ } = state;
+        if (draft_.length !== state.base_.length)
+            return true;
+        // See #116
+        // If we first shorten the length, our array interceptors will be removed.
+        // If after that new items are added, result in the same original length,
+        // those last items will have no intercepting property.
+        // So if there is no own descriptor on the last position, we know that items were removed and added
+        // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
+        // the last one
+        // last descriptor can be not a trap, if the array was extended
+        const descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1);
+        // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)
+        if (descriptor && !descriptor.get)
+            return true;
+        // if we miss a property, it has been deleted, so array probobaly changed
+        for (let i = 0; i < draft_.length; i++) {
+            if (!draft_.hasOwnProperty(i))
+                return true;
+        }
+        // For all other cases, we don't have to compare, as they would have been picked up by the index setters
+        return false;
+    }
+    
+ function hasChanges_(state: ES5State) {
+        return state.type_ === ProxyType.ES5Object
+            ? hasObjectChanges(state)
+            : hasArrayChanges(state);
+    }
+    
+ function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {
+        if (state.revoked_)
+            die(3, JSON.stringify(latest(state)));
+    }
+    
+ loadPlugin("ES5", {
+        createES5Proxy_,
+        willFinalizeES5_,
+        hasChanges_
+    });
 }
diff --git a/src/plugins/mapset.ts b/src/plugins/mapset.ts
index 17dc5ddb80a18964c092c6b15363294c9319cda6..ef8bbea6ea5fc58248e3854fbcf62a128673bef7 100644
--- a/src/plugins/mapset.ts
+++ b/src/plugins/mapset.ts
@@ -1,348 +1,403 @@
 // types only!
-import {
-	ImmerState,
-	AnyMap,
-	AnySet,
-	MapState,
-	SetState,
-	DRAFT_STATE,
-	getCurrentScope,
-	latest,
-	iteratorSymbol,
-	isDraftable,
-	createProxy,
-	loadPlugin,
-	markChanged,
-	ProxyType,
-	die,
-	each
-} from "../internal"
-
-export function enableMapSet() {
-	/* istanbul ignore next */
-	var extendStatics = function(d: any, b: any): any {
-		extendStatics =
-			Object.setPrototypeOf ||
-			({__proto__: []} instanceof Array &&
-				function(d, b) {
-					d.__proto__ = b
-				}) ||
-			function(d, b) {
-				for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
-			}
-		return extendStatics(d, b)
-	}
-
-	// Ugly hack to resolve #502 and inherit built in Map / Set
-	function __extends(d: any, b: any): any {
-		extendStatics(d, b)
-		function __(this: any): any {
-			this.constructor = d
-		}
-		d.prototype =
-			// @ts-ignore
-			((__.prototype = b.prototype), new __())
-	}
-
-	const DraftMap = (function(_super) {
-		__extends(DraftMap, _super)
-		// Create class manually, cause #502
-		function DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {
-			this[DRAFT_STATE] = {
-				type_: ProxyType.Map,
-				parent_: parent,
-				scope_: parent ? parent.scope_ : getCurrentScope()!,
-				modified_: false,
-				finalized_: false,
-				copy_: undefined,
-				assigned_: undefined,
-				base_: target,
-				draft_: this as any,
-				isManual_: false,
-				revoked_: false
-			} as MapState
-			return this
-		}
-		const p = DraftMap.prototype
-
-		Object.defineProperty(p, "size", {
-			get: function() {
-				return latest(this[DRAFT_STATE]).size
-			}
-			// enumerable: false,
-			// configurable: true
-		})
-
-		p.has = function(key: any): boolean {
-			return latest(this[DRAFT_STATE]).has(key)
-		}
-
-		p.set = function(key: any, value: any) {
-			const state: MapState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			if (!latest(state).has(key) || latest(state).get(key) !== value) {
-				prepareMapCopy(state)
-				markChanged(state)
-				state.assigned_!.set(key, true)
-				state.copy_!.set(key, value)
-				state.assigned_!.set(key, true)
-			}
-			return this
-		}
-
-		p.delete = function(key: any): boolean {
-			if (!this.has(key)) {
-				return false
-			}
-
-			const state: MapState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			prepareMapCopy(state)
-			markChanged(state)
-			if (state.base_.has(key)) {
-				state.assigned_!.set(key, false)
-			} else {
-				state.assigned_!.delete(key)
-			}
-			state.copy_!.delete(key)
-			return true
-		}
-
-		p.clear = function() {
-			const state: MapState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			if (latest(state).size) {
-				prepareMapCopy(state)
-				markChanged(state)
-				state.assigned_ = new Map()
-				each(state.base_, key => {
-					state.assigned_!.set(key, false)
-				})
-				state.copy_!.clear()
-			}
-		}
-
-		p.forEach = function(
-			cb: (value: any, key: any, self: any) => void,
-			thisArg?: any
-		) {
-			const state: MapState = this[DRAFT_STATE]
-			latest(state).forEach((_value: any, key: any, _map: any) => {
-				cb.call(thisArg, this.get(key), key, this)
-			})
-		}
-
-		p.get = function(key: any): any {
-			const state: MapState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			const value = latest(state).get(key)
-			if (state.finalized_ || !isDraftable(value)) {
-				return value
-			}
-			if (value !== state.base_.get(key)) {
-				return value // either already drafted or reassigned
-			}
-			// despite what it looks, this creates a draft only once, see above condition
-			const draft = createProxy(state.scope_.immer_, value, state)
-			prepareMapCopy(state)
-			state.copy_!.set(key, draft)
-			return draft
-		}
-
-		p.keys = function(): IterableIterator<any> {
-			return latest(this[DRAFT_STATE]).keys()
-		}
-
-		p.values = function(): IterableIterator<any> {
-			const iterator = this.keys()
-			return {
-				[iteratorSymbol]: () => this.values(),
-				next: () => {
-					const r = iterator.next()
-					/* istanbul ignore next */
-					if (r.done) return r
-					const value = this.get(r.value)
-					return {
-						done: false,
-						value
-					}
-				}
-			} as any
-		}
-
-		p.entries = function(): IterableIterator<[any, any]> {
-			const iterator = this.keys()
-			return {
-				[iteratorSymbol]: () => this.entries(),
-				next: () => {
-					const r = iterator.next()
-					/* istanbul ignore next */
-					if (r.done) return r
-					const value = this.get(r.value)
-					return {
-						done: false,
-						value: [r.value, value]
-					}
-				}
-			} as any
-		}
-
-		p[iteratorSymbol] = function() {
-			return this.entries()
-		}
-
-		return DraftMap
-	})(Map)
-
-	function proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {
-		// @ts-ignore
-		return new DraftMap(target, parent)
-	}
-
-	function prepareMapCopy(state: MapState) {
-		if (!state.copy_) {
-			state.assigned_ = new Map()
-			state.copy_ = new Map(state.base_)
-		}
-	}
-
-	const DraftSet = (function(_super) {
-		__extends(DraftSet, _super)
-		// Create class manually, cause #502
-		function DraftSet(this: any, target: AnySet, parent?: ImmerState) {
-			this[DRAFT_STATE] = {
-				type_: ProxyType.Set,
-				parent_: parent,
-				scope_: parent ? parent.scope_ : getCurrentScope()!,
-				modified_: false,
-				finalized_: false,
-				copy_: undefined,
-				base_: target,
-				draft_: this,
-				drafts_: new Map(),
-				revoked_: false,
-				isManual_: false
-			} as SetState
-			return this
-		}
-		const p = DraftSet.prototype
-
-		Object.defineProperty(p, "size", {
-			get: function() {
-				return latest(this[DRAFT_STATE]).size
-			}
-			// enumerable: true,
-		})
-
-		p.has = function(value: any): boolean {
-			const state: SetState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			// bit of trickery here, to be able to recognize both the value, and the draft of its value
-			if (!state.copy_) {
-				return state.base_.has(value)
-			}
-			if (state.copy_.has(value)) return true
-			if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))
-				return true
-			return false
-		}
-
-		p.add = function(value: any): any {
-			const state: SetState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			if (!this.has(value)) {
-				prepareSetCopy(state)
-				markChanged(state)
-				state.copy_!.add(value)
-			}
-			return this
-		}
-
-		p.delete = function(value: any): any {
-			if (!this.has(value)) {
-				return false
-			}
-
-			const state: SetState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			prepareSetCopy(state)
-			markChanged(state)
-			return (
-				state.copy_!.delete(value) ||
-				(state.drafts_.has(value)
-					? state.copy_!.delete(state.drafts_.get(value))
-					: /* istanbul ignore next */ false)
-			)
-		}
-
-		p.clear = function() {
-			const state: SetState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			if (latest(state).size) {
-				prepareSetCopy(state)
-				markChanged(state)
-				state.copy_!.clear()
-			}
-		}
-
-		p.values = function(): IterableIterator<any> {
-			const state: SetState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			prepareSetCopy(state)
-			return state.copy_!.values()
-		}
-
-		p.entries = function entries(): IterableIterator<[any, any]> {
-			const state: SetState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			prepareSetCopy(state)
-			return state.copy_!.entries()
-		}
-
-		p.keys = function(): IterableIterator<any> {
-			return this.values()
-		}
-
-		p[iteratorSymbol] = function() {
-			return this.values()
-		}
-
-		p.forEach = function forEach(cb: any, thisArg?: any) {
-			const iterator = this.values()
-			let result = iterator.next()
-			while (!result.done) {
-				cb.call(thisArg, result.value, result.value, this)
-				result = iterator.next()
-			}
-		}
-
-		return DraftSet
-	})(Set)
-
-	function proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {
-		// @ts-ignore
-		return new DraftSet(target, parent)
-	}
-
-	function prepareSetCopy(state: SetState) {
-		if (!state.copy_) {
-			// create drafts for all entries to preserve insertion order
-			state.copy_ = new Set()
-			state.base_.forEach(value => {
-				if (isDraftable(value)) {
-					const draft = createProxy(state.scope_.immer_, value, state)
-					state.drafts_.set(value, draft)
-					state.copy_!.add(draft)
-				} else {
-					state.copy_!.add(value)
-				}
-			})
-		}
-	}
-
-	function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {
-		if (state.revoked_) die(3, JSON.stringify(latest(state)))
-	}
-
-	loadPlugin("MapSet", {proxyMap_, proxySet_})
+import { ImmerState, AnyMap, AnySet, MapState, SetState, DRAFT_STATE, getCurrentScope, latest, iteratorSymbol, isDraftable, createProxy, loadPlugin, markChanged, ProxyType, die, each } from "../internal.js";
+
+ export function enableMapSet() {
+    /* istanbul ignore next */
+    var extendStatics = function (d: any, b: any): any {
+        extendStatics =
+            Object.setPrototypeOf ||
+                ({ __proto__: [] } instanceof Array &&
+                    function (d, b) {
+                        d.__proto__ = b;
+                    }) ||
+                function (d, b) {
+                    for (var p in b)
+                        if (b.hasOwnProperty(p))
+                            d[p] = b[p];
+                };
+        return extendStatics(d, b);
+    };
+    
+ // Ugly hack to resolve #502 and inherit built in Map / Set
+    function __extends(d: any, b: any): any {
+        extendStatics(d, b);
+        function __(this: any): any {
+            Object.defineProperty(this, "constructor", {
+                value: d
+            });
+        }
+        d.prototype =
+            // @ts-ignore
+            ((__.prototype = b.prototype), new __());
+    }
+    
+ const DraftMap = (function (_super) {
+        __extends(DraftMap, _super);
+        // Create class manually, cause #502
+        function DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {
+            this[DRAFT_STATE] = {
+                type_: ProxyType.Map,
+                parent_: parent,
+                scope_: parent ? parent.scope_ : getCurrentScope()!,
+                modified_: false,
+                finalized_: false,
+                copy_: undefined,
+                assigned_: undefined,
+                base_: target,
+                draft_: this as any,
+                isManual_: false,
+                revoked_: false
+            } as MapState;
+            return this;
+        }
+        const p = DraftMap.prototype;
+        
+ Object.defineProperties(p, {
+            size: {
+                get: function () {
+                    return latest(this[DRAFT_STATE]).size;
+                },
+                configurable: true
+            },
+            has: {
+                configurable: true,
+                writable: true,
+                value: function (key: any): boolean {
+                    return latest(this[DRAFT_STATE]).has(key);
+                }
+            },
+            set: {
+                configurable: true,
+                writable: true,
+                value: function (key: any, value: any) {
+                    const state: MapState = this[DRAFT_STATE];
+                    assertUnrevoked(state);
+                    if (!latest(state).has(key) || latest(state).get(key) !== value) {
+                        prepareMapCopy(state);
+                        markChanged(state);
+                        state.assigned_!.set(key, true);
+                        state.copy_!.set(key, value);
+                        state.assigned_!.set(key, true);
+                    }
+                    return this;
+                }
+            },
+            delete: {
+                configurable: true,
+                writable: true,
+                value: function (key: any): boolean {
+                    if (!this.has(key)) {
+                        return false;
+                    }
+                    
+ const state: MapState = this[DRAFT_STATE];
+                    assertUnrevoked(state);
+                    prepareMapCopy(state);
+                    markChanged(state);
+                    if (state.base_.has(key)) {
+                        state.assigned_!.set(key, false);
+                    }
+                    else {
+                        state.assigned_!.delete(key);
+                    }
+                    state.copy_!.delete(key);
+                    return true;
+                }
+            },
+            clear: {
+                configurable: true,
+                writable: true,
+                value: function () {
+                    const state: MapState = this[DRAFT_STATE];
+                    assertUnrevoked(state);
+                    if (latest(state).size) {
+                        prepareMapCopy(state);
+                        markChanged(state);
+                        state.assigned_ = new Map();
+                        each(state.base_, key => {
+                            state.assigned_!.set(key, false);
+                        });
+                        state.copy_!.clear();
+                    }
+                }
+            },
+            forEach: {
+                configurable: true,
+                writable: true,
+                value: function (cb: (value: any, key: any, self: any) => void, thisArg?: any) {
+                    const state: MapState = this[DRAFT_STATE];
+                    latest(state).forEach((_value: any, key: any, _map: any) => {
+                        cb.call(thisArg, this.get(key), key, this);
+                    });
+                }
+            },
+            get: {
+                configurable: true,
+                writable: true,
+                value: function (key: any): any {
+                    const state: MapState = this[DRAFT_STATE];
+                    assertUnrevoked(state);
+                    const value = latest(state).get(key);
+                    if (state.finalized_ || !isDraftable(value)) {
+                        return value;
+                    }
+                    if (value !== state.base_.get(key)) {
+                        return value; // either already drafted or reassigned
+                    }
+                    // despite what it looks, this creates a draft only once, see above condition
+                    const draft = createProxy(state.scope_.immer_, value, state);
+                    prepareMapCopy(state);
+                    state.copy_!.set(key, draft);
+                    return draft;
+                }
+            },
+            keys: {
+                configurable: true,
+                writable: true,
+                value: function (): IterableIterator<any> {
+                    return latest(this[DRAFT_STATE]).keys();
+                }
+            },
+            values: {
+                configurable: true,
+                writable: true,
+                value: function (): IterableIterator<any> {
+                    const iterator = this.keys();
+                    return {
+                        [iteratorSymbol]: () => this.values(),
+                        next: () => {
+                            const r = iterator.next();
+                            /* istanbul ignore next */
+                            if (r.done)
+                                return r;
+                            const value = this.get(r.value);
+                            return {
+                                done: false,
+                                value
+                            };
+                        }
+                    } as any;
+                }
+            },
+            entries: {
+                configurable: true,
+                writable: true,
+                value: function (): IterableIterator<[
+                    any,
+                    any
+                ]> {
+                    const iterator = this.keys();
+                    return {
+                        [iteratorSymbol]: () => this.entries(),
+                        next: () => {
+                            const r = iterator.next();
+                            /* istanbul ignore next */
+                            if (r.done)
+                                return r;
+                            const value = this.get(r.value);
+                            return {
+                                done: false,
+                                value: [r.value, value]
+                            };
+                        }
+                    } as any;
+                }
+            },
+            [iteratorSymbol]: {
+                configurable: true,
+                writable: true,
+                value: function () {
+                    return this.entries();
+                }
+            }
+        });
+        
+ return DraftMap;
+    })(Map);
+    
+ function proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {
+        // @ts-ignore
+        return new DraftMap(target, parent);
+    }
+    
+ function prepareMapCopy(state: MapState) {
+        if (!state.copy_) {
+            state.assigned_ = new Map();
+            state.copy_ = new Map(state.base_);
+        }
+    }
+    
+ const DraftSet = (function (_super) {
+        __extends(DraftSet, _super);
+        // Create class manually, cause #502
+        function DraftSet(this: any, target: AnySet, parent?: ImmerState) {
+            this[DRAFT_STATE] = {
+                type_: ProxyType.Set,
+                parent_: parent,
+                scope_: parent ? parent.scope_ : getCurrentScope()!,
+                modified_: false,
+                finalized_: false,
+                copy_: undefined,
+                base_: target,
+                draft_: this,
+                drafts_: new Map(),
+                revoked_: false,
+                isManual_: false
+            } as SetState;
+            return this;
+        }
+        const p = DraftSet.prototype;
+        
+ Object.defineProperties(p, {
+            size: {
+                get: function () {
+                    return latest(this[DRAFT_STATE]).size;
+                },
+                configurable: true
+            },
+            has: {
+                configurable: true,
+                writable: true,
+                value: function (value: any): boolean {
+                    const state: SetState = this[DRAFT_STATE];
+                    assertUnrevoked(state);
+                    // bit of trickery here, to be able to recognize both the value, and the draft of its value
+                    if (!state.copy_) {
+                        return state.base_.has(value);
+                    }
+                    if (state.copy_.has(value))
+                        return true;
+                    if (state.drafts_.has(value) &&
+                        state.copy_.has(state.drafts_.get(value)))
+                        return true;
+                    return false;
+                }
+            },
+            add: {
+                configurable: true,
+                writable: true,
+                value: function (value: any): any {
+                    const state: SetState = this[DRAFT_STATE];
+                    assertUnrevoked(state);
+                    if (!this.has(value)) {
+                        prepareSetCopy(state);
+                        markChanged(state);
+                        state.copy_!.add(value);
+                    }
+                    return this;
+                }
+            },
+            delete: {
+                configurable: true,
+                writable: true,
+                value: function (value: any): any {
+                    if (!this.has(value)) {
+                        return false;
+                    }
+                    
+ const state: SetState = this[DRAFT_STATE];
+                    assertUnrevoked(state);
+                    prepareSetCopy(state);
+                    markChanged(state);
+                    return (state.copy_!.delete(value) ||
+                        (state.drafts_.has(value)
+                            ? state.copy_!.delete(state.drafts_.get(value))
+                            : /* istanbul ignore next */ false));
+                }
+            },
+            clear: {
+                configurable: true,
+                writable: true,
+                value: function () {
+                    const state: SetState = this[DRAFT_STATE];
+                    assertUnrevoked(state);
+                    if (latest(state).size) {
+                        prepareSetCopy(state);
+                        markChanged(state);
+                        state.copy_!.clear();
+                    }
+                }
+            },
+            values: {
+                configurable: true,
+                writable: true,
+                value: function (): IterableIterator<any> {
+                    const state: SetState = this[DRAFT_STATE];
+                    assertUnrevoked(state);
+                    prepareSetCopy(state);
+                    return state.copy_!.values();
+                }
+            },
+            entries: {
+                configurable: true,
+                writable: true,
+                value: function entries(): IterableIterator<[
+                    any,
+                    any
+                ]> {
+                    const state: SetState = this[DRAFT_STATE];
+                    assertUnrevoked(state);
+                    prepareSetCopy(state);
+                    return state.copy_!.entries();
+                }
+            },
+            keys: {
+                configurable: true,
+                writable: true,
+                value: function (): IterableIterator<any> {
+                    return this.values();
+                }
+            },
+            [iteratorSymbol]: {
+                configurable: true,
+                writable: true,
+                value: function () {
+                    return this.values();
+                }
+            },
+            forEach: {
+                configurable: true,
+                writable: true,
+                value: function forEach(cb: any, thisArg?: any) {
+                    const iterator = this.values();
+                    let result = iterator.next();
+                    while (!result.done) {
+                        cb.call(thisArg, result.value, result.value, this);
+                        result = iterator.next();
+                    }
+                }
+            }
+        });
+        
+ return DraftSet;
+    })(Set);
+    
+ function proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {
+        // @ts-ignore
+        return new DraftSet(target, parent);
+    }
+    
+ function prepareSetCopy(state: SetState) {
+        if (!state.copy_) {
+            // create drafts for all entries to preserve insertion order
+            state.copy_ = new Set();
+            state.base_.forEach(value => {
+                if (isDraftable(value)) {
+                    const draft = createProxy(state.scope_.immer_, value, state);
+                    state.drafts_.set(value, draft);
+                    state.copy_!.add(draft);
+                }
+                else {
+                    state.copy_!.add(value);
+                }
+            });
+        }
+    }
+    
+ function assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {
+        if (state.revoked_)
+            die(3, JSON.stringify(latest(state)));
+    }
+    
+ loadPlugin("MapSet", { proxyMap_, proxySet_ });
 }
diff --git a/src/plugins/patches.ts b/src/plugins/patches.ts
index 08fe9141d422dfb38d008440741d9b90c70a301a..e1aa31089b4615007a6dd450c872a84cf337c45d 100644
--- a/src/plugins/patches.ts
+++ b/src/plugins/patches.ts
@@ -1,301 +1,248 @@
-import {immerable} from "../immer"
-import {
-	ImmerState,
-	Patch,
-	SetState,
-	ES5ArrayState,
-	ProxyArrayState,
-	MapState,
-	ES5ObjectState,
-	ProxyObjectState,
-	PatchPath,
-	get,
-	each,
-	has,
-	getArchtype,
-	isSet,
-	isMap,
-	loadPlugin,
-	ProxyType,
-	Archtype,
-	die,
-	isDraft,
-	isDraftable,
-	NOTHING
-} from "../internal"
-
-export function enablePatches() {
-	const REPLACE = "replace"
-	const ADD = "add"
-	const REMOVE = "remove"
-
-	function generatePatches_(
-		state: ImmerState,
-		basePath: PatchPath,
-		patches: Patch[],
-		inversePatches: Patch[]
-	): void {
-		switch (state.type_) {
-			case ProxyType.ProxyObject:
-			case ProxyType.ES5Object:
-			case ProxyType.Map:
-				return generatePatchesFromAssigned(
-					state,
-					basePath,
-					patches,
-					inversePatches
-				)
-			case ProxyType.ES5Array:
-			case ProxyType.ProxyArray:
-				return generateArrayPatches(state, basePath, patches, inversePatches)
-			case ProxyType.Set:
-				return generateSetPatches(
-					(state as any) as SetState,
-					basePath,
-					patches,
-					inversePatches
-				)
-		}
-	}
-
-	function generateArrayPatches(
-		state: ES5ArrayState | ProxyArrayState,
-		basePath: PatchPath,
-		patches: Patch[],
-		inversePatches: Patch[]
-	) {
-		let {base_, assigned_} = state
-		let copy_ = state.copy_!
-
-		// Reduce complexity by ensuring `base` is never longer.
-		if (copy_.length < base_.length) {
-			// @ts-ignore
-			;[base_, copy_] = [copy_, base_]
-			;[patches, inversePatches] = [inversePatches, patches]
-		}
-
-		// Process replaced indices.
-		for (let i = 0; i < base_.length; i++) {
-			if (assigned_[i] && copy_[i] !== base_[i]) {
-				const path = basePath.concat([i])
-				patches.push({
-					op: REPLACE,
-					path,
-					// Need to maybe clone it, as it can in fact be the original value
-					// due to the base/copy inversion at the start of this function
-					value: clonePatchValueIfNeeded(copy_[i])
-				})
-				inversePatches.push({
-					op: REPLACE,
-					path,
-					value: clonePatchValueIfNeeded(base_[i])
-				})
-			}
-		}
-
-		// Process added indices.
-		for (let i = base_.length; i < copy_.length; i++) {
-			const path = basePath.concat([i])
-			patches.push({
-				op: ADD,
-				path,
-				// Need to maybe clone it, as it can in fact be the original value
-				// due to the base/copy inversion at the start of this function
-				value: clonePatchValueIfNeeded(copy_[i])
-			})
-		}
-		if (base_.length < copy_.length) {
-			inversePatches.push({
-				op: REPLACE,
-				path: basePath.concat(["length"]),
-				value: base_.length
-			})
-		}
-	}
-
-	// This is used for both Map objects and normal objects.
-	function generatePatchesFromAssigned(
-		state: MapState | ES5ObjectState | ProxyObjectState,
-		basePath: PatchPath,
-		patches: Patch[],
-		inversePatches: Patch[]
-	) {
-		const {base_, copy_} = state
-		each(state.assigned_!, (key, assignedValue) => {
-			const origValue = get(base_, key)
-			const value = get(copy_!, key)
-			const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD
-			if (origValue === value && op === REPLACE) return
-			const path = basePath.concat(key as any)
-			patches.push(op === REMOVE ? {op, path} : {op, path, value})
-			inversePatches.push(
-				op === ADD
-					? {op: REMOVE, path}
-					: op === REMOVE
-					? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}
-					: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}
-			)
-		})
-	}
-
-	function generateSetPatches(
-		state: SetState,
-		basePath: PatchPath,
-		patches: Patch[],
-		inversePatches: Patch[]
-	) {
-		let {base_, copy_} = state
-
-		let i = 0
-		base_.forEach((value: any) => {
-			if (!copy_!.has(value)) {
-				const path = basePath.concat([i])
-				patches.push({
-					op: REMOVE,
-					path,
-					value
-				})
-				inversePatches.unshift({
-					op: ADD,
-					path,
-					value
-				})
-			}
-			i++
-		})
-		i = 0
-		copy_!.forEach((value: any) => {
-			if (!base_.has(value)) {
-				const path = basePath.concat([i])
-				patches.push({
-					op: ADD,
-					path,
-					value
-				})
-				inversePatches.unshift({
-					op: REMOVE,
-					path,
-					value
-				})
-			}
-			i++
-		})
-	}
-
-	function generateReplacementPatches_(
-		baseValue: any,
-		replacement: any,
-		patches: Patch[],
-		inversePatches: Patch[]
-	): void {
-		patches.push({
-			op: REPLACE,
-			path: [],
-			value: replacement === NOTHING ? undefined : replacement
-		})
-		inversePatches.push({
-			op: REPLACE,
-			path: [],
-			value: baseValue
-		})
-	}
-
-	function applyPatches_<T>(draft: T, patches: Patch[]): T {
-		patches.forEach(patch => {
-			const {path, op} = patch
-
-			let base: any = draft
-			for (let i = 0; i < path.length - 1; i++) {
-				const parentType = getArchtype(base)
-				const p = "" + path[i]
-				// See #738, avoid prototype pollution
-				if (
-					(parentType === Archtype.Object || parentType === Archtype.Array) &&
-					(p === "__proto__" || p === "constructor")
-				)
-					die(24)
-				if (typeof base === "function" && p === "prototype") die(24)
-				base = get(base, p)
-				if (typeof base !== "object") die(15, path.join("/"))
-			}
-
-			const type = getArchtype(base)
-			const value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411
-			const key = path[path.length - 1]
-			switch (op) {
-				case REPLACE:
-					switch (type) {
-						case Archtype.Map:
-							return base.set(key, value)
-						/* istanbul ignore next */
-						case Archtype.Set:
-							die(16)
-						default:
-							// if value is an object, then it's assigned by reference
-							// in the following add or remove ops, the value field inside the patch will also be modifyed
-							// so we use value from the cloned patch
-							// @ts-ignore
-							return (base[key] = value)
-					}
-				case ADD:
-					switch (type) {
-						case Archtype.Array:
-							return key === "-"
-								? base.push(value)
-								: base.splice(key as any, 0, value)
-						case Archtype.Map:
-							return base.set(key, value)
-						case Archtype.Set:
-							return base.add(value)
-						default:
-							return (base[key] = value)
-					}
-				case REMOVE:
-					switch (type) {
-						case Archtype.Array:
-							return base.splice(key as any, 1)
-						case Archtype.Map:
-							return base.delete(key)
-						case Archtype.Set:
-							return base.delete(patch.value)
-						default:
-							return delete base[key]
-					}
-				default:
-					die(17, op)
-			}
-		})
-
-		return draft
-	}
-
-	// optimize: this is quite a performance hit, can we detect intelligently when it is needed?
-	// E.g. auto-draft when new objects from outside are assigned and modified?
-	// (See failing test when deepClone just returns obj)
-	function deepClonePatchValue<T>(obj: T): T
-	function deepClonePatchValue(obj: any) {
-		if (!isDraftable(obj)) return obj
-		if (Array.isArray(obj)) return obj.map(deepClonePatchValue)
-		if (isMap(obj))
-			return new Map(
-				Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])
-			)
-		if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))
-		const cloned = Object.create(Object.getPrototypeOf(obj))
-		for (const key in obj) cloned[key] = deepClonePatchValue(obj[key])
-		if (has(obj, immerable)) cloned[immerable] = obj[immerable]
-		return cloned
-	}
-
-	function clonePatchValueIfNeeded<T>(obj: T): T {
-		if (isDraft(obj)) {
-			return deepClonePatchValue(obj)
-		} else return obj
-	}
-
-	loadPlugin("Patches", {
-		applyPatches_,
-		generatePatches_,
-		generateReplacementPatches_
-	})
+import { immerable } from "../immer.js";
+import { ImmerState, Patch, SetState, ES5ArrayState, ProxyArrayState, MapState, ES5ObjectState, ProxyObjectState, PatchPath, get, each, has, getArchtype, isSet, isMap, loadPlugin, ProxyType, Archtype, die, isDraft, isDraftable, NOTHING } from "../internal.js";
+
+ export function enablePatches() {
+    const REPLACE = "replace";
+    const ADD = "add";
+    const REMOVE = "remove";
+    
+ function generatePatches_(state: ImmerState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]): void {
+        switch (state.type_) {
+            case ProxyType.ProxyObject:
+            case ProxyType.ES5Object:
+            case ProxyType.Map:
+                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
+            case ProxyType.ES5Array:
+            case ProxyType.ProxyArray:
+                return generateArrayPatches(state, basePath, patches, inversePatches);
+            case ProxyType.Set:
+                return generateSetPatches((state as any) as SetState, basePath, patches, inversePatches);
+        }
+    }
+    
+ function generateArrayPatches(state: ES5ArrayState | ProxyArrayState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {
+        let { base_, assigned_ } = state;
+        let copy_ = state.copy_!;
+        
+ // Reduce complexity by ensuring `base` is never longer.
+        if (copy_.length < base_.length) {
+            // @ts-ignore
+            ;
+            [base_, copy_] = [copy_, base_];
+            [patches, inversePatches] = [inversePatches, patches];
+        }
+        
+ // Process replaced indices.
+        for (let i = 0; i < base_.length; i++) {
+            if (assigned_[i] && copy_[i] !== base_[i]) {
+                const path = basePath.concat([i]);
+                patches.push({
+                    op: REPLACE,
+                    path,
+                    // Need to maybe clone it, as it can in fact be the original value
+                    // due to the base/copy inversion at the start of this function
+                    value: clonePatchValueIfNeeded(copy_[i])
+                });
+                inversePatches.push({
+                    op: REPLACE,
+                    path,
+                    value: clonePatchValueIfNeeded(base_[i])
+                });
+            }
+        }
+        
+ // Process added indices.
+        for (let i = base_.length; i < copy_.length; i++) {
+            const path = basePath.concat([i]);
+            patches.push({
+                op: ADD,
+                path,
+                // Need to maybe clone it, as it can in fact be the original value
+                // due to the base/copy inversion at the start of this function
+                value: clonePatchValueIfNeeded(copy_[i])
+            });
+        }
+        if (base_.length < copy_.length) {
+            inversePatches.push({
+                op: REPLACE,
+                path: basePath.concat(["length"]),
+                value: base_.length
+            });
+        }
+    }
+    
+ // This is used for both Map objects and normal objects.
+    function generatePatchesFromAssigned(state: MapState | ES5ObjectState | ProxyObjectState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {
+        const { base_, copy_ } = state;
+        each(state.assigned_!, (key, assignedValue) => {
+            const origValue = get(base_, key);
+            const value = get(copy_!, key);
+            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
+            if (origValue === value && op === REPLACE)
+                return;
+            const path = basePath.concat(key as any);
+            patches.push(op === REMOVE ? { op, path } : { op, path, value });
+            inversePatches.push(op === ADD
+                ? { op: REMOVE, path }
+                : op === REMOVE
+                    ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) }
+                    : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) });
+        });
+    }
+    
+ function generateSetPatches(state: SetState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]) {
+        let { base_, copy_ } = state;
+        
+ let i = 0;
+        base_.forEach((value: any) => {
+            if (!copy_!.has(value)) {
+                const path = basePath.concat([i]);
+                patches.push({
+                    op: REMOVE,
+                    path,
+                    value
+                });
+                inversePatches.unshift({
+                    op: ADD,
+                    path,
+                    value
+                });
+            }
+            i++;
+        });
+        i = 0;
+        copy_!.forEach((value: any) => {
+            if (!base_.has(value)) {
+                const path = basePath.concat([i]);
+                patches.push({
+                    op: ADD,
+                    path,
+                    value
+                });
+                inversePatches.unshift({
+                    op: REMOVE,
+                    path,
+                    value
+                });
+            }
+            i++;
+        });
+    }
+    
+ function generateReplacementPatches_(baseValue: any, replacement: any, patches: Patch[], inversePatches: Patch[]): void {
+        patches.push({
+            op: REPLACE,
+            path: [],
+            value: replacement === NOTHING ? undefined : replacement
+        });
+        inversePatches.push({
+            op: REPLACE,
+            path: [],
+            value: baseValue
+        });
+    }
+    
+ function applyPatches_<T>(draft: T, patches: Patch[]): T {
+        patches.forEach(patch => {
+            const { path, op } = patch;
+            
+ let base: any = draft;
+            for (let i = 0; i < path.length - 1; i++) {
+                const parentType = getArchtype(base);
+                const p = "" + path[i];
+                // See #738, avoid prototype pollution
+                if ((parentType === Archtype.Object || parentType === Archtype.Array) &&
+                    (p === "__proto__" || p === "constructor"))
+                    die(24);
+                if (typeof base === "function" && p === "prototype")
+                    die(24);
+                base = get(base, p);
+                if (typeof base !== "object")
+                    die(15, path.join("/"));
+            }
+            
+ const type = getArchtype(base);
+            const value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411
+            const key = path[path.length - 1];
+            switch (op) {
+                case REPLACE:
+                    switch (type) {
+                        case Archtype.Map:
+                            return base.set(key, value);
+                        /* istanbul ignore next */
+                        case Archtype.Set:
+                            die(16);
+                        default:
+                            // if value is an object, then it's assigned by reference
+                            // in the following add or remove ops, the value field inside the patch will also be modifyed
+                            // so we use value from the cloned patch
+                            // @ts-ignore
+                            return (base[key] = value);
+                    }
+                case ADD:
+                    switch (type) {
+                        case Archtype.Array:
+                            return key === "-"
+                                ? base.push(value)
+                                : base.splice(key as any, 0, value);
+                        case Archtype.Map:
+                            return base.set(key, value);
+                        case Archtype.Set:
+                            return base.add(value);
+                        default:
+                            return (base[key] = value);
+                    }
+                case REMOVE:
+                    switch (type) {
+                        case Archtype.Array:
+                            return base.splice(key as any, 1);
+                        case Archtype.Map:
+                            return base.delete(key);
+                        case Archtype.Set:
+                            return base.delete(patch.value);
+                        default:
+                            return delete base[key];
+                    }
+                default:
+                    die(17, op);
+            }
+        });
+        
+ return draft;
+    }
+    
+ // optimize: this is quite a performance hit, can we detect intelligently when it is needed?
+    // E.g. auto-draft when new objects from outside are assigned and modified?
+    // (See failing test when deepClone just returns obj)
+    function deepClonePatchValue<T>(obj: T): T;
+    function deepClonePatchValue(obj: any) {
+        if (!isDraftable(obj))
+            return obj;
+        if (Array.isArray(obj))
+            return obj.map(deepClonePatchValue);
+        if (isMap(obj))
+            return new Map(Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)]));
+        if (isSet(obj))
+            return new Set(Array.from(obj).map(deepClonePatchValue));
+        const cloned = Object.create(Object.getPrototypeOf(obj));
+        for (const key in obj)
+            cloned[key] = deepClonePatchValue(obj[key]);
+        if (has(obj, immerable))
+            cloned[immerable] = obj[immerable];
+        return cloned;
+    }
+    
+ function clonePatchValueIfNeeded<T>(obj: T): T {
+        if (isDraft(obj)) {
+            return deepClonePatchValue(obj);
+        }
+        else
+            return obj;
+    }
+    
+ loadPlugin("Patches", {
+        applyPatches_,
+        generatePatches_,
+        generateReplacementPatches_
+    });
 }
diff --git a/src/types/types-external.ts b/src/types/types-external.ts
index c125e298be905f5ad109aca973e3c8ef8aef7cf7..28f73a4b4ee229e076c9d38297d9b865e5741ba1 100644
--- a/src/types/types-external.ts
+++ b/src/types/types-external.ts
@@ -1,159 +1,93 @@
-import {Nothing} from "../internal"
+import { Nothing } from "../internal.js";
 
-type AnyFunc = (...args: any[]) => any
+ type AnyFunc = (...args: any[]) => any;
 
-type PrimitiveType = number | string | boolean
+ type PrimitiveType = number | string | boolean;
 
-/** Object types that should never be mapped */
-type AtomicObject = Function | Promise<any> | Date | RegExp
+ /** Object types that should never be mapped */
+type AtomicObject = Function | Promise<any> | Date | RegExp;
 
-/**
+ /**
  * If the lib "ES2015.Collection" is not included in tsconfig.json,
  * types like ReadonlyArray, WeakMap etc. fall back to `any` (specified nowhere)
  * or `{}` (from the node types), in both cases entering an infinite recursion in
  * pattern matching type mappings
  * This type can be used to cast these types to `void` in these cases.
  */
-export type IfAvailable<T, Fallback = void> =
-	// fallback if any
-	true | false extends (T extends never
-	? true
-	: false)
-		? Fallback // fallback if empty type
-		: keyof T extends never
-		? Fallback // original type
-		: T
+export type IfAvailable<T, Fallback = void> = 
+// fallback if any
+true | false extends (T extends never ? true : false) ? Fallback // fallback if empty type
+ : keyof T extends never ? Fallback // original type
+ : T;
 
-/**
+ /**
  * These should also never be mapped but must be tested after regular Map and
  * Set
  */
-type WeakReferences = IfAvailable<WeakMap<any, any>> | IfAvailable<WeakSet<any>>
-
-export type WritableDraft<T> = {-readonly [K in keyof T]: Draft<T[K]>}
-
-/** Convert a readonly type into a mutable type, if possible */
-export type Draft<T> = T extends PrimitiveType
-	? T
-	: T extends AtomicObject
-	? T
-	: T extends IfAvailable<ReadonlyMap<infer K, infer V>> // Map extends ReadonlyMap
-	? Map<Draft<K>, Draft<V>>
-	: T extends IfAvailable<ReadonlySet<infer V>> // Set extends ReadonlySet
-	? Set<Draft<V>>
-	: T extends WeakReferences
-	? T
-	: T extends object
-	? WritableDraft<T>
-	: T
-
-/** Convert a mutable type into a readonly type */
-export type Immutable<T> = T extends PrimitiveType
-	? T
-	: T extends AtomicObject
-	? T
-	: T extends IfAvailable<ReadonlyMap<infer K, infer V>> // Map extends ReadonlyMap
-	? ReadonlyMap<Immutable<K>, Immutable<V>>
-	: T extends IfAvailable<ReadonlySet<infer V>> // Set extends ReadonlySet
-	? ReadonlySet<Immutable<V>>
-	: T extends WeakReferences
-	? T
-	: T extends object
-	? {readonly [K in keyof T]: Immutable<T[K]>}
-	: T
-
-export interface Patch {
-	op: "replace" | "remove" | "add"
-	path: (string | number)[]
-	value?: any
+type WeakReferences = IfAvailable<WeakMap<any, any>> | IfAvailable<WeakSet<any>>;
+
+ export type WritableDraft<T> = {
+    -readonly [K in keyof T]: Draft<T[K]>;
+};
+
+ /** Convert a readonly type into a mutable type, if possible */
+export type Draft<T> = T extends PrimitiveType ? T : T extends AtomicObject ? T : T extends IfAvailable<ReadonlyMap<infer K, infer V>> // Map extends ReadonlyMap
+ ? Map<Draft<K>, Draft<V>> : T extends IfAvailable<ReadonlySet<infer V>> // Set extends ReadonlySet
+ ? Set<Draft<V>> : T extends WeakReferences ? T : T extends object ? WritableDraft<T> : T;
+
+ /** Convert a mutable type into a readonly type */
+export type Immutable<T> = T extends PrimitiveType ? T : T extends AtomicObject ? T : T extends IfAvailable<ReadonlyMap<infer K, infer V>> // Map extends ReadonlyMap
+ ? ReadonlyMap<Immutable<K>, Immutable<V>> : T extends IfAvailable<ReadonlySet<infer V>> // Set extends ReadonlySet
+ ? ReadonlySet<Immutable<V>> : T extends WeakReferences ? T : T extends object ? {
+    readonly [K in keyof T]: Immutable<T[K]>;
+} : T;
+
+ export interface Patch {
+    op: "replace" | "remove" | "add";
+    path: (string | number)[];
+    value?: any;
 }
 
-export type PatchListener = (patches: Patch[], inversePatches: Patch[]) => void
+ export type PatchListener = (patches: Patch[], inversePatches: Patch[]) => void;
 
-/** Converts `nothing` into `undefined` */
-type FromNothing<T> = T extends Nothing ? undefined : T
+ /** Converts `nothing` into `undefined` */
+type FromNothing<T> = T extends Nothing ? undefined : T;
 
-/** The inferred return type of `produce` */
-export type Produced<Base, Return> = Return extends void
-	? Base
-	: Return extends Promise<infer Result>
-	? Promise<Result extends void ? Base : FromNothing<Result>>
-	: FromNothing<Return>
+ /** The inferred return type of `produce` */
+export type Produced<Base, Return> = Return extends void ? Base : Return extends Promise<infer Result> ? Promise<Result extends void ? Base : FromNothing<Result>> : FromNothing<Return>;
 
-/**
+ /**
  * Utility types
  */
-type PatchesTuple<T> = readonly [T, Patch[], Patch[]]
+type PatchesTuple<T> = readonly [
+    T,
+    Patch[],
+    Patch[]
+];
 
-type ValidRecipeReturnType<State> =
-	| State
-	| void
-	| undefined
-	| (State extends undefined ? Nothing : never)
+ type ValidRecipeReturnType<State> = State | void | undefined | (State extends undefined ? Nothing : never);
 
-type ValidRecipeReturnTypePossiblyPromise<State> =
-	| ValidRecipeReturnType<State>
-	| Promise<ValidRecipeReturnType<State>>
+ type ValidRecipeReturnTypePossiblyPromise<State> = ValidRecipeReturnType<State> | Promise<ValidRecipeReturnType<State>>;
 
-type PromisifyReturnIfNeeded<
-	State,
-	Recipe extends AnyFunc,
-	UsePatches extends boolean
-> = ReturnType<Recipe> extends Promise<any>
-	? Promise<UsePatches extends true ? PatchesTuple<State> : State>
-	: UsePatches extends true
-	? PatchesTuple<State>
-	: State
+ type PromisifyReturnIfNeeded<State, Recipe extends AnyFunc, UsePatches extends boolean> = ReturnType<Recipe> extends Promise<any> ? Promise<UsePatches extends true ? PatchesTuple<State> : State> : UsePatches extends true ? PatchesTuple<State> : State;
 
-/**
+ /**
  * Core Producer inference
  */
-type InferRecipeFromCurried<Curried> = Curried extends (
-	base: infer State,
-	...rest: infer Args
-) => any // extra assertion to make sure this is a proper curried function (state, args) => state
-	? ReturnType<Curried> extends State
-		? (
-				draft: Draft<State>,
-				...rest: Args
-		  ) => ValidRecipeReturnType<Draft<State>>
-		: never
-	: never
+type InferRecipeFromCurried<Curried> = Curried extends (base: infer State, ...rest: infer Args) => any // extra assertion to make sure this is a proper curried function (state, args) => state
+ ? ReturnType<Curried> extends State ? (draft: Draft<State>, ...rest: Args) => ValidRecipeReturnType<Draft<State>> : never : never;
 
-type InferInitialStateFromCurried<Curried> = Curried extends (
-	base: infer State,
-	...rest: any[]
-) => any // extra assertion to make sure this is a proper curried function (state, args) => state
-	? State
-	: never
+ type InferInitialStateFromCurried<Curried> = Curried extends (base: infer State, ...rest: any[]) => any // extra assertion to make sure this is a proper curried function (state, args) => state
+ ? State : never;
 
-type InferCurriedFromRecipe<
-	Recipe,
-	UsePatches extends boolean
-> = Recipe extends (draft: infer DraftState, ...args: infer RestArgs) => any // verify return type
-	? ReturnType<Recipe> extends ValidRecipeReturnTypePossiblyPromise<DraftState>
-		? (
-				base: Immutable<DraftState>,
-				...args: RestArgs
-		  ) => PromisifyReturnIfNeeded<DraftState, Recipe, UsePatches> // N.b. we return mutable draftstate, in case the recipe's first arg isn't read only, and that isn't expected as output either
-		: never // incorrect return type
-	: never // not a function
+ type InferCurriedFromRecipe<Recipe, UsePatches extends boolean> = Recipe extends (draft: infer DraftState, ...args: infer RestArgs) => any // verify return type
+ ? ReturnType<Recipe> extends ValidRecipeReturnTypePossiblyPromise<DraftState> ? (base: Immutable<DraftState>, ...args: RestArgs) => PromisifyReturnIfNeeded<DraftState, Recipe, UsePatches> // N.b. we return mutable draftstate, in case the recipe's first arg isn't read only, and that isn't expected as output either
+ : never // incorrect return type
+ : never; // not a function
 
-type InferCurriedFromInitialStateAndRecipe<
-	State,
-	Recipe,
-	UsePatches extends boolean
-> = Recipe extends (
-	draft: Draft<State>,
-	...rest: infer RestArgs
-) => ValidRecipeReturnTypePossiblyPromise<State>
-	? (
-			base?: State | undefined,
-			...args: RestArgs
-	  ) => PromisifyReturnIfNeeded<State, Recipe, UsePatches>
-	: never // recipe doesn't match initial state
+ type InferCurriedFromInitialStateAndRecipe<State, Recipe, UsePatches extends boolean> = Recipe extends (draft: Draft<State>, ...rest: infer RestArgs) => ValidRecipeReturnTypePossiblyPromise<State> ? (base?: State | undefined, ...args: RestArgs) => PromisifyReturnIfNeeded<State, Recipe, UsePatches> : never; // recipe doesn't match initial state
 
-/**
+ /**
  * The `produce` function takes a value and a "recipe function" (whose
  * return value often depends on the base state). The recipe function is
  * free to mutate its first argument however it wants. All mutations are
@@ -173,85 +107,43 @@ type InferCurriedFromInitialStateAndRecipe<
  * @returns {any} a new state, or the initial state if nothing was modified
  */
 export interface IProduce {
-	/** Curried producer that infers the recipe from the curried output function (e.g. when passing to setState) */
-	<Curried>(
-		recipe: InferRecipeFromCurried<Curried>,
-		initialState?: InferInitialStateFromCurried<Curried>
-	): Curried
-
-	/** Curried producer that infers curried from the recipe  */
-	<Recipe extends AnyFunc>(recipe: Recipe): InferCurriedFromRecipe<
-		Recipe,
-		false
-	>
-
-	/** Curried producer that infers curried from the State generic, which is explicitly passed in.  */
-	<State>(
-		recipe: (
-			state: Draft<State>,
-			initialState: State
-		) => ValidRecipeReturnType<State>
-	): (state?: State) => State
-	<State, Args extends any[]>(
-		recipe: (
-			state: Draft<State>,
-			...args: Args
-		) => ValidRecipeReturnType<State>,
-		initialState: State
-	): (state?: State, ...args: Args) => State
-	<State>(recipe: (state: Draft<State>) => ValidRecipeReturnType<State>): (
-		state: State
-	) => State
-	<State, Args extends any[]>(
-		recipe: (state: Draft<State>, ...args: Args) => ValidRecipeReturnType<State>
-	): (state: State, ...args: Args) => State
-
-	/** Curried producer with initial state, infers recipe from initial state */
-	<State, Recipe extends Function>(
-		recipe: Recipe,
-		initialState: State
-	): InferCurriedFromInitialStateAndRecipe<State, Recipe, false>
-
-	/** Normal producer */
-	<Base, D = Draft<Base>>( // By using a default inferred D, rather than Draft<Base> in the recipe, we can override it.
-		base: Base,
-		recipe: (draft: D) => ValidRecipeReturnType<D>,
-		listener?: PatchListener
-	): Base
-
-	/** Promisified dormal producer */
-	<Base, D = Draft<Base>>(
-		base: Base,
-		recipe: (draft: D) => Promise<ValidRecipeReturnType<D>>,
-		listener?: PatchListener
-	): Promise<Base>
+    /** Curried producer that infers the recipe from the curried output function (e.g. when passing to setState) */
+    <Curried>(recipe: InferRecipeFromCurried<Curried>, initialState?: InferInitialStateFromCurried<Curried>): Curried;
+    
+ /** Curried producer that infers curried from the recipe  */
+    <Recipe extends AnyFunc>(recipe: Recipe): InferCurriedFromRecipe<Recipe, false>;
+    
+ /** Curried producer that infers curried from the State generic, which is explicitly passed in.  */
+    <State>(recipe: (state: Draft<State>, initialState: State) => ValidRecipeReturnType<State>): (state?: State) => State;
+    <State, Args extends any[]>(recipe: (state: Draft<State>, ...args: Args) => ValidRecipeReturnType<State>, initialState: State): (state?: State, ...args: Args) => State;
+    <State>(recipe: (state: Draft<State>) => ValidRecipeReturnType<State>): (state: State) => State;
+    <State, Args extends any[]>(recipe: (state: Draft<State>, ...args: Args) => ValidRecipeReturnType<State>): (state: State, ...args: Args) => State;
+    
+ /** Curried producer with initial state, infers recipe from initial state */
+    <State, Recipe extends Function>(recipe: Recipe, initialState: State): InferCurriedFromInitialStateAndRecipe<State, Recipe, false>;
+    
+ /** Normal producer */
+    <Base, D = Draft<Base>>(// By using a default inferred D, rather than Draft<Base> in the recipe, we can override it.
+    base: Base, recipe: (draft: D) => ValidRecipeReturnType<D>, listener?: PatchListener): Base;
+    
+ /** Promisified dormal producer */
+    <Base, D = Draft<Base>>(base: Base, recipe: (draft: D) => Promise<ValidRecipeReturnType<D>>, listener?: PatchListener): Promise<Base>;
 }
 
-/**
+ /**
  * Like `produce`, but instead of just returning the new state,
  * a tuple is returned with [nextState, patches, inversePatches]
  *
  * Like produce, this function supports currying
  */
 export interface IProduceWithPatches {
-	// Types copied from IProduce, wrapped with PatchesTuple
-	<Recipe extends AnyFunc>(recipe: Recipe): InferCurriedFromRecipe<Recipe, true>
-	<State, Recipe extends Function>(
-		recipe: Recipe,
-		initialState: State
-	): InferCurriedFromInitialStateAndRecipe<State, Recipe, true>
-	<Base, D = Draft<Base>>(
-		base: Base,
-		recipe: (draft: D) => ValidRecipeReturnType<D>,
-		listener?: PatchListener
-	): PatchesTuple<Base>
-	<Base, D = Draft<Base>>(
-		base: Base,
-		recipe: (draft: D) => Promise<ValidRecipeReturnType<D>>,
-		listener?: PatchListener
-	): Promise<PatchesTuple<Base>>
+    // Types copied from IProduce, wrapped with PatchesTuple
+    <Recipe extends AnyFunc>(recipe: Recipe): InferCurriedFromRecipe<Recipe, true>;
+    <State, Recipe extends Function>(recipe: Recipe, initialState: State): InferCurriedFromInitialStateAndRecipe<State, Recipe, true>;
+    <Base, D = Draft<Base>>(base: Base, recipe: (draft: D) => ValidRecipeReturnType<D>, listener?: PatchListener): PatchesTuple<Base>;
+    <Base, D = Draft<Base>>(base: Base, recipe: (draft: D) => Promise<ValidRecipeReturnType<D>>, listener?: PatchListener): Promise<PatchesTuple<Base>>;
 }
 
-// Fixes #507: bili doesn't export the types of this file if there is no actual source in it..
+ // Fixes #507: bili doesn't export the types of this file if there is no actual source in it..
 // hopefully it get's tree-shaken away for everyone :)
-export function never_used() {}
+export function never_used() { }
diff --git a/src/types/types-internal.ts b/src/types/types-internal.ts
index d3bc561240d79e3f4cc56f79c1884950f7ad5fe3..e72e833c5e720341d97c594e561743964dc06d32 100644
--- a/src/types/types-internal.ts
+++ b/src/types/types-internal.ts
@@ -1,55 +1,42 @@
-import {
-	SetState,
-	ImmerScope,
-	ProxyObjectState,
-	ProxyArrayState,
-	ES5ObjectState,
-	ES5ArrayState,
-	MapState,
-	DRAFT_STATE
-} from "../internal"
+import { SetState, ImmerScope, ProxyObjectState, ProxyArrayState, ES5ObjectState, ES5ArrayState, MapState, DRAFT_STATE } from "../internal.js";
 
-export type Objectish = AnyObject | AnyArray | AnyMap | AnySet
-export type ObjectishNoSet = AnyObject | AnyArray | AnyMap
+ export type Objectish = AnyObject | AnyArray | AnyMap | AnySet;
+export type ObjectishNoSet = AnyObject | AnyArray | AnyMap;
 
-export type AnyObject = {[key: string]: any}
-export type AnyArray = Array<any>
-export type AnySet = Set<any>
-export type AnyMap = Map<any, any>
+ export type AnyObject = {
+    [key: string]: any;
+};
+export type AnyArray = Array<any>;
+export type AnySet = Set<any>;
+export type AnyMap = Map<any, any>;
 
-export const enum Archtype {
-	Object,
-	Array,
-	Map,
-	Set
+ export const enum Archtype {
+    Object,
+    Array,
+    Map,
+    Set
 }
 
-export const enum ProxyType {
-	ProxyObject,
-	ProxyArray,
-	Map,
-	Set,
-	ES5Object,
-	ES5Array
+ export const enum ProxyType {
+    ProxyObject,
+    ProxyArray,
+    Map,
+    Set,
+    ES5Object,
+    ES5Array
 }
 
-export interface ImmerBaseState {
-	parent_?: ImmerState
-	scope_: ImmerScope
-	modified_: boolean
-	finalized_: boolean
-	isManual_: boolean
+ export interface ImmerBaseState {
+    parent_?: ImmerState;
+    scope_: ImmerScope;
+    modified_: boolean;
+    finalized_: boolean;
+    isManual_: boolean;
 }
 
-export type ImmerState =
-	| ProxyObjectState
-	| ProxyArrayState
-	| ES5ObjectState
-	| ES5ArrayState
-	| MapState
-	| SetState
+ export type ImmerState = ProxyObjectState | ProxyArrayState | ES5ObjectState | ES5ArrayState | MapState | SetState;
 
-// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)
+ // The _internal_ type used for drafts (not to be confused with Draft, which is public facing)
 export type Drafted<Base = any, T extends ImmerState = ImmerState> = {
-	[DRAFT_STATE]: T
-} & Base
+    [DRAFT_STATE]: T;
+} & Base;
diff --git a/src/utils/common.ts b/src/utils/common.ts
index 27a93845a858c9c82de24a46f56312ecc22e04ca..83976180e8e5ea79ffdfd1ad6259d8de6d3845ef 100644
--- a/src/utils/common.ts
+++ b/src/utils/common.ts
@@ -1,217 +1,215 @@
-import {
-	DRAFT_STATE,
-	DRAFTABLE,
-	hasSet,
-	Objectish,
-	Drafted,
-	AnyObject,
-	AnyMap,
-	AnySet,
-	ImmerState,
-	hasMap,
-	Archtype,
-	die
-} from "../internal"
-
-/** Returns true if the given value is an Immer draft */
+import { DRAFT_STATE, DRAFTABLE, hasSet, Objectish, Drafted, AnyObject, AnyMap, AnySet, ImmerState, hasMap, Archtype, die } from "../internal.js";
+
+ /** Returns true if the given value is an Immer draft */
 /*#__PURE__*/
 export function isDraft(value: any): boolean {
-	return !!value && !!value[DRAFT_STATE]
+    return !!value && !!value[DRAFT_STATE];
 }
 
-/** Returns true if the given value can be drafted by Immer */
+ /** Returns true if the given value can be drafted by Immer */
 /*#__PURE__*/
 export function isDraftable(value: any): boolean {
-	if (!value) return false
-	return (
-		isPlainObject(value) ||
-		Array.isArray(value) ||
-		!!value[DRAFTABLE] ||
-		!!value.constructor?.[DRAFTABLE] ||
-		isMap(value) ||
-		isSet(value)
-	)
-}
-
-const objectCtorString = Object.prototype.constructor.toString()
-/*#__PURE__*/
-export function isPlainObject(value: any): boolean {
-	if (!value || typeof value !== "object") return false
-	const proto = Object.getPrototypeOf(value)
-	if (proto === null) {
-		return true
-	}
-	const Ctor =
-		Object.hasOwnProperty.call(proto, "constructor") && proto.constructor
-
-	if (Ctor === Object) return true
-
-	return (
-		typeof Ctor == "function" &&
-		Function.toString.call(Ctor) === objectCtorString
-	)
+    if (!value)
+        return false;
+    return (isPlainObject(value) ||
+        Array.isArray(value) ||
+        !!value[DRAFTABLE] ||
+        !!value.constructor?.[DRAFTABLE] ||
+        isMap(value) ||
+        isSet(value));
 }
 
-/** Get the underlying object that is represented by the given draft */
+ const objectCtorString = Object.prototype.constructor.toString();
 /*#__PURE__*/
-export function original<T>(value: T): T | undefined
-export function original(value: Drafted<any>): any {
-	if (!isDraft(value)) die(23, value)
-	return value[DRAFT_STATE].base_
-}
-
+export function isPlainObject(value: any): boolean {
+    if (!value || typeof value !== "object")
+        return false;
+    const proto = Object.getPrototypeOf(value);
+    if (proto === null) {
+        return true;
+    }
+    const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
+    
+ if (Ctor === Object)
+        return true;
+    
+ return (typeof Ctor == "function" &&
+        Function.toString.call(Ctor) === objectCtorString);
+}
+
+ /** Get the underlying object that is represented by the given draft */
 /*#__PURE__*/
-export const ownKeys: (target: AnyObject) => PropertyKey[] =
-	typeof Reflect !== "undefined" && Reflect.ownKeys
-		? Reflect.ownKeys
-		: typeof Object.getOwnPropertySymbols !== "undefined"
-		? obj =>
-				Object.getOwnPropertyNames(obj).concat(
-					Object.getOwnPropertySymbols(obj) as any
-				)
-		: /* istanbul ignore next */ Object.getOwnPropertyNames
-
-export const getOwnPropertyDescriptors =
-	Object.getOwnPropertyDescriptors ||
-	function getOwnPropertyDescriptors(target: any) {
-		// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
-		const res: any = {}
-		ownKeys(target).forEach(key => {
-			res[key] = Object.getOwnPropertyDescriptor(target, key)
-		})
-		return res
-	}
-
-export function each<T extends Objectish>(
-	obj: T,
-	iter: (key: string | number, value: any, source: T) => void,
-	enumerableOnly?: boolean
-): void
+export function original<T>(value: T): T | undefined;
+export function original(value: Drafted<any>): any {
+    if (!isDraft(value))
+        die(23, value);
+    return value[DRAFT_STATE].base_;
+}
+
+ /*#__PURE__*/
+export const ownKeys: (target: AnyObject) => PropertyKey[] = typeof Reflect !== "undefined" && Reflect.ownKeys
+    ? Reflect.ownKeys
+    : typeof Object.getOwnPropertySymbols !== "undefined"
+        ? obj => Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj) as any)
+        : /* istanbul ignore next */ Object.getOwnPropertyNames;
+
+ export const getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
+    function getOwnPropertyDescriptors(target: any) {
+        // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
+        const res: any = {};
+        ownKeys(target).forEach(key => {
+            res[key] = Object.getOwnPropertyDescriptor(target, key);
+        });
+        return res;
+    };
+
+ export function each<T extends Objectish>(obj: T, iter: (key: string | number, value: any, source: T) => void, enumerableOnly?: boolean): void;
 export function each(obj: any, iter: any, enumerableOnly = false) {
-	if (getArchtype(obj) === Archtype.Object) {
-		;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {
-			if (!enumerableOnly || typeof key !== "symbol") iter(key, obj[key], obj)
-		})
-	} else {
-		obj.forEach((entry: any, index: any) => iter(index, entry, obj))
-	}
-}
-
-/*#__PURE__*/
+    if (getArchtype(obj) === Archtype.Object) {
+        ;
+        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {
+            if (!enumerableOnly || typeof key !== "symbol")
+                iter(key, obj[key], obj);
+        });
+    }
+    else {
+        obj.forEach((entry: any, index: any) => iter(index, entry, obj));
+    }
+}
+
+ /*#__PURE__*/
 export function getArchtype(thing: any): Archtype {
-	/* istanbul ignore next */
-	const state: undefined | ImmerState = thing[DRAFT_STATE]
-	return state
-		? state.type_ > 3
-			? state.type_ - 4 // cause Object and Array map back from 4 and 5
-			: (state.type_ as any) // others are the same
-		: Array.isArray(thing)
-		? Archtype.Array
-		: isMap(thing)
-		? Archtype.Map
-		: isSet(thing)
-		? Archtype.Set
-		: Archtype.Object
-}
-
-/*#__PURE__*/
+    /* istanbul ignore next */
+    const state: undefined | ImmerState = thing[DRAFT_STATE];
+    return state
+        ? state.type_ > 3
+            ? state.type_ - 4 // cause Object and Array map back from 4 and 5
+            : (state.type_ as any) // others are the same
+        : Array.isArray(thing)
+            ? Archtype.Array
+            : isMap(thing)
+                ? Archtype.Map
+                : isSet(thing)
+                    ? Archtype.Set
+                    : Archtype.Object;
+}
+
+ /*#__PURE__*/
 export function has(thing: any, prop: PropertyKey): boolean {
-	return getArchtype(thing) === Archtype.Map
-		? thing.has(prop)
-		: Object.prototype.hasOwnProperty.call(thing, prop)
+    return getArchtype(thing) === Archtype.Map
+        ? thing.has(prop)
+        : Object.prototype.hasOwnProperty.call(thing, prop);
 }
 
-/*#__PURE__*/
+ /*#__PURE__*/
 export function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {
-	// @ts-ignore
-	return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]
+    // @ts-ignore
+    return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop];
 }
 
-/*#__PURE__*/
+ /*#__PURE__*/
 export function set(thing: any, propOrOldValue: PropertyKey, value: any) {
-	const t = getArchtype(thing)
-	if (t === Archtype.Map) thing.set(propOrOldValue, value)
-	else if (t === Archtype.Set) {
-		thing.delete(propOrOldValue)
-		thing.add(value)
-	} else thing[propOrOldValue] = value
-}
-
-/*#__PURE__*/
+    const t = getArchtype(thing);
+    if (t === Archtype.Map)
+        thing.set(propOrOldValue, value);
+    else if (t === Archtype.Set) {
+        thing.delete(propOrOldValue);
+        thing.add(value);
+    }
+    else
+        thing[propOrOldValue] = value;
+}
+
+ /*#__PURE__*/
 export function is(x: any, y: any): boolean {
-	// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
-	if (x === y) {
-		return x !== 0 || 1 / x === 1 / y
-	} else {
-		return x !== x && y !== y
-	}
+    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
+    if (x === y) {
+        return x !== 0 || 1 / x === 1 / y;
+    }
+    else {
+        return x !== x && y !== y;
+    }
 }
 
-/*#__PURE__*/
+ /*#__PURE__*/
 export function isMap(target: any): target is AnyMap {
-	return hasMap && target instanceof Map
+    return hasMap && target instanceof Map;
 }
 
-/*#__PURE__*/
+ /*#__PURE__*/
 export function isSet(target: any): target is AnySet {
-	return hasSet && target instanceof Set
+    return hasSet && target instanceof Set;
 }
 /*#__PURE__*/
 export function latest(state: ImmerState): any {
-	return state.copy_ || state.base_
+    return state.copy_ || state.base_;
 }
 
-/*#__PURE__*/
+ /*#__PURE__*/
 export function shallowCopy(base: any) {
-	if (Array.isArray(base)) return Array.prototype.slice.call(base)
-	const descriptors = getOwnPropertyDescriptors(base)
-	delete descriptors[DRAFT_STATE as any]
-	let keys = ownKeys(descriptors)
-	for (let i = 0; i < keys.length; i++) {
-		const key: any = keys[i]
-		const desc = descriptors[key]
-		if (desc.writable === false) {
-			desc.writable = true
-			desc.configurable = true
-		}
-		// like object.assign, we will read any _own_, get/set accessors. This helps in dealing
-		// with libraries that trap values, like mobx or vue
-		// unlike object.assign, non-enumerables will be copied as well
-		if (desc.get || desc.set)
-			descriptors[key] = {
-				configurable: true,
-				writable: true, // could live with !!desc.set as well here...
-				enumerable: desc.enumerable,
-				value: base[key]
-			}
-	}
-	return Object.create(Object.getPrototypeOf(base), descriptors)
-}
-
-/**
+    if (Array.isArray(base))
+        return Array.prototype.slice.call(base);
+    const descriptors = getOwnPropertyDescriptors(base);
+    delete descriptors[DRAFT_STATE as any];
+    let keys = ownKeys(descriptors);
+    for (let i = 0; i < keys.length; i++) {
+        const key: any = keys[i];
+        const desc = descriptors[key];
+        if (desc.writable === false) {
+            desc.writable = true;
+            desc.configurable = true;
+        }
+        // like object.assign, we will read any _own_, get/set accessors. This helps in dealing
+        // with libraries that trap values, like mobx or vue
+        // unlike object.assign, non-enumerables will be copied as well
+        if (desc.get || desc.set)
+            descriptors[key] = {
+                configurable: true,
+                writable: true,
+                enumerable: desc.enumerable,
+                value: base[key]
+            };
+    }
+    return Object.create(Object.getPrototypeOf(base), descriptors);
+}
+
+ /**
  * Freezes draftable objects. Returns the original object.
  * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.
  *
  * @param obj
  * @param deep
  */
-export function freeze<T>(obj: T, deep?: boolean): T
+export function freeze<T>(obj: T, deep?: boolean): T;
 export function freeze<T>(obj: any, deep: boolean = false): T {
-	if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj
-	if (getArchtype(obj) > 1 /* Map or Set */) {
-		obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any
-	}
-	Object.freeze(obj)
-	if (deep) each(obj, (key, value) => freeze(value, true), true)
-	return obj
-}
-
-function dontMutateFrozenCollections() {
-	die(2)
-}
-
-export function isFrozen(obj: any): boolean {
-	if (obj == null || typeof obj !== "object") return true
-	// See #600, IE dies on non-objects in Object.isFrozen
-	return Object.isFrozen(obj)
+    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
+        return obj;
+    if (getArchtype(obj) > 1 /* Map or Set */) {
+        const desc: PropertyDescriptor = {
+            configurable: true,
+            writable: true,
+            value: dontMutateFrozenCollections
+        };
+        Object.defineProperties(obj, {
+            set: desc,
+            add: desc,
+            clear: desc,
+            delete: desc
+        });
+    }
+    Object.freeze(obj);
+    if (deep)
+        each(obj, (key, value) => freeze(value, true), true);
+    return obj;
+}
+
+ function dontMutateFrozenCollections() {
+    die(2);
+}
+
+ export function isFrozen(obj: any): boolean {
+    if (obj == null || typeof obj !== "object")
+        return true;
+    // See #600, IE dies on non-objects in Object.isFrozen
+    return Object.isFrozen(obj);
 }
diff --git a/src/utils/plugins.ts b/src/utils/plugins.ts
index 089cf01591c2334806395c322ec1a0a89aaae842..2b5b03a1e3ede78236d0b7f7fac2be3ebc2422f4 100644
--- a/src/utils/plugins.ts
+++ b/src/utils/plugins.ts
@@ -1,109 +1,83 @@
-import {
-	ImmerState,
-	Patch,
-	ImmerScope,
-	Drafted,
-	AnyObject,
-	ImmerBaseState,
-	AnyMap,
-	AnySet,
-	ProxyType,
-	die
-} from "../internal"
+import { ImmerState, Patch, ImmerScope, Drafted, AnyObject, ImmerBaseState, AnyMap, AnySet, ProxyType, die } from "../internal.js";
 
-/** Plugin utilities */
+ /** Plugin utilities */
 const plugins: {
-	Patches?: {
-		generatePatches_(
-			state: ImmerState,
-			basePath: PatchPath,
-			patches: Patch[],
-			inversePatches: Patch[]
-		): void
-		generateReplacementPatches_(
-			base: any,
-			replacement: any,
-			patches: Patch[],
-			inversePatches: Patch[]
-		): void
-		applyPatches_<T>(draft: T, patches: Patch[]): T
-	}
-	ES5?: {
-		willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void
-		createES5Proxy_<T>(
-			base: T,
-			parent?: ImmerState
-		): Drafted<T, ES5ObjectState | ES5ArrayState>
-		hasChanges_(state: ES5ArrayState | ES5ObjectState): boolean
-	}
-	MapSet?: {
-		proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T
-		proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T
-	}
-} = {}
+    Patches?: {
+        generatePatches_(state: ImmerState, basePath: PatchPath, patches: Patch[], inversePatches: Patch[]): void;
+        generateReplacementPatches_(base: any, replacement: any, patches: Patch[], inversePatches: Patch[]): void;
+        applyPatches_<T>(draft: T, patches: Patch[]): T;
+    };
+    ES5?: {
+        willFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void;
+        createES5Proxy_<T>(base: T, parent?: ImmerState): Drafted<T, ES5ObjectState | ES5ArrayState>;
+        hasChanges_(state: ES5ArrayState | ES5ObjectState): boolean;
+    };
+    MapSet?: {
+        proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T;
+        proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T;
+    };
+} = {};
 
-type Plugins = typeof plugins
+ type Plugins = typeof plugins;
 
-export function getPlugin<K extends keyof Plugins>(
-	pluginKey: K
-): Exclude<Plugins[K], undefined> {
-	const plugin = plugins[pluginKey]
-	if (!plugin) {
-		die(18, pluginKey)
-	}
-	// @ts-ignore
-	return plugin
+ export function getPlugin<K extends keyof Plugins>(pluginKey: K): Exclude<Plugins[K], undefined> {
+    const plugin = plugins[pluginKey];
+    if (!plugin) {
+        die(18, pluginKey);
+    }
+    // @ts-ignore
+    return plugin;
 }
 
-export function loadPlugin<K extends keyof Plugins>(
-	pluginKey: K,
-	implementation: Plugins[K]
-): void {
-	if (!plugins[pluginKey]) plugins[pluginKey] = implementation
+ export function loadPlugin<K extends keyof Plugins>(pluginKey: K, implementation: Plugins[K]): void {
+    if (!plugins[pluginKey])
+        plugins[pluginKey] = implementation;
 }
 
-/** ES5 Plugin */
+ /** ES5 Plugin */
 
-interface ES5BaseState extends ImmerBaseState {
-	assigned_: {[key: string]: any}
-	parent_?: ImmerState
-	revoked_: boolean
+ interface ES5BaseState extends ImmerBaseState {
+    assigned_: {
+        [key: string]: any;
+    };
+    parent_?: ImmerState;
+    revoked_: boolean;
 }
 
-export interface ES5ObjectState extends ES5BaseState {
-	type_: ProxyType.ES5Object
-	draft_: Drafted<AnyObject, ES5ObjectState>
-	base_: AnyObject
-	copy_: AnyObject | null
+ export interface ES5ObjectState extends ES5BaseState {
+    type_: ProxyType.ES5Object;
+    draft_: Drafted<AnyObject, ES5ObjectState>;
+    base_: AnyObject;
+    copy_: AnyObject | null;
 }
 
-export interface ES5ArrayState extends ES5BaseState {
-	type_: ProxyType.ES5Array
-	draft_: Drafted<AnyObject, ES5ArrayState>
-	base_: any
-	copy_: any
+ export interface ES5ArrayState extends ES5BaseState {
+    type_: ProxyType.ES5Array;
+    draft_: Drafted<AnyObject, ES5ArrayState>;
+    base_: any;
+    copy_: any;
 }
 
-/** Map / Set plugin */
+ /** Map / Set plugin */
 
-export interface MapState extends ImmerBaseState {
-	type_: ProxyType.Map
-	copy_: AnyMap | undefined
-	assigned_: Map<any, boolean> | undefined
-	base_: AnyMap
-	revoked_: boolean
-	draft_: Drafted<AnyMap, MapState>
+ export interface MapState extends ImmerBaseState {
+    type_: ProxyType.Map;
+    copy_: AnyMap | undefined;
+    assigned_: Map<any, boolean> | undefined;
+    base_: AnyMap;
+    revoked_: boolean;
+    draft_: Drafted<AnyMap, MapState>;
 }
 
-export interface SetState extends ImmerBaseState {
-	type_: ProxyType.Set
-	copy_: AnySet | undefined
-	base_: AnySet
-	drafts_: Map<any, Drafted> // maps the original value to the draft value in the new set
-	revoked_: boolean
-	draft_: Drafted<AnySet, SetState>
+ export interface SetState extends ImmerBaseState {
+    type_: ProxyType.Set;
+    copy_: AnySet | undefined;
+    base_: AnySet;
+    drafts_: Map<any, Drafted>; // maps the original value to the draft value in the new set
+    revoked_: boolean;
+    draft_: Drafted<AnySet, SetState>;
 }
 
-/** Patches plugin */
+ /** Patches plugin */
 
-export type PatchPath = (string | number)[]
+ export type PatchPath = (string | number)[];